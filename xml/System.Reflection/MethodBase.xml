<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="790e1bf06b36b070748f989041d2b3f4ab2c5f59" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39778056" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <TypeSignature Language="F#" Value="type MethodBase = class&#xA;    inherit MemberInfo&#xA;    interface _MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b3eb6-101">Zawiera informacje dotyczące metod i konstruktorów.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3eb6-101">Provides information about methods and constructors.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-102">`MethodBase` Klasa bazowa jest <xref:System.Reflection.MethodInfo> i <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="b3eb6-103">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3eb6-103">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="b3eb6-104">Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3eb6-104">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="b3eb6-105">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3eb6-105">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <span data-ttu-id="b3eb6-106">
        <para>Przy dziedziczeniu z <see langword="MethodBase" />, konieczne jest przesłonięcie następujących składowych: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, i <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="b3eb6-106">
          <para>When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-107">Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.MethodBase" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-108">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-109">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.MethodBase.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-110">Pobiera atrybuty skojarzone z tą metodą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-110">Gets the attributes associated with this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-111">Jedną z <see cref="T:System.Reflection.MethodAttributes" /> wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-112">Wszystkie elementy członkowskie mają zestaw atrybutów, które są zdefiniowane w odniesieniu do określonego typu elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="b3eb6-113">Aby uzyskać <xref:System.Reflection.MethodAttributes>, najpierw uzyskać typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="b3eb6-114">Od typu metoda get.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-114">From the type, get the method.</span></span> <span data-ttu-id="b3eb6-115">W metodzie, uzyskać <xref:System.Reflection.MethodAttributes>.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-116">Poniższy przykład kodu wyświetla atrybuty metody Mymethod zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="b3eb6-117">Ten kod generuje następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="b3eb6-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="b3eb6-118">Przykładowe Reflection.MethodBase.Attributes</span><span class="sxs-lookup"><span data-stu-id="b3eb6-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="b3eb6-119">Mymethodbase = Mymethod Void (ByRef typu Int32, System.String ByRef System.String)</span><span class="sxs-lookup"><span data-stu-id="b3eb6-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="b3eb6-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="b3eb6-120">PrivateScope</span></span>  
  
 <span data-ttu-id="b3eb6-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="b3eb6-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="b3eb6-122">Rodzina</span><span class="sxs-lookup"><span data-stu-id="b3eb6-122">Family</span></span>  
  
 <span data-ttu-id="b3eb6-123">Public</span><span class="sxs-lookup"><span data-stu-id="b3eb6-123">Public</span></span>  
  
 <span data-ttu-id="b3eb6-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="b3eb6-124">HideBySig</span></span>  
  
 <span data-ttu-id="b3eb6-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="b3eb6-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="b3eb6-126">
            <para>Użyj <see cref="P:System.Reflection.MethodBase.Attributes" /> właściwości w celu określenia, czy metoda jest <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />i tak dalej.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-126">
              <para>Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.MethodBase.CallingConvention" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-127">Pobiera wartość wskazującą, Konwencje wywoływania dla tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-127">Gets a value indicating the calling conventions for this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-128">
            <see cref="T:System.Reflection.CallingConventions" /> Dla tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-129">Pobiera wartość wskazującą, czy metody ogólnej zawiera parametry typu ogólnego nieprzypisane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-130">
            <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentuje metody rodzajowej, zawierający parametry typu ogólnego nieprzypisane; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-130">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-131">Może być wywoływany metody rodzajowej, tylko wtedy, gdy nie ma żadnych definicji typu ogólnego lub Otwórz typy utworzone w argumentach typu sama metoda, lub w dowolnym typie otaczającym.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="b3eb6-132">Ponieważ typy mogą być dowolnie złożone, co oznaczanie cyklicznego jest trudne.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="b3eb6-133">Dla wygody, a także aby zmniejszyć prawdopodobieństwo wystąpienia błędu <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwość udostępnia standardowy sposób odróżnić zamknięte skonstruowany metod, które mogą być wywoływane, i otwórz zbudowane metody, które nie.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="b3eb6-134">Jeśli <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwość zwraca `true`, nie można wywołać metody.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="b3eb6-135"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> Właściwość przeszukiwane rekursywnie dla parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="b3eb6-136">Na przykład zwraca `true` dla dowolnej metody w ramach typu otwartego `A<T>` (`A(Of T)` w języku Visual Basic), nawet jeśli sama metoda nie jest ogólna.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="b3eb6-137">Natomiast to zachowanie <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwość, która zwraca `false` takie metody.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="b3eb6-138">Podobnie <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> parametr właściwość zwraca `true` dla dowolnego konstruktora w ramach typu otwartego, mimo że konstruktorów nie może mieć parametrów typu w swoich własnych.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="b3eb6-139">Aby uzyskać listę niezmiennych warunków dla terminów specyficznych dla metod ogólnych, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="b3eb6-140">Aby uzyskać listę niezmiennych warunków dla innych terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBase.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="b3eb6-141">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-141">An object to compare with this instance, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-142">Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-142">Returns a value that indicates whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-143">
            <see langword="true" /> Jeśli <paramref name="obj" /> equals typ i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-143">
              <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberSignature Language="F#" Value="static member GetCurrentMethod : unit -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetCurrentMethod " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-144">Zwraca <see langword="MethodBase" /> obiekt reprezentujący aktualnie wykonywanej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-145">
            <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> jest metoda statyczna, która jest wywoływana z wewnątrz metody wykonywania i który zwraca informacje na temat tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-145">
              <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span>
          </span>
          <span data-ttu-id="b3eb6-146">A <see langword="MethodBase" /> obiekt reprezentujący aktualnie wykonywanej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-146">A <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-147">Jeśli aktualnie wykonywanej metody jest zdefiniowany dla typu ogólnego, <xref:System.Reflection.MethodInfo> zwracanym przez <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> są uzyskiwane z definicji typu ogólnego (czyli <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> zwraca `true`).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="b3eb6-148">W związku z tym nie odzwierciedla argumentów typu, które zostały użyte podczas wywołania tej metody.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="b3eb6-149">Na przykład, jeśli metoda `M()` jest zdefiniowany dla typu ogólnego `C<T>` (`C(Of T)` w języku Visual Basic), a <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> jest wywoływana z `C<string>.M()`, następnie <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> zwraca `C<T>.M()` (`C(Of T).M()` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="b3eb6-150">Jeśli metoda aktualnie wykonywanej metody rodzajowej, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> zwraca definicję metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="b3eb6-151">Jeśli nie zdefiniowano metody ogólnej dla typu ogólnego, <xref:System.Reflection.MethodInfo> są uzyskiwane z definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-152">W poniższym przykładzie zdefiniowano dwa typy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-152">The following example defines two types.</span></span> <span data-ttu-id="b3eb6-153">Pierwszy jest klasą nieogólnego `TestClass`, zawiera konstruktora, metody o nazwie `GetValue`i właściwości odczytu / zapisu o nazwie `GetValue`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="b3eb6-154">Drugą jest wartość klasę ogólną o nazwie `TestClass<T>` zawierającej konstruktora, `GetValue` metoda i metody rodzajowej, `ConvertValue<Y>`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="b3eb6-155">Każdy konstruktora, metody i metody dostępu właściwości zawiera wywołanie <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="b3eb6-156">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-156">This member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-157">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-158">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBase.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-159">Zwraca tablicę <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu metody ogólnej lub parametrów typu w definicji metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-160">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu metody ogólnej lub parametrów typu w definicji metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
          <span data-ttu-id="b3eb6-161">Zwraca pustą tablicę, jeśli bieżąca metoda nie jest metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-161">Returns an empty array if the current method is not a generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-162">Elementy zwróconej tablicy są w kolejności, w jakiej są wyświetlane na liście parametrów typu dla metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="b3eb6-163">Jeśli bieżąca metoda jest metodą skonstruowany zamknięte (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwość zwraca `false`), tablica zwrócona przez <xref:System.Reflection.MethodBase.GetGenericArguments%2A> metoda zawiera typy, które zostały przypisane do parametrów typu ogólnego ogólnych — metoda Definicja.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="b3eb6-164">Jeśli bieżąca metoda definicję metody rodzajowej, tablica zawiera parametry typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="b3eb6-165">Jeśli bieżąca metoda jest metodą skonstruowany open (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwość zwraca `true`), w których określone typy zostały przypisane do niektórych parametrów typu i typ parametrów otaczającej typów ogólnych zostały przypisane do innego typu parametrów, tablica zawiera typy i typ parametrów.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="b3eb6-166">Użyj <xref:System.Type.IsGenericParameter%2A> właściwości, aby poinformować ich od siebie.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="b3eb6-167">Do pokazania w tym scenariuszu, zobacz przykładu kodu przewidzianego dla <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="b3eb6-168">Ogólny konstruktory nie są obsługiwane w programie .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="b3eb6-169">Ta właściwość zwraca <xref:System.NotSupportedException> Jeśli nie przesłonięcia w klasie pochodnej, więc wyjątek jest generowany, jeśli bieżące wystąpienie jest typu <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="b3eb6-170">Aby uzyskać listę niezmiennych warunków dla terminów specyficznych dla metod ogólnych, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="b3eb6-171">Aby uzyskać listę niezmiennych warunków dla innych terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b3eb6-172">Bieżący obiekt jest <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          </span>
          <span data-ttu-id="b3eb6-173">Ogólny konstruktory nie są obsługiwane w programie .NET Framework 2.0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-173">Generic constructors are not supported in the .NET Framework version 2.0.</span>
          </span>
          <span data-ttu-id="b3eb6-174">Ten wyjątek jest to zachowanie domyślne, jeśli ta metoda nie zostanie przesłonięta w klasie pochodnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-174">This exception is the default behavior if this method is not overridden in a derived class.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBase.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-175">Zwraca kod skrótu dla tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-175">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-176">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-176">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodBody : unit -&gt; System.Reflection.MethodBody&#xA;override this.GetMethodBody : unit -&gt; System.Reflection.MethodBody" Usage="methodBase.GetMethodBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-177">W przypadku przesłonięcia w klasie pochodnej pobiera <see cref="T:System.Reflection.MethodBody" /> obiektu, który zapewnia dostęp do strumienia MSIL, zmienne lokalne i wyjątków dla bieżącej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-178">Element <see cref="T:System.Reflection.MethodBody" /> obiektu, który zapewnia dostęp do strumienia MSIL, zmienne lokalne i wyjątków dla bieżącej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-179">Nie trzeba zastąpić <xref:System.Reflection.MethodBase.GetMethodBody%2A> do jej używania.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="b3eb6-180">Możesz wywołać <xref:System.Reflection.MethodBase.GetMethodBody%2A> metody <xref:System.Reflection.MethodInfo> i <xref:System.Reflection.ConstructorInfo> obiektów, ponieważ metoda zostanie przesłonięta w wersji środowiska uruchomieniowego tych klas.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="b3eb6-181">Na przykład, wersję środowiska uruchomieniowego <xref:System.Reflection.MethodInfo> klasa pochodzi od <xref:System.Reflection.MethodInfo> klasy, która z kolei pochodzi od klasy <xref:System.Reflection.MethodBase> klasy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-182">Poniższy przykład kodu przedstawia metodę testu o nazwie `MethodBodyExample` i wyświetla jego informacji zmiennych lokalnych i klauzule obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="b3eb6-183"><xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> Metoda jest używana do uzyskania <xref:System.Reflection.MethodBody> obiektu dla metody testowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="b3eb6-184"><xref:System.Reflection.MethodBody.LocalVariables%2A> Właściwość jest używana do uzyskiwania listy <xref:System.Reflection.LocalVariableInfo> obiektów i wyświetlania ich typy i indeks kolejności.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="b3eb6-185"><xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> Właściwość jest używana do uzyskiwania listy klauzule obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-186">Nie wszystkie języki komputer może generować <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> klauzul.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="b3eb6-187">W przykładzie w języku Visual Basic zawiera klauzulę filtru przy użyciu języka Visual Basic `When` wyrażenie, które zostanie pominięty z przykładów dla innych języków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b3eb6-188">Ta metoda jest nieprawidłowy, chyba że zastąpione w klasie pochodnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-188">This method is invalid unless overridden in a derived class.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-189">Aby uzyskać dostęp do metadanych dla elementów członkowskich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-189">for the access to metadata for members.</span>
          </span>
          <span data-ttu-id="b3eb6-190">Wartość uprawnienia: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-191">Pobiera informacje o metodzie przy użyciu określonego dojścia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-191">Gets method information using the specified handle.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="b3eb6-192">Dojście metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-192">The method's handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-193">Pobiera informacje o metodzie przy użyciu metody metadanych wewnętrznej reprezentacji (uchwyt).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-193">Gets method information by using the method's internal metadata representation (handle).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-194">Element <see langword="MethodBase" /> zawierający informacje na temat metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-194">A <see langword="MethodBase" /> containing information about the method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-195">Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3eb6-196">
            <paramref name="handle" /> jest nieprawidłowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-196">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-197">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-198">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle * RuntimeTypeHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle (handle, declaringType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="b3eb6-199">Dojście do reprezentacji wewnętrznej metadanych konstruktora lub metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-199">A handle to the internal metadata representation of a constructor or method.</span>
          </span>
        </param>
        <param name="declaringType">
          <span data-ttu-id="b3eb6-200">Dojście do typu ogólnego, który definiuje konstruktora lub metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-200">A handle to the generic type that defines the constructor or method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-201">Pobiera <see cref="T:System.Reflection.MethodBase" /> obiekt do konstruktora lub metody reprezentowanej przez określone dojście, dla określonego typu ogólnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-202">A <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentujący metodę lub Konstruktor określony przez <paramref name="handle" />, w typie ogólnym określony przez <paramref name="declaringType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-203">Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="b3eb6-204">A <xref:System.RuntimeMethodHandle> strukturę dla konstruktora lub metody rodzajowej, może reprezentować różnych <xref:System.Reflection.MethodBase> obiektów, w zależności od typów określonych dla parametrów typu ogólnego typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="b3eb6-205">Na przykład jeśli `class G<T>` (`class G(Of T)` w języku Visual Basic `generic <T> ref class G` w języku C++) ma metodę, która zwraca typ `T`, <xref:System.Reflection.MethodBase> obiektu dla tej metody w klasie skonstruowany, takich jak `G<int>` różni się od <xref:System.Reflection.MethodBase>obiektu dla tej metody w definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3eb6-206">
            <paramref name="handle" /> jest nieprawidłowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-206">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-207">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-208">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBase.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-209">Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Reflection.MethodImplAttributes" /> flag.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-210">
            <see langword="MethodImplAttributes" /> Flagi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-210">The <see langword="MethodImplAttributes" /> flags.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b3eb6-211">Poniższy przykład definiuje konstruktora w zestawie dynamicznym, a następnie używa <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> metodę w celu wyświetlenia flagi implementacji metody, które są domyślnie.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-212">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-213">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBase.GetParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-214">W przypadku przesłonięcia w klasie pochodnej pobiera parametry określonej metody lub konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-215">Tablica typu <see langword="ParameterInfo" /> zawierające informacje, które pasuje do podpisu metody (lub konstruktora) dostarczanej przez to <see langword="MethodBase" /> wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b3eb6-216">W poniższym przykładzie użyto <xref:System.Reflection.MethodBase.GetParameters%2A> metodę, aby pobrać parametry `Invoke` metody delegata.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="b3eb6-217">W przykładzie zdefiniowano delegat o nazwie `MyDelegate` i zdarzenie o nazwie `ev` typu `MyDelegate`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="b3eb6-218">Kod w `Main` metoda odnajduje podpisu zdarzenia, uzyskując typ delegata zdarzenia, wprowadzenie `Invoke` metody typu delegata, a następnie pobieranie i wyświetlanie parametrów.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-219">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-220">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodBase.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-221">Wywołuje metodę lub Konstruktor dostarczanej przez to <see langword="MethodInfo" /> wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * obj[] -&gt; obj&#xA;override this.Invoke : obj * obj[] -&gt; obj" Usage="methodBase.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="b3eb6-222">Obiekt do wywołania metody lub konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-222">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="b3eb6-223">Jeśli metoda jest statyczna, ten argument zostanie zignorowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-223">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="b3eb6-224">Jeśli konstruktor jest statyczna, ten argument musi być <see langword="null" /> lub wystąpienia klasy, która definiuje konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="b3eb6-225">Lista argumentów dla wywołanej metody lub konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-225">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="b3eb6-226">Jest to tablica obiektów przy użyciu tego samego liczbę, kolejność i typ jako parametry metody lub konstruktora do wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="b3eb6-227">Jeśli nie ma żadnych parametrów <c>parametry</c> powinien być <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-227">If there are no parameters, <c>parameters</c> should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b3eb6-228">Jeśli metoda lub Konstruktor reprezentowany przez to wystąpienie ma <see langword="ref" /> parametru (<see langword="ByRef" /> w języku Visual Basic), nie specjalne atrybut jest wymagany dla tego parametru w celu wywołania metody lub konstruktora przy użyciu tej funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="b3eb6-229">Dowolny obiekt w tej tablicy, która nie jest jawnie zainicjowana z wartością będzie zawierać wartość domyślna dla tego typu obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="b3eb6-230">Elementy typu odwołania, ta wartość jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-230">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b3eb6-231">Typ wartości elementów, ta wartość wynosi 0, 0.0, lub <see langword="false" />, w zależności od typu określonego elementu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-232">Wywołuje metodę lub Konstruktor reprezentowany przez bieżące wystąpienie, przy użyciu określonych parametrów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-233">Obiekt zawierający wartość zwracaną wywoływanej metody lub <see langword="null" /> w przypadku konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-234">Jest to wygodna metoda, która wywołuje <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> przeciążenia metody, przekazując <xref:System.Reflection.BindingFlags.Default> dla `invokeAttr` i `null` dla `binder` i `culture`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="b3eb6-235">Jeśli jest wywoływana metoda zgłasza wyjątek, <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> metoda zwróci wyjątek.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="b3eb6-236">Aby wywołać metodę statyczną za pomocą jego <xref:System.Reflection.MethodInfo> obiektu, przekazać `null` dla `obj`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-237">Użycie tego przeciążenia metody do wywołania konstruktora wystąpień obiektu podana dla `obj` są ponownie inicjowane; oznacza to, że zostały wykonane wszystkie inicjatory wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="b3eb6-238">Wartość zwracana jest `null`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-238">The return value is `null`.</span></span> <span data-ttu-id="b3eb6-239">Jeśli jest wywoływany jest konstruktor klasy, klasy są ponownie inicjowane; oznacza to wykonywane są wszystkie inicjatory klasy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="b3eb6-240">Wartość zwracana jest `null`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-241">Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="b3eb6-242">(Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="b3eb6-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="b3eb6-243">Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="b3eb6-244">Jeśli parametr bieżącej metody jest typem wartości, a odpowiedni argument w `parameters` jest `null`, środowisko uruchomieniowe przekazuje jest inicjowany z wartością zerową wystąpienie typu wartości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-245">Poniższy przykład kodu pokazuje metody dynamicznej wyszukiwania przy użyciu odbicia.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="b3eb6-246">Należy zauważyć, że nie można użyć <xref:System.Reflection.MethodInfo> obiekt z klasy bazowej, aby wywołać przesłonięte metody w klasie pochodnej, ponieważ późne wiązanie nie może rozwiązać zastąpień.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="b3eb6-247">
            <block subset="none" type="note">
              <para> W [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> zamiast tego.  </para>
            </block>
            <paramref name="obj" /> Parametr jest <see langword="null" /> i metoda nie jest statyczne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-247">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> instead.  </para>
              </block>  The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="b3eb6-248">- lub - metoda nie jest zadeklarowany lub dziedziczone przez klasy <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-248">-or-  The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="b3eb6-249">- lub - statyczny Konstruktor jest wywoływana, i <paramref name="obj" /> nie jest ani <see langword="null" /> ani wystąpienia klasy, która zadeklarowana konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-249">-or-  A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3eb6-250">Elementy <paramref name="parameters" /> tablicy nie są zgodne z podpisu metody lub konstruktora, dostarczanej przez to wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-250">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b3eb6-251">Wywołana metoda lub Konstruktor zgłasza wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-251">The invoked method or constructor throws an exception.</span>
          </span>
          <span data-ttu-id="b3eb6-252">- lub - bieżące wystąpienie jest <see cref="T:System.Reflection.Emit.DynamicMethod" /> , zawiera nieweryfikowalny kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-252">-or-  The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span>
          </span>
          <span data-ttu-id="b3eb6-253">Sekcja "Weryfikacja" w uwagi dla <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-253">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="b3eb6-254">
            <paramref name="parameters" /> Tablica nie ma poprawną liczbę argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-254">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="b3eb6-255">
            <block subset="none" type="note">
              <para> W [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), przechwycić wyjątek klasy bazowej <see cref="T:System.MemberAccessException" />, a zamiast tego.  </para>
            </block>  Obiekt wywołujący nie ma uprawnienia do wykonywania metody lub konstruktora, który jest reprezentowany przez bieżące wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-255">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.  </para>
              </block>  The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b3eb6-256">Typ, który deklaruje metody jest to otwarty typ ogólny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-256">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="b3eb6-257">Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" /> dla typu deklarującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-257">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b3eb6-258">Bieżące wystąpienie jest <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-258">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-259">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-259">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-260">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-260">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBase.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="b3eb6-261">Obiekt do wywołania metody lub konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-261">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="b3eb6-262">Jeśli metoda jest statyczna, ten argument zostanie zignorowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-262">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="b3eb6-263">Jeśli konstruktor jest statyczna, ten argument musi być <see langword="null" /> lub wystąpienia klasy, która definiuje konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-263">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="b3eb6-264">Maska bitów, który składa się z co najmniej 0 flag bitowych z <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-264">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
          <span data-ttu-id="b3eb6-265">Jeśli <c>integratora</c> jest <see langword="null" />, ten parametr jest przypisywana wartość <see cref="F:System.Reflection.BindingFlags.Default" />; w związku z tym, niezależnie od przekazanej jest ignorowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-265">If <c>binder</c> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="b3eb6-266">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see langword="MemberInfo" /> obiektów przy użyciu odbicia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-266">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="b3eb6-267">Jeśli <c>integratora</c> jest <see langword="null" />, jest używany domyślny integrator.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-267">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="b3eb6-268">Lista argumentów dla wywołanej metody lub konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-268">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="b3eb6-269">Jest to tablica obiektów przy użyciu tego samego liczbę, kolejność i typ jako parametry metody lub konstruktora do wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-269">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="b3eb6-270">Jeśli nie ma żadnych parametrów, powinna to być <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-270">If there are no parameters, this should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b3eb6-271">Jeśli ta metoda lub Konstruktor reprezentowanym przez to wystąpienie przyjmuje parametrów ByRef, nie ma specjalne atrybutu wymagane dla tego parametru w celu wywołania metody lub konstruktora przy użyciu tej funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-271">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="b3eb6-272">Dowolny obiekt w tej tablicy, która nie jest jawnie zainicjowana z wartością będzie zawierać wartość domyślna dla tego typu obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-272">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="b3eb6-273">Elementy typu odwołania, ta wartość jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-273">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="b3eb6-274">Typ wartości elementów, ta wartość wynosi 0, 0.0, lub <see langword="false" />, w zależności od typu określonego elementu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-274">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="b3eb6-275">Wystąpienie <see langword="CultureInfo" /> używane do sterowania wymuszanie typów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-275">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="b3eb6-276">Jeśli jest to <see langword="null" />, <see langword="CultureInfo" /> dla bieżącego wątku jest używana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-276">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="b3eb6-277">(Jest to konieczne przekonwertować <see langword="String" /> reprezentujący 1000- <see langword="Double" /> wartość, na przykład, ponieważ 1000 jest reprezentowany w inny sposób przez różnych kultur.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-277">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-278">W przypadku przesłonięcia w klasie pochodnej, wywołuje odzwierciedloną metodę lub Konstruktor z podanych parametrów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-278">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-279">
            <see langword="Object" /> Zawierający wartość zwracaną wywoływanej metody lub <see langword="null" /> w przypadku konstruktora, lub <see langword="null" /> Jeśli metoda zwracany typ jest <see langword="void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-279">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span>
          </span>
          <span data-ttu-id="b3eb6-280">Przed wywołaniem metody lub konstruktora, <see langword="Invoke" /> sprawdza, czy użytkownik ma uprawnienia dostępu, i sprawdza, czy parametry są prawidłowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-280">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-281">Dynamicznie wywołuje metodę przez to wystąpienie będzie przedstawiane na `obj`i przekazywane wraz z określonymi parametrami.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-281">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="b3eb6-282">Jeśli metoda jest statyczna, `obj` parametr jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-282">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="b3eb6-283">Dla metod niestatycznych `obj` powinien być wystąpieniem klasy, która dziedziczy lub deklaruje metodę i muszą być tego samego typu co tej klasy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-283">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="b3eb6-284">Jeśli metoda nie ma parametrów, wartość `parameters` powinien być `null`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-284">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="b3eb6-285">W przeciwnym razie liczbę, typ i kolejność elementów w `parameters` powinna być taka sama jak liczba, typ i kolejność parametrów dla metody, dostarczanej przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-285">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="b3eb6-286">Nie pominięto parametry opcjonalne w wywołaniach `Invoke`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-286">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="b3eb6-287">Aby wywołać metodę pominięcie następujące parametry opcjonalne, należy wywołać `Type.InvokeMember` zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-287">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-288">Użycie tego przeciążenia metody do wywołania konstruktora wystąpień obiektu podana dla `obj` są ponownie inicjowane; oznacza to, że zostały wykonane wszystkie inicjatory wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-288">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="b3eb6-289">Wartość zwracana jest `null`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-289">The return value is `null`.</span></span> <span data-ttu-id="b3eb6-290">Jeśli jest wywoływany jest konstruktor klasy, klasy są ponownie inicjowane; oznacza to wykonywane są wszystkie inicjatory klasy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-290">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="b3eb6-291">Wartość zwracana jest `null`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-291">The return value is `null`.</span></span>  
  
 <span data-ttu-id="b3eb6-292">Dla parametrów pierwotnych, przekazać przez wartość, odbywa się normalna rozszerzanie (Int16 -> typu Int32, na przykład).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-292">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="b3eb6-293">Dla parametrów, przekazać przez wartość odniesienia rozszerzanie normalne odwołanie jest dozwolona (klasy pochodnej klasy podstawowej i klasy bazowej do typu interfejsu).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-293">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="b3eb6-294">Jednak dla pierwotnych parametrów przekazywany przez odwołanie, typy musi dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-294">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="b3eb6-295">Dla parametrów przekazywany przez odwołanie, odwołanie normalne rozszerzanie nadal obowiązuje ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-295">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="b3eb6-296">Na przykład, jeśli metoda dostarczanej przez to wystąpienie jest zadeklarowany jako `public boolean Compare(String a, String b)`, następnie `parameters` powinna być tablica `Objects` o długości 2 tak, aby `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-296">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="b3eb6-297">Jeśli parametr bieżącej metody jest typem wartości, a odpowiedni argument w `parameters` jest `null`, środowisko uruchomieniowe przekazuje jest inicjowany z wartością zerową wystąpienie typu wartości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-297">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="b3eb6-298">Odbicie używa metody dynamicznej wyszukiwania podczas wywoływania metod wirtualnych.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-298">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="b3eb6-299">Na przykład załóżmy, że klasa B dziedziczy z klasy A, a oba zaimplementować metodę wirtualną o nazwie M. Teraz załóżmy, że masz `MethodInfo` obiekt, który reprezentuje M w klasie A. Jeśli używasz `Invoke` metody do wywołania M na obiekt typu B, a następnie odbicia użyje wykonania podany przez klasę B. Nawet wtedy, gdy obiekt typu B jest rzutowany na element, służy do wdrażania przez klasy B (zobacz poniższy przykład kodu).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-299">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="b3eb6-300">Z drugiej strony, w przypadku metody niewirtualnej odbicia będzie użyć implementacji określone przez typ, z którego `MethodInfo` uzyskano niezależnie od typu obiekt przekazany jako element docelowy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-300">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="b3eb6-301">Ograniczenia dostępu są ignorowane w przypadku w pełni zaufany kod.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-301">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="b3eb6-302">Oznacza to, że konstruktory prywatne, metody, pola i właściwości umożliwia dostęp i wywoływane za pośrednictwem odbicia, zawsze wtedy, gdy kod jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-302">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="b3eb6-303">Jeśli jest wywoływana metoda zgłasza wyjątek, `TargetInvocationException.GetException` zwraca wyjątek.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-303">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="b3eb6-304">Ta implementacja zwraca `NotSupportedException`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-304">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-305">Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-305">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="b3eb6-306">(Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="b3eb6-306">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="b3eb6-307">Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-307">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-308">W poniższym przykładzie pokazano wszystkie elementy członkowskie <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy za pomocą przeciążenia <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-308">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b3eb6-309">Metoda prywatna `CanConvertFrom` znajdzie zgodne typy dla danego typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-309">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="b3eb6-310">Inny przykład wywoływanie elementów członkowskich w scenariuszu niestandardowego powiązania, zobacz [dynamiczne ładowanie i przy użyciu typów](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-310">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="b3eb6-311">
            <paramref name="obj" /> Parametr jest <see langword="null" /> i metoda nie jest statyczne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-311">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="b3eb6-312">- lub - metoda nie jest zadeklarowany lub dziedziczone przez klasy <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-312">-or-  The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="b3eb6-313">- lub - statyczny Konstruktor jest wywoływana, i <paramref name="obj" /> nie jest ani <see langword="null" /> ani wystąpienia klasy, która zadeklarowana konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-313">-or-  A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3eb6-314">Typ <paramref name="parameters" /> parametr nie jest zgodny podpis metody lub konstruktora, dostarczanej przez to wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-314">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="b3eb6-315">
            <paramref name="parameters" /> Tablica nie ma poprawną liczbę argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-315">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="b3eb6-316">Wywołana metoda lub Konstruktor zgłasza wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-316">The invoked method or constructor throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="b3eb6-317">Obiekt wywołujący nie ma uprawnienia do wykonywania metody lub konstruktora, który jest reprezentowany przez bieżące wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-317">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b3eb6-318">Typ, który deklaruje metody jest to otwarty typ ogólny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-318">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="b3eb6-319">Oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" /> dla typu deklarującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-319">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="b3eb6-320">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-320">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="b3eb6-321">Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-321">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Reflection.MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-322">Pobiera wartość wskazującą, czy metoda jest abstrakcyjna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-322">Gets a value indicating whether the method is abstract.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-323">
            <see langword="true" /> Jeśli metoda jest abstrakcyjna; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-323">
              <see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-324">Abstrakcyjnej składowej jest zadeklarowana w klasie bazowej i udostępnił nie implementacji.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-324">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="b3eb6-325">Aby uzyskać <xref:System.Reflection.MethodBase>, najpierw uzyskać typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-325">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="b3eb6-326">Od typu metoda get.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-326">From the type, get the method.</span></span> <span data-ttu-id="b3eb6-327">W metodzie, uzyskać `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-327">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="b3eb6-328">Jeśli `MethodBase` lub Konstruktor jest inne niż publicznego, jest chroniona i nie jest łatwo dostępny.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-328">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="b3eb6-329">Aby uzyskać dostęp do metody niepublicznej, należy ustawić <xref:System.Reflection.BindingFlags> maski do `NonPublic` w `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-329">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-330">Poniższy przykład określa, czy określona metoda jest abstrakcyjna i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-330">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAssembly : bool" Usage="System.Reflection.MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-331">Pobiera wartość wskazującą, czy potencjalny widoczność ta metoda lub Konstruktor jest opisana przez <see cref="F:System.Reflection.MethodAttributes.Assembly" />; oznacza to, że metoda lub Konstruktor jest widoczna co najwyżej do innych typów, w tym samym zestawie, a nie są widoczne dla pochodzi typy spoza zestawu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-331">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-332">
            <see langword="true" /> Jeśli widoczność ta metoda lub Konstruktor dokładnie opisanego przez <see cref="F:System.Reflection.MethodAttributes.Assembly" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-332">
              <see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-333">Rzeczywiste widoczność metodą jest ograniczona widoczność jego typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-333">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="b3eb6-334"><xref:System.Reflection.MethodBase.IsAssembly%2A> Właściwość może być `true` dla metody, ale gdy jest metody prywatnej typu zagnieżdżonego, a następnie metoda nie jest widoczna na zewnątrz typu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-334">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="b3eb6-335">Widoczność metoda lub Konstruktor dokładnie opisanego przez <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> przypadku modyfikator tylko widoczności `internal` (`Friend` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-335">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="b3eb6-336">Ta właściwość jest `false` dla metod, które są `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++); użyj <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> właściwość do identyfikacji takich metod.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-336">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-337">Poniższy kod definiuje metod z różnymi poziomami widoczności i wyświetla wartości ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-337">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-338">W językach Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlana tylko w przykładzie w języku C++.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-338">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructor : bool" Usage="System.Reflection.MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-339">Pobiera wartość wskazującą, czy metoda jest konstruktorem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-339">Gets a value indicating whether the method is a constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-340">
            <see langword="true" /> Jeśli ta metoda jest konstruktorem, reprezentowane przez <see cref="T:System.Reflection.ConstructorInfo" /> obiekt (zobacz uwagi w uwagi <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> obiektów); w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-340">
              <see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-341"><xref:System.Reflection.MethodBase.IsConstructor%2A> Właściwość zwraca `false` dla <xref:System.Reflection.Emit.ConstructorBuilder> obiektu typu dynamicznego, chyba że <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> Flaga został włączony do `attributes` parametru podczas definiowania konstruktora.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-341">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="b3eb6-342">Pominięcie <xref:System.Reflection.MethodAttributes.RTSpecialName> flaga nie ma wpływu na poprawność emitowany konstruktora.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-342">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamily : bool" Usage="System.Reflection.MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-343">Pobiera wartość wskazującą, czy widoczność ta metoda lub Konstruktor jest opisana przez <see cref="F:System.Reflection.MethodAttributes.Family" />; metoda lub Konstruktor jest widoczny tylko w obrębie swojej klasy i klas pochodnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-343">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-344">
            <see langword="true" /> Jeśli dostęp do tej metody lub konstruktora dokładnie opisanego przez <see cref="F:System.Reflection.MethodAttributes.Family" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-344">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-345">Widoczność metoda lub Konstruktor dokładnie opisanego przez <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> przypadku modyfikator tylko widoczności `protected`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-345">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="b3eb6-346">Ta właściwość jest `false` dla metod, które są `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++); użyj <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> właściwość do identyfikacji takich metod.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-346">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-347">Poniższy kod definiuje metod z różnymi poziomami widoczności i wyświetla wartości ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-347">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-348">W językach Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlana tylko w przykładzie w języku C++.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-348">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyAndAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-349">Pobiera wartość wskazującą, czy widoczność ta metoda lub Konstruktor jest opisana przez <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; oznacza to, że metoda lub Konstruktor może być wywoływany przez klasy pochodne, ale tylko wtedy, jeśli znajdują się w tym samym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-349">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-350">
            <see langword="true" /> Jeśli dostęp do tej metody lub konstruktora dokładnie opisanego przez <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-350">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-351">Widoczność metoda lub Konstruktor dokładnie opisanego przez <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> przypadku modyfikator widoczności `protected private` w języku C++.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-351">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="b3eb6-352">Nie można zdefiniować metody to wgląd w języku Visual Basic lub C#.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-352">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-353">Poniższy kod definiuje metod z różnymi poziomami widoczności i wyświetla wartości ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-353">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-354">W językach Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlana tylko w przykładzie w języku C++.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-354">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyOrAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-355">Pobiera wartość wskazującą, czy potencjalny widoczność ta metoda lub Konstruktor jest opisana przez <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; oznacza to, że metoda lub Konstruktor może być wywoływany przez klasy pochodne wszędzie tam, gdzie one są i klas w tym samym zestawie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-355">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-356">
            <see langword="true" /> Jeśli dostęp do tej metody lub konstruktora dokładnie opisanego przez <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-356">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-357">Jeśli członek typu ma <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> widoczność, można ją wywołać z dowolnego elementu członkowskiego w klasie pochodnej lub dowolnego elementu członkowskiego, w tym samym zestawie, ale nie z innego typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-357">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="b3eb6-358">Rzeczywiste widoczność metodą jest ograniczona widoczność jego typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-358">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="b3eb6-359"><xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> Właściwość może być `true` dla metody, ale gdy jest metody prywatnej typu zagnieżdżonego, a następnie metoda nie jest widoczna na zewnątrz typu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-359">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="b3eb6-360">Widoczność metoda lub Konstruktor dokładnie opisanego przez <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> przypadku modyfikator widoczności `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-360">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-361">Poniższy kod definiuje metod z różnymi poziomami widoczności i wyświetla wartości ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-361">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-362">W językach Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlana tylko w przykładzie w języku C++.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-362">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinal : bool" Usage="System.Reflection.MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-363">Pobiera wartość wskazującą, czy ta metoda jest <see langword="final" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-363">Gets a value indicating whether this method is <see langword="final" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-364">
            <see langword="true" /> Jeśli ta metoda jest <see langword="final" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-364">
              <see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-365">Aby określić, czy metoda jest możliwym do zastąpienia, nie jest wystarczające, aby sprawdzić, czy <xref:System.Reflection.MethodBase.IsVirtual%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-365">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="b3eb6-366">Metody, która ma być możliwym do zastąpienia `IsVirtual` musi być `true` i `IsFinal` musi być `false`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-366">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="b3eb6-367">Na przykład metoda może być niewirtualną, ale implementuje metodę interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-367">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="b3eb6-368">Środowisko uruchomieniowe języka wspólnego wymaga, że wszystkie metody, które implementują interfejs członków musi być oznaczona jako `virtual`; w związku z tym, kompilator oznacza metodę `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-368">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="b3eb6-369">Dlatego istnieją przypadki, w którym metoda jest oznaczona jako `virtual` , ale jest nadal nie możliwym do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-369">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="b3eb6-370">Aby ustanowić z pewnością, czy metoda jest możliwym do zastąpienia, należy użyć kodu takiego jak to:</span><span class="sxs-lookup"><span data-stu-id="b3eb6-370">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="b3eb6-371">Jeśli `IsVirtual` jest `false` lub `IsFinal` jest `true`, a następnie metoda nie może być zastąpiona.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-371">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-372">Poniższy przykład wyświetla `false` dla `IsFinal`, co może prowadzić do myśl, że MyMethod jest możliwym do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-372">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="b3eb6-373">Ten kod wyświetla `false` nawet, jeśli nie jest oznaczony jako MyMethod `virtual` i dlatego nie można zastąpić.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-373">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodBase.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-374">Pobiera wartość wskazującą, czy metoda jest ogólna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-374">Gets a value indicating whether the method is generic.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-375">
            <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> reprezentuje metody ogólnej; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-375">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-376">Użyj <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości, aby określić, czy bieżący <xref:System.Reflection.MethodBase> obiekt reprezentuje metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-376">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="b3eb6-377">Użyj <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwości, aby określić, czy bieżącego <xref:System.Reflection.MethodBase> obiekt reprezentuje zbudowany metody open lub zamknięte metody skonstruowany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-377">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-378">Typy ogólne nie są obsługiwane przez domyślny; Ta właściwość zwraca `false` Jeśli nie zostanie zastąpiona w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-378">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="b3eb6-379">Ogólny konstruktorów nie są obsługiwane w wersji 2.0, .NET Framework, więc ta właściwość zwraca `false` Jeśli bieżące wystąpienie jest typu <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-379">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="b3eb6-380">Poniższa tabela zawiera podsumowanie niezmiennych warunków dla terminów specyficznych dla metod ogólnych.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-380">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="b3eb6-381">Dla innych terminów używanych w odbiciu rodzajowym, takich jak *parametr typu ogólnego* i *typu ogólnego*, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-381">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="b3eb6-382">Termin</span><span class="sxs-lookup"><span data-stu-id="b3eb6-382">Term</span></span>|<span data-ttu-id="b3eb6-383">Niezmienna warunku</span><span class="sxs-lookup"><span data-stu-id="b3eb6-383">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="b3eb6-384">definicja metody ogólnej</span><span class="sxs-lookup"><span data-stu-id="b3eb6-384">generic method definition</span></span>| <span data-ttu-id="b3eb6-385"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-385">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="b3eb6-386">Definiuje metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-386">Defines a generic method.</span></span> <span data-ttu-id="b3eb6-387">Metoda stworzonego elementu jest tworzony przez wywołanie <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metody <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje definicję metody rodzajowej, a następnie określając tablicę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-387">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="b3eb6-388"><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> Metoda może być wywoływana tylko w definicji metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-388">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="b3eb6-389">Dowolna definicja metody ogólnej jest metody rodzajowej, ale nie jest to prawdą.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-389">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="b3eb6-390">Metoda ogólna</span><span class="sxs-lookup"><span data-stu-id="b3eb6-390">generic method</span></span>|<span data-ttu-id="b3eb6-391">`IsGenericMethod` Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-391">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="b3eb6-392">Może być definicję metody rodzajowej, zbudowany metody open lub zamknięte metodę skonstruowany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-392">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="b3eb6-393">Open skonstruowany — metoda</span><span class="sxs-lookup"><span data-stu-id="b3eb6-393">open constructed method</span></span>|<span data-ttu-id="b3eb6-394"><xref:System.Reflection.MethodBase.ContainsGenericParameters> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-394">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="b3eb6-395">Nie jest możliwe do wywołania metody open skonstruowany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-395">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="b3eb6-396">zamknięte skonstruowany — metoda</span><span class="sxs-lookup"><span data-stu-id="b3eb6-396">closed constructed method</span></span>|<span data-ttu-id="b3eb6-397"><xref:System.Reflection.MethodBase.ContainsGenericParameters> Właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-397">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="b3eb6-398">Gdy zbadane cyklicznie, metoda nie ma nieprzypisane ogólnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-398">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="b3eb6-399">Typ zawierający nie ma żadnych parametrów typu ogólnego, a żaden z argumentów typu nie ma parametrów typu genetycznego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-399">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="b3eb6-400">Może być wywołana metoda.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-400">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-401">Pobiera wartość wskazującą, czy metoda jest definicją metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-401">Gets a value indicating whether the method is a generic method definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-402">
            <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentuje definicję metody ogólnej; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-402">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-403">Jeśli bieżący <xref:System.Reflection.MethodBase> reprezentuje definicję metody rodzajowej, następnie:</span><span class="sxs-lookup"><span data-stu-id="b3eb6-403">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="b3eb6-404"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-404">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="b3eb6-405">Dla każdego <xref:System.Type> obiektów w tablicy zwracanej przez <xref:System.Reflection.MethodBase.GetGenericArguments%2A> metody:</span><span class="sxs-lookup"><span data-stu-id="b3eb6-405">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="b3eb6-406"><xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-406">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="b3eb6-407"><xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> Właściwość zwraca bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-407">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="b3eb6-408"><xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> Właściwości jest taka sama jak pozycja <xref:System.Type> obiektów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-408">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b3eb6-409">Typy ogólne nie są obsługiwane przez domyślny; Ta właściwość zwraca `false` Jeśli nie zostanie zastąpiona w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-409">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="b3eb6-410">Ogólny konstruktorów nie są obsługiwane w wersji 2.0, .NET Framework, więc ta właściwość zwraca `false` Jeśli bieżące wystąpienie jest typu <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-410">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="b3eb6-411">Aby uzyskać listę niezmiennych warunków dla terminów specyficznych dla metod ogólnych, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-411">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="b3eb6-412">Aby uzyskać listę niezmiennych warunków dla innych terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-412">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHideBySig : bool" Usage="System.Reflection.MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-413">Pobiera wartość wskazującą, czy jest członkiem tego samego rodzaju przy użyciu dokładnie taki sam podpis jest ukryty w klasie pochodnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-413">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-414">
            <see langword="true" /> Jeśli element członkowski jest ukryty przez podpis. w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-414">
              <see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-415">Gdy element członkowski w klasie pochodnej jest zadeklarowana za pomocą języka C# `new` modyfikator lub Visual Basic `Shadows` modyfikator, można ukryć, jest członkiem tej samej nazwie w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-415">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="b3eb6-416">C# ukrywa składowych klasy bazowej podpisem.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-416">C# hides base class members by signature.</span></span> <span data-ttu-id="b3eb6-417">Jeśli składowej klasy bazowej ma wiele przeciążeń, tylko jeden, który jest ukryty jest ten, który ma podpis identyczny.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-417">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="b3eb6-418">Z drugiej strony Visual Basic ukrywa wszystkie przeciążenia klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-418">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="b3eb6-419">W efekcie <xref:System.Reflection.MethodBase.IsHideBySig%2A> zwraca `false` w elemencie członkowskim zadeklarowane za pomocą języka Visual Basic `Shadows` modyfikator, i `true` w elemencie członkowskim zadeklarowane za pomocą języka C# `new` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-419">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="b3eb6-420">Ta właściwość nie określa, czy metoda ma <xref:System.Reflection.MethodAttributes.NewSlot> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-420">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="b3eb6-421">Metody, która jest zadeklarowana za pomocą albo `new` lub `Shadows` mają modyfikator <xref:System.Reflection.MethodAttributes.NewSlot> atrybut, ale tylko metod zadeklarowanych za pomocą `new` (czyli tylko C# metody) będzie miał <xref:System.Reflection.MethodBase.IsHideBySig%2A> właściwość ustawioną na `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-421">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="b3eb6-422">Aby ustalić, czy metoda ma <xref:System.Reflection.MethodAttributes.NewSlot> atrybutu, należy użyć kodu podobnego do następującego: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` w języku C# lub `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-422">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="b3eb6-423">Należy jednak pamiętać, że mimo, że wszystkie metody zadeklarowane za pomocą `new` lub `Shadows` mają <xref:System.Reflection.MethodAttributes.NewSlot> atrybutu, nie wszystkie metody, które mają <xref:System.Reflection.MethodAttributes.NewSlot> atrybut jest zadeklarowany za pomocą `new` lub `Shadows`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-423">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-424">Poniższy przykład kodu zawiera klasę bazową z przeciążonej metody i Klasa pochodna, która ukrywa jedno z przeciążeń.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-424">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="b3eb6-425">W wersji Visual Basic przykładowy kod <xref:System.Reflection.MethodBase.IsHideBySig%2A> właściwość zwraca `false` dla elementu członkowskiego w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-425">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="b3eb6-426">W języku C# wersji przykładowy kod, właściwość ta zwraca `true` dla elementu członkowskiego w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-426">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrivate : bool" Usage="System.Reflection.MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-427">Pobiera wartość wskazującą, czy ten element członkowski jest oznaczony jako prywatny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-427">Gets a value indicating whether this member is private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-428">
            <see langword="true" /> Jeśli dostęp do tej metody jest ograniczony do innych składowych klasy. w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-428">
              <see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-429">Jeśli członek typu ma `Private` poziom widoczności, może ona zostać wywołana z dowolnego elementu członkowskiego w tej samej klasie i nie inne osoby.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-429">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Reflection.MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-430">Pobiera wartość wskazującą, czy jest to metoda publiczna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-430">Gets a value indicating whether this is a public method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-431">
            <see langword="true" /> Jeśli ta metoda jest publiczny; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-431">
              <see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-432">Aby uzyskać <xref:System.Reflection.MethodBase>, najpierw uzyskać typu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-432">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="b3eb6-433">Od typu metoda get.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-433">From the type, get the method.</span></span> <span data-ttu-id="b3eb6-434">W metodzie, uzyskać `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-434">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="b3eb6-435">Jeśli `MethodBase` lub Konstruktor jest inne niż publicznego, jest chroniona i nie jest łatwo dostępny.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-435">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="b3eb6-436">Aby uzyskać dostęp do metody niepublicznej, należy ustawić <xref:System.Reflection.BindingFlags> maski do `NonPublic` w `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-436">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-437">W poniższym przykładzie użyto <xref:System.Reflection.MethodBase.IsPublic%2A> właściwość, aby wyświetlić komunikat, który wskazuje, czy podana metoda jest publiczny.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-437">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-438">Pobiera wartość wskazującą, czy bieżąca metoda lub Konstruktor jest krytyczne dla bezpieczeństwa lub zabezpieczenia bezpieczny krytyczny na bieżącym poziomie zaufania, a w związku z tym można wykonywać krytyczne operacje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-438">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-439">
            <see langword="true" /> Jeśli bieżąca metoda lub Konstruktor jest krytyczne dla bezpieczeństwa lub zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. <see langword="false" /> , gdy jest za przezroczysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-439">
              <see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-440"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metodę lub Konstruktor w jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-440">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="b3eb6-441">W poniższej tabeli przedstawiono kombinacje tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="b3eb6-441">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="b3eb6-442">Poziom zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="b3eb6-442">Security level</span></span>|<span data-ttu-id="b3eb6-443">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="b3eb6-443">IsSecurityCritical</span></span>|<span data-ttu-id="b3eb6-444">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="b3eb6-444">IsSecuritySafeCritical</span></span>|<span data-ttu-id="b3eb6-445">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="b3eb6-445">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="b3eb6-446">Krytyczny</span><span class="sxs-lookup"><span data-stu-id="b3eb6-446">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="b3eb6-447">Bezpieczne krytyczne</span><span class="sxs-lookup"><span data-stu-id="b3eb6-447">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="b3eb6-448">Przezroczyste</span><span class="sxs-lookup"><span data-stu-id="b3eb6-448">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="b3eb6-449">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów i elementów członkowskich, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-449">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3eb6-450">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-450">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="b3eb6-451">Jeśli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-451">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="b3eb6-452">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-452">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="b3eb6-453">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-453">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="b3eb6-454">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-454">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="b3eb6-455">Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-455">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="b3eb6-456">Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-456">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="b3eb6-457">Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-457">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-458">Pobiera wartość, która wskazuje, czy bieżąca metoda lub Konstruktor zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. oznacza to, czy go może wykonywać krytyczne operacje i może zostać oceniony przez kod przezroczysty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-458">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-459">
            <see langword="true" /> Jeśli metoda lub Konstruktor zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. <see langword="false" /> przypadku krytyczne dla bezpieczeństwa lub przezroczyste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-459">
              <see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-460"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metodę lub Konstruktor w jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-460">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="b3eb6-461">W poniższej tabeli przedstawiono kombinacje tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="b3eb6-461">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="b3eb6-462">Poziom zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="b3eb6-462">Security level</span></span>|<span data-ttu-id="b3eb6-463">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="b3eb6-463">IsSecurityCritical</span></span>|<span data-ttu-id="b3eb6-464">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="b3eb6-464">IsSecuritySafeCritical</span></span>|<span data-ttu-id="b3eb6-465">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="b3eb6-465">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="b3eb6-466">Krytyczny</span><span class="sxs-lookup"><span data-stu-id="b3eb6-466">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="b3eb6-467">Bezpieczne krytyczne</span><span class="sxs-lookup"><span data-stu-id="b3eb6-467">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="b3eb6-468">Przezroczyste</span><span class="sxs-lookup"><span data-stu-id="b3eb6-468">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="b3eb6-469">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów i elementów członkowskich, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-469">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3eb6-470">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-470">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="b3eb6-471">Jeśli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-471">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="b3eb6-472">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-472">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="b3eb6-473">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-473">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="b3eb6-474">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-474">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="b3eb6-475">Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-475">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="b3eb6-476">Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-476">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="b3eb6-477">Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-477">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-478">Pobiera wartość wskazującą, czy bieżąca metoda lub Konstruktor jest niewidoczny w zaufania bieżącym poziomie i w związku z tym nie można wykonać krytyczne operacje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-478">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-479">
            <see langword="true" /> Jeśli metoda lub Konstruktor jest przezroczyste dla zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-479">
              <see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-480">Jeśli ta właściwość zwraca `true`, <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> i <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> return właściwości `false`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-480">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="b3eb6-481"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metodę lub Konstruktor w jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-481">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="b3eb6-482">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów i elementów członkowskich, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-482">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3eb6-483">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-483">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="b3eb6-484">Jeśli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-484">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="b3eb6-485">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-485">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="b3eb6-486">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-486">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="b3eb6-487">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-487">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="b3eb6-488">Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-488">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="b3eb6-489">Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-489">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="b3eb6-490">Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-490">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-491">Pobiera wartość wskazującą, czy ta metoda ma specjalną nazwę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-491">Gets a value indicating whether this method has a special name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-492">
            <see langword="true" /> Jeśli ta metoda ma specjalną nazwę; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-492">
              <see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-493"><xref:System.Reflection.MethodAttributes.SpecialName> Bit jest ustawiony do elementów członkowskich, które są traktowane w specjalny sposób przez niektóre kompilatory (na przykład metod dostępu do właściwości i metod przeciążenia operatora).</span><span class="sxs-lookup"><span data-stu-id="b3eb6-493">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-494">W tym przykładzie przedstawiono użycie <xref:System.Reflection.MethodBase.IsSpecialName%2A> filtrowanie wewnętrznych lub prywatnych elementów członkowskich spoza listy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-494">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Reflection.MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-495">Pobiera wartość wskazującą, czy metoda jest <see langword="static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-495">Gets a value indicating whether the method is <see langword="static" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-496">
            <see langword="true" /> Jeśli ta metoda jest <see langword="static" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-496">
              <see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-497">Statyczny element członkowski niejawnie nie mogą odwoływać się dane wystąpienia w klasie.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-497">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVirtual : bool" Usage="System.Reflection.MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-498">Pobiera wartość wskazującą, czy metoda jest <see langword="virtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-498">Gets a value indicating whether the method is <see langword="virtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-499">
            <see langword="true" /> Jeśli ta metoda jest <see langword="virtual" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-499">
              <see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-500">Wirtualny element członkowski może odwoływać się do danych wystąpienia w klasie i musi odwoływać się za pośrednictwem wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-500">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="b3eb6-501">Aby określić, czy metoda jest możliwym do zastąpienia, nie jest wystarczające, aby sprawdzić, czy `IsVirtual` jest `true`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-501">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="b3eb6-502">Metody, która ma być możliwym do zastąpienia `IsVirtual` musi być `true` i <xref:System.Reflection.MethodBase.IsFinal%2A> musi być `false`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-502">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="b3eb6-503">Na przykład metoda może być niewirtualną, ale implementuje metodę interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-503">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="b3eb6-504">Środowisko uruchomieniowe języka wspólnego wymaga, że wszystkie metody, które implementują interfejs członków musi być oznaczona jako `virtual`; w związku z tym, kompilator oznacza metodę `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-504">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="b3eb6-505">Dlatego istnieją przypadki, w którym metoda jest oznaczona jako `virtual` , ale jest nadal nie możliwym do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-505">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="b3eb6-506">Aby ustanowić z pewnością, czy metoda jest możliwym do zastąpienia, należy użyć kodu takiego jak to:</span><span class="sxs-lookup"><span data-stu-id="b3eb6-506">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="b3eb6-507">Jeśli `IsVirtual` jest `false` lub `IsFinal` jest `true`, a następnie metoda nie może być zastąpiona.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-507">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="b3eb6-508">Można określić, czy bieżąca metoda zastępuje metodę w klasie bazowej, wywołując <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-508">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b3eb6-509">Poniższy przykład implementuje `IsOverride` metodę, która wykonuje to.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-509">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="b3eb6-510">Poniższy przykład wyświetla `false` dla `IsFinal`, co może prowadzić na myśl, że `MyMethod` jest możliwym do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-510">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="b3eb6-511">Ten kod wyświetla `false` mimo że `MyMethod` nie jest oznaczony jako `virtual` i dlatego nie można zastąpić.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-511">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.MethodBase.MethodHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-512">Pobiera uchwyt do reprezentacji wewnętrznej metadanych metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-512">Gets a handle to the internal metadata representation of a method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-513">Element <see cref="T:System.RuntimeMethodHandle" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-513">A <see cref="T:System.RuntimeMethodHandle" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-514">Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-514">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-515">Pobiera <see cref="T:System.Reflection.MethodImplAttributes" /> flagi, które określają atrybuty implementacji metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-515">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-516">Flagi implementacji metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-516">The method implementation flags.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-517">Zobacz <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> metody, aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-517">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b3eb6-518">Pierwszy obiekt, który ma zostać porównany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-518">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b3eb6-519">Drugi obiekt, który będzie porównywany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-519">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-520">Wskazuje, czy dwa <see cref="T:System.Reflection.MethodBase" /> obiekty są sobie równe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-520">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-521">
            <see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-521">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="System.Reflection.MethodBase.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b3eb6-522">Pierwszy obiekt, który ma zostać porównany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-522">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b3eb6-523">Drugi obiekt, który będzie porównywany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-523">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-524">Wskazuje, czy dwa <see cref="T:System.Reflection.MethodBase" /> obiekty nie są równe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-524">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-525">
            <see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-525">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="b3eb6-526">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-526">Reserved for future use.</span>
          </span>
          <span data-ttu-id="b3eb6-527">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-527">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="b3eb6-528">Przekazana tablica nazw ma być mapowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-528">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="b3eb6-529">Liczba nazw, które mają być mapowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-529">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="b3eb6-530">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-530">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="b3eb6-531">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-531">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-532">Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-532">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-533">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-533">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b3eb6-534">Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-534">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b3eb6-535">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-535">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-536">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-536">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3eb6-537">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-537">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-538">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-538">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-539">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-539">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="b3eb6-540">Informacje o typie, który będzie zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-540">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="b3eb6-541">Identyfikator regionalny dla informacji o typie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-541">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="b3eb6-542">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-542">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-543">Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-543">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-544">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-544">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b3eb6-545">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-545">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b3eb6-546">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-546">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="b3eb6-547">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-547">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-548">Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-548">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-549">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-549">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b3eb6-550">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-550">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b3eb6-551">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-551">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="b3eb6-552">Określa element członkowski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-552">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="b3eb6-553">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-553">Reserved for future use.</span>
          </span>
          <span data-ttu-id="b3eb6-554">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-554">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="b3eb6-555">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-555">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="b3eb6-556">Flagi opisujące kontekst wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-556">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="b3eb6-557">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-557">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="b3eb6-558">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-558">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="b3eb6-559">Wskaźnik do struktury, która zawiera informacje o wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-559">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="b3eb6-560">Indeks pierwszego argumentu, który zawiera błąd.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-560">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3eb6-561">Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-561">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-562">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-562">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="b3eb6-563">Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-563">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="b3eb6-564">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-564">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-565">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-565">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-566">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-566">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-567">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-567">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-568">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-568">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-569">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-569">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-570">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-570">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-571">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-571">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-572">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-572">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-573">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-573">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-574">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-574">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-575">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-575">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-576">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-576">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-577">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-577">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-578">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-578">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-579">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-579">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-580">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-580">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-581">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-581">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-582">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-582">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-583">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-583">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-584">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-584">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-585">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-585">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-586">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-586">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-587">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-587">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-588">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-588">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-589">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-589">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-590">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-590">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-591">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-591">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-592">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-592">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-593">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-593">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-594">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-594">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-595">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-595">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-596">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-596">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-597">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-597">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-598">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-598">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-599">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-599">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-600">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-600">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-601">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-601">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-602">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-602">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-603">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-603">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-604">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-604">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-605">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-605">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-606">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-606">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-607">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-607">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-608">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-608">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-609">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-609">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-610">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-610">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-611">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-611">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-612">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-612">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3eb6-613">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-613">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3eb6-614">Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3eb6-614">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3eb6-615">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-615">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="b3eb6-616">Mogą być używane tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="b3eb6-616">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
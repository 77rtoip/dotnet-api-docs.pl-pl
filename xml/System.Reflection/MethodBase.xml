<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cc835ba89554a81318a5948b06c2447df89fe759" />
    <Meta Name="ms.sourcegitcommit" Value="254e16ae65e82f4aa59360cd8572b36b6b5b2f80" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/05/2018" />
    <Meta Name="ms.locfileid" Value="30826219" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera informacje dotyczące metody i konstruktory.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `MethodBase` Klasa podstawowa jest <xref:System.Reflection.MethodInfo> i <xref:System.Reflection.ConstructorInfo>.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides">
      <para>Przy dziedziczeniu z <see langword="MethodBase" />, konieczne jest przesłonięcie następujących członków: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, i <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.MethodBase" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty skojarzone z tą metodą.</summary>
        <value>Jeden z <see cref="T:System.Reflection.MethodAttributes" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszyscy członkowie mają zestaw atrybutów, które są zdefiniowane w odniesieniu do określonego typu elementu członkowskiego.  
  
 Aby uzyskać <xref:System.Reflection.MethodAttributes>, najpierw pobrać typu. Z tego typu get, metoda. W metodzie uzyskać <xref:System.Reflection.MethodAttributes>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia atrybuty zdefiniowane przez użytkownika metoda Mymethod.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 Ten kod generuje następujące dane wyjściowe:  
  
 Przykładowe Reflection.MethodBase.Attributes  
  
 Mymethodbase = Mymethod Void (Int32, System.String ByRef System.String ByRef)  
  
 PrivateScope  
  
 FamANDAssem  
  
 Rodziny  
  
 Public  
  
 HideBySig  
  
 ReuseSlot  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Użyj <see cref="P:System.Reflection.MethodBase.Attributes" /> właściwości w celu określenia, czy metoda jest <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />i tak dalej.</para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą konwencji wywoływania tej metody.</summary>
        <value>
          <see cref="T:System.Reflection.CallingConventions" /> Dla tej metody.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda ogólna zawiera parametry typu ogólnego nieprzypisane.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentuje Metoda ogólna, który zawiera parametry typu ogólnego nieprzypisane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ogólna można wywołać tylko wtedy, gdy nie ma żadnych definicji typu ogólnego lub Otwórz typy utworzone w argumenty typu tej metody lub w dowolnym typie otaczającym. Typy mogą być arbitralnie złożonych, oznaczanie cykliczne jest trudne. Dla wygody, a także aby zmniejszyć prawdopodobieństwo wystąpienia błędu <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwość udostępnia standardowy sposób rozróżnienia zamkniętego skonstruowane metody, które można wywołać, i metody, które nie może skonstruować open. Jeśli <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> zwraca `true`, nie można wywołać metody.  
  
 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> Właściwość wyszukuje rekursywnie dla parametrów typu. Na przykład zwraca `true` dla dowolnej metody w ramach typu otwartego `A<T>` (`A(Of T)` w języku Visual Basic), nawet jeśli tej metody nie jest rodzajowa. Natomiast to z zachowaniem <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwość, która zwraca `false` dla takiej metody.  
  
 Podobnie <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> zwraca parametr właściwości `true` dla dowolnego konstruktora w ramach typu otwartego, mimo że konstruktorów nie może mieć parametrów typu w swoich własnych.  
  
 Lista niezmiennej warunki postanowienia związane z metody ogólne, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości. Lista niezmiennej warunki dla innych terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> equals, typ i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="MethodBase" /> obiekt reprezentujący metodę aktualnie wykonywane.</summary>
        <returns>
          <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> jest metodą statyczną, która jest wywoływana z wewnątrz metody wykonywania i który zwraca informacje na temat tej metody.  
  
 A <see langword="MethodBase" /> obiekt reprezentujący metodę aktualnie wykonywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda aktualnie wykonywane jest zdefiniowany dla typu ogólnego, <xref:System.Reflection.MethodInfo> zwróconego przez <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> są uzyskiwane z definicji typu ogólnego (to znaczy <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> zwraca `true`). W związku z tym nie odzwierciedla argumentów typu, które były używane podczas wywoływania metody. Na przykład, jeśli metoda `M()` jest zdefiniowany dla typu ogólnego `C<T>` (`C(Of T)` w języku Visual Basic), a <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> jest wywoływana z `C<string>.M()`, następnie <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> zwraca `C<T>.M()` (`C(Of T).M()` w języku Visual Basic).  
  
 Jeśli aktualnie wykonywane metoda jest metodą podstawową <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> zwraca definicję metody rodzajowej. Jeśli metoda rodzajowa jest zdefiniowany dla typu ogólnego, <xref:System.Reflection.MethodInfo> są uzyskiwane z definicji typu ogólnego.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano dwa typy. Pierwszy jest klasą nieogólnego `TestClass`, zawiera konstruktora, metody o nazwie `GetValue`i właściwości odczytu / zapisu o nazwie `GetValue`. Drugim jest klasą szablonową o nazwie `TestClass<T>` zawiera konstruktora, `GetValue` — metoda i metody rodzajowej `ConvertValue<Y>`. Każdy konstruktora, metody i metody dostępu właściwości zawiera wywołanie <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> metody.  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące argumenty typu metody ogólnej lub parametrów typu definicję metody rodzajowej.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące argumenty typu metody ogólnej lub parametrów typu definicję metody rodzajowej. Zwraca pustą tablicę, jeśli bieżąca metoda nie jest metody rodzajowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy zwracane są w kolejności, w którym są wyświetlane na liście parametrów typu dla metody ogólnej.  
  
-   Jeśli bieżąca metoda jest metodą skonstruowane zamkniętego (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> zwraca `false`), tablica zwrócona przez <xref:System.Reflection.MethodBase.GetGenericArguments%2A> metoda zawiera typy, które zostały przypisane do parametrów typu ogólnego Metoda ogólna Definicja.  
  
-   Jeśli bieżąca metoda jest ogólną definicją metody, tablica zawiera parametry typu.  
  
-   Jeśli bieżąca metoda jest metodą skonstruowane Otwórz (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> zwraca `true`), w których określone typy zostały przypisane do niektórych parametrów typu i typu parametry otaczającej typów ogólnych zostały przypisane do innego typu Parametry, tablica zawiera typy i typ parametrów. Użyj <xref:System.Type.IsGenericParameter%2A> właściwości, aby wiedzieli, od siebie. Do pokazania w tym scenariuszu, zobacz przykładowy kod podany dla <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwości.  
  
 Konstruktory ogólne nie są obsługiwane w programie .NET Framework w wersji 2.0. Ta właściwość zwraca <xref:System.NotSupportedException> Jeśli nie przesłonięcia w klasie pochodnej, dlatego jest zwracany wyjątek, jeśli bieżące wystąpienie jest typu <xref:System.Reflection.ConstructorInfo>.  
  
 Lista niezmiennej warunki postanowienia związane z metody ogólne, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości. Lista niezmiennej warunki dla innych terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżący obiekt jest <see cref="T:System.Reflection.ConstructorInfo" />. Konstruktory ogólne nie są obsługiwane w programie .NET Framework w wersji 2.0. Ten wyjątek jest to zachowanie domyślne, jeśli ta metoda nie zostanie przesłonięta w klasie pochodnej.</exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera <see cref="T:System.Reflection.MethodBody" /> obiekt, który zapewnia dostęp do strumienia MSIL, zmienne lokalne i wyjątków dla bieżącej metody.</summary>
        <returns>A <see cref="T:System.Reflection.MethodBody" /> obiekt, który zapewnia dostęp do strumienia MSIL, zmienne lokalne i wyjątków dla bieżącej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie masz do przesłonięcia <xref:System.Reflection.MethodBase.GetMethodBody%2A> do jej używania. Możesz wywołać <xref:System.Reflection.MethodBase.GetMethodBody%2A> metoda <xref:System.Reflection.MethodInfo> i <xref:System.Reflection.ConstructorInfo> obiektów, ponieważ metoda zostanie przesłonięta w wersji środowiska uruchomieniowego tych klas. Na przykład wersję środowiska uruchomieniowego <xref:System.Reflection.MethodInfo> pochodną klasy <xref:System.Reflection.MethodInfo> klasy, która z kolei jest pochodną <xref:System.Reflection.MethodBase> klasy.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metodę testu o nazwie `MethodBodyExample` i wyświetla jego informacje o zmiennych lokalnych i klauzule obsługi wyjątków. <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> Metoda jest używana do uzyskania <xref:System.Reflection.MethodBody> obiektu dla metody testowej.  
  
 <xref:System.Reflection.MethodBody.LocalVariables%2A> Właściwość jest używana do uzyskiwania listy <xref:System.Reflection.LocalVariableInfo> obiektów i ich typów i indeks kolejności. <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> Właściwość jest używana do uzyskiwania listy klauzule obsługi wyjątków.  
  
> [!NOTE]
>  Nie wszystkie języki komputer może generować <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> klauzul. Przykład Visual Basic zawiera klauzulę filtru, za pomocą języka Visual Basic `When` wyrażenia, który został pominięty w przykładach dla innych języków.  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta metoda jest nieprawidłowy, chyba że przesłonięcia w klasie pochodnej.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do metadanych dla elementów członkowskich. Wartość uprawnienia: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera informacje o metodzie przy użyciu określonego dojścia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście metody.</param>
        <summary>Pobiera informacje o metodzie przy użyciu metody wewnętrznej metadanych reprezentacja (dojście).</summary>
        <returns>A <see langword="MethodBase" /> zawierający informacje na temat metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Dojście do reprezentacji wewnętrznej metadanych konstruktora lub metody.</param>
        <param name="declaringType">Dojście do typu ogólnego, który definiuje konstruktora lub metody.</param>
        <summary>Pobiera <see cref="T:System.Reflection.MethodBase" /> obiektu konstruktora lub metody reprezentowanego przez określone dojście dla określonego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentujący metody lub konstruktora określonego przez <paramref name="handle" />, w typu ogólnego określonego przez <paramref name="declaringType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
 A <xref:System.RuntimeMethodHandle> struktury konstruktora lub metody typu ogólnego może reprezentować różnych <xref:System.Reflection.MethodBase> obiektów, w zależności od typów określone dla parametrów typu ogólnego typu. Na przykład jeśli `class G<T>` (`class G(Of T)` w języku Visual Basic `generic <T> ref class G` w języku C++) ma metodę, która zwraca typ `T`, <xref:System.Reflection.MethodBase> obiektu dla tej metody w klasie skonstruowane, takich jak `G<int>` różni się od <xref:System.Reflection.MethodBase>obiektu dla tej metody w definicji typu ogólnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Reflection.MethodImplAttributes" /> flagi.</summary>
        <returns>
          <see langword="MethodImplAttributes" /> Flagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład definiuje konstruktora w zestawie dynamicznym, a następnie używa <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> metodę w celu wyświetlenia flagi implementacji metod, które są wybrane domyślnie.  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera parametry określonej metody lub konstruktora.</summary>
        <returns>Tablica typu <see langword="ParameterInfo" /> zawierających informacje o pasującego podpisu — metoda (lub konstruktora) odzwierciedla to <see langword="MethodBase" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Reflection.MethodBase.GetParameters%2A> metoda pobierania parametry `Invoke` metody delegata.  
  
 W przykładzie zdefiniowano delegata o nazwie `MyDelegate` i zdarzenia o nazwie `ev` typu `MyDelegate`. Kod w `Main` metody odnajduje z sygnaturą zdarzenia pobierając typ delegata zdarzenia, uzyskiwanie `Invoke` metody typu delegowanego, a następnie pobierania i wyświetlania parametrów.  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje metody lub konstruktora, sprawdzając to <see langword="MethodInfo" /> wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wywołania metody lub konstruktora. Jeśli metoda jest statyczna, ten argument zostanie zignorowany. W przypadku statycznego konstruktora, ten argument musi być <see langword="null" /> lub wystąpienia klasy, która definiuje konstruktora.</param>
        <param name="parameters">Lista argumentów dla wywołanej metody lub konstruktora. To jest Tablica obiektów numer, kolejność i typ jako parametry metody lub konstruktora do wywołania. Jeśli nie ma żadnych parametrów <c>parametry</c> powinien być <see langword="null" />.  
  
 Jeśli ta metoda lub konstruktora reprezentowany przez to wystąpienie ma <see langword="ref" /> parametr (<see langword="ByRef" /> w języku Visual Basic), nie specjalne atrybut jest wymagany dla tego parametru w celu wywołania metody lub konstruktora przy użyciu tej funkcji. Dowolny obiekt tej tablicy, która nie jest jawnie zainicjowany z wartością będzie zawierał wartość domyślną dla tego typu obiektu. Elementy typu odwołania, ta wartość jest <see langword="null" />. Typ wartości elementów, ta wartość jest równa 0, 0.0, lub <see langword="false" />, w zależności od typu określonego elementu.</param>
        <summary>Wywołuje metody lub konstruktora reprezentowany przez bieżące wystąpienie przy użyciu określonych parametrów.</summary>
        <returns>Obiekt zawierający wartość zwracaną wywołana metoda lub <see langword="null" /> w przypadku konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda wygody, który wywołuje <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> przeciążenie metody, przekazywanie <xref:System.Reflection.BindingFlags.Default> dla `invokeAttr` i `null` dla `binder` i `culture`.  
  
 Jeśli wywołana metoda zgłasza wyjątek, <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> metoda zwróci wyjątek.  
  
 Do wywołania metody statycznej przy użyciu jego <xref:System.Reflection.MethodInfo> obiektów należy przekazać `null` dla `obj`.  
  
> [!NOTE]
>  Użycie tego przeciążenia metody do wywołania konstruktora wystąpienia obiektu podany dla `obj` są ponownie inicjowane; oznacza to, że wszystkie wystąpienia inicjatory są wykonywane. Wartość zwracana jest `null`. Jeśli zostanie wywołany Konstruktor klasy, klasy są ponownie inicjowane; oznacza to wykonywane są wszystkie inicjatory klasy. Wartość zwracana jest `null`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 Jeśli parametr bieżącej metody jest typem wartości, a odpowiedni argument w `parameters` jest `null`, środowisko uruchomieniowe przekazuje zainicjować zero wystąpienia typu wartości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje metody dynamicznej wyszukiwania za pomocą odbicia. Należy pamiętać, że nie można użyć <xref:System.Reflection.MethodInfo> obiekt z klasy podstawowej, aby wywołać przesłoniętej metody w klasie pochodnej, ponieważ późne wiązanie nie można rozpoznać zastąpienia.  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>  
 W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośnej biblioteki klas](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> zamiast tego.  
  
</para>
          </block>
          <paramref name="obj" /> Parametr jest <see langword="null" /> i metoda nie jest statyczne.  
  
 —lub—  
  
 Metoda nie jest zadeklarowany lub dziedziczone przez klasy <paramref name="obj" />.  
  
 —lub—  
  
 Konstruktor statyczny zostanie wywołany, i <paramref name="obj" /> nie jest ani <see langword="null" /> ani wystąpienia klasy, która jest zadeklarowana konstruktora.</exception>
        <exception cref="T:System.ArgumentException">Elementy <paramref name="parameters" /> tablicy nie są zgodne podpis metody lub konstruktora dostarczanej przez to wystąpienie.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywołana metoda lub konstruktora zgłasza wyjątek.  
  
 —lub—  
  
 Bieżące wystąpienie jest <see cref="T:System.Reflection.Emit.DynamicMethod" /> zawierający kod niemożliwy do zweryfikowania. Sekcja "Weryfikacja" w uwagi dla <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <paramref name="parameters" /> Tablicy nie ma poprawnej liczby argumentów.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośnej biblioteki klas](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch wyjątku klasy podstawowej <see cref="T:System.MemberAccessException" />, zamiast tego.  
  
</para>
          </block>  
  
 Obiekt wywołujący nie ma uprawnień do wykonania metody lub konstruktora, który jest reprezentowany przez bieżące wystąpienie.</exception>
        <exception cref="T:System.InvalidOperationException">Typ, który deklaruje metody jest otwartym typem ogólnym. Oznacza to <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" /> dla typ deklarujący.</exception>
        <exception cref="T:System.NotSupportedException">Bieżące wystąpienie jest <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wywołania metody lub konstruktora. Jeśli metoda jest statyczna, ten argument zostanie zignorowany. W przypadku statycznego konstruktora, ten argument musi być <see langword="null" /> lub wystąpienia klasy, która definiuje konstruktora.</param>
        <param name="invokeAttr">Maska bitowa, który jest kombinacją flag bitowych 0 lub więcej z <see cref="T:System.Reflection.BindingFlags" />. Jeśli <c>integratora</c> jest <see langword="null" />, ten parametr jest przypisywana wartość <see cref="F:System.Reflection.BindingFlags.Default" />; w związku z tym niezależnie od przekazywane w jest ignorowana.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see langword="MemberInfo" /> obiektów za pomocą odbicia. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="parameters">Lista argumentów dla wywołanej metody lub konstruktora. To jest Tablica obiektów numer, kolejność i typ jako parametry metody lub konstruktora do wywołania. Jeśli nie ma żadnych parametrów, należy to <see langword="null" />.  
  
 Jeśli ta metoda lub konstruktora reprezentowanym przez to wystąpienie przyjmuje parametr ByRef, nie istnieje atrybut specjalne wymagane dla tego parametru w celu wywołania metody lub konstruktora przy użyciu tej funkcji. Dowolny obiekt tej tablicy, która nie jest jawnie zainicjowany z wartością będzie zawierał wartość domyślną dla tego typu obiektu. Elementy typu odwołania, ta wartość jest <see langword="null" />. Typ wartości elementów, ta wartość jest równa 0, 0.0, lub <see langword="false" />, w zależności od typu określonego elementu.</param>
        <param name="culture">Wystąpienie <see langword="CultureInfo" /> używane do sterowania koercja typów. Jeśli jest to <see langword="null" />, <see langword="CultureInfo" /> służy bieżącego wątku. (Jest to konieczne przekonwertować <see langword="String" /> reprezentujący 1000 do <see langword="Double" /> wartość, na przykład, ponieważ 1000 jest inaczej reprezentowany przez innych kultur.)</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej wywołuje metody odbite lub konstruktora z podanych parametrów.</summary>
        <returns>
          <see langword="Object" /> Zawierający wartość zwracaną wywołana metoda lub <see langword="null" /> w przypadku konstruktora, lub <see langword="null" /> Jeśli metoda zwracany typ jest <see langword="void" />. Przed wywołaniem metody lub konstruktora, <see langword="Invoke" /> sprawdza, czy użytkownik ma uprawnienia dostępu i sprawdza, czy parametry są prawidłowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamicznie wywołuje metodę odzwierciedlone przez to wystąpienie na `obj`i przekazuje wraz z określonymi parametrami. Jeśli metoda jest statyczna, `obj` parametru jest ignorowana. Dla metod niestatycznych `obj` powinien być wystąpienia klasy, która dziedziczy lub deklaruje metody i musi być taki sam typ jak tej klasy. Jeśli metoda nie ma parametrów, wartość `parameters` powinien być `null`. W przeciwnym razie liczbę, typ i kolejność elementów `parameters` powinna być taka sama jak liczba, typ i kolejność parametrów dla metody dostarczanej przez to wystąpienie.  
  
 Nie może pominąć następujące parametry opcjonalne w wywołaniach `Invoke`. Aby wywołać metodę pominięcie następujące parametry opcjonalne, należy wywołać `Type.InvokeMember` zamiast tego.  
  
> [!NOTE]
>  Użycie tego przeciążenia metody do wywołania konstruktora wystąpienia obiektu podany dla `obj` są ponownie inicjowane; oznacza to, że wszystkie wystąpienia inicjatory są wykonywane. Wartość zwracana jest `null`. Jeśli zostanie wywołany Konstruktor klasy, klasy są ponownie inicjowane; oznacza to wykonywane są wszystkie inicjatory klasy. Wartość zwracana jest `null`.  
  
 Przebieg przez wartość parametru pierwotnych, odbywa się normalna rozszerzanie (wartości Int16 -> Int32, na przykład). Dla parametrów przebiegu przez wartości odwołania normalne odwołanie do rozszerzenia jest dozwolone (klasy pochodnej klasy podstawowej i klasy podstawowej na typ interfejsu). Jednak dla parametrów pierwotnych przekazywany przez odwołanie, typy muszą być całkowicie zgodne. Dla parametrów odwołania przekazywany przez odwołanie rozszerzanie normalne nadal ma zastosowanie.  
  
 Na przykład, jeśli metoda dostarczanej przez to wystąpienie jest zadeklarowany jako `public boolean Compare(String a, String b)`, następnie `parameters` powinna być tablicą `Objects` o długości 2 tak, aby `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.  
  
 Jeśli parametr bieżącej metody jest typem wartości, a odpowiedni argument w `parameters` jest `null`, środowisko uruchomieniowe przekazuje zainicjować zero wystąpienia typu wartości.  
  
 Odbicie używa metody dynamicznej wyszukiwania podczas wywoływania metody wirtualne. Załóżmy na przykład, że klasa B dziedziczy z klasy A i implementować zarówno metoda wirtualna o nazwie M. Teraz załóżmy, że masz `MethodInfo` obiekt, który reprezentuje M klasy A. Jeśli używasz `Invoke` metody do wywołania M na obiekt typu b odbicia zastosuje wykonania podany przez klasę B. Nawet wtedy, gdy obiekt typu b jest rzutowany A, służy do wykonania podany przez klasy B (zobacz poniższy przykład kodu).  
  
 Z drugiej strony, jeśli metoda jest niewirtualną, odbicia będzie używać wykonania podany przez typ, z którego `MethodInfo` uzyskano, bez względu na typ obiektu przekazanego jako element docelowy.  
  
 Ograniczenia dostępu są ignorowane w przypadku całkowicie zaufanego kodu. Oznacza to konstruktory prywatne, pola, metody i właściwości można można uzyskać dostępu do i wywoływane za pośrednictwem odbicia zawsze, gdy kod jest w pełni zaufany.  
  
 Jeśli wywołana metoda zgłasza wyjątek, `TargetInvocationException.GetException` zwraca wyjątek. Ta implementacja zwraca `NotSupportedException`.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkie elementy członkowskie <xref:System.Reflection.Binder?displayProperty=nameWithType> przy użyciu przeciążenia <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>. Metoda prywatna `CanConvertFrom` znajduje niezgodne typy dla danego typu. Na przykład innego wywoływanie elementów członkowskich w scenariuszu niestandardowego powiązania zobacz [dynamiczne ładowanie i przy użyciu typów](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <paramref name="obj" /> Parametr jest <see langword="null" /> i metoda nie jest statyczne.  
  
 —lub—  
  
 Metoda nie jest zadeklarowany lub dziedziczone przez klasy <paramref name="obj" />.  
  
 —lub—  
  
 Konstruktor statyczny zostanie wywołany, i <paramref name="obj" /> nie jest ani <see langword="null" /> ani wystąpienia klasy, która jest zadeklarowana konstruktora.</exception>
        <exception cref="T:System.ArgumentException">Typ <paramref name="parameters" /> parametr niezgodny podpis metody lub konstruktora dostarczanej przez to wystąpienie.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <paramref name="parameters" /> Tablicy nie ma poprawnej liczby argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywołana metoda lub konstruktora zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wykonania metody lub konstruktora, który jest reprezentowany przez bieżące wystąpienie.</exception>
        <exception cref="T:System.InvalidOperationException">Typ, który deklaruje metody jest otwartym typem ogólnym. Oznacza to <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" /> dla typ deklarujący.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda jest abstrakcyjna.</summary>
        <value>
          <see langword="true" /> Jeśli metoda jest abstrakcyjna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abstrakcyjny element członkowski jest zadeklarowany w klasie podstawowej i dostarczył żadnej implementacji.  
  
 Aby uzyskać <xref:System.Reflection.MethodBase>, najpierw pobrać typu. Z tego typu get, metoda. W metodzie uzyskać `MethodBase`. Jeśli `MethodBase` lub konstruktora innego niż publicznego, jest chroniony i nie można łatwo uzyskać dostępu. Aby uzyskać dostęp do metody niepubliczne, ustaw <xref:System.Reflection.BindingFlags> maski do `NonPublic` w `GetMethod`.  
  
   
  
## Examples  
 Poniższy przykład określa, czy określona metoda jest abstrakcyjna i wyświetla wyniki.  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy potencjalne widoczność tej metody lub konstruktora jest opisane przez <see cref="F:System.Reflection.MethodAttributes.Assembly" />; oznacza to, metody lub konstruktora jest widoczny co najwyżej na inne typy w tym samym zestawie, i jest uzyskiwana nie są widoczne dla typów poza zestaw.</summary>
        <value>
          <see langword="true" /> Jeśli widoczność tej metody lub konstruktora jest dokładnie opisanego przez <see cref="F:System.Reflection.MethodAttributes.Assembly" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rzeczywiste Widoczność metody jest ograniczona widoczność jego typu. <xref:System.Reflection.MethodBase.IsAssembly%2A> Właściwość może być `true` metody, ale jeśli jest to metoda typu zagnieżdżonego prywatnej, a następnie metoda nie jest widoczna na zewnątrz typu zawierającego.  
  
 Widoczność metody lub konstruktora dokładnie jest opisane przez <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> w przypadku widoczności tylko modyfikator `internal` (`Friend` w języku Visual Basic). Ta właściwość jest `false` dla metod, które są `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++); użyj <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> właściwość do identyfikacji tych metod.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metody o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda jest konstruktorem.</summary>
        <value>
          <see langword="true" /> Jeśli ta metoda jest reprezentowany przez konstruktora <see cref="T:System.Reflection.ConstructorInfo" /> obiektu (patrz Uwaga do uwagi <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> obiektów); w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Reflection.MethodBase.IsConstructor%2A> Zwraca `false` dla <xref:System.Reflection.Emit.ConstructorBuilder> obiektu w typu dynamicznego, chyba że <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flagi została uwzględniona w `attributes` parametr podczas definiowania konstruktora. Pominięcie <xref:System.Reflection.MethodAttributes.RTSpecialName> flagi nie ma wpływu na poprawność emitowany konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widoczność tej metody lub konstruktora jest opisane przez <see cref="F:System.Reflection.MethodAttributes.Family" />; metody lub konstruktora jest widoczne tylko w ramach jego klasa i klasy pochodne.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tej metody lub konstruktora dokładnie jest opisane przez <see cref="F:System.Reflection.MethodAttributes.Family" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Widoczność metody lub konstruktora dokładnie jest opisane przez <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> w przypadku widoczności tylko modyfikator `protected`. Ta właściwość jest `false` dla metod, które są `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++); użyj <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> właściwość do identyfikacji tych metod.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metody o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widoczność tej metody lub konstruktora jest opisane przez <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; oznacza to, metody lub konstruktora może być wywoływany przez klasy pochodnej, ale tylko wtedy, gdy znajdują się w tym samym zestawie.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tej metody lub konstruktora dokładnie jest opisane przez <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Widoczność metody lub konstruktora dokładnie jest opisane przez <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> przypadku modyfikator widoczności `protected private` w języku C++. Nie można zdefiniować metody to wgląd w języku Visual Basic lub C#.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metody o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy potencjalne widoczność tej metody lub konstruktora jest opisane przez <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; oznacza to, metody lub konstruktora może być wywoływany przez klas pochodnych wszędzie tam, gdzie są one, a także klas w tym samym zestawie.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tej metody lub konstruktora dokładnie jest opisane przez <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski typu ma <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> widoczność, może ona zostać wywołana z dowolnego elementu członkowskiego w klasie pochodnej lub dowolnego elementu członkowskiego w tym samym zestawie, ale nie z innego typu.  
  
 Rzeczywiste Widoczność metody jest ograniczona widoczność jego typu. <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> Właściwość może być `true` metody, ale jeśli jest to metoda typu zagnieżdżonego prywatnej, a następnie metoda nie jest widoczna na zewnątrz typu zawierającego.  
  
 Widoczność metody lub konstruktora dokładnie jest opisane przez <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> przypadku modyfikator widoczności `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++).  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metody o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować metody z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta metoda jest <see langword="final" />.</summary>
        <value>
          <see langword="true" /> Jeśli ta metoda jest <see langword="final" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, czy metoda jest możliwym do zastąpienia, nie jest wystarczające, aby sprawdzić, czy <xref:System.Reflection.MethodBase.IsVirtual%2A> jest `true`. Metody, która ma być możliwym do zastąpienia `IsVirtual` musi być `true` i `IsFinal` musi być `false`. Na przykład metoda może być niewirtualną, ale implementuje metody interfejsu. Środowisko uruchomieniowe języka wspólnego wymaga, aby wszystkie metody, które implementują członków interfejsu muszą być oznaczone jako `virtual`; dlatego kompilator oznacza metodę `virtual final`. Dlatego istnieją przypadki, w którym metoda jest oznaczona jako `virtual` , ale jest nadal nie możliwym do zastąpienia.  
  
 Aby ustanowić z pewności, czy metoda jest możliwym do zastąpienia, należy użyć kodu, takich jak ta:  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 Jeśli `IsVirtual` jest `false` lub `IsFinal` jest `true`, a następnie nie można zastąpić metody.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `false` dla `IsFinal`, który może prowadzić do podejrzenie, że MyMethod jest możliwym do zastąpienia. Wyświetla kod `false` nawet, jeśli nie jest oznaczony jako MyMethod `virtual` i w związku z tym nie może zostać zastąpiona.  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda jest rodzajowy.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> reprezentuje metody rodzajowej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Reflection.MethodBase.IsGenericMethod%2A> umożliwia określenie, czy bieżący <xref:System.Reflection.MethodBase> obiekt reprezentuje metody rodzajowej. Użyj <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> umożliwia określenie, czy bieżący <xref:System.Reflection.MethodBase> obiekt reprezentuje skonstruowane metody open lub zamkniętych skonstruowane — metoda.  
  
> [!NOTE]
>  Typy ogólne nie są obsługiwane przez domyślny; Ta właściwość zwraca `false` Jeśli nie przesłonięcia w klasie pochodnej. Ogólny konstruktorów nie są obsługiwane w programie .NET Framework w wersji 2.0, więc ta właściwość zwraca `false` Jeśli bieżące wystąpienie jest typu <xref:System.Reflection.ConstructorInfo>.  
  
Poniższa tabela zawiera podsumowanie niezmiennej warunki postanowienia związane z metody ogólne. Inne warunki używane w ogólnym odbicia, taką jak *parametr typu ogólnego* i *typu ogólnego*, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.   

|Termin|Niezmienna warunku| 
|---|---| 
|ogólną definicją metody| <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> Jest właściwość `true`. <br />Definiuje metody rodzajowej. Skonstruowane metody jest tworzony przez wywołanie metody <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metoda <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje definicję metody rodzajowej i określając tablicę argumentów typu. <br /><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> Metoda może być wywołana tylko dla definicji metody rodzajowej. <br/>Wszelkie ogólną definicją metody jest to metoda ogólna, ale odwrotnej nie jest prawdziwe.|    
|Metoda ogólna|`IsGenericMethod` Jest właściwość `true`. <br/> Może być definicję metody rodzajowej, skonstruowane metody open lub zamkniętego skonstruowane — metoda.| 
|Otwórz skonstruowane — metoda|<xref:System.Reflection.MethodBase.ContainsGenericParameters> Jest właściwość `true`. <br/>Nie jest możliwe do wywołania metody open skonstruowane.|  
|zamknięte skonstruowane — metoda|<xref:System.Reflection.MethodBase.ContainsGenericParameters> Jest właściwość `false`. <br/>Gdy rekursywnie zbadane, metoda nie ma nieprzypisane ogólnych parametrów. Typ zawierający nie ma typu ogólnego parametrów, a żaden z argumentów typu nie ma parametrów typu ogólnego. <br/>Można wywołać metody.|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda jest ogólną definicją metody.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentuje definicję metody rodzajowej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Reflection.MethodBase> reprezentuje ogólną definicją metody, następnie:  
  
-   <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> Jest właściwość `true`.  
  
-   Dla każdego <xref:System.Type> obiektu w tablicy zwracanej przez <xref:System.Reflection.MethodBase.GetGenericArguments%2A> metody:  
  
    -   <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> Jest właściwość `true`.  
  
    -   <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> Właściwość zwraca bieżącego wystąpienia.  
  
    -   <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> Właściwości jest taka sama jak pozycja <xref:System.Type> obiektu w tablicy.  
  
> [!NOTE]
>  Typy ogólne nie są obsługiwane przez domyślny; Ta właściwość zwraca `false` Jeśli nie przesłonięcia w klasie pochodnej. Ogólny konstruktorów nie są obsługiwane w programie .NET Framework w wersji 2.0, więc ta właściwość zwraca `false` Jeśli bieżące wystąpienie jest typu <xref:System.Reflection.ConstructorInfo>.  
  
 Lista niezmiennej warunki postanowienia związane z metody ogólne, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości. Lista niezmiennej warunki dla innych terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy tylko element członkowski o tej samej sygnaturze tego rodzaju jest ukryty w klasie pochodnej.</summary>
        <value>
          <see langword="true" /> Jeśli element członkowski jest ukryty przez podpis. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element członkowski w klasie pochodnej jest zadeklarowany w języku C# `new` modyfikator lub Visual Basic `Shadows` modyfikator, można ukryć element członkowski o takiej samej nazwie w klasie podstawowej. C# ukrywa elementów członkowskich klasy podstawowej podpisem. Jeśli element członkowski klasy podstawowej ma kilka przeciążeń, tylko jeden, który jest ukryty jest ten, który ma taki sam podpis. Z kolei Visual Basic ukrywa przeciążeń klasy podstawowej. W związku z tym <xref:System.Reflection.MethodBase.IsHideBySig%2A> zwraca `false` na element członkowski zadeklarowany za pomocą Visual Basic `Shadows` modyfikator, i `true` na element członkowski zadeklarowany w języku C# `new` modyfikator.  
  
> [!WARNING]
>  Ta właściwość nie określa, czy metoda ma <xref:System.Reflection.MethodAttributes.NewSlot> atrybutu. Metody, która jest zadeklarowana przy użyciu jednej `new` lub `Shadows` będzie mieć modyfikatora <xref:System.Reflection.MethodAttributes.NewSlot> atrybut, ale tylko metody zadeklarowana z `new` (to znaczy tylko C# metody) będzie miał <xref:System.Reflection.MethodBase.IsHideBySig%2A> właściwość `true`.  Aby określić, czy metoda <xref:System.Reflection.MethodAttributes.NewSlot> atrybutu, podobny do następującego kodu: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` w języku C# lub `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` w języku Visual Basic. Należy jednak pamiętać, który mimo, że wszystkie metody zadeklarowana z `new` lub `Shadows` ma <xref:System.Reflection.MethodAttributes.NewSlot> atrybutu, nie wszystkie metody, które mają <xref:System.Reflection.MethodAttributes.NewSlot> atrybut został zadeklarowany z `new` lub `Shadows`.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera klasę podstawową metodą przeciążona i klasy pochodnej, która ukrywa jednego z przeciążeń. W wersji Visual Basic przykładu kodu <xref:System.Reflection.MethodBase.IsHideBySig%2A> zwraca właściwość `false` elementu członkowskiego w klasie pochodnej. W języku C# wersji przykładowy kod, zwraca właściwość `true` elementu członkowskiego w klasie pochodnej.  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element członkowski jest prywatny.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tej metody jest ograniczony do innych członków klasy. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski typu ma `Private` poziomu widoczność, może ona zostać wywołana z dowolnego elementu członkowskiego w tej samej klasy, a nie inne.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest to metoda publiczna.</summary>
        <value>
          <see langword="true" /> Jeśli ta metoda jest publiczna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać <xref:System.Reflection.MethodBase>, najpierw pobrać typu. Z tego typu get, metoda. W metodzie uzyskać `MethodBase`. Jeśli `MethodBase` lub konstruktora innego niż publicznego, jest chroniony i nie można łatwo uzyskać dostępu. Aby uzyskać dostęp do metody niepubliczne, ustaw <xref:System.Reflection.BindingFlags> maski do `NonPublic` w `GetMethod`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Reflection.MethodBase.IsPublic%2A> właściwość, aby wyświetlić komunikat informujący o tym, czy określona metoda jest publiczna.  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącej metody lub konstruktora jest krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania i dlatego mogą wykonywać operacje krytyczne.</summary>
        <value>
          <see langword="true" /> w przypadku bieżącej metody lub konstruktora krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; <see langword="false" /> Jeśli jest niewidoczne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metody lub konstruktora na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu typów i członków, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeśli zestaw jest ładowany do aplikacji częściowo zaufanej domeny (na przykład w domenie aplikacji piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącej metody lub konstruktora jest bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; oznacza to, czy go mogą wykonywać operacje krytyczne i można uzyskać, sprawdzając kod przezroczysty.</summary>
        <value>
          <see langword="true" /> w przypadku metody lub konstruktora bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; <see langword="false" /> przypadku zabezpieczeń krytyczny ani przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metody lub konstruktora na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu typów i członków, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeśli zestaw jest ładowany do aplikacji częściowo zaufanej domeny (na przykład w domenie aplikacji piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącej metody lub konstruktora jest niewidoczny w zaufania bieżącym poziomie i w związku z tym nie można wykonać ważne operacje.</summary>
        <value>
          <see langword="true" /> w przypadku metody lub konstruktora przezroczystym poziomie bezpieczeństwa na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość zwraca `true`, <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> i <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> return właściwości `false`.  
  
 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metody lub konstruktora na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu typów i członków, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeśli zestaw jest ładowany do aplikacji częściowo zaufanej domeny (na przykład w domenie aplikacji piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta metoda ma specjalną nazwą.</summary>
        <value>
          <see langword="true" /> Jeśli ta metoda ma specjalną nazwą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.MethodAttributes.SpecialName> Bit jest ustawiony na wartość Flaga elementów członkowskich, które są traktowane w specjalny sposób przez niektóre kompilatory (na przykład metod dostępu do właściwości i metod przeładowania operatora).  
  
   
  
## Examples  
 W tym przykładzie pokazano sposób użycia <xref:System.Reflection.MethodBase.IsSpecialName%2A> filtru wewnętrzne lub prywatne elementy członkowskie z listy.  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda jest <see langword="static" />.</summary>
        <value>
          <see langword="true" /> Jeśli ta metoda jest <see langword="static" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statyczny element członkowski nie może odwoływać się niejawnie danych wystąpienia w klasie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda jest <see langword="virtual" />.</summary>
        <value>
          <see langword="true" /> Jeśli ta metoda jest <see langword="virtual" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wirtualny element członkowski może odwoływać się dane wystąpienia w klasie i musi odwoływać się do wystąpienia klasy.  
  
 Aby określić, czy metoda jest możliwym do zastąpienia, nie jest wystarczające, aby sprawdzić, czy `IsVirtual` jest `true`. Metody, która ma być możliwym do zastąpienia `IsVirtual` musi być `true` i <xref:System.Reflection.MethodBase.IsFinal%2A> musi być `false`. Na przykład metoda może być niewirtualną, ale implementuje metody interfejsu. Środowisko uruchomieniowe języka wspólnego wymaga, aby wszystkie metody, które implementują członków interfejsu muszą być oznaczone jako `virtual`; dlatego kompilator oznacza metodę `virtual final`. Dlatego istnieją przypadki, w którym metoda jest oznaczona jako `virtual` , ale jest nadal nie możliwym do zastąpienia.  
  
 Aby ustanowić z pewności, czy metoda jest możliwym do zastąpienia, należy użyć kodu, takich jak ta:  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 Jeśli `IsVirtual` jest `false` lub `IsFinal` jest `true`, a następnie nie można zastąpić metody.  
  
 Można określić, czy bieżąca metoda zastępuje metodę w klasie podstawowej przez wywołanie metody <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> metody. Poniższy przykład implementuje `IsOverride` metody, w tym.  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `false` dla `IsFinal`, który może prowadzić do podejrzenie, że `MyMethod` jest możliwym do zastąpienia. Wyświetla kod `false` mimo że `MyMethod` nie jest oznaczony jako `virtual` i w związku z tym nie może zostać zastąpiona.  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojścia do reprezentacji wewnętrznej metadanych metody.</summary>
        <value>A <see cref="T:System.RuntimeMethodHandle" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.MethodImplAttributes" /> flagi, które określają atrybuty implementacji metody.</summary>
        <value>Flagi implementacji metod.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> metody, aby uzyskać więcej informacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.MethodBase" /> obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.MethodBase" /> obiekty nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</summary>
        <returns>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Reflection.MethodBase> wystąpienia jest rzutowane na <xref:System.Runtime.InteropServices._MethodBase> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
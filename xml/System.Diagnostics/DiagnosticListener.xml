<Type Name="DiagnosticListener" FullName="System.Diagnostics.DiagnosticListener">
  <TypeSignature Language="C#" Value="public class DiagnosticListener : System.Diagnostics.DiagnosticSource, IDisposable, IObservable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DiagnosticListener extends System.Diagnostics.DiagnosticSource implements class System.IDisposable, class System.IObservable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticListener" />
  <TypeSignature Language="VB.NET" Value="Public Class DiagnosticListener&#xA;Inherits DiagnosticSource&#xA;Implements IDisposable, IObservable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticListener : System::Diagnostics::DiagnosticSource, IDisposable, IObservable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type DiagnosticListener = class&#xA;    inherit DiagnosticSource&#xA;    interface IDisposable&#xA;    interface IObservable&lt;KeyValuePair&lt;string, obj&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.1</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.DiagnosticSource</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IObservable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="f6d0f-101">Zapewnia implementację klasy abstrakcyjnej <see cref="T:System.Diagnostics.DiagnosticSource" /> , która reprezentuje nazwane miejsce, do którego źródło wysyła informacje (zdarzenia).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-101">Provides an implementation of the abstract <see cref="T:System.Diagnostics.DiagnosticSource" /> class that represents a named place to which a source sends its information (events).</span></span></summary>
    <remarks>
      <format type="text/markdown">
  <![CDA

## Remarks

<span data-ttu-id="f6d0f-102">`DiagnosticListener`to NotificationSource, co oznacza, że zwracany wynik może służyć do rejestrowania powiadomień, ale również ma <xref:System.Diagnostics.DiagnosticListener.Subscribe%2A> metodę, aby powiadomienia były przekazywane arbitralnie.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-102">`DiagnosticListener` is a NotificationSource, which means the returned result can be used to  log notifications, but it also has a <xref:System.Diagnostics.DiagnosticListener.Subscribe%2A> method so notifications can be forwarded arbitrarily.</span></span> <span data-ttu-id="f6d0f-103">W ten sposób jego zadaniem jest przekazanie rzeczy od producenta do wszystkich odbiorników (wiele operacji rzutowania).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-103">Thus, its job is to forward things from the producer to all the listeners (multi-casting).</span></span> <span data-ttu-id="f6d0f-104">Ogólnie rzecz biorąc nie należy wprowadzać własnych <xref:System.Diagnostics.DiagnosticListener> danych, ale używać ich domyślnie, aby powiadomienia były możliwie jak najbardziej publiczne.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-104">Generally, you should not be making your own <xref:System.Diagnostics.DiagnosticListener> but use the default, so that notifications are as public as possible.</span></span>

<span data-ttu-id="f6d0f-105">Aby uzyskać więcej informacji na <xref:System.Diagnostics.DiagnosticSource> temat <xref:System.Diagnostics.DiagnosticListener> klas i, zobacz [Podręcznik użytkownika DiagnosticSource](https://github.com/dotnet/corefx/blob/d3942d4671919edb0cca6ddc1840190f524a809d/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-105">For more information on the <xref:System.Diagnostics.DiagnosticSource> and <xref:System.Diagnostics.DiagnosticListener> classes, see [DiagnosticSource User's Guide](https://github.com/dotnet/corefx/blob/d3942d4671919edb0cca6ddc1840190f524a809d/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).</span></span>

        ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DiagnosticListener (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DiagnosticListener(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.DiagnosticListener : string -&gt; System.Diagnostics.DiagnosticListener" Usage="new System.Diagnostics.DiagnosticListener name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f6d0f-106">Nazwa tego <see cref="T:System.Diagnostics.DiagnosticListener" />elementu.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-106">The name of this <see cref="T:System.Diagnostics.DiagnosticListener" />.</span></span></param>
        <summary><span data-ttu-id="f6d0f-107">Tworzy nowy <see cref="T:System.Diagnostics.DiagnosticListener" />.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-107">Creates a new <see cref="T:System.Diagnostics.DiagnosticListener" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllListeners">
      <MemberSignature Language="C#" Value="public static IObservable&lt;System.Diagnostics.DiagnosticListener&gt; AllListeners { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IObservable`1&lt;class System.Diagnostics.DiagnosticListener&gt; AllListeners" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.DiagnosticListener.AllListeners" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllListeners As IObservable(Of DiagnosticListener)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IObservable&lt;System::Diagnostics::DiagnosticListener ^&gt; ^ AllListeners { IObservable&lt;System::Diagnostics::DiagnosticListener ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllListeners : IObservable&lt;System.Diagnostics.DiagnosticListener&gt;" Usage="System.Diagnostics.DiagnosticListener.AllListeners" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObservable&lt;System.Diagnostics.DiagnosticListener&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d0f-108">Pobiera kolekcję odbiorników <see cref="T:System.Diagnostics.DiagnosticListener" />.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-108">Gets the collection of listeners for this <see cref="T:System.Diagnostics.DiagnosticListener" />.</span></span></summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="f6d0f-109">Gdy subskrybujesz tę usługę, otrzymasz wywołania zwrotne dla wszystkich NotificationListeners w domenie aplikacji, a także tych, które wystąpiły w przeszłości, i wszystkich przyszłych odbiorników utworzonych w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-109">When you subscribe to this, you get callbacks for all NotificationListeners in the appdomain, as well as those that occurred in the past, and all future Listeners created in the future.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="diagnosticListener.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6d0f-110">Usuwa NotificationListeners.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-110">Disposes the NotificationListeners.</span></span></summary>
        <remarks><span data-ttu-id="f6d0f-111">Odbiorniki powiadomień nie są używane, ponieważ znajdują się na globalnej liście (na potrzeby odnajdywania).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-111">Notification listeners do not die on their own because they are in a global list (for discoverability).</span></span> <span data-ttu-id="f6d0f-112">Należy usunąć je jawnie.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-112">You must dispose of them explicitly.</span></span> <span data-ttu-id="f6d0f-113">Należy pamiętać, że nie jest to wzorzec <c>Dispose (bool)</c> , ponieważ nie chcemy obsługiwać podklas, które mają stan niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-113">Note that we do not do the <c>Dispose(bool)</c> pattern because we don't want to support subclasses that have non-managed state.</span></span></remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="override this.IsEnabled : unit -&gt; bool" Usage="diagnosticListener.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6d0f-114">Określa, czy istnieją zarejestrowani Subskrybenci.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-114">Determines whether there are any registered subscribers.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-115"><see langword="true" />Jeśli istnieją jakieś zarejestrowane Subskrybenci, <see langword="false" /> w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-115"><see langword="true" /> if there are any registered subscribers, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="f6d0f-116">Jeśli Instalator powiadomienia jest kosztowny, można wywołać `IsEnabled` przed przeprowadzeniem tej instalacji.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-116">If setup for the notification is expensive, you can call `IsEnabled` before performing this setup.</span></span> <span data-ttu-id="f6d0f-117">Producenci mogą opcjonalnie wywołać `IsEnabled` przed wywołaniem. <xref:System.Diagnostics.DiagnosticListener.IsEnabled(System.String) in performance-critical parts of the application to determine whether there are any listeners to the <xref:System.Diagnostics.DiagnosticListener></span><span class="sxs-lookup"><span data-stu-id="f6d0f-117">Producers may optionally call `IsEnabled` before calling <xref:System.Diagnostics.DiagnosticListener.IsEnabled(System.String) in performance-critical parts of the application to determine whether there are any listeners to the <xref:System.Diagnostics.DiagnosticListener>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public override bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.IsEnabled : string -&gt; bool" Usage="diagnosticListener.IsEnabled name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary><span data-ttu-id="f6d0f-118">Sprawdza, <see cref="T:System.Diagnostics.DiagnosticListener" /> czy jest włączona.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-118">Checks whether the <see cref="T:System.Diagnostics.DiagnosticListener" /> is enabled.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-119"><see langword="true" />Jeśli włączono powiadomienia; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="f6d0f-119"><see langword="true" /> if notifications are enabled; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public override bool IsEnabled (string name, object arg1, object arg2 = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticListener.IsEnabled (name, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="arg1">To be added.</param>
        <param name="arg2">To be added.</param>
        <summary><span data-ttu-id="f6d0f-120">Sprawdza, czy DiagnosticListener jest włączony.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-120">Checks if the DiagnosticListener is enabled.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-121"><see langword="true" />Jeśli jest włączona, <see langword="false" /> w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-121"><see langword="true" /> if it is enabled, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.DiagnosticListener.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Diagnostics.DiagnosticListener.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d0f-122">Pobiera nazwę tego <see cref="T:System.Diagnostics.DiagnosticListener" />elementu.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-122">Gets the name of this <see cref="T:System.Diagnostics.DiagnosticListener" />.</span></span></summary>
        <value><span data-ttu-id="f6d0f-123">Nazwa <see cref="T:System.Diagnostics.DiagnosticListener" />.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-123">The name of the <see cref="T:System.Diagnostics.DiagnosticListener" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityExport">
      <MemberSignature Language="C#" Value="public override void OnActivityExport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnActivityExport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.OnActivityExport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnActivityExport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="override this.OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticListener.OnActivityExport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="f6d0f-124">Działanie, na które ma wpływ zdarzenie zewnętrzne.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-124">The activity affected by an external event.</span></span></param>
        <param name="payload"><span data-ttu-id="f6d0f-125">Obiekt, który reprezentuje żądanie wychodzące.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-125">An object that represents the outgoing request.</span></span></param>
        <summary><span data-ttu-id="f6d0f-126">Wywołuje metodę OnActivityExport dla wszystkich subskrybentów.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-126">Invokes the OnActivityExport method of all the subscribers.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityImport">
      <MemberSignature Language="C#" Value="public override void OnActivityImport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnActivityImport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.OnActivityImport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnActivityImport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="override this.OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticListener.OnActivityImport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="f6d0f-127">Działanie, na które ma wpływ zdarzenie zewnętrzne.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-127">The activity affected by an external event.</span></span></param>
        <param name="payload"><span data-ttu-id="f6d0f-128">Obiekt, który reprezentuje żądanie przychodzące.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-128">An object that represents the incoming request.</span></span></param>
        <summary><span data-ttu-id="f6d0f-129">Wywołuje metodę OnActivityImport dla wszystkich subskrybentów.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-129">Invokes the OnActivityImport method of all the subscribers.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object))) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ Subscribe(IObserver&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ observer);" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe observer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IObservable`1.Subscribe(System.IObserver{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="observer"><span data-ttu-id="f6d0f-130">Subskrybent.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-130">A subscriber.</span></span></param>
        <summary><span data-ttu-id="f6d0f-131">Dodaje subskrybenta.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-131">Adds a subscriber.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-132">Odwołanie do interfejsu, który umożliwia odbiornikowi zatrzymanie otrzymywania powiadomień przed <see cref="T:System.Diagnostics.DiagnosticSource" /> zakończeniem ich wysyłania.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-132">A reference to an interface that allows the listener to stop receiving notifications before the <see cref="T:System.Diagnostics.DiagnosticSource" /> has finished sending them.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer, Func&lt;string,object,object,bool&gt; isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer, class System.Func`4&lt;string, object, object, bool&gt; isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Func{System.String,System.Object,System.Object,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object)), isEnabled As Func(Of String, Object, Object, Boolean)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ Subscribe(IObserver&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ observer, Func&lt;System::String ^, System::Object ^, System::Object ^, bool&gt; ^ isEnabled);" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe (observer, isEnabled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="isEnabled" Type="System.Func&lt;System.String,System.Object,System.Object,System.Boolean&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="observer"><span data-ttu-id="f6d0f-133">Subskrybent.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-133">A subscriber.</span></span></param>
        <param name="isEnabled"><span data-ttu-id="f6d0f-134">Delegat, który filtruje zdarzenia na podstawie ich nazwy oraz do dwóch obiektów kontekstu (może to być <see langword="null" />) lub <see langword="null" /> Jeśli filtr zdarzenia nie jest pożądany.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-134">A delegate that filters events based on their name and up to two context objects (which can be <see langword="null" />), or <see langword="null" /> to if an event filter is not desirable.</span></span></param>
        <summary><span data-ttu-id="f6d0f-135">Dodaje abonenta i opcjonalnie filtruje zdarzenia na podstawie ich nazwy oraz do dwóch obiektów kontekstu.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-135">Adds a subscriber, and optionally filters events based on their name and up to two context objects.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-136">Odwołanie do interfejsu, który umożliwia odbiornikowi zatrzymanie otrzymywania powiadomień przed <see cref="T:System.Diagnostics.DiagnosticSource" /> zakończeniem ich wysyłania.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-136">A reference to an interface that allows the listener to stop receiving notifications before the <see cref="T:System.Diagnostics.DiagnosticSource" /> has finished sending them.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="f6d0f-137">Jeśli `isEnabled` tak nie `null`jest, oznacza to, że niektóre zdarzenia są nieinteresujące może być pominięte w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-137">If `isEnabled` is not `null`, it indicates that some events are uninteresting can be skipped for efficiency.</span></span>

<span data-ttu-id="f6d0f-138">Konkretna lokacja Instrumentacji ma możliwość wywołania co najmniej jednego <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> przeciążenia, w którym przekazuje nazwę zdarzenia i maksymalnie dwie inne (specyficzne dla lokacji Instrumentacji) obiekty jako argumenty.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-138">A particular instrumentation site has the option of calling one or more <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> overloads  in which it passes the name of the event and up to two other (instrumentation site specific) objects as arguments.</span></span> <span data-ttu-id="f6d0f-139">Jeśli którekolwiek z tych <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> wywołań zostanie wykonane, ten `isEnabled` predykat jest wywoływany z wartościami zakończonymi (jeśli są używane krótsze przeciążenia, `null` są przekazywane w przypadku brakujących obiektów kontekstu).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-139">If any of these <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> calls are made then this `isEnabled` predicate is invoked with passed values (if shorter overloads are used, `null` is passed for missing context objects).</span></span>

<span data-ttu-id="f6d0f-140">Dzięki temu każda konkretna lokacja Instrumentacji może przekazać subskrybentowi do dwóch informacji, aby wykonać zaawansowane, wydajne filtrowanie.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-140">This gives any particular instrumentation site the ability to pass up to two pieces of information to the subscriber to do sophisticated, efficient filtering.</span></span> <span data-ttu-id="f6d0f-141">Wymaga to więcej sprzęgania między lokacją Instrumentacji a kodem subskrybenta.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-141">This requires more coupling between the instrumentation site and the subscriber code.</span></span>

<span data-ttu-id="f6d0f-142">Oczekuje się, że określona lokacja Instrumentacji może wywoływać różne `IsEnabled` przeciążenia dla tego samego zdarzenia, po <xref:System.Diagnostics.DiagnosticListener.IsEnabled(System.String)>pierwsze wywołanie, które wywołuje filtr z `null` dwoma obiektami kontekstu.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-142">It is expected that a particular instrumentation site may call different overloads of `IsEnabled` for the same event, first calling <xref:System.Diagnostics.DiagnosticListener.IsEnabled(System.String)>, which calls the filter with two `null` context objects.</span></span> <span data-ttu-id="f6d0f-143">Jeśli `isEnabled` zwraca`true`, wywołuje ponownie z obiektami kontekstu.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-143">If `isEnabled` returns `true`, it calls again with context objects.</span></span> <span data-ttu-id="f6d0f-144">`isEnabled` Filtr powinien zostać zaprojektowany z myślą o tym.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-144">The `isEnabled` filter should be designed with this in mind.</span></span>

<span data-ttu-id="f6d0f-145">Należy zauważyć, `isEnabled` że predykat jest opcjonalną optymalizacją, aby umożliwić lokacji Instrumentacji uniknięcie konfigurowania ładunku i <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)> wywoływania, gdy żaden subskrybent nie dba o nim.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-145">Note that the `isEnabled` predicate is an optional optimization to allow the instrumentation site to avoid setting up the payload and calling <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)> when no subscriber cares about it.</span></span> <span data-ttu-id="f6d0f-146">W szczególności lokacja Instrumentacji ma opcję ignorowania <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> predykatu (niewywołującego go) i po prostu wywołanie. <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)></span><span class="sxs-lookup"><span data-stu-id="f6d0f-146">In particular, the instrumentation site has the option of ignoring the <xref:System.Diagnostics.DiagnosticListener.IsEnabled%2A> predicate (not calling it) and simply calling <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)>.</span></span> <span data-ttu-id="f6d0f-147">W takim przypadku, jeśli Subskrybenci wymagają filtrowania, musi wykonać to samo.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-147">Thus, if the subscriber requires the filtering, it needs to do it itself.</span></span>

<span data-ttu-id="f6d0f-148">Jeśli ten parametr jest `null`, nie jest wykonywane filtrowanie (wszystkie <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> przeciążenia zwracające `true`).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-148">If this parameter is `null`, no filtering is done (all overloads of <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> return `true`).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer, Predicate&lt;string&gt; isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer, class System.Predicate`1&lt;string&gt; isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Predicate{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object)), isEnabled As Predicate(Of String)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ Subscribe(IObserver&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ observer, Predicate&lt;System::String ^&gt; ^ isEnabled);" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Predicate&lt;string&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Predicate&lt;string&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe (observer, isEnabled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
        <Parameter Name="isEnabled" Type="System.Predicate&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="observer"><span data-ttu-id="f6d0f-149">Subskrybent.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-149">A subscriber.</span></span></param>
        <param name="isEnabled"><span data-ttu-id="f6d0f-150">Delegat, który filtruje zdarzenia na podstawie ich nazwy<see cref="T:System.String" />().</span><span class="sxs-lookup"><span data-stu-id="f6d0f-150">A delegate that filters events based on their name (<see cref="T:System.String" />).</span></span> <span data-ttu-id="f6d0f-151">Delegat powinien zwrócić <see langword="true" /> , jeśli zdarzenie jest włączone.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-151">The delegate should return <see langword="true" /> if the event is enabled.</span></span></param>
        <summary><span data-ttu-id="f6d0f-152">Dodaje abonenta i opcjonalnie filtruje zdarzenia na podstawie ich nazwy.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-152">Adds a subscriber, and optionally filters events based on their name.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-153">Odwołanie do interfejsu, który umożliwia odbiornikowi zatrzymanie otrzymywania powiadomień przed <see cref="T:System.Diagnostics.DiagnosticSource" /> zakończeniem ich wysyłania.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-153">A reference to an interface that allows the listener to stop receiving notifications before the <see cref="T:System.Diagnostics.DiagnosticSource" /> has finished sending them.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="f6d0f-154">Jeśli `isEnabled` tak nie `null`jest, niektóre zdarzenia są nieinteresujące i można je pominąć w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-154">If `isEnabled` is not `null`, some events are uninteresting and can be skipped for efficiency.</span></span> <span data-ttu-id="f6d0f-155">Predykat jest opcjonalną optymalizacją umożliwiającą lokacjom Instrumentacji uniknięcie konfigurowania ładunku i wywoływania <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)> , gdy nie dba subskrybenta. `isEnabled`</span><span class="sxs-lookup"><span data-stu-id="f6d0f-155">The `isEnabled` predicate is an optional optimization to allow the instrumentation site to avoid setting up the payload and calling <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)> when no subscriber cares about it.</span></span> <span data-ttu-id="f6d0f-156">W szczególności lokacja Instrumentacji ma opcję ignorowania <xref:System.Diagnostics.DiagnosticListener.IsEnabled> predykatu (niewywołującego go) i po prostu wywołanie. <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)></span><span class="sxs-lookup"><span data-stu-id="f6d0f-156">In particular the instrumentation site has the option of ignoring the <xref:System.Diagnostics.DiagnosticListener.IsEnabled> predicate (not calling it) and simply calling <xref:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)>.</span></span> <span data-ttu-id="f6d0f-157">W takim przypadku, jeśli Subskrybenci wymagają filtrowania, musi wykonać to samo.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-157">Thus if the subscriber requires the filtering, it needs to do it itself.</span></span>

<span data-ttu-id="f6d0f-158">Jeśli `isEnabled` <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> `true`jest `null`, filtrowanie nie jest wykonywane (wszystkie przeciążenia powrotu).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-158">If `isEnabled` is `null`, no filtering is done (all overloads of <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> return `true`).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public virtual IDisposable Subscribe (IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; observer, Func&lt;string,object,object,bool&gt; isEnabled, Action&lt;System.Diagnostics.Activity,object&gt; onActivityImport = null, Action&lt;System.Diagnostics.Activity,object&gt; onActivityExport = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Subscribe(class System.IObserver`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; observer, class System.Func`4&lt;string, object, object, bool&gt; isEnabled, class System.Action`2&lt;class System.Diagnostics.Activity, object&gt; onActivityImport, class System.Action`2&lt;class System.Diagnostics.Activity, object&gt; onActivityExport) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Subscribe(System.IObserver{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Func{System.String,System.Object,System.Object,System.Boolean},System.Action{System.Diagnostics.Activity,System.Object},System.Action{System.Diagnostics.Activity,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Subscribe (observer As IObserver(Of KeyValuePair(Of String, Object)), isEnabled As Func(Of String, Object, Object, Boolean), Optional onActivityImport As Action(Of Activity, Object) = null, Optional onActivityExport As Action(Of Activity, Object) = null) As IDisposable" />
      <MemberSignature Language="F#" Value="abstract member Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; -&gt; IDisposable&#xA;override this.Subscribe : IObserver&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * Func&lt;string, obj, obj, bool&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; * Action&lt;System.Diagnostics.Activity, obj&gt; -&gt; IDisposable" Usage="diagnosticListener.Subscribe (observer, isEnabled, onActivityImport, onActivityExport)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="System.IObserver&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="isEnabled" Type="System.Func&lt;System.String,System.Object,System.Object,System.Boolean&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="onActivityImport" Type="System.Action&lt;System.Diagnostics.Activity,System.Object&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="onActivityExport" Type="System.Action&lt;System.Diagnostics.Activity,System.Object&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <param name="isEnabled">To be added.</param>
        <param name="onActivityImport">To be added.</param>
        <param name="onActivityExport">To be added.</param>
        <summary><span data-ttu-id="f6d0f-159">Dodaje subskrybenta, opcjonalnie filtruje zdarzenia na podstawie ich nazwy i do dwóch obiektów kontekstu, a także określa metody do wywołania, gdy dostawcy importują lub eksportują działania z zewnątrz procesu.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-159">Adds a subscriber, optionally filters events based on their name and up to two context objects, and specifies methods to call when providers import or export activites from outside the process.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-160">Odwołanie do interfejsu, który umożliwia odbiornikowi zatrzymanie otrzymywania powiadomień przed <see cref="T:System.Diagnostics.DiagnosticSource" /> zakończeniem ich wysyłania.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-160">A reference to an interface that allows the listener to stop receiving notifications before the <see cref="T:System.Diagnostics.DiagnosticSource" /> has finished sending them.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="f6d0f-161">Jeśli `isEnabled` ma wartość inną niż null, niektóre zdarzenia są nieinteresujące może zostać pominięte w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-161">If `isEnabled` is non-null, some events are uninteresting can be skipped for efficiency.</span></span>  

<span data-ttu-id="f6d0f-162">Można również dostarczyć metody "onActivityImport" i "onActivityExport", które są wywoływane, gdy dostawcy importują lub eksportują działania spoza procesu (na przykład z żądań HTTP).</span><span class="sxs-lookup"><span data-stu-id="f6d0f-162">You can also supply 'onActivityImport' and 'onActivityExport' methods that are called when providers importing or export activities from outside the process (for example, from HTTP requests).</span></span> <span data-ttu-id="f6d0f-163">Te metody są wywoływane po zaimportowaniu lub wyeksportowaniu działania i mogą być używane do modyfikowania działania lub żądania wychodzącego w celu dodania zasad.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-163">These methods are called after importing or exporting the activity and can be used to modify the activity or the outgoing request to add policy.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="diagnosticListener.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6d0f-164">Zwraca ciąg o nazwie DiagnosticListener.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-164">Returns a string with the name of this DiagnosticListener.</span></span></summary>
        <returns><span data-ttu-id="f6d0f-165">Nazwa tego DiagnosticListener.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-165">The name of this DiagnosticListener.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (string name, object value);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string name, object value) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (name As String, value As Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ name, System::Object ^ value);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
      <MemberSignature Language="C#" Value="public override void Write (string name, object parameters);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string name, object parameters) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (name As String, parameters As Object)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ name, System::Object ^ parameters);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticListener.Write(System.String,System.Object)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="F#" Value="override this.Write : string * obj -&gt; unit" Usage="diagnosticListener.Write (name, parameters)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="F#" Value="override this.Write : string * obj -&gt; unit" Usage="diagnosticListener.Write (name, parameters)" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-3.0" />
        <Parameter Name="parameters" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f6d0f-166">Nazwa zdarzenia do zarejestrowania.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-166">The name of the event to log.</span></span></param>
        <param name="value"><span data-ttu-id="f6d0f-167">Obiekt, który reprezentuje ładunek dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-167">An object that represents the payload for the event.</span></span></param>
        <param name="parameters"><span data-ttu-id="f6d0f-168">Obiekt, który reprezentuje ładunek dla zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-168">An object that represents the payload for the event.</span></span></param>
        <summary><span data-ttu-id="f6d0f-169">Rejestruje powiadomienie.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-169">Logs a notification.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="f6d0f-170">Aby uzyskać więcej informacji, zobacz <xref:System.Diagnostics.DiagnosticSource.Write%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="f6d0f-170">For more information, see the <xref:System.Diagnostics.DiagnosticSource.Write%2A?displayProperty=nameWithType> method.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58cf5f02c19c3c52ac8d26e1ed52e28a450d7b17" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36676171" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do procesów lokalnych i zdalnych i umożliwia uruchamianie i zatrzymywanie procesów system lokalny.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.Process> składnik zapewnia dostęp do procesu, który jest uruchomiony na komputerze. Proces, w zakresie najprostszym jest uruchomionej aplikacji. Wątek jest podstawową jednostką system operacyjny przydziela czas procesora. Wątek może wykonać dowolną część kod proces, w tym części wykonywana przez inny wątek.  
  
 <xref:System.Diagnostics.Process> Składnik jest przydatne narzędzie podczas uruchamianie, zatrzymywanie, kontrolowanie i monitorowanie aplikacji. Można użyć <xref:System.Diagnostics.Process> lub składnik, aby uzyskać listę procesów, które są uruchomione, można uruchomić nowego procesu. A <xref:System.Diagnostics.Process> składnika umożliwia dostęp do procesów systemowych. Po <xref:System.Diagnostics.Process> składnik został zainicjowany, może służyć do uzyskiwania informacji na temat uruchomionego procesu. Zawierają one zestaw wątków, załadowanych modułów (pliki dll i .exe) i używa informacje o wydajności, takich jak ilość pamięci procesu.  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
> [!NOTE]
>  procesy 32-bitowe nie może uzyskać dostępu modułów procesu 64-bitowego. Jeśli użytkownik spróbuje uzyskać informacje na temat procesu 64-bitowym z proces 32-bitowy, otrzyma <xref:System.ComponentModel.Win32Exception> wyjątku. Procesu 64-bitowego, z drugiej strony, mają dostęp do modułów procesu 32-bitowego.  
  
 Składnik procesu uzyskuje informacje o grupie właściwości jednocześnie. Po <xref:System.Diagnostics.Process> składnika uzyskał informacje o jeden element członkowski grupy, będzie pamięci podręcznej wartości innych właściwości w tej grupie, a nie uzyskać nowe informacje o innych członków grupy, do czasu wywołania <xref:System.Diagnostics.Process.Refresh%2A> metody. W związku z tym wartość właściwości nie jest gwarantowana na każdym nowsza ostatnim wywołaniem <xref:System.Diagnostics.Process.Refresh%2A> metody. Podział grupy są zależne od systemu operacyjnego.  
  
 Jeśli zmienna ścieżki zadeklarowana w systemie za pomocą oferty, możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie będzie zawierał ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, i dodaj go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji każdy proces w `c:\mypath` podczas jego uruchamiania.  
  
 Proces systemowy jest unikatowo identyfikowana w systemie za pomocą jego identyfikatora procesu. Jak wiele zasobów systemu Windows proces jest również identyfikowany przez jego uchwytu, które nie muszą być unikatowe na komputerze. Dojście jest ogólny termin dla identyfikatora zasobu. System operacyjny będzie się powtarzał uchwytu procesu, który jest dostępny za pośrednictwem <xref:System.Diagnostics.Process.Handle%2A> właściwość <xref:System.Diagnostics.Process> składnika, nawet wtedy, gdy proces został zakończony. W związku z tym informacji można znaleźć procesu administracyjnych, takich jak <xref:System.Diagnostics.Process.ExitCode%2A> (zazwyczaj albo od zera dla powodzenie lub kod błędu różną od zera) i <xref:System.Diagnostics.Process.ExitTime%2A>. Uchwyty są bardzo istotne zasobów, tak aby przeciek dojść zjadliwe więcej niż przeciek pamięci.  
  
> [!NOTE]
>  Ta klasa zawiera żądanie łącza i dziedziczenia na poziomie klasy stosowane do wszystkich składowych. A <xref:System.Security.SecurityException> jest generowany, gdy bezpośredniego obiektu wywołującego lub Klasa pochodna nie ma uprawnienia pełnego zaufania. Aby uzyskać szczegółowe informacje dotyczące żądania kontroli zabezpieczeń, zobacz [Linkdemand](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Uwagi  
 W programie .NET Framework <xref:System.Diagnostics.Process> klasy domyślnie używa <xref:System.Console> kodowania, które są zazwyczaj kodu strony kodowania, dla strumieni danych wejściowych, wyjściowych i błędów. Na przykład kodu, w systemach, w których kultury jest angielski (Stany Zjednoczone), strona kodowa 437 jest domyślne kodowanie <xref:System.Console> klasy. Jednak [!INCLUDE[net_core](~/includes/net-core-md.md)] może udostępnić ograniczonym podzbiorem te kodowania. Jeśli tak jest, używa <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> jako domyślne kodowanie.  
  
 Jeśli <xref:System.Diagnostics.Process> obiektu zależy od konkretnego kodu strony kodowania, można nadal udostępniać je, wykonując następujące *przed* wywołać dowolną <xref:System.Diagnostics.Process> metod:  
  
1.  Dodaj odwołanie do zestawu System.Text.Encoding.CodePages.dll do projektu.  
  
2.  Pobrać <xref:System.Text.EncodingProvider> obiekt z <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> właściwości.  
  
3.  Przekaż <xref:System.Text.EncodingProvider> do obiektu <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> metodę, aby wprowadzić dodatkowe kodowania, obsługiwane przez dostawcę kodowania, która jest dostępna.  
  
 <xref:System.Diagnostics.Process> Klasy będzie automatycznie używać systemu domyślne kodowanie zamiast UTF8, pod warunkiem, że zarejestrowano dostawcę kodowania przed wywołaniem dowolnej <xref:System.Diagnostics.Process> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wystąpienia <xref:System.Diagnostics.Process> klasy do uruchomienia procesu.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.Diagnostics.Process> klasy sam i statycznego <xref:System.Diagnostics.Process.Start%2A> metody do uruchomienia procesu.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 W poniższym przykładzie F # definiuje `runProc` funkcja, która rozpoczyna się proces przechwytuje wszystkie informacje w danych wyjściowych i błędów i rejestruje wyrażony w milisekundach czas, uruchamiane przez proces.  `runProc` Funkcja ma trzy parametry: Nazwa aplikacji, aby uruchomić argumenty w celu dostarczenia do aplikacji i katalog początkowy.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Kod `runProc` zapisał funkcja [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) i jest dostępny w obszarze [licencji publicznej Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.Process" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie określisz <xref:System.Diagnostics.Process.MachineName%2A> właściwości, wartość domyślna to komputer lokalny, (".").  
  
 Dostępne są dwie opcje do kojarzenia nowy <xref:System.Diagnostics.Process> składnika procesu na komputerze. Pierwsza opcja jest używanie konstruktora, aby utworzyć <xref:System.Diagnostics.Process> składnika, ustawić odpowiednie elementy członkowskie <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywołanie <xref:System.Diagnostics.Process.Start%2A> do skojarzenia <xref:System.Diagnostics.Process> z nowego procesu systemu. Drugą opcją jest skojarzenie <xref:System.Diagnostics.Process> z uruchomionego procesu systemu za pomocą <xref:System.Diagnostics.Process.GetProcessById%2A> lub jednego z <xref:System.Diagnostics.Process.GetProcesses%2A> zwracają wartości.  
  
 Jeśli używasz `static` przeciążenia z <xref:System.Diagnostics.Process.Start%2A> metodę, aby uruchomić nowego procesu systemu, metoda tworzy nowy <xref:System.Diagnostics.Process> składnika i kojarzy ją z procesem.  
  
 Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> właściwość jest ustawiona na wartość domyślną `true`, możesz uruchomić aplikacji oraz dokumentów w taki sposób, który jest podobny do sposobu używania `Run` okno dialogowe systemu Windows `Start` menu. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> jest `false`, można uruchomić tylko pliki wykonywalne.  
  
 Plik wykonywalny, który można wywołać z poziomu wiersza polecenia można uruchomić w jednym z dwóch sposobów: przez ustawienie odpowiednich członków <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> metody bez parametrów lub przez przekazanie odpowiedni parametr do `static` <xref:System.Diagnostics.Process.Start%2A> elementu członkowskiego.  
  
 Można utworzyć <xref:System.Diagnostics.Process> składnika za pomocą konstruktora, jeden statycznych <xref:System.Diagnostics.Process.Start%2A> przeciążenia lub dowolnym <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, lub <xref:System.Diagnostics.Process.GetProcessesByName%2A> metody. Po wykonaniu, aby mieć wgląd do skojarzonego procesu. To nie jest dynamiczny widok, który aktualizuje się automatycznie podczas procesu właściwości zostały zmienione w pamięci. Zamiast tego należy wywołać <xref:System.Diagnostics.Process.Refresh%2A> dla składnika zaktualizować <xref:System.Diagnostics.Process> informacje dotyczące właściwości w aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowy priorytet skojarzonego procesu.</summary>
        <value>Priorytet podstawowy jest obliczana na podstawie <see cref="P:System.Diagnostics.Process.PriorityClass" /> skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> Procesu jest początkowy priorytet wątków utworzone w ramach skojarzonego procesu. Można przeglądać informacje o priorytet podstawowy licznik priorytet podstawowy Monitor systemu.  
  
 Na podstawie czasu zwiększenie czas lub innego systemu operacyjnego można zmienić priorytet podstawowy, gdy proces powinien być umieszczony przed innymi znakami.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Właściwości umożliwia wyświetlanie początkowy priorytetu przypisanego do procesu. Jednakże, ponieważ jest tylko do odczytu, nie można użyć <xref:System.Diagnostics.Process.BasePriority%2A> można ustawić priorytetu procesu. Aby zmienić priorytet, użyj <xref:System.Diagnostics.Process.PriorityClass%2A> właściwości. <xref:System.Diagnostics.Process.BasePriority%2A> Można wyświetlać przy użyciu Monitora systemu, podczas gdy <xref:System.Diagnostics.Process.PriorityClass%2A> nie jest. Zarówno <xref:System.Diagnostics.Process.BasePriority%2A> i <xref:System.Diagnostics.Process.PriorityClass%2A> można programowo wyświetlać. W poniższej tabeli przedstawiono relacje między <xref:System.Diagnostics.Process.BasePriority%2A> wartości i <xref:System.Diagnostics.Process.PriorityClass%2A> wartości.  
  
|BasePriority|Klasa priorytetu|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został zakończony.  - lub - proces nie rozpoczął, więc nie ma żadnych identyfikatora procesu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> Synchronicznie lub asynchronicznie można odczytać strumienia. Metody, takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> przeprowadzić synchronicznej operacji odczytu na błąd strumień wyjściowy procesu. Te synchroniczne do odczytu do skojarzonego nie są wykonywane operacje <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardError%2A> strumienia lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> strumienia. Ta metoda umożliwia programu obsługi zdarzeń w wyznaczonych strumieni wyjściowych i natychmiast zwraca obiekt wywołujący, które można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Wykonaj te kroki do wykonywania asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> dla <xref:System.Diagnostics.Process> :  
  
1.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> do `false`.  
  
2.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> do `true`.  
  
3.  Dodawanie obsługi zdarzenia do <xref:System.Diagnostics.Process.ErrorDataReceived> zdarzeń. Program obsługi zdarzeń musi być zgodna <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> podpisu delegata.  
  
4.  Uruchom <xref:System.Diagnostics.Process>.  
  
5.  Wywołanie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> dla <xref:System.Diagnostics.Process>. To wywołanie uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Podczas uruchamiania asynchronicznych operacji odczytu, program obsługi zdarzeń jest wywoływana po każdej aktualizacji skojarzony <xref:System.Diagnostics.Process> zapisuje wiersz tekstu do jego <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Możesz anulować operację asynchroniczną odczytu przez wywołanie metody <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Operacja odczytu mogą zostać anulowane przez obiekt wywołujący lub przez program obsługi zdarzeń. Po anulowanie, należy wywołać <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ponownie, aby wznowić asynchronicznych operacji odczytu.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla strumienia przekierowane. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchroniczne i synchroniczne, wszystkie dalsze odczytu operacji na strumieniu musi być w tym samym trybie. Na przykład nie wykonuj <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardError%2A> strumienia, albo na odwrót. Można jednak odczytać dwóch różnych strumieni w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `net view` polecenie, aby wyświetlić zasoby sieciowe dostępne na komputerze zdalnym. Użytkownik podaje nazwę komputera docelowego jako argument wiersza polecenia. Użytkownik może też podawać nazwę pliku dla danych wyjściowych błędu. Przykład zbiera dane wyjściowe polecenia net, czeka na zakończenie procesu, a następnie zapisuje wyniki dane wyjściowe do konsoli. Jeśli użytkownik poda opcjonalne błędów, przykładzie zapisuje błędy do pliku.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> Jest właściwość <see langword="false" />.  \- lub — operacja odczytu asynchronicznego jest już w toku na <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia.  \- lub - <see cref="P:System.Diagnostics.Process.StandardError" /> strumień został użyty przez synchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> Synchronicznie lub asynchronicznie można odczytać strumienia. Metody, takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> przeprowadzić synchronicznej operacji odczytu na strumień wyjściowy procesu. Te synchroniczne do odczytu do skojarzonego nie są wykonywane operacje <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Ta metoda umożliwia obsługi zdarzeń w wyznaczonych dla strumieni wyjściowych i natychmiast zwraca obiekt wywołujący, które można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Wykonaj te kroki do wykonywania asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> dla <xref:System.Diagnostics.Process> :  
  
1.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> do `false`.  
  
2.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> do `true`.  
  
3.  Dodawanie obsługi zdarzenia do <xref:System.Diagnostics.Process.OutputDataReceived> zdarzeń. Program obsługi zdarzeń musi być zgodna <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> podpisu delegata.  
  
4.  Uruchom <xref:System.Diagnostics.Process>.  
  
5.  Wywołanie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> dla <xref:System.Diagnostics.Process>. To wywołanie uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Podczas uruchamiania asynchronicznych operacji odczytu, program obsługi zdarzeń jest wywoływana po każdej aktualizacji skojarzony <xref:System.Diagnostics.Process> zapisuje wiersz tekstu do jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
 Możesz anulować operację asynchroniczną odczytu przez wywołanie metody <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Operacja odczytu mogą zostać anulowane przez obiekt wywołujący lub przez program obsługi zdarzeń. Po anulowanie, należy wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ponownie, aby wznowić asynchronicznych operacji odczytu.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla strumienia przekierowane. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchroniczne i synchroniczne, wszystkie dalsze odczytu operacji na strumieniu musi być w tym samym trybie. Na przykład nie wykonuj <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, albo na odwrót. Można jednak odczytać dwóch różnych strumieni w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wykonywania asynchronicznych operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumień `sort` polecenia. `sort` Polecenie jest aplikacja konsolowa, która odczytuje i sortuje wprowadzania tekstu.  
  
 W przykładzie jest tworzony delegata zdarzenia dla `SortOutputHandler` obsługi zdarzeń i kojarzy ją z <xref:System.Diagnostics.Process.OutputDataReceived> zdarzeń. Program obsługi zdarzeń odbiera wierszy tekstu z przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, formatuje tekst i zapisuje tekst do ekranu.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> Jest właściwość <see langword="false" />.  \- lub — operacja odczytu asynchronicznego jest już w toku na <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia.  \- lub - <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumień został użyty przez synchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> strumienia. <xref:System.Diagnostics.Process.CancelErrorRead%2A> kończy się asynchronicznych operacji odczytu.  
  
 Po anulowanie, można wznowić asynchronicznych operacji odczytu, wywołując <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ponownie.  
  
 Podczas wywoływania <xref:System.Diagnostics.Process.CancelErrorRead%2A>, wszystkie trwające operacje dla odczytu <xref:System.Diagnostics.Process.StandardError%2A> zostały zakończone, a następnie program obsługi zdarzeń jest wyłączona. Wszystkie dodatkowe przekierowane dane wyjściowe do <xref:System.Diagnostics.Process.StandardError%2A> jest zapisywany w buforze. Jeśli ponownie włączyć program obsługi zdarzeń w wyniku wywołania <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, zapisane dane wyjściowe są wysyłane do programu obsługi zdarzeń i wznowić asynchronicznych operacji odczytu. Jeśli chcesz zmienić programu obsługi zdarzeń przed wznowieniem asynchronicznych operacji odczytu, należy usunąć istniejącego programu obsługi zdarzeń przed dodaniem nowego programu obsługi zdarzeń:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardError%2A> strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchroniczne i synchroniczne, wszystkie dalsze odczytu operacji na strumieniu musi być w tym samym trybie. Jeśli anulujesz asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> , a następnie trzeba odczytany ze strumienia ponownie, należy użyć <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wznowienie asynchronicznych operacji odczytu. Nie wykonuj <xref:System.Diagnostics.Process.CancelErrorRead%2A> w wyniku wywołania synchronicznego odczytu metod <xref:System.Diagnostics.Process.StandardError%2A> takich jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, lub <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 W następującym przykładzie uruchomiono `nmake` polecenie z użytkownikiem dostarczonych argumentów. Strumienie o błędach i dane wyjściowe są odczytywane asynchronicznie; wiersze tekstu zbierane są wyświetlane w konsoli także zapisywane w pliku dziennika. Jeśli dane wyjściowe polecenia przekroczy określoną liczbę wierszy, są anulowane asynchronicznych operacji odczytu.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardError" /> Strumień nie jest włączony dla asynchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. <xref:System.Diagnostics.Process.CancelOutputRead%2A> kończy się asynchronicznych operacji odczytu.  
  
 Po anulowanie, można wznowić asynchronicznych operacji odczytu, wywołując <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ponownie.  
  
 Podczas wywoływania <xref:System.Diagnostics.Process.CancelOutputRead%2A>, wszystkie trwające operacje dla odczytu <xref:System.Diagnostics.Process.StandardOutput%2A> zostały zakończone, a następnie program obsługi zdarzeń jest wyłączona. Wszystkie dodatkowe przekierowane dane wyjściowe do <xref:System.Diagnostics.Process.StandardOutput%2A> jest zapisywany w buforze. Jeśli ponownie włączyć program obsługi zdarzeń w wyniku wywołania <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, zapisane dane wyjściowe są wysyłane do programu obsługi zdarzeń i wznowić asynchronicznych operacji odczytu. Jeśli chcesz zmienić programu obsługi zdarzeń przed wznowieniem asynchronicznych operacji odczytu, należy usunąć istniejącego programu obsługi zdarzeń przed dodaniem nowego programu obsługi zdarzeń:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchroniczne i synchroniczne, wszystkie dalsze odczytu operacji na strumieniu musi być w tym samym trybie. Jeśli anulujesz asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> , a następnie trzeba odczytany ze strumienia ponownie, należy użyć <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wznowienie asynchronicznych operacji odczytu. Nie wykonuj <xref:System.Diagnostics.Process.CancelOutputRead%2A> w wyniku wywołania synchronicznego odczytu metod <xref:System.Diagnostics.Process.StandardOutput%2A> takich jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, lub <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 W następującym przykładzie uruchomiono `nmake` polecenie z użytkownikiem dostarczonych argumentów. Strumienie o błędach i dane wyjściowe są odczytywane asynchronicznie; wiersze tekstu zbierane są wyświetlane w konsoli także zapisywane w pliku dziennika. Jeśli dane wyjściowe polecenia przekroczy określoną liczbę wierszy, są anulowane asynchronicznych operacji odczytu.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumień nie jest włączony dla asynchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są skojarzone z danym składnikiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> Metoda powoduje, że proces zatrzymać oczekiwanie na zakończenia Jeśli oczekiwał, zamyka uchwytu procesu i czyści właściwości specyficzne dla procesu. <xref:System.Diagnostics.Process.Close%2A> w przypadku, gdy odwołują zewnętrznie, nie Zamknij standardowe wyjście, dane wejściowe i błąd czytników i zapisywania.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> Wywołania metody <xref:System.Diagnostics.Process.Close%2A>. Wprowadzenie do <xref:System.Diagnostics.Process> obiektu w `using` bloku usuwa zasoby bez konieczności wywoływania <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Pobiera następnie użycie pamięci fizycznej przez skojarzony proces odstępach 2 sekundy maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje zamknięcie procesu, który ma interfejsu użytkownika, wysyłając komunikat zamknięcia do jego głównego okna.</summary>
        <returns>
          <see langword="true" /> Jeśli pomyślnie wysłała komunikat o zamykaniu; <see langword="false" /> jeśli skojarzony proces nie ma głównego okna lub wyłączenie okna głównego (na przykład jeśli modalne okno dialogowe jest wyświetlane).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania procesu jego Pętla wiadomości jest w stanie oczekiwania. Pętla wiadomości jest wykonywana za każdym razem, gdy komunikatów systemu Windows są wysyłane do procesu przez system operacyjny. Wywoływanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> wysyła żądanie bliski głównego okna, które w poprawnie sformułowanym aplikacji, zamyka okno podrzędne i wycofanie wszystkich uruchomionych pętli komunikatów dla aplikacji. Żądanie, aby zakończyć proces przez wywołanie metody <xref:System.Diagnostics.Process.CloseMainWindow%2A> wymusza na aplikacji, aby zakończyć. Aplikacja może poprosić o weryfikacji użytkownika przed zamknięciem lub go odmówić zakończyć. Aby wymusić zakończenie aplikacji, użyj <xref:System.Diagnostics.Process.Kill%2A> metody. Zachowanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> jest identyczna jak użytkownik zamknięcie okna głównego aplikacji przy użyciu menu systemowego. W związku z tym żądaniu, aby zakończyć proces przez zamknięcie okna głównego nie wymusza aplikacji, aby natychmiast zamknąć.  
  
 Dane edytowane przez proces lub zasoby przydzielone do procesu mogą zostać utracone jeśli wywołujesz <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> powoduje, że po zakończeniu procesu nietypowe i powinna być używana tylko wtedy, gdy jest to konieczne. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Włącza uporządkowany zakończenie procesu i zamknięcie wszystkich okien, dlatego zaleca się dla aplikacji z interfejsem. Jeśli <xref:System.Diagnostics.Process.CloseMainWindow%2A> kończy się niepowodzeniem, można użyć <xref:System.Diagnostics.Process.Kill%2A> zakończenie procesu. <xref:System.Diagnostics.Process.Kill%2A> jest jedynym sposobem, aby zakończyć procesy, które nie mają graficzne interfejsy.  
  
 Możesz wywołać <xref:System.Diagnostics.Process.Kill%2A> i <xref:System.Diagnostics.Process.CloseMainWindow%2A> tylko dla procesów uruchomionych na komputerze lokalnym. Nie można spowodować procesów na komputerach zdalnych, aby zakończyć. Mogą wyświetlać tylko informacje dla procesów uruchomionych na komputerach zdalnych.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Pobiera następnie użycie pamięci fizycznej przez skojarzony proces odstępach drugi 2 maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został już zakończony.  - lub - nie jest skojarzony z tym żaden proces <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia wszelkie zasoby używane przez ten proces.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czy <see cref="E:System.Diagnostics.Process.Exited" /> zdarzenia powinien być wywoływany, gdy zakończenie procesu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="E:System.Diagnostics.Process.Exited" /> zdarzenia powinien być wywoływany, gdy skojarzony proces zostanie zakończony (za pośrednictwem zakończenia lub wywołanie <see cref="M:System.Diagnostics.Process.Kill" />); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />. Należy pamiętać, że <see cref="E:System.Diagnostics.Process.Exited" /> zdarzenie jest zgłaszane, nawet jeśli wartość <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> jest <see langword="false" /> podczas procesu opuszcza podczas lub przed użytkownik wykonuje <see cref="P:System.Diagnostics.Process.HasExited" /> Sprawdź.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Właściwość sugeruje, czy składnik powinien otrzymać powiadomienie, gdy system operacyjny został zamknięty procesu. <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Właściwość jest używana podczas przetwarzania asynchronicznego, by powiadomić aplikację proces został zakończony. Aby wymusić aplikację synchronicznie oczekiwania na zdarzenie zakończenia (który przerywa przetwarzania aplikacji, do momentu zakończenia zdarzenia), użyj <xref:System.Diagnostics.Process.WaitForExit%2A> metody.

> [!NOTE]
> Jeśli korzystasz z programu Visual Studio i kliknij dwukrotnie <xref:System.Diagnostics.Process> składnika w projekcie, <xref:System.Diagnostics.Process.Exited> delegata zdarzenia i obsługi zdarzenia są generowane automatycznie. Ustawia dodatkowy kod <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwości `false`. Należy zmienić tę właściwość, aby `true` dla obsługi zdarzenia do wykonania, gdy skojarzony proces kończy się.

Jeśli składnika <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> wartość jest `true`, lub gdy <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> jest `false` i <xref:System.Diagnostics.Process.HasExited%2A> wyboru jest wywoływany przez składnik, składnik mogą uzyskiwać dostęp do informacji administracyjnych dla skojarzonego procesu, który pozostaje przechowywane przez system operacyjny. Zawierają one <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.ExitCode%2A>.

Po skojarzony proces zostanie zakończony, <xref:System.Diagnostics.Process.Handle%2A> składnika nie wskazuje na istniejący zasób procesu. Zamiast tego można można używać tylko dostępu do systemu operacyjnego informacji o zasobie procesu. System operacyjny jest pamiętać, że są dojścia do zakończone procesy, które nie zostały wydane przez <xref:System.Diagnostics.Process> składników, więc zapewnia <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci.

Brak kosztów związanych z oczekiwania na zakończenie procesu. Jeśli <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> jest `true`, <xref:System.Diagnostics.Process.Exited> zdarzenie jest wywoływane, gdy zakończenie skojarzonego procesu. Z procedurami <xref:System.Diagnostics.Process.Exited> zdarzeń teraz uruchomić.

Czasami aplikacja rozpoczyna się proces, ale nie wymaga powiadomienia o jego zamknięcia. Na przykład aplikację można uruchomić Notatnik, aby zezwolić użytkownikowi na przeprowadzić edycję tekstu, ale należy dalsze korzystanie z aplikacji Notatnik. Można uniknąć powiadomień, gdy proces zostaje zamknięty, ponieważ nie jest ważna dla dalszego działania aplikacji. Ustawienie <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> do `false` może zapisać zasobów systemowych.

## Examples  
Poniższy przykład kodu tworzy proces, który wyświetla plik. Ustawia <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość, aby spowodować, że proces pozyskiwania <xref:System.Diagnostics.Process.Exited> zdarzenie, gdy kończy działanie. <xref:System.Diagnostics.Process.Exited> Program obsługi zdarzeń wyświetla informacje o procesach.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umieszcza <see cref="T:System.Diagnostics.Process" /> składnik do interakcji z systemem operacyjnym w stanie przetwarza uruchomionymi w specjalnym trybie, włączając właściwość natywnego <see langword="SeDebugPrivilege" /> w bieżącym wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre procesy systemu operacyjnego są uruchamiane w specjalnym trybie. Nie jest możliwe próby odczytu właściwości lub Dołącz do tych procesów, chyba że wywołano <xref:System.Diagnostics.Process.EnterDebugMode%2A> dla składnika. Wywołanie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> gdy nie jest już potrzebny dostęp do tych procesów, które są uruchamiane w specjalnym trybie.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zapisuje jego przekierowanego <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> Zdarzeń wskazuje, czy skojarzony proces został zapisany do jego przekierowanego <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Zdarzenie występuje tylko podczas asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A>. Aby uruchomić asynchronicznych operacji odczytu, należy kierować <xref:System.Diagnostics.Process.StandardError%2A> strumień <xref:System.Diagnostics.Process>, dodać obsługi zdarzenia do <xref:System.Diagnostics.Process.ErrorDataReceived> zdarzeń i wywołania <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Później <xref:System.Diagnostics.Process.ErrorDataReceived> sygnały zdarzeń zawsze proces zapisuje linię przekierowanego <xref:System.Diagnostics.Process.StandardError%2A> strumienia, dopóki proces kończy działanie lub wywołuje <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Aplikacja, która jest przetwarzania asynchronicznego dane wyjściowe powinny wywoływać <xref:System.Diagnostics.Process.WaitForExit> metody, aby upewnić się, że zostały opróżnione buforu wyjściowego. Należy pamiętać, ten limit czasu określanie przy użyciu <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> jest przeciążenie *nie* upewnij się, liczba opróżnionych buforu wyjściowego.
  
   
  
## Examples  
 W poniższym przykładzie użyto `net view` polecenie, aby wyświetlić zasoby sieciowe dostępne na komputerze zdalnym. Użytkownik podaje nazwę komputera docelowego jako argument wiersza polecenia. Użytkownik może też podawać nazwę pliku dla danych wyjściowych błędu. Przykład zbiera dane wyjściowe polecenia net, czeka na zakończenie procesu, a następnie zapisuje wyniki dane wyjściowe do konsoli. Jeśli użytkownik poda opcjonalne błędów, przykładzie zapisuje błędy do pliku.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która skojarzonego procesu określić, kiedy zakończone.</summary>
        <value>Kod skojarzony proces określić, kiedy zakończone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.ExitCode%2A> stan zwróconą przez proces systemu, gdy został zakończony. Można użyć kodu zakończenia znacznie, tak jak całkowitą wartością zwracaną z `main()` procedury.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> Wartość dla procesu odzwierciedla określonych konwencji określoną przez dewelopera aplikacji dla tego procesu. Jeśli używasz wartość kodu zakończenia do podejmowania decyzji w kodzie, należy znać Konwencji kod zakończenia używanych przez proces aplikacji.  
  
 Deweloperzy zazwyczaj wskazują pomyślnego zakończenia przez <xref:System.Diagnostics.Process.ExitCode%2A> wartości zero i wyznaczania błędów przez niezerowe wartości, które wywołanie metody można użyć do zidentyfikowania przyczyny zakończenia procesu nietypowe. Nie jest konieczne zgodna z tymi wytycznymi, ale są one Konwencji.  
  
 Jeśli spróbujesz uzyskać <xref:System.Diagnostics.Process.ExitCode%2A> przed proces został zakończony, próba zgłasza wyjątek. Sprawdź <xref:System.Diagnostics.Process.HasExited%2A> właściwości, aby sprawdzić, czy skojarzony proces został zakończony.  
  
> [!NOTE]
>  Gdy wyjścia standardowego został przekierowany do obsługi zdarzeń asynchroniczne, jest to możliwe, że przetwarzanie danych wyjściowych nie ukończy kiedy <xref:System.Diagnostics.Process.HasExited%2A> zwraca `true`. Aby zakończenie obsługi zdarzenia asynchroniczne, wywołaj <xref:System.Diagnostics.Process.WaitForExit> przeciążenia, które przyjmuje żadnego parametru przed zaewidencjonowaniem <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Można użyć <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A> metodę, aby spowodować zakończenie skojarzonego procesu.  
  
 Trwa powiadomienie, gdy skojarzony proces zostanie zakończony na dwa sposoby: synchronicznego i asynchronicznego. Synchroniczne powiadomień zależy od wywołania <xref:System.Diagnostics.Process.WaitForExit%2A> metodę, aby wstrzymać przetwarzania aplikacji, dopóki opuszcza składnik skojarzony. Asynchroniczne powiadomienia polega na <xref:System.Diagnostics.Process.Exited> zdarzeń. Używając asynchronicznych powiadomień <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> musi mieć ustawioną `true` dla <xref:System.Diagnostics.Process> składnik, aby otrzymać powiadomienie, że proces został zakończony.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie został zakończony.  - lub - proces <see cref="P:System.Diagnostics.Process.Handle" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.ExitCode" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kończy proces.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> Zdarzenie wskazuje, czy skojarzony proces został zakończony. To wystąpienie oznacza, że proces zakończone (przerwana), czy pomyślnie zamknięte. To zdarzenie może wystąpić tylko wtedy, gdy wartość <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> jest właściwość `true`.  
  
 Trwa powiadomienie, gdy skojarzony proces zostanie zakończony na dwa sposoby: synchronicznego i asynchronicznego. Synchroniczne powiadomień oznacza wywołania <xref:System.Diagnostics.Process.WaitForExit%2A> metodę, aby zablokować bieżącego wątku, dopóki proces kończy się. Asynchroniczne powiadomienia używa <xref:System.Diagnostics.Process.Exited> zdarzenia, dzięki czemu wątek wywołujący do kontynuowania wykonywania w tym samym czasie. W drugim przypadku <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> musi mieć ustawioną `true` wywoływania aplikacji na odbieranie zdarzenie Exited.  
  
 System operacyjny będzie zamykany procesu, powiadamia o wszystkich procesów, które zarejestrowane obsługi zdarzenie Exited. W tej chwili uchwytu procesu, który właśnie został zakończony może służyć do dostępu do niektórych właściwości, takie jak <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.HasExited%2A> czy system operacyjny obsługuje aż całkowicie zwalnia dojścia.  
  
> [!NOTE]
>  Nawet jeśli dojścia do procesu zakończone, nie można wywołać <xref:System.Diagnostics.Process.Start%2A> ponownie, aby ponownie połączyć się z tym samym procesie. Wywoływanie <xref:System.Diagnostics.Process.Start%2A> automatycznie zwalnia skojarzonego procesu i łączy z procesów z tego samego pliku, ale całkowicie nowa <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Aby uzyskać więcej informacji o wykorzystaniu <xref:System.Diagnostics.Process.Exited> zdarzeń w aplikacjach formularzy systemu Windows, temacie <xref:System.Diagnostics.Process.SynchronizingObject%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy proces, który wyświetla plik. Uruchamia <xref:System.Diagnostics.Process.Exited> zdarzenie, gdy proces kończy pracę, ponieważ <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość została ustawiona, gdy proces został utworzony. <xref:System.Diagnostics.Process.Exited> Program obsługi zdarzeń wyświetla informacje o procesach.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas zakończenia skojarzonego procesu.</summary>
        <value>A <see cref="T:System.DateTime" /> wskazujące, gdy skojarzony proces został zakończony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli proces nie został zakończony, próby pobrania <xref:System.Diagnostics.Process.ExitTime%2A> właściwości zgłasza wyjątek. Użyj <xref:System.Diagnostics.Process.HasExited%2A> przed pobraniem <xref:System.Diagnostics.Process.ExitTime%2A> właściwości w celu określenia, czy skojarzony proces został zakończony.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy proces, który wyświetla plik. Uruchamia proces <xref:System.Diagnostics.Process.Exited> zdarzeń po wydaniu i wyświetla program obsługi zdarzeń <xref:System.Diagnostics.Process.ExitTime%2A> właściwości i inne przetworzyć informacji.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.ExitTime" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nową <see cref="T:System.Diagnostics.Process" /> składnika i kojarzy ją z aktualnie aktywnego procesu.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> składnik skojarzony z zasobem procesu, który jest uruchomiona aplikacja wywołująca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia i powiązać ją z zasobem procesu na komputerze lokalnym.  
  
 Jak podobne <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, i <xref:System.Diagnostics.Process.GetProcesses%2A> metod, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> kojarzy istniejący zasób usługi z nową <xref:System.Diagnostics.Process> składnika.  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o bieżącego procesu procesów uruchomionych na komputerze lokalnym, wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera ona następnie informacje dla tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Diagnostics.Process" /> składnika i skojarzy ją z istniejącym przetworzyć zasobu, który określisz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">System Unikatowy identyfikator zasobu procesu.</param>
        <summary>Zwraca nowy <see cref="T:System.Diagnostics.Process" /> składnika podany identyfikator procesu na komputerze lokalnym.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> składnik, który jest skojarzony z zasobem proces lokalny identyfikowane przez <paramref name="processId" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> składnika i powiązać ją z zasobem procesu na komputerze lokalnym. Proces zasobów musi już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> nie tworzy zasób systemowy, ale raczej kojarzy zasobu z wygenerowanymi <xref:System.Diagnostics.Process> składnika. Proces <xref:System.Diagnostics.Process.Id%2A> można pobrać tylko dla procesu, który obecnie jest uruchomiona na komputerze. Po kończy proces, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> zgłasza wyjątek w przypadku przekazania wygasłe identyfikator.  
  
 Na dowolnym komputerze z konkretnym identyfikator procesu jest unikatowa. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Zwraca co najwyżej jeden proces. Jeśli chcesz pobrać wszystkie procesy, które są uruchomione określonej aplikacji, użyj <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Jeśli istnieje wiele procesów na komputerze z uruchomionym określonej aplikacji <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> zwraca tablicę zawierającą skojarzonych z nimi procesów. Można zbadać każdego z tych procesów, które z kolei w nich własny identyfikator. Identyfikator procesu można wyświetlić w `Processes` panelu Menedżera zadań systemu Windows. `PID` Kolumny zawiera identyfikator procesu, który jest przypisany do procesu.  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o bieżącego procesu procesów uruchomionych na komputerze lokalnym, wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera ona następnie informacje dla tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony proces <paramref name="processId" /> parametru nie jest uruchomiona. Identyfikator mógł wygasnąć.</exception>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony przez ten obiekt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">System Unikatowy identyfikator zasobu procesu.</param>
        <param name="machineName">Nazwa komputera w sieci.</param>
        <summary>Zwraca nowy <see cref="T:System.Diagnostics.Process" /> składnika podany identyfikator procesu i nazwę komputera w sieci.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> składnika, który jest skojarzony z procesu zdalnego zasobu identyfikowanego przez <paramref name="processId" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> składnika i powiązać ją z zasobem procesu na komputerze zdalnym w sieci. Proces zasobów musi już istnieć na określonym komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> nie tworzy zasób systemowy, ale raczej kojarzy zasobu z wygenerowanymi <xref:System.Diagnostics.Process> składnika. Proces <xref:System.Diagnostics.Process.Id%2A> można pobrać tylko dla procesu, który obecnie jest uruchomiona na komputerze. Po kończy proces, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> zgłasza wyjątek w przypadku przekazania wygasłe identyfikator.  
  
 Na dowolnym komputerze z konkretnym identyfikator procesu jest unikatowa. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Zwraca co najwyżej jeden proces. Jeśli chcesz pobrać wszystkie procesy, które są uruchomione określonej aplikacji, użyj <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Jeśli istnieje wiele procesów na komputerze z uruchomionym określonej aplikacji <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> zwraca tablicę zawierającą skojarzonych z nimi procesów. Można zbadać każdego z tych procesów, które z kolei w nich własny identyfikator. Identyfikator procesu można wyświetlić w `Processes` panelu Menedżera zadań systemu Windows. `PID` Kolumny zawiera identyfikator procesu, który jest przypisany do procesu.  
  
 Jeśli nie określisz `machineName`, używany jest komputer lokalny. Można również określić komputer lokalny, ustawiając `machineName` na wartość "." lub ciąg pusty ("").  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o bieżącego procesu procesów uruchomionych na komputerze lokalnym, wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera ona następnie informacje dla tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony proces <paramref name="processId" /> parametru nie jest uruchomiona. Identyfikator mógł wygasnąć.  - lub - <paramref name="machineName" /> składnia parametru jest nieprawidłowa. Nazwa może mieć długość zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony przez ten obiekt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i skojarzyć je z istniejącymi zasobami procesu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Diagnostics.Process" /> składnika dla każdego zasobu procesu na komputerze lokalnym.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący wszystkie zasoby procesu uruchomionego na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je z wszystkimi zasobami procesu na komputerze lokalnym. Proces zasobów musi już istnieć na komputerze lokalnym, ponieważ <xref:System.Diagnostics.Process.GetProcesses%2A> nie tworzy zasobów systemowych, ale raczej kojarzy zasobów z wygenerowanymi <xref:System.Diagnostics.Process> składników. Ponieważ system operacyjny jest uruchomione procesy w tle, ta tablica nigdy nie jest pusta.  
  
 Jeśli nie chcesz pobrać wszystkich procesów uruchomionych na komputerze, można ograniczyć ich liczbę za pomocą <xref:System.Diagnostics.Process.GetProcessById%2A> lub <xref:System.Diagnostics.Process.GetProcessesByName%2A> metody. <xref:System.Diagnostics.Process.GetProcessById%2A> Tworzy <xref:System.Diagnostics.Process> składnik, który jest skojarzony z procesem oznaczona identyfikatora procesu, który jest przekazywany do metody w systemie. <xref:System.Diagnostics.Process.GetProcessesByName%2A> tworzy tablicę <xref:System.Diagnostics.Process> składniki, których zasoby skojarzony proces udział pliku wykonywalnego przekazać do metody.  
  
> [!NOTE]
>  Wiele usług systemu Windows mogą być ładowane w ramach tego samego wystąpienia procesu hosta usługi (svchost.exe). GetProcesses nie będzie rozpoznawał tych poszczególnych usług; w tym temacie <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o bieżącego procesu procesów uruchomionych na komputerze lokalnym, wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera ona następnie informacje dla tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, z którego można odczytać listy procesów.</param>
        <summary>Tworzy nową <see cref="T:System.Diagnostics.Process" /> składnika dla każdego zasobu procesu na określonym komputerze.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący wszystkie zasoby procesu uruchamiania na określonym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je z wszystkimi zasobami procesu na określonym komputerze (zazwyczaj zdalnego). Proces zasobów musi już istnieć na komputerze lokalnym, ponieważ <xref:System.Diagnostics.Process.GetProcesses%2A> nie tworzy zasobów systemowych, ale raczej kojarzy zasobów z wygenerowanymi <xref:System.Diagnostics.Process> składników. Ponieważ system operacyjny jest uruchomione procesy w tle, ta tablica nigdy nie jest pusta.  
  
 Jeśli nie chcesz pobrać wszystkich procesów uruchomionych na komputerze, można ograniczyć ich liczbę za pomocą <xref:System.Diagnostics.Process.GetProcessById%2A> lub <xref:System.Diagnostics.Process.GetProcessesByName%2A> metody. <xref:System.Diagnostics.Process.GetProcessById%2A> Tworzy <xref:System.Diagnostics.Process> składnik, który jest skojarzony z procesem oznaczona identyfikatora procesu, który jest przekazywany do metody w systemie. <xref:System.Diagnostics.Process.GetProcessesByName%2A> tworzy tablicę <xref:System.Diagnostics.Process> składniki, których zasoby skojarzony proces udział pliku wykonywalnego przekazać do metody.  
  
 To przeciążenie metody <xref:System.Diagnostics.Process.GetProcesses%2A> — metoda jest zazwyczaj używane do pobierania listy zasobów proces uruchomiony na komputerze zdalnym w sieci, ale można określić komputer lokalny, przekazując ".".  
  
> [!NOTE]
>  Wiele usług systemu Windows mogą być ładowane w ramach tego samego wystąpienia procesu hosta usługi (svchost.exe). GetProcesses nie będzie rozpoznawał tych poszczególnych usług; w tym temacie <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o bieżącego procesu procesów uruchomionych na komputerze lokalnym, wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera ona następnie informacje dla tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Składnia parametru jest nieprawidłowa. Może mieć długości zerowej (0).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma systemu operacyjnego nie obsługuje tej operacji na komputerach zdalnych.</exception>
        <exception cref="T:System.InvalidOperationException">Wystąpiły problemy podczas uzyskiwania dostępu do interfejsu API używany do pobierania informacji o procesie licznik wydajności. Ten wyjątek dotyczy systemu Windows NT, Windows 2000 i Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił problem podczas uzyskiwania dostępu do interfejsu API z systemu źródłowego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i skojarzyć je z istniejącymi zasobami procesu, aby udostępnić wszystkie podana nazwa procesu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Przyjazna nazwa procesu.</param>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i skojarzyć je z wszystkimi zasobami procesu na komputerze lokalnym mających podana nazwa procesu.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący zasoby procesu uruchomienie określonej aplikacji lub pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je z wszystkimi zasobami procesów uruchomionych na tym samym pliku wykonywalnego na komputerze lokalnym. Proces zasobów musi już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessesByName%2A> nie tworzy zasobów systemowych, ale raczej kojarzy je z wygenerowanymi <xref:System.Diagnostics.Process> składników. A `processName` można określić dla pliku wykonywalnego, który nie jest obecnie uruchomiona na komputerze lokalnym, metoda zwraca tablicy nie może być puste.  
  
 Nazwa procesu jest przyjazną nazwę dla procesu, takich jak Outlook, który nie ma rozszerzenia .exe lub ścieżki. <xref:System.Diagnostics.Process.GetProcessesByName%2A> jest przydatne do pobierania i operowanie nimi wszystkie procesy, które są skojarzone z tym samym pliku wykonywalnego. Na przykład można przekazać jako nazwa pliku wykonywalnego `processName` parametr, aby zamknąć wszystkie uruchomione wystąpienia tego pliku wykonywalnego.  
  
 Chociaż proces <xref:System.Diagnostics.Process.Id%2A> jest unikatowy zasób jednego procesu w systemie, wiele procesów na komputerze lokalnym może być uruchomiony aplikacji określonej przez `processName` parametru. W związku z tym <xref:System.Diagnostics.Process.GetProcessById%2A> zwraca co najwyżej jeden proces, ale <xref:System.Diagnostics.Process.GetProcessesByName%2A> zwraca tablicę zawierającą skojarzonych z nimi procesów. Jeśli potrzebujesz do manipulowania procesu przy użyciu standardowych wywołań interfejsu API, można zbadać każdego z tych procesów, które z kolei w nich własny identyfikator. Nie można uzyskać dostęp do zasobów proces, za pomocą samej nazwy procesu, ale po pobraniu tablicę <xref:System.Diagnostics.Process> składników, które zostały skojarzone z zasobami procesu można uruchomić, przerwanie i inaczej manipulowania zasobów systemowych.  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o bieżącego procesu procesów uruchomionych na komputerze lokalnym, wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera ona następnie informacje dla tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpiły problemy podczas uzyskiwania dostępu do interfejsu API używany do pobierania informacji o procesie licznik wydajności. Ten wyjątek dotyczy systemu Windows NT, Windows 2000 i Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Przyjazna nazwa procesu.</param>
        <param name="machineName">Nazwa komputera w sieci.</param>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i skojarzyć je z wszystkimi zasobami procesu na komputerze zdalnym mających podana nazwa procesu.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący zasoby procesu uruchomienie określonej aplikacji lub pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je z wszystkimi zasobami procesów uruchomionych na tym samym pliku wykonywalnego na określonym komputerze. Proces zasobów musi już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessesByName%2A> nie tworzy zasobów systemowych, ale raczej kojarzy je z wygenerowanymi <xref:System.Diagnostics.Process> składników. A `processName` można określić dla pliku wykonywalnego, który nie jest obecnie uruchomiona na komputerze lokalnym, metoda zwraca tablicy nie może być puste.  
  
 Nazwa procesu jest przyjazną nazwę dla procesu, takich jak Outlook, który nie ma rozszerzenia .exe lub ścieżki. <xref:System.Diagnostics.Process.GetProcessesByName%2A> jest przydatne do pobierania i operowanie nimi wszystkie procesy, które są skojarzone z tym samym pliku wykonywalnego. Na przykład można przekazać jako nazwa pliku wykonywalnego `processName` parametr, aby zamknąć wszystkie uruchomione wystąpienia tego pliku wykonywalnego.  
  
 Chociaż proces <xref:System.Diagnostics.Process.Id%2A> jest unikatowy zasób jednego procesu w systemie, wiele procesów na komputerze lokalnym może być uruchomiony aplikacji określonej przez `processName` parametru. W związku z tym <xref:System.Diagnostics.Process.GetProcessById%2A> zwraca co najwyżej jeden proces, ale <xref:System.Diagnostics.Process.GetProcessesByName%2A> zwraca tablicę zawierającą skojarzonych z nimi procesów. Jeśli potrzebujesz do manipulowania procesu przy użyciu standardowych wywołań interfejsu API, można zbadać każdego z tych procesów, które z kolei w nich własny identyfikator. Nie można uzyskać dostęp do zasobów proces, za pomocą samej nazwy procesu, ale po pobraniu tablicę <xref:System.Diagnostics.Process> składników, które zostały skojarzone z zasobami procesu można uruchomić, przerwanie i inaczej manipulowania zasobów systemowych.  
  
 To przeciążenie umożliwia pobrać procesów na komputerze lokalnym, a także na komputerze zdalnym. Użyj ".", aby określić komputer lokalny. Istnieje innego przeciążenia, która domyślnie używa komputera lokalnego.  
  
 Można uzyskać dostępu do procesów na komputerach zdalnych jedynie, aby wyświetlić informacje, takie jak statystyki dotyczące procesów. Nie można zamknąć, zakończenie (przy użyciu <xref:System.Diagnostics.Process.Kill%2A>), lub uruchamiania procesów na komputerach zdalnych.  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o bieżącego procesu procesów uruchomionych na komputerze lokalnym, wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera ona następnie informacje dla tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Składnia parametru jest nieprawidłowa. Może mieć długości zerowej (0).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma systemu operacyjnego nie obsługuje tej operacji na komputerach zdalnych.</exception>
        <exception cref="T:System.InvalidOperationException">Wystąpiły problemy podczas uzyskiwania dostępu do interfejsu API używany do pobierania informacji o procesie licznik wydajności. Ten wyjątek dotyczy systemu Windows NT, Windows 2000 i Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił problem podczas uzyskiwania dostępu do interfejsu API z systemu źródłowego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty skojarzonego procesu.</summary>
        <value>Dojście systemu operacyjnego przypisana do skojarzonego procesu w momencie uruchomienia procesu. System używa tego dojścia do śledzenia procesu atrybutów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikację można uzyskać dojścia do procesu, który może służyć jako parametr wiele funkcji informacji o procesie i kontroli. Przy użyciu tego uchwytu zainicjować <xref:System.Threading.WaitHandle> lub wywołać metod natywnych z platformą wywołanie.  
  
 Ta dojścia procesu jest prywatne do aplikacji — innymi słowy, proces, który nie może być współużytkowana uchwytów. Proces ma również proces <xref:System.Diagnostics.Process.Id%2A> które, w przeciwieństwie do <xref:System.Diagnostics.Process.Handle%2A>, jest unikatowa i w związku z tym prawidłowy w całym systemie.  
  
 Tylko procesy uruchomione przez wywołanie <xref:System.Diagnostics.Process.Start%2A> ustawić <xref:System.Diagnostics.Process.Handle%2A> właściwości odpowiadającego <xref:System.Diagnostics.Process> wystąpień.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony lub został zakończony. <see cref="P:System.Diagnostics.Process.Handle" /> Nie można odczytać właściwości, ponieważ nie ma żadnych procesów skojarzonych z tym <see cref="T:System.Diagnostics.Process" /> wystąpienia.  - lub - <see cref="T:System.Diagnostics.Process" /> wystąpienia została dołączona do uruchomionego procesu, ale nie masz wystarczających uprawnień do uzyskania dojścia z pełnych praw dostępu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.Handle" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczba dojść otwartych przez proces.</summary>
        <value>Liczba dojść systemu operacyjnego, który otworzył procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty umożliwiają proces odwoływać się do obiektów. Proces można uzyskać dojścia do plików, zasobów, kolejki komunikatów i wiele innych obiektów systemu operacyjnego. System operacyjny zwraca pamięci skojarzonych z procesem tylko wtedy, gdy liczba dojścia wynosi zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy skojarzony proces został zakończony.</summary>
        <value>
          <see langword="true" /> Jeśli proces systemu operacyjnego odwołuje <see cref="T:System.Diagnostics.Process" /> składnik został zakończony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `true` dla <xref:System.Diagnostics.Process.HasExited%2A> wskazuje, czy skojarzony proces został zakończony, zwykle lub nieprawidłowo. Można zażądać lub wymusić zakończenie wywołując skojarzonego procesu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Jeśli dojścia jest otwarty do procesu, system operacyjny zwalnia pamięć procesu, gdy proces został zakończony, ale zachowuje administracyjne informacji na temat procesu, taką jak uchwytu, kod zakończenia i czas zakończenia. Aby uzyskać te informacje, można użyć <xref:System.Diagnostics.Process.ExitCode%2A> i <xref:System.Diagnostics.Process.ExitTime%2A> właściwości. Te właściwości są wypełniane automatycznie dla procesów, które zostały uruchomione przez tego składnika. Informacje administracyjne zwolnieniu podczas wszystkich <xref:System.Diagnostics.Process> składników, które są skojarzone z procesu systemu zostaną zniszczone i przytrzymaj ma więcej dojść do procesu zakończone.  
  
 Proces może zakończyć niezależnie od kodu. Jeśli rozpoczęto proces przy użyciu tego składnika, system aktualizuje wartość <xref:System.Diagnostics.Process.HasExited%2A> automatycznie, nawet wtedy, gdy skojarzony proces zostanie zakończony niezależnie.  
  
> [!NOTE]
>  Gdy wyjścia standardowego został przekierowany do obsługi zdarzeń asynchroniczne, jest to możliwe, że przetwarzanie danych wyjściowych nie będzie została ukończona, gdy ta właściwość zwraca `true`. Aby zakończenie obsługi zdarzenia asynchroniczne, wywołaj <xref:System.Diagnostics.Process.WaitForExit> przeciążenia, które przyjmuje żadnego parametru przed zaewidencjonowaniem <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Pobiera następnie użycie pamięci fizycznej przez skojarzony proces odstępach drugi 2 maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma żadnych procesów, skojarzony z obiektem.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać kodu zakończenia procesu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.HasExited" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator skojarzonego procesu.</summary>
        <value>Wygenerowana przez system Unikatowy identyfikator procesu, który odwołuje się do niego to <see cref="T:System.Diagnostics.Process" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proces <xref:System.Diagnostics.Process.Id%2A> jest nieprawidłowy w przypadku skojarzonego procesu nie jest uruchomiona. Dlatego należy upewnić się, że proces jest uruchomiony przed próbą pobrania <xref:System.Diagnostics.Process.Id%2A> właściwości. Aż do zakończenia procesu, identyfikator procesu jest unikatowym identyfikatorem procesu w systemie.  
  
 Możesz połączyć procesu, który jest uruchomiony na komputerze lokalnym lub zdalnym na nowy <xref:System.Diagnostics.Process> wystąpienia przez przekazanie identyfikator procesu, aby <xref:System.Diagnostics.Process.GetProcessById%2A> metody. <xref:System.Diagnostics.Process.GetProcessById%2A> jest `static` metodę, która tworzy nowy składnik i ustawia <xref:System.Diagnostics.Process.Id%2A> właściwości dla nowego <xref:System.Diagnostics.Process> wystąpienia automatycznie.  
  
 Identyfikatory procesu mogą być ponownie używane przez system. <xref:System.Diagnostics.Process.Id%2A> Wartość właściwości jest unikatowy tylko wtedy, gdy skojarzony proces jest uruchomiony. Po zakończeniu procesu, można użyć ponownie system <xref:System.Diagnostics.Process.Id%2A> wartości właściwości dla procesu niepowiązanych.  
  
 Identyfikator jest unikatowy w systemie, można przekazać go do innych wątków zamiast przekazywanie <xref:System.Diagnostics.Process> wystąpienia. Ta akcja może zapisać zasobów systemowych jeszcze gwarantuje, że proces jest poprawnie zidentyfikowane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób uzyskiwania <xref:System.Diagnostics.Process.Id%2A> wszystkie uruchomione wystąpienia aplikacji. Kod tworzy nowe wystąpienie programu Notatnik, wyświetlane są wszystkie wystąpienia Notatnika, a następnie umożliwia użytkownikowi wprowadzenie <xref:System.Diagnostics.Process.Id%2A> numer, aby usunąć określonego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie ustawiono właściwości.  - lub - nie ma żadnych procesów skojarzonych z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Natychmiastowe zatrzymanie skojarzonego procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Wymusza przerwanie procesu, gdy <xref:System.Diagnostics.Process.CloseMainWindow%2A> tylko żądań przerwanie. Podczas wykonywania procesu z interfejsem graficznym jego Pętla wiadomości jest w stanie oczekiwania. Pętla wiadomości jest wykonywana za każdym razem, gdy komunikatów systemu Windows są wysyłane do procesu przez system operacyjny. Wywoływanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> wysyła żądanie bliski głównego okna, które w poprawnie sformułowanym aplikacji, zamyka okno podrzędne i wycofanie wszystkich uruchomionych pętli komunikatów dla aplikacji. Żądanie, aby zakończyć proces przez wywołanie metody <xref:System.Diagnostics.Process.CloseMainWindow%2A> wymusza na aplikacji, aby zakończyć. Aplikacja może poprosić o weryfikacji użytkownika przed zamknięciem lub go odmówić zakończyć. Aby wymusić zakończenie aplikacji, użyj <xref:System.Diagnostics.Process.Kill%2A> metody. Zachowanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> jest identyczna jak użytkownik zamknięcie okna głównego aplikacji przy użyciu menu systemowego. W związku z tym żądaniu, aby zakończyć proces przez zamknięcie okna głównego nie wymusza aplikacji, aby natychmiast zamknąć.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A> Metoda wykonuje asynchronicznie. Po wywołaniu <xref:System.Diagnostics.Process.Kill%2A> metody, wywołaj <xref:System.Diagnostics.Process.WaitForExit%2A> metody oczekiwania procesu zamknąć lub sprawdź <xref:System.Diagnostics.Process.HasExited%2A> właściwości w celu określenia, czy Proces został zakończony.  
  
 Dane edytowane przez proces lub zasoby przydzielone do procesu mogą zostać utracone jeśli wywołujesz <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> powoduje, że po zakończeniu procesu nietypowe i powinna być używana tylko wtedy, gdy jest to konieczne. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Włącza uporządkowany zakończenie procesu i zamknięcie wszystkich okien, dlatego zaleca się dla aplikacji z interfejsem. Jeśli <xref:System.Diagnostics.Process.CloseMainWindow%2A> kończy się niepowodzeniem, można użyć <xref:System.Diagnostics.Process.Kill%2A> zakończenie procesu. <xref:System.Diagnostics.Process.Kill%2A> jest jedynym sposobem, aby zakończyć procesy, które nie mają graficzne interfejsy.  
  
 Możesz wywołać <xref:System.Diagnostics.Process.Kill%2A> i <xref:System.Diagnostics.Process.CloseMainWindow%2A> tylko dla procesów uruchomionych na komputerze lokalnym. Nie można spowodować procesów na komputerach zdalnych, aby zakończyć. Mogą wyświetlać tylko informacje dla procesów uruchomionych na komputerach zdalnych.  
  
> [!NOTE]
>  Jeśli wywołanie <xref:System.Diagnostics.Process.Kill%2A> metody staje się podczas obecnie Trwa przerywanie procesu <xref:System.ComponentModel.Win32Exception> jest zgłaszany w przypadku odmowy dostępu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można przerwać skojarzonego procesu.  - lub - Trwa przerywanie procesu.  - lub - wykonywalny Win16 jest skojarzony proces.</exception>
        <exception cref="T:System.NotSupportedException">Próba wywołania <see cref="M:System.Diagnostics.Process.Kill" /> dla procesu, który jest uruchomiony na komputerze zdalnym. Metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został już zakończony.  - lub - nie ma żadnych procesów skojarzonych z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Trwa <see cref="T:System.Diagnostics.Process" /> składnika stanu, który umożliwia mu interakcję z procesami systemu operacyjnego, które są uruchamiane w specjalnym trybie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre procesy systemu operacyjnego są uruchamiane w specjalnym trybie. Nie jest możliwe próby odczytu właściwości lub Dołącz do tych procesów, chyba że wywołano <xref:System.Diagnostics.Process.EnterDebugMode%2A> dla składnika. Wywołanie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> gdy nie jest już potrzebny dostęp do tych procesów, które są uruchamiane w specjalnym trybie.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę komputera, na którym uruchomiono skojarzony proces.</summary>
        <value>Nazwa komputera, na którym uruchomiono skojarzony proces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mogą wyświetlać dane statystyczne i informacji o procesie dla procesów uruchomionych na komputerach zdalnych, ale nie można wywołać <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, lub <xref:System.Diagnostics.Process.Kill%2A> na komputerach zdalnych.  
  
> [!NOTE]
>  Gdy skojarzony proces jest wykonywany na komputerze lokalnym, ta właściwość zwraca kropką (".") dla nazwy komputera. Należy używać <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości można uzyskać nazwy poprawny.  
  
   
  
## Examples  
 Aby użyć poniższy przykład, że należy najpierw uruchomić co najmniej jedno wystąpienie programu Notatnik na komputerze zdalnym. Przykład wymaga podania nazwy komputera zdalnego, na którym jest uruchomiony program Notatnik, a następnie wyświetla odpowiednich <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, i <xref:System.Diagnostics.Process.MachineName%2A> właściwości dla każdego wystąpienia.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma żadnych procesów skojarzonych z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł główny skojarzonego procesu.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessModule" /> Użytego do uruchomienia procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł procesu reprezentuje plik a.dll lub .exe, który jest ładowany do określonego procesu. <xref:System.Diagnostics.Process.MainModule%2A> Właściwości umożliwia wyświetlanie informacji o pliku wykonywalnego, używana do rozpoczęcia procesu, łącznie z nazwą modułu, nazwa pliku i szczegółów pamięci modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.MainModule" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Proces 32-bitowy próbuje uzyskać dostępu do modułów procesu 64-bitowego.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  - lub - proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwytu okna głównego okna skojarzonego procesu.</summary>
        <value>Uchwyt okna generowanych przez system w głównym oknie skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Główne okno jest oknem otwarty przez proces, który aktualnie ma fokus ( <xref:System.Windows.Forms.Form.TopLevel%2A> formularza). Należy użyć <xref:System.Diagnostics.Process.Refresh%2A> metodę, aby odświeżyć <xref:System.Diagnostics.Process> obiektu można pobrać bieżącego uchwytu okna głównego, jeśli została ona zmieniona. Ogólnie rzecz biorąc, ponieważ uchwytu okna są buforowane, użyj <xref:System.Diagnostics.Process.Refresh%2A> uprzednio, aby zagwarantować, że będzie pobrać dojścia bieżącej.  
  
 Możesz uzyskać <xref:System.Diagnostics.Process.MainWindowHandle%2A> właściwość tylko dla procesów uruchomionych na komputerze lokalnym. <xref:System.Diagnostics.Process.MainWindowHandle%2A> Właściwość ma wartość, która unikatowo identyfikuje okna, który jest skojarzony z procesem.  
  
 Proces ma okno główne skojarzonych z nim tylko wtedy, gdy proces interfejsu graficznego. Jeśli skojarzony proces nie ma okno główne, <xref:System.Diagnostics.Process.MainWindowHandle%2A> wartość jest równa zero. Wartość jest także zero dla procesów, które zostały ukryte, czyli procesów, które nie są widoczne na pasku zadań. Ma to miejsce w przypadku procesów, które są wyświetlane jako ikony w obszarze powiadomień na prawym końcu paska zadań.  
  
 Jeśli właśnie uruchomiono proces i chcesz użyć uchwytu okna głównego, należy rozważyć użycie <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodę umożliwiającą proces zakończy się uruchamianie, zapewniając, że utworzono uchwyt głównego okna. W przeciwnym razie zostanie wygenerowany wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> Nie jest zdefiniowana, ponieważ proces został zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podpis głównego okna procesu.</summary>
        <value>Tytuł głównego okna procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proces ma okno główne skojarzonych z nim tylko wtedy, gdy proces interfejsu graficznego. Jeśli skojarzony proces nie ma głównego okna (dzięki czemu <xref:System.Diagnostics.Process.MainWindowHandle%2A> wynosi zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> to ciąg pusty (""). Jeśli właśnie uruchomiono proces i chcesz użyć jego tytuł okna głównego, należy rozważyć użycie <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodę umożliwiającą proces zakończy się uruchamianie, zapewniając, że utworzono uchwyt głównego okna. W przeciwnym razie system zgłasza wyjątek.  
  
> [!NOTE]
>  Główne okno jest oknem, który aktualnie ma fokus; należy pamiętać, że nie może to być podstawowy okna procesu. Należy użyć <xref:System.Diagnostics.Process.Refresh%2A> metodę, aby odświeżyć <xref:System.Diagnostics.Process> obiektu można pobrać bieżącego uchwytu okna głównego, jeśli została ona zmieniona.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik i pobiera podpis głównego okna procesu.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> Właściwość nie została zdefiniowana, ponieważ proces został zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny dopuszczalny rozmiar zestawu roboczego, w bajtach skojarzonego procesu.</summary>
        <value>Maksymalny rozmiar zestawu roboczego jest dozwolony w pamięci dla procesu, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu to zbiór stron pamięci widocznych aktualnie przez proces w pamięci fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, aby użyć bez wyzwalania błąd strony.  
  
 Zestaw roboczy zawiera dane zarówno udostępnionego, jak i prywatnych. Udostępnionych danych obejmuje stron, które zawierają instrukcje, które wykonuje aplikacji, takich jak strony plików dll i pliki system.dll. Jak zwiększania rozmiaru zestawu roboczego, zwiększa to żądanie pamięci.  
  
 Proces ma rozmiary zestaw roboczy minimalną i maksymalną. Zawsze, gdy jest tworzony zasób procesu, system rezerwuje ilość pamięci równy minimalny rozmiar zestawu roboczego dla procesu. Menedżer pamięci wirtualnej próbuje zachować co najmniej minimalną ilość pamięci rezydentnego podczas procesu jest aktywny, ale zachowuje nigdy nie przekracza maksymalny rozmiar.  
  
 System ustawia domyślny rozmiary zestaw roboczy. Możesz zmodyfikować te rozmiary przy użyciu <xref:System.Diagnostics.Process.MaxWorkingSet%2A> i <xref:System.Diagnostics.Process.MinWorkingSet%2A> elementów członkowskich. Jednak ustawienie tych wartości nie gwarantuje, że pamięć będzie zarezerwowany lub znajdują się.  
  
> [!NOTE]
>  Wraz ze zwiększeniem rozmiaru zestawu roboczego procesu, należy wykonać pamięci fizycznej w kierunku od pozostałej części systemu. Upewnij się, że żądanie nie rozmiar zestawu roboczego minimalnej lub maksymalnej, która jest zbyt duży, ponieważ może to zmniejszyć wydajność systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Maksymalny rozmiar zestawu roboczego jest nieprawidłowy. Go musi być większa lub równa minimalny rozmiar zestawu roboczego.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać pracy Ustawianie informacji z zasobów skojarzonego procesu.  - lub - identyfikatora procesu lub uchwytu procesu wynosi zero, ponieważ proces nie został uruchomiony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  - lub - proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia minimalną dopuszczalny rozmiar zestawu roboczego, w bajtach skojarzonego procesu.</summary>
        <value>Minimalna pracy Ustaw rozmiar, który jest wymagany w pamięci dla procesu, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu to zbiór stron pamięci widocznych aktualnie przez proces w pamięci fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, aby użyć bez wyzwalania błąd strony.  
  
 Zestaw roboczy zawiera dane zarówno udostępnionego, jak i prywatnych. Udostępnionych danych obejmuje stron, które zawierają instrukcje, które wykonuje aplikacji, takich jak strony plików dll i pliki system.dll. Jak zwiększania rozmiaru zestawu roboczego, zwiększa to żądanie pamięci.  
  
 Proces ma rozmiary zestaw roboczy minimalną i maksymalną. Zawsze, gdy jest tworzony zasób procesu, system rezerwuje ilość pamięci równy minimalny rozmiar zestawu roboczego dla procesu. Menedżer pamięci wirtualnej próbuje zachować co najmniej minimalną ilość pamięci rezydentnego podczas procesu jest aktywny, ale zachowuje nigdy nie przekracza maksymalny rozmiar.  
  
 System ustawia domyślny rozmiary zestaw roboczy. Możesz zmodyfikować te rozmiary przy użyciu <xref:System.Diagnostics.Process.MaxWorkingSet%2A> i <xref:System.Diagnostics.Process.MinWorkingSet%2A> elementów członkowskich. Jednak ustawienie tych wartości nie gwarantuje, że pamięć będzie zarezerwowany lub znajdują się.  
  
> [!NOTE]
>  Wraz ze zwiększeniem rozmiaru zestawu roboczego procesu, należy wykonać pamięci fizycznej w kierunku od pozostałej części systemu. Upewnij się, że żądanie nie rozmiar zestawu roboczego minimalnej lub maksymalnej, która jest zbyt duży, ponieważ może to zmniejszyć wydajność systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Minimalny rozmiar zestawu roboczego jest nieprawidłowy. Musi być większa niż maksymalny rozmiar zestawu roboczego.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać pracy Ustawianie informacji z zasobów skojarzonego procesu.  - lub - identyfikatora procesu lub uchwytu procesu wynosi zero, ponieważ proces nie został uruchomiony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp do <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  - lub - proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduły, które zostały załadowane przez skojarzony proces.</summary>
        <value>Tablica typu <see cref="T:System.Diagnostics.ProcessModule" /> reprezentujący modułów, które zostały załadowane przez skojarzony proces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł procesu reprezentuje plik a.dll lub .exe, który jest ładowany do określonego procesu. A <xref:System.Diagnostics.ProcessModule> wystąpienia umożliwia wyświetlanie informacji o module, łącznie z nazwą modułu, nazwa pliku i szczegółów pamięci modułu.  
  
 Proces można załadować wiele modułów do pamięci. Na przykład pliki .exe, które ładują plików dll dodatkowe mieć wiele modułów.  
  
 Po rozpoczęciu procesu, ta kolekcja jest pusta, dopóki proces załadował systemu. Jeśli proces okno główne, można wywołać <xref:System.Diagnostics.Process.WaitForInputIdle%2A> przed pobraniem tej właściwości, aby upewnić się, czy kolekcja jest niepusty gdy można pobrać listy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Modules" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Modules" /> właściwość procesu lub proces bezczynny. Te procesy nie mają modułów.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci systemowej niestronicowanej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach skojarzonego procesu, który nie można zapisać w pliku stronicowania pamięci wirtualnej przydzielonej systemu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci systemowej niestronicowanej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci systemowej w bajtach przydzielone skojarzonego procesu, który nie można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci systemowej niestronicowanej używanej przez proces w bajtach. Ilość pamięci w systemie jest pamięci fizycznej używanej przez system operacyjny i jest podzielony na puli stronicowanej i niestronicowanej. Alokacje pamięci niestronicowanej pozostawać w pamięci i nie są stronicowany pliku stronicowania pamięci wirtualnej.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **puli niestronicowanej** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza <see cref="E:System.Diagnostics.Process.Exited" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> Metoda interfejsu API, która wywołuje <xref:System.Diagnostics.Process.Exited> zdarzeń. Wywoływanie <xref:System.Diagnostics.Process.OnExited%2A> powoduje, że <xref:System.Diagnostics.Process.Exited> zdarzenia i jest jedynym sposobem, aby zgłosić zdarzenie, przy użyciu <xref:System.Diagnostics.Process> składnika. <xref:System.Diagnostics.Process.OnExited%2A> jest używany głównie podczas tworzenia klasy pochodnej klasy ze składnika.  
  
 Alternatywą wobec <xref:System.Diagnostics.Process.OnExited%2A>, można napisać obsługi zdarzenia. Możesz utworzyć własne delegata obsługi zdarzeń i własnej metody obsługi zdarzeń.  
  
> [!NOTE]
>  Jeśli używasz środowiska Visual Studio delegata obsługi zdarzeń (AddOnExited) i metody obsługi zdarzeń (Process1_Exited) są tworzone automatycznie podczas przeciągania <xref:System.Diagnostics.Process> składnika w formularzu i kliknij dwukrotnie ikonę. Kod można utworzyć w celu uruchomienia podczas <xref:System.Diagnostics.Process.Exited> jest wprowadzany do procedury Process1_Exited wystąpi zdarzenie. Nie trzeba tworzyć <xref:System.Diagnostics.Process.OnExited%2A> elementu członkowskiego, ponieważ jest zaimplementowany dla Ciebie.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Diagnostics.Process.OnExited%2A> metody w klasie pochodnej.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zawsze aplikacja zapisuje wiersz do jego przekierowanego <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> Zdarzenie oznacza, że skojarzone <xref:System.Diagnostics.Process> został zapisany linii kończące się znakiem nowego wiersza, do jego przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
 Zdarzenie jest włączona podczas asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A>. Aby uruchomić asynchronicznych operacji odczytu, należy kierować <xref:System.Diagnostics.Process.StandardOutput%2A> strumień <xref:System.Diagnostics.Process>, dodać obsługi zdarzenia do <xref:System.Diagnostics.Process.OutputDataReceived> zdarzeń i wywołania <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Później <xref:System.Diagnostics.Process.OutputDataReceived> sygnały zdarzeń zawsze proces zapisuje linię przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, dopóki proces kończy działanie lub wywołuje <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Aplikacja, która jest przetwarzania asynchronicznego dane wyjściowe powinny wywoływać <xref:System.Diagnostics.Process.WaitForExit%2A> metody, aby upewnić się, że zostały opróżnione buforu wyjściowego.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wykonywania asynchronicznych operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumień `ipconfig` polecenia.  
  
 W przykładzie jest tworzony delegata zdarzenia dla `OutputHandler` obsługi zdarzeń i kojarzy ją z <xref:System.Diagnostics.Process.OutputDataReceived> zdarzeń. Program obsługi zdarzeń odbiera wierszy tekstu z przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, formatuje tekst i zapisuje go w postaci ciągu wyjściowego później podane w oknie konsoli w tym przykładzie.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci stronicowanej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach przydzielone przez skojarzony proces, który można zapisać pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci stronicowanej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtów przydzielonych w pliku stronicowania pamięci wirtualnej skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci w pliku stronicowania pamięci wirtualnej, które są używane przez ten proces, w bajtach. System operacyjny używa pliku stronicowania pamięci wirtualnej w połączeniu z pamięci fizycznej do wirtualnej przestrzeni adresowej dla każdego procesu zarządzania. Gdy stronicowalnej pamięci nie jest używany, można przenieść pliku stronicowania pamięci wirtualnej na dysku. Aby uzyskać rozmiar pamięci używanej przez system operacyjny dla procesu, użyj <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> właściwości.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Licznik Bajty pliku stronicowania** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik, a następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość stronicowalnej pamięci systemowej, w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach skojarzonego procesu, który można zapisać pliku stronicowania pamięci wirtualnej przydzielonej systemu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość stronicowalnej pamięci systemowej, w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci systemowej w bajtach przydzielone skojarzonego procesu, który można zapisać pliku stronicowania pamięci wirtualnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę wartość właściwości reprezentuje stronicowalnej pamięci systemowej używany przez proces w bajtach bieżący rozmiar. Ilość pamięci w systemie jest pamięci fizycznej używanej przez system operacyjny i jest podzielony na puli stronicowanej i niestronicowanej. Gdy stronicowalnej pamięci nie jest używany, można przenieść pliku stronicowania pamięci wirtualnej na dysku. Aby uzyskać rozmiar pamięci aplikacji używanej przez proces, użyj <xref:System.Diagnostics.Process.PagedMemorySize64%2A> właściwości.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **puli stronicowanej** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci w pliku stronicowania pamięci wirtualnej w bajtach, używany przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci w bajtach przydzielone przez skojarzony proces, który może zapisać do pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci w pliku stronicowania pamięci wirtualnej w bajtach, używany przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci w bajtach, przydzielona w pliku stronicowania pamięci wirtualnej skojarzony proces od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę wartość właściwości reprezentuje maksymalny rozmiar pamięci w pliku stronicowania pamięci wirtualnej, które są używane przez proces od momentu jego uruchomienia, w bajtach. System operacyjny używa pliku stronicowania pamięci wirtualnej w połączeniu z pamięci fizycznej do wirtualnej przestrzeni adresowej dla każdego procesu zarządzania. Gdy stronicowalnej pamięci nie jest używany, można przenieść pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Bajty pliku stronicowania** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci wirtualnej w bajtach, używany przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci wirtualnej w bajtach, które zażądał skojarzonego procesu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci wirtualnej w bajtach, używany przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci wirtualnej w bajtach przydzielone skojarzony proces od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje maksymalny rozmiar pamięci wirtualnej używanych przez proces od momentu jego uruchomienia, w bajtach. System operacyjny mapuje wirtualnej przestrzeni adresowej dla każdego procesu załadowane do stron w pamięci fizycznej ani stron przechowywane w pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Maksimum bajtów wirtualnych** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szczytowy rozmiar zestawu roboczego skojarzonego procesu w bajtach.</summary>
        <value>Maksymalna ilość pamięci fizycznej, która skojarzonego procesu jest wymagana w całości w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu to zbiór stron pamięci widocznych aktualnie przez proces w pamięci fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, aby użyć bez wyzwalania błąd strony.  
  
 Zestaw roboczy zawiera dane zarówno udostępnionego, jak i prywatnych. Udostępnionych danych obejmuje stron, które zawierają instrukcje, które wykonuje proces, łącznie z modułami procesu i biblioteki systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci fizycznej w bajtach, używany przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci fizycznej w bajtach przydzielone skojarzony proces od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje maksymalny rozmiar używanych przez proces od momentu jego uruchomienia, w bajtach pamięć zestawu roboczego. Zestaw roboczy procesu to zbiór stron pamięci widocznych aktualnie przez proces w pamięci fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, aby użyć bez wyzwalania błąd strony.  
  
 Zestaw roboczy zawiera dane zarówno udostępnionego, jak i prywatnych. Udostępnionych danych obejmuje stron, które zawierają instrukcje, które wykonuje proces, łącznie z instrukcjami z modułów procesów i biblioteki systemu.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Maksimum bajtów zestawu roboczego** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy priorytet skojarzonego procesu tymczasowo powinien boosted przez system operacyjny, gdy główne okno ma fokus.</summary>
        <value>
          <see langword="true" /> Jeśli dynamiczne zwiększanie wyniku priorytetu procesu powinno mieć miejsce dla procesu, gdy jest zajęty ze stanu oczekiwania; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek jest uruchomiony w procesie, dla której priorytet ma jedną z wartości wyliczenia priorytet dynamiczny (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, lub <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), jest ona pobierana z stanu oczekiwania system tymczasowo zwiększa priorytet wątku. Ta akcja uniemożliwia inne procesy przerywania przetwarzania bieżącego wątku. <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Ustawienie ma wpływ na wszystkie istniejące wątki i wszystkie wątki następnie utworzone przez proces. Aby przywrócić normalne działanie, należy ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> właściwości `false`.  
  
> [!NOTE]
>  Zwiększanie wyniku zbyt wysoki priorytet może opróżnienia zasobów z podstawowych systemu operacyjnego i funkcji sieciowych, powoduje problemy z innymi zadaniami systemu operacyjnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać informacji zwiększanie wyniku priorytet z zasobu skojarzonego procesu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.  - lub - identyfikatora procesu lub uchwytu procesu wynosi zero. (Proces nie została uruchomiona.)</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ogólnej kategorii priorytet skojarzonego procesu.</summary>
        <value>Kategoria priorytet skojarzonego procesu, z którego <see cref="P:System.Diagnostics.Process.BasePriority" /> procesu jest obliczana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy priorytetu procesu obejmuje zakres poziomy priorytetu wątku. Uruchamiane są wątki o różnych priorytetach, które są uruchomione w procesie względem klasy priorytetu procesu. Win32 używa czterech klasy priorytetów z siedmiu poziomów podstawowy priorytet dla klasy. Te klasy priorytetu procesu są przechwytywane <xref:System.Diagnostics.ProcessPriorityClass> wyliczenia, która pozwala na wartość priorytetu procesu <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, lub <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Na podstawie czasu przez zwiększenie czas lub inne poziom podstawowy priorytet mogą zostać zmienione przez system operacyjny, gdy proces musi zostać wprowadzone przed innymi dostępu do procesora. Ponadto można ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Aby tymczasowo zwiększyć poziom priorytetu wątków, które miały stanu oczekiwania. Priorytet jest resetowany, gdy proces powróci do stanu oczekiwania.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Właściwości umożliwia wyświetlanie priorytetu początkowy, który jest przypisany do procesu. Jednakże, ponieważ jest tylko do odczytu, nie można użyć <xref:System.Diagnostics.Process.BasePriority%2A> właściwości można ustawić priorytetu procesu. Aby zmienić priorytet, użyj <xref:System.Diagnostics.Process.PriorityClass%2A> właściwość, która pobiera lub ustawia ogólnej kategorii priorytetu procesu.  
  
 Nie można wyświetlić klasy priorytetów monitora wydajności. W poniższej tabeli przedstawiono relacje między <xref:System.Diagnostics.Process.BasePriority%2A> i <xref:System.Diagnostics.Process.PriorityClass%2A> wartości.  
  
|BasePriority|Klasa priorytetu|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można ustawić ani pobrać z zasobu skojarzonego procesu informacji priorytetu procesu.  - lub - identyfikatora procesu lub uchwytu procesu wynosi zero. (Proces nie została uruchomiona.)</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PriorityClass" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ustawiono <see cref="P:System.Diagnostics.Process.PriorityClass" /> do <see langword="AboveNormal" /> lub <see langword="BelowNormal" /> podczas korzystania z systemu Windows 98 lub Windows Millennium Edition (Windows Me). Dla klasy priorytetów, względem tych platform nie obsługują tych wartości.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Klasy priorytetów nie można ustawić, ponieważ nie używa prawidłową wartość, zgodnie z definicją w <see cref="T:System.Diagnostics.ProcessPriorityClass" /> wyliczenia.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci prywatnej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Liczba bajtów przydzielonych przez skojarzony proces, która nie może być współużytkowana z innymi procesami.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci prywatnej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach przydzielone skojarzonego procesu, który nie może być współużytkowana z innymi procesami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci używanej przez proces w bajtach, które nie może być współużytkowana z innymi procesami.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Bajty prywatne** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas uprzywilejowany procesora dla tego procesu.</summary>
        <value>A <see cref="T:System.TimeSpan" /> który wskazuje czas spędzony proces uruchomiony kod wewnątrz rdzenia systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę procesu.</summary>
        <value>Nazwa, która system używa do identyfikacji procesów do użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> Właściwość przechowuje nazwa pliku wykonywalnego, takich jak Outlook, który nie ma rozszerzenia .exe lub ścieżki. Jest przydatne do pobierania i operowanie nimi wszystkie procesy, które są skojarzone z tym samym pliku wykonywalnego.  
  
> [!NOTE]
>  Na [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] systemów operacyjnych <xref:System.Diagnostics.Process.ProcessName%2A> właściwość może zostać obcięty do 15 znaków, jeśli nie można uzyskać informacji o module procesu.  
  
 Możesz wywołać <xref:System.Diagnostics.Process.GetProcessesByName%2A>, przekazanie jej nazwa pliku wykonywalnego, aby pobrać tablicę zawierającą co uruchomione wystąpienie na określonym komputerze. Ta tablica, na przykład umożliwia Zamknij wszystkie uruchomione wystąpienia pliku wykonywalnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie ma identyfikatora lub jest skojarzony żaden proces <see cref="T:System.Diagnostics.Process" />.  - lub - skojarzony proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <exception cref="T:System.NotSupportedException">Proces nie jest na tym komputerze.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia procesory, na których wątki tego procesu może zostać zaplanowane do uruchomienia.</summary>
        <value>Maska bitowa reprezentująca procesory, uruchamianych wątków w procesie skojarzone. Wartość domyślna zależy od liczby procesorów w komputerze. Wartość domyślna to 2 <sup>n</sup> -1, gdzie n to liczba procesorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W systemie Windows 2000 lub nowszego oraz wątku w procesie można migrować z procesora do procesora, za pomocą każdej migracji ponownego ładowania pamięci podręcznej procesora. Pod obciążeniem duże systemu określania, który procesor powinno być ono uruchomione konkretnym wątkiem może poprawić wydajność dzięki zmniejszeniu liczby powtórzeń załadowaniu pamięci podręcznej procesora. Skojarzenie między procesorów i wątku jest wywoływana koligacji procesora.  
  
 Każdemu procesorowi jest reprezentowany jako nieco. Bit 0 jest procesora, co, bit 1 jest procesora dwa i tak dalej. Jeśli ustawisz wartość 1 nieco odpowiedniego procesora został wybrany do przypisania wątku. Podczas ustawiania <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartość zero, system operacyjny do planowania algorytmów zestaw koligacji wątku. Gdy <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartość jest ustawiona na dowolną wartość niezerową, wartość jest interpretowana jako maską bitów określa tych kwalifikuje się do wyboru procesorów.  
  
 W poniższej tabeli przedstawiono wyboru <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartości system ośmiu procesora.  
  
|Maska bitowa|Wartość binarna|Kwalifikujące się procesorów|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 i 2|  
|0x0007|00000000 00000111|1, 2 i 3|  
|0x0009|00000000 00001001|1 i 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 i 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> Nie można ustawić lub pobrać z zasobu skojarzonego procesu informacji.  - lub - identyfikatora procesu lub uchwytu procesu wynosi zero. (Proces nie została uruchomiona.)</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  - lub - proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odrzuca żadnych informacji o skojarzonego procesu buforowane wewnątrz składnika procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po <xref:System.Diagnostics.Process.Refresh%2A> zostanie wywołany, to pierwsze żądanie do informacji na temat każdej właściwości powoduje, że składnik procesu uzyskać nową wartość ze skojarzonego procesu.  
  
 Gdy <xref:System.Diagnostics.Process> składnik jest skojarzony z zasobem procesu wartości właściwości <xref:System.Diagnostics.Process> natychmiast są wypełniane zgodnie ze stanu skojarzonego procesu. Jeśli informacje o skojarzonego procesu następnie zmian, te zmiany nie zostaną odzwierciedlone w <xref:System.Diagnostics.Process> wartości elementu w pamięci podręcznej. <xref:System.Diagnostics.Process> Składnika jest migawką zasobów procesu w czasie są skojarzone. Aby wyświetlić bieżące wartości skojarzonego procesu, należy wywołać <xref:System.Diagnostics.Process.Refresh%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Pobiera następnie użycie pamięci fizycznej przez skojarzony proces odstępach drugi 2 maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy odpowiada procesu interfejsu użytkownika.</summary>
        <value>
          <see langword="true" /> Jeśli interfejs użytkownika skojarzonego procesu odpowiada systemowi; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli proces ma interfejs użytkownika <xref:System.Diagnostics.Process.Responding%2A> właściwości kontaktuje się z interfejsu użytkownika, aby określić, czy Proces odpowiada na dane wejściowe użytkownika. Jeśli interfejs nie odpowiada, <xref:System.Diagnostics.Process.Responding%2A> zwraca właściwość `false`. Ta właściwość umożliwia określenie, czy interfejs skojarzonego procesu przestał odpowiadać.  
  
 Jeśli proces nie ma <xref:System.Diagnostics.Process.MainWindowHandle%2A>, ta właściwość zwraca `true`.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma żadnych procesów skojarzonych z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Responding" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty tego procesu.</summary>
        <value>Uchwyt macierzysty tego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojście jest dostępna tylko jeśli wywołanie składnik uruchomiony proces.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator sesji usług terminalowych skojarzonego procesu.</summary>
        <value>Identyfikator sesji usług terminalowych skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> Właściwość identyfikuje sesji, w którym aplikacja jest obecnie uruchomiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Nie istnieje żadna sesja skojarzonych z tym procesem.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma żadnych procesów, skojarzone z tego identyfikatora sesji.  - lub - skojarzony proces nie znajduje się na tym komputerze.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="P:System.Diagnostics.Process.SessionId" /> Właściwość nie jest obsługiwana w systemach Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do odczytu danych wyjściowych błędu aplikacji.</summary>
        <value>A <see cref="T:System.IO.StreamReader" /> można odczytać Standardowy strumień błędów aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.Process> zapisuje tekst jego Standardowy strumień błędów, że tekst jest zwykle wyświetlany w konsoli. Dzięki przekierowaniu <xref:System.Diagnostics.Process.StandardError%2A> strumienia, można manipulować i pomijania błędów wyjścia procesu. Na przykład możesz filtrować tekst, sformatuj go w inny sposób i zapisać dane wyjściowe do konsoli i pliku dziennika wyznaczonych.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardError%2A>, należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> do `false`, i należy ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> do `true`. W przeciwnym razie odczytu z <xref:System.Diagnostics.Process.StandardError%2A> strumienia zgłasza wyjątek.  
  
 Przekierowane <xref:System.Diagnostics.Process.StandardError%2A> synchronicznie lub asynchronicznie można odczytać strumienia. Metody, takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> przeprowadzić synchronicznej operacji odczytu na błąd strumień wyjściowy procesu. Te synchroniczne do odczytu do skojarzonego nie są wykonywane operacje <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardError%2A> strumienia lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> strumienia. Ta metoda umożliwia obsługi zdarzeń w wyznaczonych dla strumieni wyjściowych i natychmiast zwraca obiekt wywołujący, które można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Synchroniczne odczytu operacji wprowadzenie zależności między wywołującego odczytu z <xref:System.Diagnostics.Process.StandardError%2A> strumienia i podrzędnego procesu zapisywanie w strumieniu. Te zależności może doprowadzić do zakleszczenia warunków. Gdy obiekt wywołujący odczytuje z przekierowanego strumienia procesu podrzędnego, jest on zależny od elementu podrzędnego. Obiekt wywołujący oczekuje na operacji odczytu, aż podrzędne zapisuje do strumienia lub zamyka strumienia. Podczas procesu podrzędnego zapisuje wystarczającej ilości danych w celu wypełnienia jej przekierowanego strumienia, jest on zależny od obiektu nadrzędnego. Procesu podrzędnego oczekuje na następnej operacji zapisu, aż nadrzędnego odczytuje strumienia pełnego lub zamyka strumienia. Zakleszczenia wyników, gdy obiekt wywołujący i procesu podrzędnego oczekiwanie na siebie do wykonania operacji, i nie można kontynuować. Można uniknąć zakleszczenie wyniku obliczenia zależności między wywołującego i procesu podrzędnego.  
  
 Następujący kod C#, na przykład przedstawia sposób czytać ze strumienia przekierowane i poczekaj na zakończenie procesu podrzędnego.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 Przykładowy kod pozwala uniknąć zakleszczenie, wywołując `p.StandardError.ReadToEnd` przed `p.WaitForExit`. Zakleszczenie może powodować, jeśli element nadrzędny przetwarzania wywołania `p.WaitForExit` przed `p.StandardError.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst, aby wypełnić przekierowanego strumienia. Proces nadrzędny będzie czekać w nieskończoność na zakończenie procesu podrzędnego. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Brak podobne problem podczas odczytu cały tekst z wyjście standardowe i błąd standardowy strumieni. Na przykład następujący kod C#, wykonuje operacji odczytu dla obu strumieni.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Przykład kodu pozwala uniknąć zakleszczenia, wykonując asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Zakleszczenie wyniki, jeśli element nadrzędny przetwarzania wywołania `p.StandardOutput.ReadToEnd` następuje `p.StandardError.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst w celu wypełnienia jej strumień błędów. Proces nadrzędny będzie czekać w nieskończoność procesu podrzędnego zamknąć jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Aby uniknąć tych zależności i ich potencjalne zakleszczenia, można użyć asynchronicznych operacji odczytu. Alternatywnie można uniknąć zakleszczenia przez utworzenie dwóch wątków i odczytywania dane wyjściowe każdego strumienia w oddzielnym wątku.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla strumienia przekierowane. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchroniczne i synchroniczne, wszystkie dalsze odczytu operacji na strumieniu musi być w tym samym trybie. Na przykład nie wykonuj <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardError%2A> strumienia, albo na odwrót. Można jednak odczytać dwóch różnych strumieni w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `net use` polecenia razem z użytkownikiem podany argument mapować zasobu sieciowego. Następnie Standardowy strumień błędów polecenia net odczytuje i zapisuje go do konsoli.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardError" /> Strumienia nie został zdefiniowany dla przekierowania; upewnij się, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> ustawiono <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ma ustawioną wartość <see langword="false" />.  \- lub - <see cref="P:System.Diagnostics.Process.StandardError" /> strumień został otwarty dla asynchronicznych operacji odczytu z <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do zapisywania danych wejściowych w aplikacji.</summary>
        <value>A <see cref="T:System.IO.StreamWriter" /> można zapisać Standardowy strumień wejściowy aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.Process> można odczytać tekstu wejściowego z jego Standardowy strumień wejściowy zwykle klawiatury. Dzięki przekierowaniu <xref:System.Diagnostics.Process.StandardInput%2A> strumienia, można programowo Określ dane wejściowe. Na przykład zamiast przy użyciu klawiatury, musisz podać tekst z zawartości wybrany plik lub wyjście z innej aplikacji.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardInput%2A>, należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> do `false`, i należy ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> do `true`. W przeciwnym razie zapisywania <xref:System.Diagnostics.Process.StandardInput%2A> strumienia zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przekierowania <xref:System.Diagnostics.Process.StandardInput%2A> strumienia procesu. W przykładzie uruchomiono `sort` polecenia przy użyciu przekierowanych danych wejściowych. Następnie monituje użytkownika o tekstu i przekazuje do `sort` procesu za pomocą przekierowanego <xref:System.Diagnostics.Process.StandardInput%2A> strumienia. `sort` Wyniki są wyświetlane użytkownikowi na konsoli.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardInput" /> Strumienia nie została zdefiniowana, ponieważ <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> ma ustawioną wartość <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do odczytu tekstową dane wyjściowe aplikacji.</summary>
        <value>A <see cref="T:System.IO.StreamReader" /> można odczytać Standardowy strumień wyjściowy aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.Process> zapisuje tekst jego Standardowy strumień, że tekst jest zwykle wyświetlany w konsoli. Dzięki przekierowaniu <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, można manipulować lub pominąć wyjścia procesu. Na przykład możesz filtrować tekst, sformatuj go w inny sposób i zapisać dane wyjściowe do konsoli i pliku dziennika wyznaczonych.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardOutput%2A>, należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> do `false`, i należy ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> do `true`. W przeciwnym razie odczytu z <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia zgłasza wyjątek.  
  
 Przekierowane <xref:System.Diagnostics.Process.StandardOutput%2A> synchronicznie lub asynchronicznie można odczytać strumienia. Metody, takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> przeprowadzić synchronicznej operacji odczytu na strumień wyjściowy procesu. Te synchroniczne do odczytu do skojarzonego nie są wykonywane operacje <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Ta metoda umożliwia obsługi zdarzeń w wyznaczonych dla strumieni wyjściowych i natychmiast zwraca obiekt wywołujący, które można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Synchroniczne odczytu operacji wprowadzenie zależności między wywołującego odczytu z <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia i podrzędnego procesu zapisywanie w strumieniu. Te zależności może doprowadzić do zakleszczenia warunków. Gdy obiekt wywołujący odczytuje z przekierowanego strumienia procesu podrzędnego, jest on zależny od elementu podrzędnego. Obiekt wywołujący oczekuje na operacji odczytu, aż podrzędne zapisuje do strumienia lub zamyka strumienia. Podczas procesu podrzędnego zapisuje wystarczającej ilości danych w celu wypełnienia jej przekierowanego strumienia, jest on zależny od obiektu nadrzędnego. Procesu podrzędnego oczekuje na następnej operacji zapisu, aż nadrzędnego odczytuje strumienia pełnego lub zamyka strumienia. Zakleszczenia wyników, gdy obiekt wywołujący i procesu podrzędnego oczekiwanie na siebie do wykonania operacji, i nie można kontynuować. Można uniknąć zakleszczenie wyniku obliczenia zależności między wywołującego i procesu podrzędnego.  
  
 Następujący kod C#, na przykład przedstawia sposób czytać ze strumienia przekierowane i poczekaj na zakończenie procesu podrzędnego.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 Przykładowy kod pozwala uniknąć zakleszczenie, wywołując `p.StandardOutput.ReadToEnd` przed `p.WaitForExit`. Zakleszczenie może powodować, jeśli element nadrzędny przetwarzania wywołania `p.WaitForExit` przed `p.StandardOutput.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst, aby wypełnić przekierowanego strumienia. Proces nadrzędny będzie czekać w nieskończoność na zakończenie procesu podrzędnego. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
 Brak podobne problem podczas odczytu cały tekst z wyjście standardowe i błąd standardowy strumieni. Na przykład następujący kod C#, wykonuje operacji odczytu dla obu strumieni.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Przykład kodu pozwala uniknąć zakleszczenia, wykonując asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Zakleszczenie wyniki, jeśli element nadrzędny przetwarzania wywołania `p.StandardOutput.ReadToEnd` następuje `p.StandardError.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst w celu wypełnienia jej strumień błędów. Proces nadrzędny będzie czekać w nieskończoność procesu podrzędnego zamknąć jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Aby uniknąć tych zależności i ich potencjalne zakleszczenia, można użyć asynchronicznych operacji odczytu. Alternatywnie można uniknąć zakleszczenia przez utworzenie dwóch wątków i odczytywania dane wyjściowe każdego strumienia w oddzielnym wątku.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla strumienia przekierowane. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchroniczne i synchroniczne, wszystkie dalsze odczytu operacji na strumieniu musi być w tym samym trybie. Na przykład nie wykonuj <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, albo na odwrót. Można jednak odczytać dwóch różnych strumieni w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
   
  
## Examples  
 W poniższym przykładzie uruchamia polecenia ipconfig.exe i przekierowuje dane wyjściowe standardowe przykład okna konsoli.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumienia nie został zdefiniowany dla przekierowania; upewnij się, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ustawiono <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ma ustawioną wartość <see langword="false" />.  \- lub - <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumień został otwarty dla asynchronicznych operacji odczytu z <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia proces zasobu i kojarzy ją z <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia (lub ponownie używa) zasobu procesu, który jest określony przez <see cref="P:System.Diagnostics.Process.StartInfo" /> właściwości tego <see cref="T:System.Diagnostics.Process" /> składnika i kojarzy ją za pomocą składnika.</summary>
        <returns>
          <see langword="true" /> Jeśli zasobów proces jest uruchomiony; <see langword="false" /> Jeśli żaden z zasobów nowego procesu jest uruchomiona (na przykład, jeśli istniejący proces zostanie ponownie użyty).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia do uruchamiania procesu zasobu i skojarzyć go z bieżącą <xref:System.Diagnostics.Process> składnika. Wartość zwracana `true` wskazuje, że nowy zasób procesu została uruchomiona. Jeśli zasób proces określony przez <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> członkiem <xref:System.Diagnostics.Process.StartInfo%2A> właściwości jest już uruchomiona na komputerze, zasobu bez dodatkowych procesów jest uruchomiona. Zamiast tego uruchomić przetworzyć zasobów zostanie ponownie użyty i `false` jest zwracany.  
  
 Określanie lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację można uruchomić aplikacji ClickOnce. Nie należy uruchamiać aplikacji ClickOnce, określając jego zainstalowanej lokalizacji na dysku twardym.  
  
> [!NOTE]
>  Jeśli używasz programu Visual Studio, to przeciążenie metody <xref:System.Diagnostics.Process.Start%2A> metody jest wstawiany do kodu, gdy zostanie przeciągnięty <xref:System.Diagnostics.Process> składnika do projektanta. Użyj `Properties` okna, aby rozwinąć `StartInfo` kategorii i zapisać odpowiednie wartości w `FileName` właściwości. Wprowadzone zmiany zostaną wyświetlone w postaci `InitializeComponent` procedury.  
  
 To przeciążenie metody <xref:System.Diagnostics.Process.Start%2A> nie jest `static` metody. Należy wywołać go z wystąpieniem <xref:System.Diagnostics.Process> klasy. Przed wywołaniem <xref:System.Diagnostics.Process.Start%2A>, należy najpierw określić <xref:System.Diagnostics.Process.StartInfo%2A> właściwości informacje na temat tego <xref:System.Diagnostics.Process> wystąpienia, ponieważ te informacje służy do określania zasobów procesu, aby uruchomić.  
  
 Inne przeciążenia <xref:System.Diagnostics.Process.Start%2A> metody są `static` elementów członkowskich. Nie trzeba tworzyć wystąpienia <xref:System.Diagnostics.Process> składnik przed wywołaniem tych przeciążenia metody. Zamiast tego można wywołać <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> klasy samej siebie, a nowy <xref:System.Diagnostics.Process> składnik jest tworzony, jeśli proces został uruchomiony. Lub, `null` jest zwracany, jeśli proces został użyty ponownie. Proces zasobów jest automatycznie kojarzony z nowym <xref:System.Diagnostics.Process> składnik, który jest zwracany przez <xref:System.Diagnostics.Process.Start%2A> metody.  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> Elementów członkowskich może służyć do powielają funkcjonalność programu `Run` okno dialogowe systemu Windows `Start` menu. Wszystkie elementy, które można wpisać w wierszu polecenia można uruchomić ustawiając odpowiednie wartości w <xref:System.Diagnostics.Process.StartInfo%2A> właściwości. Jedynym <xref:System.Diagnostics.Process.StartInfo%2A> właściwość, która musi być ustawiona jest <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Właściwości musi być plikiem wykonywalnym. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją, która jest zainstalowana w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości może mieć rozszerzeniem txt czy skojarzony plików tekstowych za pomocą edytora, takiego jak Notatnik, może mieć rozszerzeniem doc, jeśli pliki associated.doc z narzędzia edytora tekstów, takiego jak Microsoft Word.  
  
 W wierszu polecenia można określić akcjami wykonywanymi w przypadku niektórych typów plików. Można na przykład drukowanie dokumentów lub edytowanie plików tekstowych. Określ te akcje za pomocą <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> członkiem <xref:System.Diagnostics.Process.StartInfo%2A> właściwości. Dla innych typów plików, można określić argumenty wiersza polecenia, po uruchomieniu pliku z `Run` okno dialogowe. Na przykład można przekazać adres URL jako argument określenia przeglądarkę jako <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Tych argumentów można określić w <xref:System.Diagnostics.Process.StartInfo%2A> właściwości <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> elementu członkowskiego.  
  
 Jeśli zmienna ścieżki zadeklarowana w systemie za pomocą oferty, możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie będzie zawierał ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, i dodaj go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji każdy proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda stronę sieci Web ASP.NET lub formantu serwera, nowego procesu jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Zawsze, gdy używana <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, konieczne może być Zamknij je lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 W tym miejscu jest konieczne notatkę dotyczącą stany apartamentu w zarządzanych wątkach. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` składnika procesu <xref:System.Diagnostics.Process.StartInfo%2A> właściwości, upewnij się, że ustawiono model wątkowy do aplikacji przez ustawienie atrybutu `[STAThread]` na `main()` — metoda. W przeciwnym razie zarządzanego wątku mogą znajdować się w `unknown` stanu lub umieść w `MTA` stanu, jego powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`. W przypadku niektórych metod wymagają stanu apartamentu nie `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotka taka metoda, domyślne `MTA`, a po ustawieniu stanu apartamentu nie można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku był zgłaszany, gdy wątek zarządza powłoki systemu operacyjnego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wystąpienia <xref:System.Diagnostics.Process> klasy do uruchomienia procesu.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku, nie została określona w <see cref="T:System.Diagnostics.Process" /> składnika <see cref="P:System.Diagnostics.Process.StartInfo" />.
- lub - <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> członkiem <see cref="P:System.Diagnostics.Process.StartInfo" /> właściwość jest <see langword="true" /> podczas <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, lub <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemach operacyjnych, które nie obsługują powłoki, takie jak Nano Server (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> Zawierający informacje, które są używane do uruchamiania procesu, w tym nazwę pliku i żadnych argumentów wiersza polecenia.</param>
        <summary>Rozpoczyna się zasób procesu, który jest określony przez parametr zawierający informacje do rozpoczęcia procesu (na przykład nazwę pliku do rozpoczęcia procesu) i kojarzy zasobu z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzonego z zasobem procesu lub <see langword="null" /> Jeśli żaden z zasobów proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle z uruchomionym wystąpień tego samego procesu niezależnie od innych. Ponadto Start może zwrócić proces inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną właściwość <see langword="true" />. W takim przypadku uruchomiono proces może mieć aktywowana istniejącego wystąpienia samej siebie i następnie został zakończony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić proces zasobu, określając <xref:System.Diagnostics.ProcessStartInfo> wystąpienia. Przeciążenie kojarzy zasobu z nową <xref:System.Diagnostics.Process> obiektu.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia adresu URL, proces nie jest uruchomiona i `null` jest zwracany.  
  
 To przeciążenie umożliwia uruchomić proces bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Za pomocą tego przeciążenia z <xref:System.Diagnostics.ProcessStartInfo> parametr jest zamiast jawnego kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia, ustawienie jej <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Przy użyciu <xref:System.Diagnostics.ProcessStartInfo> wystąpienia jako parametr umożliwia wywołanie <xref:System.Diagnostics.Process.Start%2A> najbardziej kontrolę nad co to jest przekazywany do wywołania, aby rozpocząć proces. Jeśli trzeba przekazać nazwę pliku lub nazwę pliku i argumentów, nie jest konieczne utworzyć nową <xref:System.Diagnostics.ProcessStartInfo> wystąpienia, ale jest opcją. Jedynym <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> właściwość, która musi być ustawiona jest <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Właściwości nie musi reprezentować pliku wykonywalnego. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją, która jest zainstalowana w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości może mieć rozszerzeniem txt czy skojarzony plików tekstowych za pomocą edytora, takiego jak Notatnik, może mieć rozszerzeniem doc, jeśli pliki associated.doc z narzędzia edytora tekstów, takiego jak Microsoft Word.  
  
 Określanie lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację można uruchomić aplikacji ClickOnce. Nie należy uruchamiać aplikacji ClickOnce, określając jego zainstalowanej lokalizacji na dysku twardym.  
  
 Jeśli <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> właściwości <xref:System.Diagnostics.Process.StartInfo%2A> wystąpienia są ustawione, niezarządzanej `CreateProcessWithLogonW` zostanie wywołana funkcja, która uruchamia proces w nowe okno nawet jeśli <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> wartość właściwości jest `true` lub <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> wartość właściwości jest <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Jeśli <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> właściwość jest `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> właściwość musi być w formacie UPN, *użytkownika*@*DNS_domain_name*.   
  
 W odróżnieniu od innych przeciążeniach przeciążenia <xref:System.Diagnostics.Process.Start%2A> która nie ma parametrów nie jest `static` elementu członkowskiego. Użyj tego przeciążenia, gdy utworzono już <xref:System.Diagnostics.Process> wystąpienia, informacje o określonym rozpoczęcia (w tym nazwa pliku) i chcesz uruchomić proces zasobu i skojarzyć go z istniejącym <xref:System.Diagnostics.Process> wystąpienia. Użyj jednej z `static` overloads, jeśli chcesz utworzyć nową <xref:System.Diagnostics.Process> składnika, zamiast uruchomić proces istniejący składnik. Zarówno tego przeciążenia i przeciążenia, które nie ma parametrów można określić informacje rozpoczęcia dla zasobu procesu przy użyciu <xref:System.Diagnostics.ProcessStartInfo> wystąpienia.  
  
 Jeśli zmienna ścieżki zadeklarowana w systemie za pomocą oferty, możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie będzie zawierał ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, i dodaj go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji każdy proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda stronę sieci Web ASP.NET lub formantu serwera, nowego procesu jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Zawsze, gdy używana <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, konieczne może być Zamknij je lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 W tym miejscu jest konieczne notatkę dotyczącą stany apartamentu w zarządzanych wątkach. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` na `startInfo` parametru, upewnij się, ustawiając dla atrybutu ustawiono model wątkowy do aplikacji `[STAThread]` na `main()` metody. W przeciwnym razie zarządzanego wątku mogą znajdować się w `unknown` stanu lub umieść w `MTA` stanu, jego powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`. W przypadku niektórych metod wymagają stanu apartamentu nie `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotka taka metoda, domyślne `MTA`, a po ustawieniu stanu apartamentu nie można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku był zgłaszany, gdy wątek zarządza powłoki systemu operacyjnego.  
  
   
  
## Examples  
 W poniższym przykładzie najpierw spowoduje utworzenie wystąpienia programu Internet Explorer i wyświetla zawartość folderu ulubionych w przeglądarce. Następnie uruchamia innych wystąpień programu Internet Explorer i wyświetla niektóre określone strony lub witryny. Na koniec uruchamia program Internet Explorer, w oknie minimalizowanie podczas nawigowania do określonej lokacji.  
  
 Dodatkowe przykłady innych celów tej metody można odwoływać się do poszczególnych właściwości <xref:System.Diagnostics.ProcessStartInfo> klasy.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku, nie została określona w <paramref name="startInfo" /> parametru <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> właściwości.  - lub - <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwość <paramref name="startInfo" /> parametr jest <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, lub <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> właściwość jest również <see langword="true" />.  - lub - <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwość <paramref name="startInfo" /> parametr jest <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> właściwość nie jest <see langword="null" /> lub jest pusta lub <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> właściwość nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startInfo" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="startInfo" /> parametru <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> nie można odnaleźć właściwości.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.  - lub - 2080 przekracza sumę długości argumentów i długość pełnej ścieżki do procesu. Komunikat o błędzie skojarzony z tym wyjątkiem może być jedną z następujących: "obszar danych przekazany do wywołania systemowego jest za mały." lub "Odmowa dostępu."</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemach operacyjnych, które nie obsługują powłoki, takie jak Nano Server (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku dokumentu lub aplikacji do uruchamiania w procesie.</param>
        <summary>Uruchamia proces zasobu, określając nazwę pliku dokumentu lub aplikacji i kojarzy zasobu z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzonego z zasobem procesu lub <see langword="null" /> Jeśli żaden z zasobów proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle z uruchomionym wystąpień tego samego procesu niezależnie od innych. Ponadto Start może zwrócić proces inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną właściwość <see langword="true" />. W takim przypadku uruchomiono proces może mieć aktywowana istniejącego wystąpienia samej siebie i następnie został zakończony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić proces zasobu, określając jego nazwa pliku. Przeciążenie kojarzy zasobu z nową <xref:System.Diagnostics.Process> obiektu.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia adresu URL, proces nie jest uruchomiona i `null` jest zwracany.  
  
 To przeciążenie umożliwia uruchomić proces bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie stanowi alternatywę jawne kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia ustawienie <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> członkiem <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Można uruchomić aplikacji ClickOnce, ustawiając `fileName` parametru do lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację. Nie należy uruchamiać aplikacji ClickOnce, określając jego zainstalowanej lokalizacji na dysku twardym.  
  
 Uruchamia proces, określając jego nazwa pliku jest podobny do wpisywania informacji w `Run` okno dialogowe systemu Windows `Start` menu. W związku z tym nazwa pliku nie musi reprezentować pliku wykonywalnego. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją zainstalowane w systemie. Na przykład nazwa pliku może mieć rozszerzeniem txt czy skojarzony plików tekstowych za pomocą edytora, takiego jak Notatnik, może mieć doc, jeśli pliki associated.doc z narzędzia edytora tekstów, takiego jak Microsoft Word. Podobnie, w taki sam jak robi `Run` okno dialogowe zaakceptować nazwę pliku wykonywalnego z lub bez rozszerzeniem .exe, rozszerzeniem .exe jest opcjonalna w `fileName` parametru. Na przykład można ustawić `fileName` parametru "Notepad.exe" lub "Notatnik".  
  
 To przeciążenie nie zezwala na argumenty wiersza polecenia do procesu. Jeśli trzeba określić co najmniej jeden argument wiersza polecenia dla procesu, użyj <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> lub <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> przeciążenia.  
  
 W odróżnieniu od innych przeciążeniach przeciążenia <xref:System.Diagnostics.Process.Start%2A> która nie ma parametrów nie jest `static` elementu członkowskiego. Użyj tego przeciążenia, gdy utworzono już <xref:System.Diagnostics.Process> wystąpienia, informacje o określonym rozpoczęcia (w tym nazwa pliku) i chcesz uruchomić proces zasobu i skojarzyć go z istniejącym <xref:System.Diagnostics.Process> wystąpienia. Użyj jednej z `static` overloads, jeśli chcesz utworzyć nową <xref:System.Diagnostics.Process> składnika, zamiast uruchomić proces istniejący składnik. Zarówno tego przeciążenia i przeciążenia, które nie ma parametrów umożliwia Określ nazwę pliku zasobu procesu, aby rozpocząć.  
  
 Jeśli zmienna ścieżki zadeklarowana w systemie za pomocą oferty, możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie będzie zawierał ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, i dodaj go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji każdy proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda stronę sieci Web ASP.NET lub formantu serwera, nowego procesu jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Zawsze, gdy używana <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, konieczne może być Zamknij je lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 W tym miejscu jest konieczne notatkę dotyczącą stany apartamentu w zarządzanych wątkach. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` składnika procesu <xref:System.Diagnostics.Process.StartInfo%2A> właściwości, upewnij się, że ustawiono model wątkowy do aplikacji przez ustawienie atrybutu `[STAThread]` na `main()` — metoda. W przeciwnym razie zarządzanego wątku mogą znajdować się w `unknown` stanu lub umieść w `MTA` stanu, jego powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`. W przypadku niektórych metod wymagają stanu apartamentu nie `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotka taka metoda, domyślne `MTA`, a po ustawieniu stanu apartamentu nie można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku był zgłaszany, gdy wątek zarządza powłoki systemu operacyjnego.  
  
   
  
## Examples  
 W poniższym przykładzie najpierw spowoduje utworzenie wystąpienia programu Internet Explorer i wyświetla zawartość folderu ulubionych w przeglądarce. Następnie uruchamia innych wystąpień programu Internet Explorer i wyświetla niektóre określone strony lub witryny. Na koniec uruchamia program Internet Explorer, w oknie minimalizowanie podczas nawigowania do określonej lokacji.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zmienna środowiskowa PATH ma ciąg zawierający cudzysłowów.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchamiania w procesie.</param>
        <param name="arguments">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Rozpoczyna się proces zasobu, określając nazwę aplikacji i zestaw argumenty wiersza polecenia i kojarzy zasobu z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzonego z zasobem procesu lub <see langword="null" /> Jeśli żaden z zasobów proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle z uruchomionym wystąpień tego samego procesu niezależnie od innych. Ponadto Start może zwrócić proces inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną właściwość <see langword="true" />. W takim przypadku uruchomiono proces może mieć aktywowana istniejącego wystąpienia samej siebie i następnie został zakończony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić proces zasobu, określając jej nazwę pliku i argumenty wiersza polecenia. Przeciążenie kojarzy zasobu z nową <xref:System.Diagnostics.Process> obiektu.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia adresu URL, proces nie jest uruchomiona i `null` jest zwracany.  
  
 To przeciążenie umożliwia uruchomić proces bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie stanowi alternatywę jawne kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia ustawienie <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> i <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> członkami <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Uruchamia proces, określając jej nazwę pliku i argumentów jest podobny do wpisanie nazwy pliku i argumenty wiersza polecenia w `Run` okno dialogowe systemu Windows `Start` menu. W związku z tym nazwa pliku nie musi reprezentować pliku wykonywalnego. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją zainstalowane w systemie. Na przykład nazwa pliku może mieć rozszerzeniem txt czy skojarzony plików tekstowych za pomocą edytora, takiego jak Notatnik, może mieć doc, jeśli pliki associated.doc z narzędzia edytora tekstów, takiego jak Microsoft Word. Podobnie, w taki sam jak robi `Run` okno dialogowe zaakceptować nazwę pliku wykonywalnego z lub bez rozszerzeniem .exe, rozszerzeniem .exe jest opcjonalna w `fileName` parametru. Na przykład można ustawić `fileName` parametru "Notepad.exe" lub "Notatnik". Jeśli `fileName` parametr reprezentuje plik wykonywalny `arguments` parametr może reprezentować pliku działanie, np. w pliku tekstowym w `Notepad.exe myfile.txt`. Jeśli `fileName` parametr reprezentuje plik polecenia (cmd) `arguments` musi zawierać parametr "`/c`"lub"`/k`" argument, aby określić czy okno polecenia opuszcza lub pozostaje po zakończeniu.  
  
 W odróżnieniu od innych przeciążeniach przeciążenia <xref:System.Diagnostics.Process.Start%2A> która nie ma parametrów nie jest `static` elementu członkowskiego. Użyj tego przeciążenia, gdy utworzono już <xref:System.Diagnostics.Process> wystąpienia, informacje o określonym rozpoczęcia (w tym nazwa pliku) i chcesz uruchomić proces zasobu i skojarzyć go z istniejącym <xref:System.Diagnostics.Process> wystąpienia. Użyj jednej z `static` overloads, jeśli chcesz utworzyć nową <xref:System.Diagnostics.Process> składnika, zamiast uruchomić proces istniejący składnik. Zarówno tego przeciążenia i przeciążenia, które nie ma parametrów umożliwia Określ nazwę pliku zasobu procesu do uruchomienia i argumenty wiersza polecenia do przekazania.  
  
 Jeśli zmienna ścieżki zadeklarowana w systemie za pomocą oferty, możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie będzie zawierał ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, i dodaj go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji każdy proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda stronę sieci Web ASP.NET lub formantu serwera, nowego procesu jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Zawsze, gdy używana <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, konieczne może być Zamknij je lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości...  
  
 W tym miejscu jest konieczne notatkę dotyczącą stany apartamentu w zarządzanych wątkach. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` składnika procesu <xref:System.Diagnostics.Process.StartInfo%2A> właściwości, upewnij się, że ustawiono model wątkowy do aplikacji przez ustawienie atrybutu `[STAThread]` na `main()` — metoda. W przeciwnym razie zarządzanego wątku mogą znajdować się w `unknown` stanu lub umieść w `MTA` stanu, jego powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`. W przypadku niektórych metod wymagają stanu apartamentu nie `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotka taka metoda, domyślne `MTA`, a po ustawieniu stanu apartamentu nie można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku był zgłaszany, gdy wątek zarządza powłoki systemu operacyjnego.  
  
   
  
## Examples  
 W poniższym przykładzie najpierw spowoduje utworzenie wystąpienia programu Internet Explorer i wyświetla zawartość folderu ulubionych w przeglądarce. Następnie uruchamia innych wystąpień programu Internet Explorer i wyświetla niektóre określone strony lub witryny. Na koniec uruchamia program Internet Explorer, w oknie minimalizowanie podczas nawigowania do określonej lokacji.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="fileName" /> Lub <paramref name="arguments" /> parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.  - lub - 2080 przekracza sumę długości argumentów i długość pełnej ścieżki do procesu. Komunikat o błędzie skojarzony z tym wyjątkiem może być jedną z następujących: "obszar danych przekazany do wywołania systemowego jest za mały." lub "Odmowa dostępu."</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zmienna środowiskowa PATH ma ciąg zawierający cudzysłowów.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchamiania w procesie.</param>
        <param name="userName">Nazwa użytkownika używana podczas uruchamiania procesu.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> zawiera hasło do użycia podczas uruchamiania procesu.</param>
        <param name="domain">Domeny do użycia podczas uruchamiania procesu.</param>
        <summary>Uruchamia proces zasobu, określając nazwę aplikacji, nazwę użytkownika, hasło i domeny i kojarzy zasobu z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzonego z zasobem procesu lub <see langword="null" /> Jeśli żaden z zasobów proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle z uruchomionym wystąpień tego samego procesu niezależnie od innych. Ponadto Start może zwrócić proces inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną właściwość <see langword="true" />. W takim przypadku uruchomiono proces może mieć aktywowana istniejącego wystąpienia samej siebie i następnie został zakończony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia utworzenie nowego procesu i jego podstawowym wątku, określając nazwę pliku, nazwa użytkownika, hasło i domenę. Nowy proces następnie uruchamia określony plik wykonywalny w kontekście zabezpieczeń określonych poświadczeń (użytkownika, domena i hasło).  
  
> [!NOTE]
>  Jeśli plik wykonywalny znajduje się na dysku zdalnym, należy określić udziału sieciowego przy użyciu identyfikator uniform resource identifier (URI), nie połączonych literę.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia adresu URL, proces nie jest uruchomiona i `null` jest zwracany.  
  
 To przeciążenie umożliwia uruchomić proces bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie stanowi alternatywę jawne kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia ustawienie <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, i <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> właściwości <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Podobnie, w tym samym jak robi **Uruchom** okno dialogowe zaakceptować nazwę pliku wykonywalnego z lub bez rozszerzeniem .exe, rozszerzeniem .exe jest opcjonalna w `fileName` parametru. Na przykład można ustawić `fileName` parametru "Notepad.exe" lub "Notatnik". Jeśli `fileName` parametr reprezentuje plik wykonywalny `arguments` parametr może reprezentować pliku działanie, np. w pliku tekstowym w `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Nazwa pliku musi reprezentować plik wykonywalny w <xref:System.Diagnostics.Process.Start%2A> przeciążenia, które mają `userName`, `password`, i `domain` parametrów.  
  
 Zawsze, gdy używana <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, konieczne może być Zamknij je lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości...  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia tego przeciążenia, aby uruchomić plik wykonywalny i ilustruje też zgłaszanie z <xref:System.ComponentModel.Win32Exception> podczas próby uruchomienia aplikacji skojarzonych z plikiem niewykonywalne.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku nie została określona.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemie Linux lub macOS (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchamiania w procesie.</param>
        <param name="arguments">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <param name="userName">Nazwa użytkownika używana podczas uruchamiania procesu.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> zawiera hasło do użycia podczas uruchamiania procesu.</param>
        <param name="domain">Domeny do użycia podczas uruchamiania procesu.</param>
        <summary>Uruchamia proces zasobu, określając nazwę aplikacji, zestaw argumenty wiersza polecenia nazwę użytkownika, hasło i domenę i kojarzy zasobu z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzonego z zasobem procesu lub <see langword="null" /> Jeśli żaden z zasobów proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle z uruchomionym wystąpień tego samego procesu niezależnie od innych. Ponadto Start może zwrócić proces inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną właściwość <see langword="true" />. W takim przypadku uruchomiono proces może mieć aktywowana istniejącego wystąpienia samej siebie i następnie został zakończony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia utworzenie nowego procesu i jego podstawowym wątku, określając nazwę pliku, argumenty wiersza polecenia, nazwę użytkownika, hasło i domenę. Nowy proces następnie uruchamia określony plik wykonywalny w kontekście zabezpieczeń określonych poświadczeń (użytkownika, domena i hasło).  
  
> [!NOTE]
>  Jeśli plik wykonywalny znajduje się na dysku zdalnym, należy określić udziału sieciowego przy użyciu identyfikator uniform resource identifier (URI), nie połączonych literę.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia adresu URL, proces nie jest uruchomiona i `null` jest zwracany.  
  
 To przeciążenie umożliwia uruchomić proces bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie stanowi alternatywę jawne kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia ustawienie <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, i <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> właściwości <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Podobnie, w tym samym jak robi **Uruchom** okno dialogowe zaakceptować nazwę pliku wykonywalnego z lub bez rozszerzeniem .exe, rozszerzeniem .exe jest opcjonalna w `fileName` parametru. Na przykład można ustawić `fileName` parametru "Notepad.exe" lub "Notatnik". Jeśli `fileName` parametr reprezentuje plik wykonywalny `arguments` parametr może reprezentować pliku działanie, np. w pliku tekstowym w `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Nazwa pliku musi reprezentować plik wykonywalny w <xref:System.Diagnostics.Process.Start%2A> przeciążenia, które mają `userName`, `password`, i `domain` parametrów.  
  
 Zawsze, gdy używana <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, konieczne może być Zamknij je lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku nie została określona.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.  - lub - 2080 przekracza sumę długości argumentów i długość pełnej ścieżki do pliku skojarzone. Komunikat o błędzie skojarzony z tym wyjątkiem może być jedną z następujących: "obszar danych przekazany do wywołania systemowego jest za mały." lub "Odmowa dostępu."</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemie Linux lub macOS (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwości do przekazania do <see cref="M:System.Diagnostics.Process.Start" /> metody <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> Reprezentujący danych, z którym można uruchomić procesu. Tych argumentów obejmują nazwę pliku wykonywalnego lub dokumentu, używany do uruchomienia procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> reprezentuje zestaw parametrów na potrzeby uruchomienia procesu. Gdy <xref:System.Diagnostics.Process.Start%2A> jest nazywany <xref:System.Diagnostics.Process.StartInfo%2A> służy do określania do rozpoczęcia procesu. Tylko niezbędne <xref:System.Diagnostics.Process.StartInfo%2A> jest element członkowski, aby ustawić <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. Uruchamia proces, określając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości jest podobny do wpisywania informacji w **Uruchom** okno dialogowe systemu Windows **Start** menu. W związku z tym <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości nie musi reprezentować pliku wykonywalnego. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją zainstalowane w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> może mieć rozszerzeniem txt czy skojarzony plików tekstowych za pomocą edytora, takiego jak Notatnik, może mieć doc, jeśli pliki associated.doc z narzędzia edytora tekstów, takiego jak Microsoft Word. Podobnie, w tym samym jak robi **Uruchom** okno dialogowe zaakceptować nazwę pliku wykonywalnego z lub bez rozszerzeniem .exe, rozszerzeniem .exe jest opcjonalna w <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> elementu członkowskiego. Na przykład można ustawić <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości "Notepad.exe" lub "Notatnik".  
  
 Można uruchomić aplikacji ClickOnce, ustawiając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości do lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację. Nie należy uruchamiać aplikacji ClickOnce, określając jego zainstalowanej lokalizacji na dysku twardym.  
  
 Jeśli nazwa pliku obejmuje niewykonywalne pliku, na przykład plik doc mogą obejmować zlecenie określania, jaka akcja ma być do pliku. Na przykład można ustawić <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> do "Print" w odniesieniu do pliku w rozszerzeniem doc. Nazwa pliku określona w <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość musi mieć rozszerzenie, jeśli ręcznie wprowadzić wartość <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> właściwości. Jednak jeśli używasz <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> właściwości w celu określenia, jakie zlecenia są dostępne, musi zawierać rozszerzenia.  
  
 Można zmienić parametrów określonych w <xref:System.Diagnostics.Process.StartInfo%2A> właściwości do czasu, który można wywołać <xref:System.Diagnostics.Process.Start%2A> metody w procesie. Po rozpoczęciu procesu zmiana <xref:System.Diagnostics.Process.StartInfo%2A> wartości nie wpływa na lub uruchom ponownie skojarzony proces. Jeśli należy wywołać <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> metody z <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> zestaw właściwości, niezarządzanej `CreateProcessWithLogonW` zostanie wywołana funkcja, która uruchamia proces w nowe okno nawet jeśli <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> wartość właściwości jest `true` lub <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> wartość właściwości jest <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Jeśli nie używasz <xref:System.Diagnostics.Process.Start%2A> metodę, aby uruchomić proces, <xref:System.Diagnostics.Process.StartInfo%2A> właściwości nie odzwierciedla parametry używane do uruchomienia procesu. Na przykład, jeśli używasz <xref:System.Diagnostics.Process.GetProcesses%2A> uzyskać tablicę procesów uruchomionych na komputerze, <xref:System.Diagnostics.Process.StartInfo%2A> właściwości każdego <xref:System.Diagnostics.Process> nie zawiera oryginalna nazwa pliku lub argumenty używane do uruchamiania procesu.  
  
 Po uruchomieniu procesu, nazwa pliku jest plik, który wypełnia (tylko do odczytu) <xref:System.Diagnostics.Process.MainModule%2A> właściwości. Jeśli chcesz pobrać plik wykonywalny, który jest skojarzony z procesem, po rozpoczęciu procesu, użyj <xref:System.Diagnostics.Process.MainModule%2A> właściwości. Jeśli chcesz ustawić plik wykonywalny <xref:System.Diagnostics.Process> wystąpienia, dla którego skojarzony proces nie został uruchomiony, użyj <xref:System.Diagnostics.Process.StartInfo%2A> właściwości <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> elementu członkowskiego. Ponieważ członków <xref:System.Diagnostics.Process.StartInfo%2A> właściwości są argumenty, które są przekazywane do <xref:System.Diagnostics.Process.Start%2A> metody procesu zmiana <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości po rozpoczęciu skojarzonego procesu nie spowoduje zresetowanie <xref:System.Diagnostics.Process.MainModule%2A> właściwości. Te właściwości są używane tylko w celu zainicjowania skojarzonego procesu.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Diagnostics.Process.StartInfo%2A> z pliku do wykonania akcji wykonywać na nim i określa, czy powinien on wyświetla interfejsu użytkownika. Dodatkowe przykłady można znaleźć na stronach właściwości <xref:System.Diagnostics.ProcessStartInfo> klasy.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość, która określa <see cref="P:System.Diagnostics.Process.StartInfo" /> jest <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera godzinę rozpoczęcia skojarzonego procesu.</summary>
        <value>Obiekt, który wskazuje, kiedy rozpocząć proces. Jeśli nie jest uruchomiony proces jest zgłaszany wyjątek.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.StartTime" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został zakończony.  - lub - proces nie został uruchomiony.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd w wywołaniu funkcji systemu Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane w wyniku zdarzenia zakończenia procesu.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Używany do organizowania wywołań obsługi zdarzeń, które są wydawane w <see cref="E:System.Diagnostics.Process.Exited" /> zdarzenia w procesie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> jest `null`, metody, które obsługują <xref:System.Diagnostics.Process.Exited> zdarzenia są wywołany w wątku z puli wątków systemu. Aby uzyskać więcej informacji na temat pule wątków systemu, zobacz <xref:System.Threading.ThreadPool>.  
  
 Gdy <xref:System.Diagnostics.Process.Exited> zdarzenie jest obsługiwane przez składnik visual formularzy systemu Windows, takich jak <xref:System.Windows.Forms.Button>, dostęp do składnika za pośrednictwem puli wątków systemu mogą nie działać lub może spowodować wyjątek. Tego uniknąć, ustawiając <xref:System.Diagnostics.Process.SynchronizingObject%2A> składnika formularzy systemu Windows, co powoduje, że metody obsługi <xref:System.Diagnostics.Process.Exited> zdarzeń ma być wywołane na tym samym wątku, w której utworzono składnika.  
  
 Jeśli <xref:System.Diagnostics.Process> jest używany wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w projektancie formularzy systemu Windows, <xref:System.Diagnostics.Process.SynchronizingObject%2A> jest automatycznie ustawiana formant, który zawiera <xref:System.Diagnostics.Process>. Na przykład, jeśli zostanie <xref:System.Diagnostics.Process> na projektanta dla `Form1` (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.Process.SynchronizingObject%2A> właściwość <xref:System.Diagnostics.Process> ustawiono wystąpienie `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Ta właściwość ma zwykle wartość gdy składnik jest umieszczony wewnątrz formantu lub formularza, ponieważ te składniki są powiązane z konkretnym wątkiem.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw wątków, które są uruchomione w skojarzonych procesach.</summary>
        <value>Tablica typu <see cref="T:System.Diagnostics.ProcessThread" /> reprezentujący system operacyjny wątki uruchomione w skojarzonych procesach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek wykonuje kod w procesie. Każdy proces jest uruchomiony z jednym wątkiem, a jego podstawowym wątku. Którymkolwiek wątku można utworzyć dodatkowe wątki. Wątki w ramach procesu udostępniania przestrzeni adresowej procesu.  
  
 Użyj <xref:System.Diagnostics.ProcessThread> można pobrać wszystkie wątki skojarzone z bieżącym procesie. Podstawowy wątek nie jest w indeksie zero w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Proces nie ma <see cref="P:System.Diagnostics.Process.Id" />, lub jest skojarzony żaden proces <see cref="T:System.Diagnostics.Process" /> wystąpienia.  - lub - skojarzony proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> można uzyskać dostępu do tej właściwości w systemach Windows 98 i systemu Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formatuje nazwa procesu jako ciąg, w połączeniu z typu składnika nadrzędnego, jeśli ma to zastosowanie.</summary>
        <returns>
          <see cref="P:System.Diagnostics.Process.ProcessName" />, Połączonych ze składnikiem podstawowej <see cref="M:System.Object.ToString" /> zwracają wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> nie jest obsługiwana w systemach Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitego czasu procesora dla tego procesu.</summary>
        <value>A <see cref="T:System.TimeSpan" /> który wskazuje ilość czasu skojarzonego procesu ma wykorzystanie procesora CPU. Ta wartość jest sumą <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> i <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas użytkownika procesora dla tego procesu.</summary>
        <value>A <see cref="T:System.TimeSpan" /> który wskazuje czas spędzony skojarzonego procesu uruchamianie kodu w aplikacji część procesu (nie wewnątrz rdzenia systemu operacyjnego).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar pamięci wirtualnej przez proces, w bajtach.</summary>
        <value>Ilość pamięci wirtualnej w bajtach, które zażądał skojarzonego procesu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci wirtualnej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci wirtualnej w bajtach przydzielone skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar wirtualnej pamięci używanej przez proces w bajtach. System operacyjny mapuje wirtualnej przestrzeni adresowej dla każdego procesu załadowane do stron w pamięci fizycznej ani stron przechowywane w pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Bajty wirtualne** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia okres oczekiwania skojarzonego procesu zakończenia i bloki bieżącego wątku wykonywania, dopóki nie upłynie czas lub proces został zakończony. Aby uniknąć zablokowania bieżącego wątku, należy użyć <see cref="E:System.Diagnostics.Process.Exited" /> zdarzeń.  Aby uzyskać przykłady kodu, zobacz <see cref="P:System.Diagnostics.Process.StandardError" /> i <see cref="P:System.Diagnostics.Process.ExitCode" /> strony właściwości odwołania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika nieograniczony czas oczekiwania na zakończenie skojarzonego procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> powoduje, że bieżący wątek, poczekaj, aż do zakończenia skojarzonego procesu.  Należy wywołać po wszystkie inne metody są nazywane procesu. Aby uniknąć zablokowania bieżącego wątku, należy użyć <xref:System.Diagnostics.Process.Exited> zdarzeń.  
  
 Ta metoda powoduje, że <xref:System.Diagnostics.Process> składnika oczekiwania nieskończoną ilość czasu dla procesu i programów obsługi zakończyć. Może to spowodować, że aplikacja przestanie odpowiadać. Na przykład, jeśli wywołujesz <xref:System.Diagnostics.Process.CloseMainWindow%2A> dla procesu, który ma interfejsu użytkownika, żądanie do systemu operacyjnego zakończenie skojarzonego procesu może nie zostać obsłużone, jeśli proces zapisywany jest komunikat nigdy nie wprowadzają jego pętli komunikatów.  
  
> [!NOTE]
>  W [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] i wcześniejsze wersje <xref:System.Diagnostics.Process.WaitForExit> przeciążenia czas potrzebny na <xref:System.Int32.MaxValue> milisekund (około 24 dni), nie w nieskończoność. Ponadto poprzednie wersje czeka obsługi zdarzeń zakończyć, jeśli cały <xref:System.Int32.MaxValue> czasu został osiągnięty.  
  
 To przeciążenie zapewnia zakończenie przetwarzania w tym obsługi zdarzenia asynchroniczne dla przekierowania wyjścia standardowego. To przeciążenie należy używać po wywołaniu <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> przeciążenia podczas wyjścia standardowego został przekierowany do obsługi zdarzeń asynchronicznego.  
  
 Gdy skojarzony proces zostanie zakończony (Jeśli zostanie ona zamknięta przez system operacyjny za pośrednictwem zakończenia prawidłowe lub nieprawidłowe), system przechowuje administracyjne informacji o procesie i zwraca do składnika, który wywołał <xref:System.Diagnostics.Process.WaitForExit>. <xref:System.Diagnostics.Process> Składnika można następnie uzyskać dostęp do informacji, w tym <xref:System.Diagnostics.Process.ExitTime%2A>, za pomocą <xref:System.Diagnostics.Process.Handle%2A> do procesu zakończone.  
  
 Ponieważ skojarzony proces został zakończony, <xref:System.Diagnostics.Process.Handle%2A> właściwość składnika nie wskazuje na istniejący zasób procesu. Zamiast tego dojścia może służyć tylko dostęp do systemu operacyjnego informacji o zasobie procesu. System jest świadome dojścia do zakończone procesy, które nie zostały zwolnione przez <xref:System.Diagnostics.Process> składników, więc zapewnia <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci do <xref:System.Diagnostics.Process> składnika w szczególności zwalnia zasoby. Z tego powodu dowolnej chwili, należy wywołać <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia, należy wywołać <xref:System.Diagnostics.Process.Close%2A> gdy skojarzony proces został zakończony i nie ma już potrzeby administracyjne żadnych informacji ich dotyczących. <xref:System.Diagnostics.Process.Close%2A> zwalnia pamięć przydzielona do procesu zakończone.  
  
   
  
## Examples  
 Zobacz sekcję uwag <xref:System.Diagnostics.Process.StandardError%2A> strona właściwości odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można uzyskać dostępu do ustawienia oczekiwania.</exception>
        <exception cref="T:System.SystemException">Żaden proces <see cref="P:System.Diagnostics.Process.Id" /> została ustawiona, a <see cref="P:System.Diagnostics.Process.Handle" /> z którego <see cref="P:System.Diagnostics.Process.Id" /> można określić właściwości nie istnieje.  - lub - nie ma żadnych procesów skojarzonych z tym <see cref="T:System.Diagnostics.Process" /> obiektu.  Próba wywołania - lub - <see cref="M:System.Diagnostics.Process.WaitForExit" /> dla procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Ilość czasu (w milisekundach) oczekiwania na zakończenie skojarzonego procesu. Maksymalna liczba to największa możliwa wartość 32-bitową liczbę całkowitą, na reprezentujący nieskończoności do systemu operacyjnego.</param>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika oczekiwania określoną liczbę milisekund zakończenie skojarzonego procesu.</summary>
        <returns>
          <see langword="true" /> Jeśli skojarzony proces został zakończony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> powoduje, że bieżący wątek, poczekaj, aż do zakończenia skojarzonego procesu. Należy wywołać po wszystkie inne metody są nazywane procesu. Aby uniknąć zablokowania bieżącego wątku, należy użyć <xref:System.Diagnostics.Process.Exited> zdarzeń.  
  
 Ta metoda powoduje, że <xref:System.Diagnostics.Process> składnika oczekiwania ograniczona ilość czasu na zakończenie procesu. Jeśli do końca interwału skojarzonego procesu nie zamknięty, ponieważ nastąpiła odmowa żądania, aby zakończyć `false` jest zwracana do procedury wywołującej. Można określić <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> dla `milliseconds`, i <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> będą zachowywać się taka sama jak <xref:System.Diagnostics.Process.WaitForExit> przeciążenia. Jeśli możesz przekazać do metody 0 (zero), zwraca `true` tylko wtedy, gdy proces został już zakończony; w przeciwnym razie natychmiast zwraca `false`.  
  
> [!NOTE]
>  W [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] i starszych wersjach, jeśli `milliseconds` został -1, <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> przeciążenia czas potrzebny na <xref:System.Int32.MaxValue> milisekund (około 24 dni), nie zawsze.  
  
 Standardowe dane wyjściowe został przekierowany do obsługi zdarzeń asynchroniczne, jest to możliwe, że przetwarzanie danych wyjściowych nie będzie została ukończona, gdy metoda zwróci wartość. Aby zakończenie obsługi zdarzenia asynchroniczne, wywołaj <xref:System.Diagnostics.Process.WaitForExit> przeciążenia, które przyjmuje żadnego parametru od momentu odebrania `true` z tego przeciążenia. Aby zapewnić <xref:System.Diagnostics.Process.Exited> zdarzeń odbywa się prawidłowo w formularzach systemu Windows, należy ustawić <xref:System.Diagnostics.Process.SynchronizingObject%2A> właściwości.  
  
 Gdy skojarzony proces zostanie zakończony (zostanie zamknięta przez system operacyjny za pośrednictwem zakończenia prawidłowe lub nieprawidłowe), system przechowuje administracyjne informacji o procesie i zwraca do składnika, który wywołał <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. <xref:System.Diagnostics.Process> Składnika można następnie uzyskać dostęp do informacji, w tym <xref:System.Diagnostics.Process.ExitTime%2A>, za pomocą <xref:System.Diagnostics.Process.Handle%2A> do procesu zakończone.  
  
 Ponieważ skojarzony proces został zakończony, <xref:System.Diagnostics.Process.Handle%2A> właściwość składnika nie wskazuje na istniejący zasób procesu. Zamiast tego dojścia może służyć tylko dostęp do systemu operacyjnego informacji o zasobie procesu. System jest świadome dojścia do zakończone procesy, które nie zostały zwolnione przez <xref:System.Diagnostics.Process> składników, więc zapewnia <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci do <xref:System.Diagnostics.Process> składnika w szczególności zwalnia zasoby. Z tego powodu dowolnej chwili, należy wywołać <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia, należy wywołać <xref:System.Diagnostics.Process.Close%2A> gdy skojarzony proces został zakończony i nie ma już potrzeby administracyjne żadnych informacji ich dotyczących. <xref:System.Diagnostics.Process.Close%2A> zwalnia pamięć przydzielona do procesu zakończone.  
  
   
  
## Examples  
 Zobacz przykład kodu <xref:System.Diagnostics.Process.ExitCode%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można uzyskać dostępu do ustawienia oczekiwania.</exception>
        <exception cref="T:System.SystemException">Żaden proces <see cref="P:System.Diagnostics.Process.Id" /> została ustawiona, a <see cref="P:System.Diagnostics.Process.Handle" /> z którego <see cref="P:System.Diagnostics.Process.Id" /> można określić właściwości nie istnieje.  - lub - nie ma żadnych procesów skojarzonych z tym <see cref="T:System.Diagnostics.Process" /> obiektu.  Próba wywołania - lub - <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> dla procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika oczekiwania skojarzonego procesu na przejściu w stan bezczynności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika będzie czekać w nieskończoność skojarzonego procesu na przejściu w stan bezczynności. To przeciążenie dotyczy tylko procesów przy użyciu interfejsu użytkownika, w związku z tym pętli komunikatów.</summary>
        <returns>
          <see langword="true" /> Jeśli skojarzonego procesu osiągnął stanu bezczynności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.WaitForInputIdle> wymusić przetwarzania aplikacji poczekać, aż pętli komunikatów powrócił do stanu bezczynności. Podczas wykonywania procesu za pomocą interfejsu użytkownika jego Pętla wiadomości jest wykonywana za każdym razem, gdy komunikatów systemu Windows są wysyłane do procesu przez system operacyjny. Proces zwraca do pętli komunikatów. Proces jest nazywany jest w stanie bezczynności, jeśli oczekuje na komunikaty wewnątrz pętli komunikatów. Ten stan jest przydatne, na przykład, gdy aplikacja musi czekać na uruchamiania procesu zakończyć tworzenie okna głównego, zanim aplikacja komunikuje się z tego okna.  
  
 Jeśli proces nie ma pętlę komunikatów <xref:System.Diagnostics.Process.WaitForInputIdle> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> Powoduje, że przeciążenia <xref:System.Diagnostics.Process> składnika będzie czekać w nieskończoność procesu w stan bezczynności w pętli komunikatów. Tej instrukcji można spowodować, że aplikacja przestanie odpowiadać. Na przykład, jeśli proces są zawsze zapisywane zakończyć jego pętli komunikatów natychmiast, tak jak fragmentu kodu `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie ma interfejsu graficznego.  - lub - wystąpił nieznany błąd. Nie można wprowadzić stanu bezczynności.  - lub - proces został już zakończony.  - lub - nie jest skojarzony z tym żaden proces <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Wartość 1, aby <see cref="F:System.Int32.MaxValue" /> ilość czasu, który określa w milisekundach, poczekaj, aż przejdzie w stan bezczynności skojarzonego procesu. Wartość 0 określa bezpośredniego zwrotu i nieskończone oczekiwanie określa wartość -1.</param>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika oczekiwania określoną liczbę milisekund skojarzonego procesu na przejściu w stan bezczynności. To przeciążenie dotyczy tylko procesów przy użyciu interfejsu użytkownika, w związku z tym pętli komunikatów.</summary>
        <returns>
          <see langword="true" /> Jeśli skojarzonego procesu osiągnął stanu bezczynności; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> wymusić przetwarzania aplikacji poczekać, aż pętli komunikatów powrócił do stanu bezczynności. Podczas wykonywania procesu za pomocą interfejsu użytkownika jego Pętla wiadomości jest wykonywana za każdym razem, gdy komunikatów systemu Windows są wysyłane do procesu przez system operacyjny. Proces zwraca do pętli komunikatów. Proces jest nazywany jest w stanie bezczynności, jeśli oczekuje na komunikaty wewnątrz pętli komunikatów. Ten stan jest przydatne, na przykład, gdy aplikacja musi czekać na uruchamiania procesu zakończyć tworzenie okna głównego, zanim aplikacja komunikuje się z tego okna.  
  
 Jeśli proces nie ma pętlę komunikatów <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Powoduje, że przeciążenia <xref:System.Diagnostics.Process> składnika oczekiwania ograniczona ilość czasu dla procesu w stan bezczynności w pętli komunikatów. Jeśli skojarzony proces został przejdzie w stan bezczynności końca interwał ponieważ pętli nadal przetwarza wiadomości, `false` jest zwracana do procedury wywołującej.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie ma interfejsu graficznego.  - lub - wystąpił nieznany błąd. Nie można wprowadzić stanu bezczynności.  - lub - proces został już zakończony.  - lub - nie jest skojarzony z tym żaden proces <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera skojarzonego procesu wykorzystania pamięci fizycznej w bajtach.</summary>
        <value>Całkowita ilość pamięci fizycznej skojarzone używanej przez proces, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje pracy zestawu pamięci używanej przez proces w bajtach bieżący rozmiar. Zestaw roboczy procesu to zbiór stron pamięci widocznych aktualnie przez proces w pamięci fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, aby użyć bez wyzwalania błąd strony.  
  
 Zestaw roboczy zawiera dane zarówno udostępnionego, jak i prywatnych. Udostępnionych danych obejmuje stron, które zawierają instrukcje, które wykonuje proces, łącznie z modułami procesu i biblioteki systemu.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci fizycznej w bajtach przydzielone skojarzonego procesu.</summary>
        <value>Ilość pamięci fizycznej w bajtach przydzielone skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje pracy zestawu pamięci używanej przez proces w bajtach bieżący rozmiar. Zestaw roboczy procesu to zbiór stron pamięci widocznych aktualnie przez proces w pamięci fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, aby użyć bez wyzwalania błąd strony.  
  
 Zestaw roboczy zawiera dane zarówno udostępnionego, jak i prywatnych. Udostępnionych danych obejmuje stron, które zawierają instrukcje, które wykonuje proces, łącznie z instrukcjami w modułach procesu i biblioteki systemu.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **zestaw roboczy** licznik wydajności procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa kończy proces i wyświetla jego statystyki pamięci zakończenia, jak kod i godzinami szczytu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
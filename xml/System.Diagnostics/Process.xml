<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e86827f17b9b76752a39897defd149ec700f5789" /><Meta Name="ms.sourcegitcommit" Value="a81314feefaa9d10797d6bfe39dab52ca7fd1709" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/22/2019" /><Meta Name="ms.locfileid" Value="69973133" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do procesów lokalnych i zdalnych oraz umożliwia uruchamianie i zatrzymywanie procesów systemu lokalnego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> Składnik zapewnia dostęp do procesu, który jest uruchomiony na komputerze. Proces, w najprostszych warunkach, jest uruchomioną aplikacją. Wątek jest jednostką podstawową, do której system operacyjny przydziela czas procesora. Wątek może wykonać dowolną część kodu procesu, w tym części, które są aktualnie wykonywane przez inny wątek.  
  
 <xref:System.Diagnostics.Process> Składnik jest użytecznym narzędziem do uruchamiania, zatrzymywania, kontrolowania i monitorowania aplikacji. Możesz użyć <xref:System.Diagnostics.Process> składnika, aby uzyskać listę procesów, które są uruchomione, lub można uruchomić nowy proces. <xref:System.Diagnostics.Process> Składnik służy do uzyskiwania dostępu do procesów systemowych. Po zainicjowaniu <xref:System.Diagnostics.Process> składnika można go użyć, aby uzyskać informacje o uruchomionym procesie. Takie informacje obejmują zestaw wątków, załadowanych modułów (pliki. dll i. exe) oraz informacje o wydajności, takie jak ilość pamięci używanej przez proces.  
  
 Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `finally` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
> [!NOTE]
>  32 — procesy bitowe nie mogą uzyskać dostępu do modułów procesu 64-bitowego. Jeśli spróbujesz uzyskać informacje o procesie 64-bitowym z procesu 32-bitowym, zostanie wyświetlony <xref:System.ComponentModel.Win32Exception> wyjątek. Proces 64-bitowy, z drugiej strony, może uzyskać dostęp do modułów procesu 32-bitowego.  
  
 Składnik procesu uzyskuje informacje o grupie Właściwości wszystkie jednocześnie. Gdy składnik uzyska informacje o jednym członku dowolnej grupy, będzie buforować wartości innych właściwości w tej grupie i nie otrzymuje nowych informacji o innych elementach członkowskich grupy do momentu <xref:System.Diagnostics.Process.Refresh%2A> wywołania metody. <xref:System.Diagnostics.Process> W związku z tym nie ma gwarancji, że wartość właściwości nie może być nowsza niż ostatnie <xref:System.Diagnostics.Process.Refresh%2A> wywołanie metody. Podziały grup są zależne od systemu operacyjnego.  
  
 Jeśli masz zmienną PATH zadeklarowaną w systemie przy użyciu cudzysłowów, musisz w pełni zakwalifikować tę ścieżkę podczas uruchamiania dowolnego procesu znajdującego się w tej lokalizacji. W przeciwnym razie system nie znajdzie ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce i dodasz ją przy użyciu cudzysłowu: `path = %path%;"c:\mypath"`, należy w `c:\mypath` pełni zakwalifikować każdy proces podczas jego uruchamiania.  
  
 Proces systemowy jest jednoznacznie identyfikowany w systemie przez jego identyfikator procesu. Podobnie jak w przypadku wielu zasobów systemu Windows, proces jest również identyfikowany przez jego uchwyt, który może nie być unikatowy na komputerze. Dojście jest ogólnym terminem dla identyfikatora zasobu. System operacyjny utrzymuje dojście procesu, do którego dostęp jest uzyskiwany przez <xref:System.Diagnostics.Process.Handle%2A> Właściwość <xref:System.Diagnostics.Process> składnika, nawet jeśli proces został zakończony. W związku z tym można uzyskać informacje administracyjne procesu, takie jak <xref:System.Diagnostics.Process.ExitCode%2A> (zazwyczaj zero dla sukcesu lub niezerowego kodu błędu) <xref:System.Diagnostics.Process.ExitTime%2A>i. Dojścia są niezwykle cennymi zasobami, więc przecieki są bardziej virulent niż przeciek pamięci.  
  
> [!NOTE]
>  Ta klasa zawiera żądanie łącza i dziedziczenia na poziomie klasy stosowane do wszystkich składowych. Występuje <xref:System.Security.SecurityException> , gdy bezpośredni obiekt wywołujący lub Klasa pochodna nie ma uprawnienia pełnego zaufania. Aby uzyskać szczegółowe informacje o wymaganiach dotyczących zabezpieczeń, zobacz [wymagania dotyczące linków](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenet_coreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)]O  
 W .NET Framework <xref:System.Diagnostics.Process> Klasa domyślnie używa <xref:System.Console> kodowania, które zwykle kodowania strony kodowej, dla strumieni danych wejściowych, wyjściowych i błędów. Na przykład kod, w systemach, których kultura jest w języku angielskim (Stany Zjednoczone), strona kodowa 437 jest domyślnym <xref:System.Console> kodowaniem dla klasy. [!INCLUDE[net_core](~/includes/net-core-md.md)] Jednak mogą być dostępne tylko ograniczone podzbiór tych kodowań. W takim przypadku jest używane <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> jako domyślne kodowanie.  
  
 Jeśli obiekt zależy od określonych kodowań stron kodowych, można nadal udostępnić je, wykonując następujące czynności *przed* wywołaniem jakichkolwiek <xref:System.Diagnostics.Process> metod: <xref:System.Diagnostics.Process>  
  
1.  Dodaj odwołanie do zestawu System. Text. Encoding. CodePage. dll do projektu.  
  
2.  <xref:System.Text.EncodingProvider> Pobierz obiekt<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> z właściwości.  
  
3.  <xref:System.Text.EncodingProvider> Przekaż obiekt<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> do metody, aby umożliwić dostęp do dodatkowych kodowań obsługiwanych przez dostawcę kodowania.  
  
 Następnie Klasa automatycznie użyje domyślnego kodowania systemowego zamiast UTF8, pod warunkiem, że zarejestrowano dostawcę kodowania przed wywołaniem <xref:System.Diagnostics.Process> jakichkolwiek metod. <xref:System.Diagnostics.Process>  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano wystąpienie <xref:System.Diagnostics.Process> klasy do uruchomienia procesu.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 Poniższy przykład używa <xref:System.Diagnostics.Process> samej klasy i metody statycznej <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 W poniższym F# przykładzie zdefiniowano `runProc` funkcję, która uruchamia proces, przechwytuje wszystkie dane wyjściowe i informacje o błędzie oraz rejestruje liczbę milisekund, w których proces został uruchomiony.  `runProc` Funkcja ma trzy parametry: Nazwa aplikacji do uruchomienia, argumenty do dostarczenia do aplikacji i katalog początkowy.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Kod `runProc` funkcji został zapisany przez [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) i jest dostępny w ramach [publicznej licencji firmy Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Korzystanie z klasy procesu .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.Process" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Diagnostics.Process.MachineName%2A> właściwość nie zostanie określona, wartość domyślna to komputer lokalny, (".").  
  
 Istnieją dwie opcje kojarzenia nowego <xref:System.Diagnostics.Process> składnika z procesem na komputerze. Pierwsza opcja polega na użyciu <xref:System.Diagnostics.Process> konstruktora do utworzenia składnika, skonfigurowania odpowiednich członków <xref:System.Diagnostics.Process.StartInfo%2A> właściwości <xref:System.Diagnostics.Process> i wywołania <xref:System.Diagnostics.Process.Start%2A> w celu skojarzenia z nowym procesem systemowym. Druga opcja polega na skojarzeniu <xref:System.Diagnostics.Process> z uruchomionym procesem systemowym przy użyciu <xref:System.Diagnostics.Process.GetProcessById%2A> lub jednej z <xref:System.Diagnostics.Process.GetProcesses%2A> wartości zwracanych.  
  
 Jeśli używasz `static` przeciążenia <xref:System.Diagnostics.Process.Start%2A> metody do uruchamiania nowego procesu systemowego, metoda tworzy nowy <xref:System.Diagnostics.Process> składnik i kojarzy go z procesem.  
  
 Gdy właściwość jest ustawiona na wartość domyślną, `true`można uruchamiać aplikacje i dokumenty w sposób podobny do `Run` okna dialogowego menu systemu Windows `Start`. <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> tak `false`jest, można uruchamiać tylko pliki wykonywalne.  
  
 Każdy plik wykonywalny, który można wywołać z wiersza polecenia, można uruchomić na jeden z dwóch sposobów: przez ustawienie odpowiednich elementów członkowskich <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i <xref:System.Diagnostics.Process.Start%2A> wywołanie metody bez parametrów lub przez przekazanie odpowiedniego parametru do `static` element członkowski<xref:System.Diagnostics.Process.Start%2A> .  
  
 Można <xref:System.Diagnostics.Process> utworzyć składnik przy użyciu konstruktora, jednego z przeciążeń statycznych <xref:System.Diagnostics.Process.Start%2A> lub dowolnej <xref:System.Diagnostics.Process.GetProcessById%2A>metody, <xref:System.Diagnostics.Process.GetProcesses%2A>lub <xref:System.Diagnostics.Process.GetProcessesByName%2A> . Po wykonaniu tej czynności będziesz mieć wgląd w skojarzony proces. To nie jest Widok dynamiczny, który automatycznie aktualizuje się, gdy właściwości procesu uległy zmianie w pamięci. Zamiast tego należy wywołać <xref:System.Diagnostics.Process.Refresh%2A> dla składnika, aby <xref:System.Diagnostics.Process> zaktualizować informacje o właściwościach w aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowy priorytet skojarzonego procesu.</summary>
        <value>Priorytet podstawowy, który jest obliczany na podstawie <see cref="P:System.Diagnostics.Process.PriorityClass" /> skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> Proces jest priorytetem początkowym dla wątków utworzonych w ramach skojarzonego procesu. Informacje o priorytecie podstawowym można wyświetlić za pomocą bazowego licznika priorytetowego monitora systemu.  
  
 W zależności od czasu, który upłynął lub inne usprawnienia, system operacyjny może zmienić priorytet podstawowy, gdy proces powinien zostać umieszczony przed innymi.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Właściwość umożliwia wyświetlenie priorytetu początkowego przypisanego do procesu. Jednak ponieważ jest tylko <xref:System.Diagnostics.Process.BasePriority%2A> do odczytu, nie można użyć do ustawienia priorytetu procesu. Aby zmienić priorytet, użyj <xref:System.Diagnostics.Process.PriorityClass%2A> właściwości. Jest on widoczny przy użyciu Monitora systemu, <xref:System.Diagnostics.Process.PriorityClass%2A> natomiast nie jest. <xref:System.Diagnostics.Process.BasePriority%2A> <xref:System.Diagnostics.Process.BasePriority%2A> Zarówno ,<xref:System.Diagnostics.Process.PriorityClass%2A> jak i można programowo przeglądać. W poniższej tabeli przedstawiono relacje między <xref:System.Diagnostics.Process.BasePriority%2A> wartościami i <xref:System.Diagnostics.Process.PriorityClass%2A> wartościami.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces został zakończony.  
  
 —lub—  
  
 Proces nie został uruchomiony, dlatego nie ma identyfikatora procesu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna asynchroniczne operacje odczytu w przekierowanym <see cref="P:System.Diagnostics.Process.StandardError" /> strumieniu aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> Strumień można odczytywać synchronicznie lub asynchronicznie. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonują synchroniczne operacje odczytu w strumieniu wyjściowym procesu. Te synchroniczne operacje odczytu nie są wykonywane do momentu <xref:System.Diagnostics.Process> skojarzonego zapisu w <xref:System.Diagnostics.Process.StandardError%2A> jego strumieniu lub zamknięcia strumienia.  
  
 Z kolei program <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> uruchamia asynchroniczne operacje odczytu <xref:System.Diagnostics.Process.StandardError%2A> w strumieniu. Ta metoda umożliwia wyznaczeniu programu obsługi zdarzeń dla danych wyjściowych strumienia i natychmiastowe powrót do obiektu wywołującego, który może wykonywać inne czynności, gdy dane wyjściowe strumienia są kierowane do programu obsługi zdarzeń.  
  
 Wykonaj następujące kroki, aby wykonać asynchroniczne operacje <xref:System.Diagnostics.Process.StandardError%2A> odczytu <xref:System.Diagnostics.Process> dla:  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ustaw wartość .`false`  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> Ustaw wartość .`true`  
  
3.  Dodaj obsługę zdarzeń do <xref:System.Diagnostics.Process.ErrorDataReceived> zdarzenia. Program obsługi zdarzeń musi być zgodny <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> z podpisem delegata.  
  
4.  <xref:System.Diagnostics.Process>Uruchom.  
  
5.  Wywołanie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> .<xref:System.Diagnostics.Process> To wywołanie uruchamia asynchroniczne operacje odczytu w <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Po rozpoczęciu asynchronicznych operacji odczytu procedura obsługi zdarzeń jest wywoływana za każdym <xref:System.Diagnostics.Process> razem, gdy skojarzone zapisuje wiersz tekstu <xref:System.Diagnostics.Process.StandardError%2A> w jego strumieniu.  
  
 Można anulować asynchroniczne operacje odczytu przez wywołanie <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Operacja odczytu może zostać anulowana przez obiekt wywołujący lub przez procedurę obsługi zdarzeń. Po anulowaniu można wywoływać <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ponownie w celu wznowienia asynchronicznych operacji odczytu.  
  
> [!NOTE]
>  Nie można mieszać asynchronicznych i synchronicznych operacji odczytu w przekierowanym strumieniu. Gdy przekierowany strumień a <xref:System.Diagnostics.Process> zostanie otwarty w trybie asynchronicznym lub synchronicznym, wszystkie dalsze operacje odczytu w tym strumieniu muszą znajdować się w tym samym trybie. Na przykład nie należy śledzić <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wywołania do <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardError%2A> strumienia lub na odwrót. Można jednak odczytywać dwa różne strumienie w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> i wywołać <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardOutput%2A> strumień.  
  
   
  
## Examples  
 Poniższy przykład używa `net view` polecenia, aby wyświetlić listę dostępnych zasobów sieciowych na komputerze zdalnym. Użytkownik dostarcza nazwę komputera docelowego jako argument wiersza polecenia. Użytkownik może również podać nazwę pliku dla danych wyjściowych błędu. Przykład zbiera dane wyjściowe polecenia NET, czeka na zakończenie procesu, a następnie zapisuje wyniki wyjściowe w konsoli programu. Jeśli użytkownik poda opcjonalny plik błędu, przykład zapisuje błędy do pliku.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> Właściwość jest<see langword="false" />.  
  
—lub— 
Asynchroniczna operacja odczytu jest już w toku w <see cref="P:System.Diagnostics.Process.StandardError" /> strumieniu.  
  
—lub— 
<see cref="P:System.Diagnostics.Process.StandardError" /> Strumień został użyty w operacji odczytu synchronicznego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna asynchroniczne operacje odczytu w przekierowanym <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumieniu aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> Strumień można odczytywać synchronicznie lub asynchronicznie. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonują synchroniczne operacje odczytu w strumieniu wyjściowym procesu. Te synchroniczne operacje odczytu nie są wykonywane do momentu <xref:System.Diagnostics.Process> skojarzonego zapisu w <xref:System.Diagnostics.Process.StandardOutput%2A> jego strumieniu lub zamknięcia strumienia.  
  
 Z kolei program <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> uruchamia asynchroniczne operacje odczytu <xref:System.Diagnostics.Process.StandardOutput%2A> w strumieniu. Ta metoda umożliwia wyznaczeniu programu obsługi zdarzeń dla danych wyjściowych strumienia i natychmiast powraca do obiektu wywołującego, który może wykonywać inne czynności, gdy dane wyjściowe strumienia są kierowane do programu obsługi zdarzeń.  
  
 Wykonaj następujące kroki, aby wykonać asynchroniczne operacje <xref:System.Diagnostics.Process.StandardOutput%2A> odczytu <xref:System.Diagnostics.Process> dla:  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Ustaw wartość .`false`  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> Ustaw wartość .`true`  
  
3.  Dodaj obsługę zdarzeń do <xref:System.Diagnostics.Process.OutputDataReceived> zdarzenia. Program obsługi zdarzeń musi być zgodny <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> z podpisem delegata.  
  
4.  <xref:System.Diagnostics.Process>Uruchom.  
  
5.  Wywołanie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> .<xref:System.Diagnostics.Process> To wywołanie uruchamia asynchroniczne operacje odczytu w <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Po rozpoczęciu asynchronicznych operacji odczytu procedura obsługi zdarzeń jest wywoływana za każdym <xref:System.Diagnostics.Process> razem, gdy skojarzone zapisuje wiersz tekstu <xref:System.Diagnostics.Process.StandardOutput%2A> w jego strumieniu.  
  
 Można anulować asynchroniczne operacje odczytu przez wywołanie <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Operacja odczytu może zostać anulowana przez obiekt wywołujący lub przez procedurę obsługi zdarzeń. Po anulowaniu można wywoływać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ponownie w celu wznowienia asynchronicznych operacji odczytu.  
  
> [!NOTE]
>  Nie można mieszać asynchronicznych i synchronicznych operacji odczytu w przekierowanym strumieniu. Gdy przekierowany strumień a <xref:System.Diagnostics.Process> zostanie otwarty w trybie asynchronicznym lub synchronicznym, wszystkie dalsze operacje odczytu w tym strumieniu muszą znajdować się w tym samym trybie. Na przykład nie należy śledzić <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wywołania do <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia lub na odwrót. Można jednak odczytywać dwa różne strumienie w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> i wywołać <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardError%2A> strumień.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wykonywania asynchronicznych operacji odczytu w przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumieniu `sort` polecenia. `sort` Polecenie jest aplikacją konsolową, która odczytuje i sortuje dane wejściowe tekstu.  
  
 Przykład tworzy delegata zdarzenia dla `SortOutputHandler` programu obsługi zdarzeń i kojarzy go <xref:System.Diagnostics.Process.OutputDataReceived> ze zdarzeniem. Program obsługi zdarzeń odbiera wiersze tekstowe z przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, formatuje tekst i zapisuje tekst na ekranie.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> Właściwość jest<see langword="false" />.  
  
—lub— 
Asynchroniczna operacja odczytu jest już w toku w <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumieniu.  
  
—lub— 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumień został użyty w operacji odczytu synchronicznego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje asynchroniczne operacje odczytu w przekierowanym <see cref="P:System.Diagnostics.Process.StandardError" /> strumieniu aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>uruchamia asynchroniczną operację <xref:System.Diagnostics.Process.StandardError%2A> odczytu strumienia. <xref:System.Diagnostics.Process.CancelErrorRead%2A>zamyka asynchroniczne operacje odczytu.  
  
 Po anulowaniu można wznowić asynchroniczne operacje odczytu, wywołując <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ponownie.  
  
 Po wywołaniu <xref:System.Diagnostics.Process.CancelErrorRead%2A>, wszystkie operacje odczytu w toku dla <xref:System.Diagnostics.Process.StandardError%2A> są wykonywane, a następnie program obsługi zdarzeń jest wyłączony. Wszystkie dalsze przekierowane dane <xref:System.Diagnostics.Process.StandardError%2A> wyjściowe do zostaną utracone. Po ponownym włączeniu procedury obsługi zdarzeń z wywołaniem <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>asynchroniczne operacje odczytu są wznawiane. Jeśli chcesz zmienić procedurę obsługi zdarzeń przed wznowieniem asynchronicznych operacji odczytu, musisz usunąć istniejącą procedurę obsługi zdarzeń przed dodaniem nowego programu obsługi zdarzeń:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  W przekierowanym <xref:System.Diagnostics.Process.StandardError%2A> strumieniu nie można mieszać asynchronicznych i synchronicznych operacji odczytu. Gdy przekierowany strumień a <xref:System.Diagnostics.Process> zostanie otwarty w trybie asynchronicznym lub synchronicznym, wszystkie dalsze operacje odczytu w tym strumieniu muszą znajdować się w tym samym trybie. W przypadku anulowania asynchronicznej operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> , a następnie należy ponownie odczytywać ze strumienia, należy użyć <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> do wznowienia asynchronicznych operacji odczytu. Nie <xref:System.Diagnostics.Process.CancelErrorRead%2A> należy wykonywać wywołania synchronicznych <xref:System.Diagnostics.Process.StandardError%2A> metod odczytu takich jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, lub <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Poniższy przykład uruchamia `nmake` polecenie z argumentami podanymi przez użytkownika. Strumienie błędów i danych wyjściowych są odczytywane asynchronicznie; zebrane wiersze tekstu są wyświetlane w konsoli programu, a także zapisywane w pliku dziennika. Jeśli dane wyjściowe polecenia przekraczają określoną liczbę wierszy, asynchroniczne operacje odczytu są anulowane.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> Strumień nie jest włączony dla asynchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje asynchroniczne operacje odczytu w przekierowanym <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumieniu aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>uruchamia asynchroniczną operację <xref:System.Diagnostics.Process.StandardOutput%2A> odczytu strumienia. <xref:System.Diagnostics.Process.CancelOutputRead%2A>zamyka asynchroniczne operacje odczytu.  
  
 Po anulowaniu można wznowić asynchroniczne operacje odczytu, wywołując <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ponownie.  
  
 Po wywołaniu <xref:System.Diagnostics.Process.CancelOutputRead%2A>, wszystkie operacje odczytu w toku dla <xref:System.Diagnostics.Process.StandardOutput%2A> są wykonywane, a następnie program obsługi zdarzeń jest wyłączony. Wszystkie dalsze przekierowywane dane <xref:System.Diagnostics.Process.StandardOutput%2A> wyjściowe do programu są zapisywane w buforze. Jeśli ponownie włączysz procedurę obsługi zdarzeń z wywołaniem <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, zapisane dane wyjściowe są wysyłane do programu obsługi zdarzeń i wznawia asynchroniczne operacje odczytu. Jeśli chcesz zmienić procedurę obsługi zdarzeń przed wznowieniem asynchronicznych operacji odczytu, musisz usunąć istniejącą procedurę obsługi zdarzeń przed dodaniem nowego programu obsługi zdarzeń:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  W przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumieniu nie można mieszać asynchronicznych i synchronicznych operacji odczytu. Gdy przekierowany strumień a <xref:System.Diagnostics.Process> zostanie otwarty w trybie asynchronicznym lub synchronicznym, wszystkie dalsze operacje odczytu w tym strumieniu muszą znajdować się w tym samym trybie. W przypadku anulowania asynchronicznej operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> , a następnie należy ponownie odczytywać ze strumienia, należy użyć <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> do wznowienia asynchronicznych operacji odczytu. Nie <xref:System.Diagnostics.Process.CancelOutputRead%2A> należy wykonywać wywołania synchronicznych <xref:System.Diagnostics.Process.StandardOutput%2A> metod odczytu takich jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, lub <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Poniższy przykład uruchamia `nmake` polecenie z argumentami podanymi przez użytkownika. Strumienie błędów i danych wyjściowych są odczytywane asynchronicznie; zebrane wiersze tekstu są wyświetlane w konsoli programu, a także zapisywane w pliku dziennika. Jeśli dane wyjściowe polecenia przekraczają określoną liczbę wierszy, asynchroniczne operacje odczytu są anulowane.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumień nie jest włączony dla asynchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są skojarzone z tym składnikiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> Metoda powoduje, że proces przerywa oczekiwanie na zakończenie w przypadku oczekiwania, zamyka uchwyt procesu i czyści właściwości specyficzne dla procesu. <xref:System.Diagnostics.Process.Close%2A>nie zamyka standardowych danych wyjściowych, wejściowych i błędów i autorów w przypadku, gdy są one przywoływane zewnętrznie.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> Metoda wywołuje<xref:System.Diagnostics.Process.Close%2A>metodę. Umieszczenie obiektu w bloku usuwania zasobów bez konieczności wywoływania <xref:System.Diagnostics.Process.Close%2A>. `using` <xref:System.Diagnostics.Process>  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej przez skojarzony proces w 2-sekundowych odstępach przez maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli nadal działa po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka proces, który ma interfejs użytkownika, wysyłając wiadomość zamykającą do okna głównego.</summary>
        <returns><see langword="true" />Jeśli komunikat zamknięcia został pomyślnie wysłany; <see langword="false" /> Jeśli skojarzony proces nie ma okna głównego lub okno główne jest wyłączone (na przykład w przypadku wyświetlenia modalnego okna dialogowego).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy proces jest wykonywany, jego pętla komunikatów jest w stanie oczekiwania. Pętla komunikatów jest wykonywana za każdym razem, gdy komunikat systemu Windows jest wysyłany do procesu przez system operacyjny. Wywołanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> wysyła żądanie zamknięcia głównego okna, które w dobrze uformowanej aplikacji zamyka okna podrzędne i odwołuje wszystkie uruchomione pętle komunikatów dla aplikacji. Żądanie zakończenia procesu przez wywołanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> nie wymusza zamknięcia aplikacji. Aplikacja może poprosił o weryfikację użytkownika przed zamknięciem lub może odmówić zamknięcia. Aby wymusić zakończenie działania aplikacji, należy <xref:System.Diagnostics.Process.Kill%2A> użyć metody. Zachowanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> jest takie samo jak w przypadku użytkownika zamykającego okno główne aplikacji przy użyciu menu systemowego. W związku z tym żądanie zakończenia procesu przez zamknięcie okna głównego nie wymusza natychmiastowego zakończenia działania aplikacji.  
  
 W przypadku wywołania <xref:System.Diagnostics.Process.Kill%2A>programu dane edytowane przez proces lub zasoby przydzielone do procesu mogą zostać utracone. <xref:System.Diagnostics.Process.Kill%2A>powoduje nietypowe zakończenie procesu i powinno być używane tylko wtedy, gdy jest to konieczne. <xref:System.Diagnostics.Process.CloseMainWindow%2A>Włącza uporządkowane zakończenie procesu i zamyka wszystkie okna, dlatego jest preferowany dla aplikacji z interfejsem. Jeśli <xref:System.Diagnostics.Process.CloseMainWindow%2A> to się nie powiedzie <xref:System.Diagnostics.Process.Kill%2A> , można użyć, aby zakończyć proces. <xref:System.Diagnostics.Process.Kill%2A>jest jedynym sposobem zakończenia procesów, które nie mają interfejsów graficznych.  
  
 Można wywołać <xref:System.Diagnostics.Process.Kill%2A> i <xref:System.Diagnostics.Process.CloseMainWindow%2A> tylko dla procesów, które są uruchomione na komputerze lokalnym. Nie można spowodować zakończenia procesów na komputerach zdalnych. Można wyświetlić tylko informacje dotyczące procesów uruchomionych na komputerach zdalnych.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej przez skojarzony proces w ciągu 2 sekund przez maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli nadal działa po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces został już zakończony.  
  
—lub— 
Żaden proces nie jest skojarzony z <see cref="T:System.Diagnostics.Process" /> tym obiektem.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwolnij wszystkie zasoby używane przez ten proces.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, <see cref="E:System.Diagnostics.Process.Exited" /> czy zdarzenie ma zostać zgłoszone po zakończeniu procesu.</summary>
        <value><see langword="true" />Jeśli zdarzenie ma zostać zgłoszone po zakończeniu skojarzonego procesu (za pomocą wyjścia lub <see cref="M:System.Diagnostics.Process.Kill" />wywołania); w przeciwnym razie <see langword="false" />. <see cref="E:System.Diagnostics.Process.Exited" /> Wartość domyślna to <see langword="false" />. Należy zauważyć, <see cref="E:System.Diagnostics.Process.Exited" /> że zdarzenie jest zgłaszane nawet wtedy, gdy <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> wartość <see langword="false" /> jest w momencie zakończenia procesu podczas lub przed wykonaniem <see cref="P:System.Diagnostics.Process.HasExited" /> sprawdzenia przez użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Właściwość sugeruje, czy składnik powinien zostać powiadomiony, gdy system operacyjny zamknie proces. Ta <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość jest używana w przetwarzaniu asynchronicznym w celu powiadomienia aplikacji o zakończeniu procesu. Aby wymusić, że aplikacja synchronicznie czeka na zdarzenie zakończenia (które przerywa przetwarzanie aplikacji do momentu wystąpienia zdarzenia zakończenia), użyj <xref:System.Diagnostics.Process.WaitForExit%2A> metody.

> [!NOTE]
> Jeśli używasz programu Visual Studio i dwukrotnie klikniesz <xref:System.Diagnostics.Process> składnik w projekcie <xref:System.Diagnostics.Process.Exited> , zostanie automatycznie wygenerowany obiekt delegowany zdarzeń i program obsługi zdarzeń. Dodatkowy kod ustawia <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość na `false`. Należy zmienić tę właściwość na, `true` aby program obsługi zdarzeń mógł zostać wykonany po zakończeniu skojarzonego procesu.

Jeśli <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> wartość składnika to `true`, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> lubgdy`false` jest wywoływanaprzezskładnik,składnikmożeuzyskaćdostępdoinformacjiadministracyjnychdlaskojarzonegoprocesu,którypozostanie<xref:System.Diagnostics.Process.HasExited%2A> przechowywane przez system operacyjny. Te informacje obejmują <xref:System.Diagnostics.Process.ExitTime%2A> <xref:System.Diagnostics.Process.ExitCode%2A>i.

Po zakończeniu <xref:System.Diagnostics.Process.Handle%2A> skojarzonego procesu składnik składnika nie będzie już wskazywał istniejącego zasobu procesu. Zamiast tego można go użyć tylko w celu uzyskania dostępu do informacji o zasobie procesu. System operacyjny ma świadomość, że istnieją uchwyty dla zakończonych procesów, które nie zostały wydane przez <xref:System.Diagnostics.Process> składniki, więc <xref:System.Diagnostics.Process.ExitTime%2A> utrzymuje i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci.

Istnieje koszt związany z obserwowaniem do zakończenia procesu. Jeśli <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> jest `true` ,<xref:System.Diagnostics.Process.Exited> zdarzenie jest zgłaszane w przypadku zakończenia skojarzonego procesu. Twoje procedury dla zdarzenia <xref:System.Diagnostics.Process.Exited> są uruchamiane w tym czasie.

Czasami aplikacja uruchamia proces, ale nie wymaga powiadomienia o jego zamknięciu. Na przykład aplikacja może uruchomić program Notepad, aby umożliwić użytkownikowi edycję tekstu, ale nie należy używać aplikacji Notatnik. Można zdecydować się na uniknięcie powiadomienia o zakończeniu procesu, ponieważ nie ma on zastosowania do kontynuowania działania aplikacji. Ustawienie <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>pozwalające zaoszczędzić zasoby systemowe. `false`

## Examples  
Poniższy przykład kodu tworzy proces, który drukuje plik. Ustawia <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość, aby spowodować, że proces <xref:System.Diagnostics.Process.Exited> zgłasza zdarzenie po jego zakończeniu. Program <xref:System.Diagnostics.Process.Exited> obsługi zdarzeń wyświetla informacje o procesie.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umieszcza składnik w stanie w celu współdziałania z procesami systemu operacyjnego, które są uruchamiane w trybie specjalnym <see langword="SeDebugPrivilege" /> przez włączenie właściwości natywnej w bieżącym wątku. <see cref="T:System.Diagnostics.Process" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre procesy systemu operacyjnego są uruchamiane w trybie specjalnym. Próba odczytania właściwości lub dołączenia do tych procesów nie jest możliwa, chyba że zostanie <xref:System.Diagnostics.Process.EnterDebugMode%2A> wywołana w składniku. Wywołaj <xref:System.Diagnostics.Process.LeaveDebugMode%2A> , gdy nie potrzebujesz już dostępu do tych procesów, które są uruchamiane w trybie specjalnym.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zapisuje dane w przekierowanym <see cref="P:System.Diagnostics.Process.StandardError" /> strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie wskazuje, że skojarzony proces został zapisany w przekierowanym <xref:System.Diagnostics.Process.StandardError%2A> strumieniu. <xref:System.Diagnostics.Process.ErrorDataReceived>  
  
 Zdarzenie występuje tylko podczas asynchronicznych operacji odczytu w <xref:System.Diagnostics.Process.StandardError%2A>. Aby rozpocząć asynchroniczne operacje odczytu <xref:System.Diagnostics.Process.StandardError%2A> , należy przekierować strumień <xref:System.Diagnostics.Process>obiektu, dodać obsługę zdarzenia do <xref:System.Diagnostics.Process.ErrorDataReceived> zdarzenia i wywołać metodę <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Następnie Zdarzenie sygnalizuje każdorazowe zapisanie wiersza w przekierowanym <xref:System.Diagnostics.Process.StandardError%2A> strumieniu do momentu zakończenia procesu lub wywołania <xref:System.Diagnostics.Process.CancelErrorRead%2A>. <xref:System.Diagnostics.Process.ErrorDataReceived>  
  
> [!NOTE]
>  Aplikacja, która przetwarza asynchroniczne dane wyjściowe, powinna wywołać <xref:System.Diagnostics.Process.WaitForExit> metodę, aby upewnić się, że bufor wyjściowy został opróżniony. Należy zauważyć, że określenie limitu czasu przy <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> użyciu przeciążenia ** nie gwarantuje, że bufor wyjściowy został opróżniony.
  
   
  
## Examples  
 Poniższy przykład używa `net view` polecenia, aby wyświetlić listę dostępnych zasobów sieciowych na komputerze zdalnym. Użytkownik dostarcza nazwę komputera docelowego jako argument wiersza polecenia. Użytkownik może również podać nazwę pliku dla danych wyjściowych błędu. Przykład zbiera dane wyjściowe polecenia NET, czeka na zakończenie procesu, a następnie zapisuje wyniki wyjściowe w konsoli programu. Jeśli użytkownik poda opcjonalny plik błędu, przykład zapisuje błędy do pliku.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określoną przez skojarzony proces po jej zakończeniu.</summary>
        <value>Kod, który został określony przez skojarzony proces po jego zakończeniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.ExitCode%2A> polecenia, aby uzyskać stan, który został zwrócony przez proces systemowy po jego zakończeniu. Możesz użyć kodu zakończenia, tak jak liczby całkowitej zwracanej z `main()` procedury.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> Wartość procesu odzwierciedla konkretną Konwencję wdrożoną przez dewelopera aplikacji dla tego procesu. Jeśli używasz wartości kodu zakończenia, aby podejmować decyzje w kodzie, upewnij się, że znasz Konwencję kodu zakończenia wykorzystywaną przez proces aplikacji.  
  
 Deweloperzy zwykle wskazują pomyślne wyjście przez <xref:System.Diagnostics.Process.ExitCode%2A> wartość zero i wyznaczać błędy przez wartości niezerowe, których Metoda wywołująca może użyć do zidentyfikowania przyczyny nietypowego zakończenia procesu. Nie jest konieczne przestrzeganie tych wytycznych, ale są one Konwencją.  
  
 Jeśli spróbujesz uzyskać <xref:System.Diagnostics.Process.ExitCode%2A> przed zakończeniem procesu, próba wygeneruje wyjątek. Najpierw sprawdź <xref:System.Diagnostics.Process.HasExited%2A> właściwość, aby sprawdzić, czy skojarzony proces został zakończony.  
  
> [!NOTE]
>  Gdy standardowe wyjście zostało przekierowane do obsługi zdarzeń asynchronicznych, istnieje możliwość, że przetwarzanie danych wyjściowych nie zakończy <xref:System.Diagnostics.Process.HasExited%2A> się `true`po powrocie. Aby upewnić się, że obsługa zdarzeń asynchronicznych została ukończona, wywołaj <xref:System.Diagnostics.Process.WaitForExit> Przeciążenie, które nie przyjmuje parametru przed sprawdzeniem. <xref:System.Diagnostics.Process.HasExited%2A>  
  
 Możesz użyć <xref:System.Diagnostics.Process.CloseMainWindow%2A> metody lub, <xref:System.Diagnostics.Process.Kill%2A> aby spowodować zakończenie skojarzonego procesu.  
  
 Istnieją dwa sposoby powiadamiania o zakończeniu skojarzonego procesu: synchronicznie i asynchronicznie. Powiadomienia synchroniczne opierają się na wywołaniu <xref:System.Diagnostics.Process.WaitForExit%2A> metody w celu wstrzymania przetwarzania aplikacji do momentu zakończenia skojarzonego składnika. Asynchroniczne powiadomienia bazują na <xref:System.Diagnostics.Process.Exited> zdarzeniu. W przypadku korzystania z powiadomień <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> asynchronicznych należy `true` ustawić dla <xref:System.Diagnostics.Process> składnika otrzymywanie powiadomień o zakończeniu procesu.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie został zakończony.  
  
—lub— 
Proces <see cref="P:System.Diagnostics.Process.Handle" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.ExitCode" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> Zdarzenie wskazuje, że skojarzony proces zakończył działanie. To wystąpienie oznacza, że proces został przerwany (przerwany) lub został pomyślnie zamknięty. To zdarzenie może wystąpić tylko wtedy, gdy wartość <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwości jest. `true`  
  
 Istnieją dwa sposoby powiadamiania o zakończeniu skojarzonego procesu: synchronicznie i asynchronicznie. Powiadomienie synchroniczne oznacza wywołanie <xref:System.Diagnostics.Process.WaitForExit%2A> metody w celu zablokowania bieżącego wątku do momentu zakończenia procesu. Powiadomienie asynchroniczne używa <xref:System.Diagnostics.Process.Exited> zdarzenia, co umożliwia wątek wywołujący kontynuować wykonywanie w międzyczasie. W tym drugim przypadku <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> należy `true` ustawić dla aplikacji wywołującej odbieranie zdarzenia zakończonego.  
  
 Gdy system operacyjny zamknie proces, powiadamia wszystkie inne procesy, dla których zarejestrowano programy obsługi dla zdarzenia zamkniętego. W tej chwili dojście procesu, który zakończył się, może być używane do uzyskiwania dostępu do niektórych właściwości <xref:System.Diagnostics.Process.ExitTime%2A> , <xref:System.Diagnostics.Process.HasExited%2A> takich jak i że system operacyjny utrzymuje się do momentu całkowitego zwolnienia tego dojścia.  
  
> [!NOTE]
>  Nawet jeśli masz dojście do zakończonego procesu, nie możesz ponownie wywołać <xref:System.Diagnostics.Process.Start%2A> , aby połączyć się z tym samym procesem. Wywołanie <xref:System.Diagnostics.Process.Start%2A> automatycznie zwalnia skojarzony proces i łączy się z procesem przy użyciu tego samego pliku, ale zupełnie nowy <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Aby uzyskać więcej informacji na temat używania <xref:System.Diagnostics.Process.Exited> zdarzenia w aplikacjach Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> Zobacz właściwość.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy proces, który drukuje plik. Wywołuje <xref:System.Diagnostics.Process.Exited> zdarzenie po zakończeniu procesu, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> ponieważ właściwość została ustawiona podczas tworzenia procesu. Program <xref:System.Diagnostics.Process.Exited> obsługi zdarzeń wyświetla informacje o procesie.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas zakończenia skojarzonego procesu.</summary>
        <value>Wskazuje <see cref="T:System.DateTime" /> , kiedy skojarzony proces został zakończony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli proces nie zakończył się, próba pobrania <xref:System.Diagnostics.Process.ExitTime%2A> właściwości zgłasza wyjątek. Użyj <xref:System.Diagnostics.Process.HasExited%2A> przed<xref:System.Diagnostics.Process.ExitTime%2A> pobraniem właściwości, aby określić, czy skojarzony proces został zakończony.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy proces, który drukuje plik. Proces wywołuje <xref:System.Diagnostics.Process.Exited> zdarzenie po jego zakończeniu, a program obsługi zdarzeń <xref:System.Diagnostics.Process.ExitTime%2A> wyświetla Właściwość i inne informacje o procesie.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.ExitTime" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nowy <see cref="T:System.Diagnostics.Process" /> składnik i kojarzy go z aktualnie aktywnym procesem.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> składnik skojarzony z zasobem procesu, który korzysta z aplikacji wywołującej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia i kojarzenia go z zasobem procesu na komputerze lokalnym.  
  
 Podobnie jak podobne <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>i <xref:System.Diagnostics.Process.GetProcesses%2A> metody, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> kojarzy istniejący zasób z nowym <xref:System.Diagnostics.Process> składnikiem.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącym procesie, procesach uruchomionych na komputerze lokalnym, wszystkich wystąpieniach programu Notepad uruchomionych na komputerze lokalnym i określonym procesie na komputerze lokalnym. Następnie pobiera informacje dotyczące tych samych procesów na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Diagnostics.Process" /> składnik i kojarzy go z istniejącym zasobem procesu, który określisz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Unikatowy identyfikator systemu dla zasobu procesu.</param>
        <summary>Zwraca nowy <see cref="T:System.Diagnostics.Process" /> składnik z uwzględnieniem identyfikatora procesu na komputerze lokalnym.</summary>
        <returns>Składnik skojarzony z zasobem procesu lokalnego identyfikowanym <paramref name="processId" /> przez parametr. <see cref="T:System.Diagnostics.Process" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> składnika i kojarzenia go z zasobem procesu na komputerze lokalnym. Zasób procesu musi już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> nie tworzy zasobu systemowego, ale zamiast tego kojarzy zasób z składnikiem wygenerowanym <xref:System.Diagnostics.Process> przez aplikację. Proces <xref:System.Diagnostics.Process.Id%2A> można pobrać tylko dla procesu, który jest aktualnie uruchomiony na komputerze. Po zakończeniu procesu program zgłasza wyjątek <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> , jeśli przekaże mu wygasły identyfikator.  
  
 Na dowolnym komputerze identyfikator procesu jest unikatowy. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>zwraca jeden proces o największej liczbie. Jeśli chcesz uzyskać wszystkie procesy z uruchomioną określoną aplikacją, użyj <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>programu. Jeśli na komputerze z uruchomioną określoną aplikacją istnieje wiele procesów, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> funkcja zwraca tablicę zawierającą wszystkie skojarzone procesy. Każdy z tych procesów można badać z kolei dla jego identyfikatora. Identyfikator procesu można wyświetlić w `Processes` panelu menedżera zadań systemu Windows. W `PID` kolumnie zostanie wyświetlony identyfikator procesu, który jest przypisany do procesu.  
  
 Parametr jest (a 32-bitową liczbą całkowitą ze znakiem), chociaż podstawowy interfejs API systemu `DWORD` Windows używa (a niepodpisanej 32-bitowej liczby całkowitej) dla podobnych interfejsów API. <xref:System.Int32> `processId` Jest to możliwe z przyczyn historycznych.
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącym procesie, procesach uruchomionych na komputerze lokalnym, wszystkich wystąpieniach programu Notepad uruchomionych na komputerze lokalnym i określonym procesie na komputerze lokalnym. Następnie pobiera informacje dotyczące tych samych procesów na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Proces określony przez <paramref name="processId" /> parametr nie jest uruchomiony. Identyfikator może wygasnąć.</exception>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony przez ten obiekt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Unikatowy identyfikator systemu dla zasobu procesu.</param>
        <param name="machineName">Nazwa komputera w sieci.</param>
        <summary>Zwraca nowy <see cref="T:System.Diagnostics.Process" /> składnik, uwzględniając identyfikator procesu i nazwę komputera w sieci.</summary>
        <returns>Składnik skojarzony z zasobem procesu zdalnego identyfikowanym <paramref name="processId" /> przez parametr. <see cref="T:System.Diagnostics.Process" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> składnika i kojarzenia go z zasobem procesu na komputerze zdalnym w sieci. Zasób procesu musi już istnieć na określonym komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> nie tworzy zasobu systemowego, ale zamiast tego kojarzy zasób z składnikiem wygenerowanym <xref:System.Diagnostics.Process> przez aplikację. Proces <xref:System.Diagnostics.Process.Id%2A> można pobrać tylko dla procesu, który jest aktualnie uruchomiony na komputerze. Po zakończeniu procesu program zgłasza wyjątek <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> , jeśli przekaże mu wygasły identyfikator.  
  
 Na dowolnym komputerze identyfikator procesu jest unikatowy. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>zwraca jeden proces o największej liczbie. Jeśli chcesz uzyskać wszystkie procesy z uruchomioną określoną aplikacją, użyj <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>programu. Jeśli na komputerze z uruchomioną określoną aplikacją istnieje wiele procesów, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> funkcja zwraca tablicę zawierającą wszystkie skojarzone procesy. Każdy z tych procesów można badać z kolei dla jego identyfikatora. Identyfikator procesu można wyświetlić w `Processes` panelu menedżera zadań systemu Windows. W `PID` kolumnie zostanie wyświetlony identyfikator procesu, który jest przypisany do procesu.  
  
 Jeśli nie określisz `machineName`, używany jest komputer lokalny. Alternatywnie można określić komputer lokalny przez ustawienie `machineName` wartości "." lub pustego ciągu ("").  
  
 Parametr jest (a 32-bitową liczbą całkowitą ze znakiem), chociaż podstawowy interfejs API systemu `DWORD` Windows używa (a niepodpisanej 32-bitowej liczby całkowitej) dla podobnych interfejsów API. <xref:System.Int32> `processId` Jest to możliwe z przyczyn historycznych.   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącym procesie, procesach uruchomionych na komputerze lokalnym, wszystkich wystąpieniach programu Notepad uruchomionych na komputerze lokalnym i określonym procesie na komputerze lokalnym. Następnie pobiera informacje dotyczące tych samych procesów na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Proces określony przez <paramref name="processId" /> parametr nie jest uruchomiony. Identyfikator może wygasnąć.  
  
—lub— 
Składnia <paramref name="machineName" /> parametru jest nieprawidłowa. Nazwa może mieć długość zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="machineName" /></exception>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony przez ten obiekt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je z istniejącymi zasobami procesów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Diagnostics.Process" /> składnik dla każdego zasobu procesu na komputerze lokalnym.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> , która reprezentuje wszystkie zasoby procesu uruchomione na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia tablicy nowych <xref:System.Diagnostics.Process> składników i kojarzenia ich ze wszystkimi zasobami procesów na komputerze lokalnym. Zasoby procesu muszą już istnieć na komputerze lokalnym, ponieważ <xref:System.Diagnostics.Process.GetProcesses%2A> nie tworzy zasobów systemowych, ale raczej kojarzy zasoby z składnikami wygenerowanymi <xref:System.Diagnostics.Process> przez aplikację. Ponieważ sam system operacyjny ma uruchomione procesy w tle, ta tablica nie jest pusta.  
  
 Jeśli nie chcesz pobierać wszystkich procesów uruchomionych na komputerze, możesz ograniczyć ich liczbę przy użyciu <xref:System.Diagnostics.Process.GetProcessById%2A> metody lub. <xref:System.Diagnostics.Process.GetProcessesByName%2A> <xref:System.Diagnostics.Process.GetProcessById%2A><xref:System.Diagnostics.Process> tworzy składnik skojarzony z procesem zidentyfikowanym w systemie przez identyfikator procesu, który został przekazany do metody. <xref:System.Diagnostics.Process.GetProcessesByName%2A>Tworzy tablicę <xref:System.Diagnostics.Process> składników, której skojarzone zasoby procesu współużytkują plik wykonywalny przekazywany do metody.  
  
> [!NOTE]
>  Można załadować wiele usług systemu Windows w ramach tego samego wystąpienia procesu hosta usługi (svchost. exe). Proces getprocesss nie identyfikuje tych pojedynczych usług; w tym celu zobacz <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącym procesie, procesach uruchomionych na komputerze lokalnym, wszystkich wystąpieniach programu Notepad uruchomionych na komputerze lokalnym i określonym procesie na komputerze lokalnym. Następnie pobiera informacje dotyczące tych samych procesów na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, z którego ma zostać odczytana lista procesów.</param>
        <summary>Tworzy nowy <see cref="T:System.Diagnostics.Process" /> składnik dla każdego zasobu procesu na określonym komputerze.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> , która reprezentuje wszystkie zasoby procesu uruchomione na określonym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia tablicy nowych <xref:System.Diagnostics.Process> składników i kojarzenia ich ze wszystkimi zasobami procesów na określonym (zazwyczaj zdalnym) komputerze. Zasoby procesu muszą już istnieć na komputerze lokalnym, ponieważ <xref:System.Diagnostics.Process.GetProcesses%2A> nie tworzy zasobów systemowych, ale raczej kojarzy zasoby z składnikami wygenerowanymi <xref:System.Diagnostics.Process> przez aplikację. Ponieważ sam system operacyjny ma uruchomione procesy w tle, ta tablica nie jest pusta.  
  
 Jeśli nie chcesz pobierać wszystkich procesów uruchomionych na komputerze, możesz ograniczyć ich liczbę przy użyciu <xref:System.Diagnostics.Process.GetProcessById%2A> metody lub. <xref:System.Diagnostics.Process.GetProcessesByName%2A> <xref:System.Diagnostics.Process.GetProcessById%2A><xref:System.Diagnostics.Process> tworzy składnik skojarzony z procesem zidentyfikowanym w systemie przez identyfikator procesu, który został przekazany do metody. <xref:System.Diagnostics.Process.GetProcessesByName%2A>Tworzy tablicę <xref:System.Diagnostics.Process> składników, której skojarzone zasoby procesu współużytkują plik wykonywalny przekazywany do metody.  
  
 To Przeciążenie <xref:System.Diagnostics.Process.GetProcesses%2A> metody jest zwykle używane do pobierania listy zasobów procesów uruchomionych na komputerze zdalnym w sieci, ale można określić komputer lokalny, przekazując ".".  
  
> [!NOTE]
>  Można załadować wiele usług systemu Windows w ramach tego samego wystąpienia procesu hosta usługi (svchost. exe). Proces getprocesss nie identyfikuje tych pojedynczych usług; w tym celu zobacz <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącym procesie, procesach uruchomionych na komputerze lokalnym, wszystkich wystąpieniach programu Notepad uruchomionych na komputerze lokalnym i określonym procesie na komputerze lokalnym. Następnie pobiera informacje dotyczące tych samych procesów na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="machineName" /> parametru jest nieprawidłowa. Może mieć długość zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="machineName" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma systemu operacyjnego nie obsługuje tej operacji na komputerach zdalnych.</exception>
        <exception cref="T:System.InvalidOperationException">Występują problemy z dostępem do interfejsu API licznika wydajności używanego do uzyskiwania informacji o procesie. Ten wyjątek dotyczy systemów Windows NT, Windows 2000 i Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił problem podczas uzyskiwania dostępu do podstawowego interfejsu API systemu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je z istniejącymi zasobami procesów, które współużytkują określoną nazwę procesu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Przyjazna nazwa procesu.</param>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je ze wszystkimi zasobami procesów na komputerze lokalnym, które współużytkują określoną nazwę procesu.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> , która reprezentuje zasoby procesu, na których działa określona aplikacja lub plik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia tablicy nowych <xref:System.Diagnostics.Process> składników i kojarzenia ich ze wszystkimi zasobami procesów, na których jest uruchomiony ten sam plik wykonywalny na komputerze lokalnym. Zasoby procesu muszą już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessesByName%2A> nie tworzy zasobów systemowych, ale kojarzą je ze składnikami wygenerowanymi <xref:System.Diagnostics.Process> przez aplikację. `processName` Można określić dla pliku wykonywalnego, który nie jest aktualnie uruchomiony na komputerze lokalnym, więc tablica, która zwraca metodę, może być pusta.  
  
 Nazwa procesu jest przyjazną nazwą dla procesu, takiego jak program Outlook, który nie zawiera rozszerzenia exe lub ścieżki. <xref:System.Diagnostics.Process.GetProcessesByName%2A>jest przydatne do pobierania i manipulowania wszystkimi procesami, które są skojarzone z tym samym plikiem wykonywalnym. Na przykład można przekazać nazwę pliku wykonywalnego jako `processName` parametr, aby zamknąć wszystkie uruchomione wystąpienia tego pliku wykonywalnego.  
  
 Chociaż proces <xref:System.Diagnostics.Process.Id%2A> jest unikatowy dla pojedynczego zasobu procesu w systemie, wiele procesów na komputerze lokalnym może uruchamiać aplikację określoną `processName` przez parametr. W związku z tym <xref:System.Diagnostics.Process.GetProcessesByName%2A> zwracajedenproces,alezwracatablicęzawierającąwszystkieskojarzoneprocesy.<xref:System.Diagnostics.Process.GetProcessById%2A> Jeśli potrzebujesz manipulować procesem przy użyciu standardowych wywołań interfejsu API, możesz wykonać zapytanie dotyczące każdego z tych procesów z kolei, aby uzyskać jego identyfikator. Nie można uzyskać dostępu do zasobów przetwarzanych tylko za pomocą samej nazwy procesu, ale po pobraniu <xref:System.Diagnostics.Process> tablicy składników skojarzonych z zasobami procesów można uruchamiać, kończyć i w inny sposób manipulować zasobami systemu.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącym procesie, procesach uruchomionych na komputerze lokalnym, wszystkich wystąpieniach programu Notepad uruchomionych na komputerze lokalnym i określonym procesie na komputerze lokalnym. Następnie pobiera informacje dotyczące tych samych procesów na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Występują problemy z dostępem do interfejsu API licznika wydajności używanego do uzyskiwania informacji o procesie. Ten wyjątek dotyczy systemów Windows NT, Windows 2000 i Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Przyjazna nazwa procesu.</param>
        <param name="machineName">Nazwa komputera w sieci.</param>
        <summary>Tworzy tablicę nowych <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je ze wszystkimi zasobami procesu na komputerze zdalnym, który współużytkuje określoną nazwę procesu.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> , która reprezentuje zasoby procesu, na których działa określona aplikacja lub plik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia tablicy nowych <xref:System.Diagnostics.Process> składników i kojarzenia ich ze wszystkimi zasobami procesów, które są uruchomione w tym samym pliku wykonywalnym na określonym komputerze. Zasoby procesu muszą już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessesByName%2A> nie tworzy zasobów systemowych, ale kojarzą je ze składnikami wygenerowanymi <xref:System.Diagnostics.Process> przez aplikację. `processName` Można określić dla pliku wykonywalnego, który nie jest aktualnie uruchomiony na komputerze lokalnym, więc tablica, która zwraca metodę, może być pusta.  
  
 Nazwa procesu jest przyjazną nazwą dla procesu, takiego jak program Outlook, który nie zawiera rozszerzenia exe lub ścieżki. <xref:System.Diagnostics.Process.GetProcessesByName%2A>jest przydatne do pobierania i manipulowania wszystkimi procesami, które są skojarzone z tym samym plikiem wykonywalnym. Na przykład można przekazać nazwę pliku wykonywalnego jako `processName` parametr, aby zamknąć wszystkie uruchomione wystąpienia tego pliku wykonywalnego.  
  
 Chociaż proces <xref:System.Diagnostics.Process.Id%2A> jest unikatowy dla pojedynczego zasobu procesu w systemie, wiele procesów na komputerze lokalnym może uruchamiać aplikację określoną `processName` przez parametr. W związku z tym <xref:System.Diagnostics.Process.GetProcessesByName%2A> zwracajedenproces,alezwracatablicęzawierającąwszystkieskojarzoneprocesy.<xref:System.Diagnostics.Process.GetProcessById%2A> Jeśli potrzebujesz manipulować procesem przy użyciu standardowych wywołań interfejsu API, możesz wykonać zapytanie dotyczące każdego z tych procesów z kolei, aby uzyskać jego identyfikator. Nie można uzyskać dostępu do zasobów przetwarzanych tylko za pomocą samej nazwy procesu, ale po pobraniu <xref:System.Diagnostics.Process> tablicy składników skojarzonych z zasobami procesów można uruchamiać, kończyć i w inny sposób manipulować zasobami systemu.  
  
 Za pomocą tego przeciążenia można pobrać procesy na komputerze lokalnym oraz na komputerze zdalnym. Użyj ".", aby określić komputer lokalny. Istnieje inne Przeciążenie, które domyślnie używa komputera lokalnego.  
  
 Można uzyskać dostęp do procesów na komputerach zdalnych tylko w celu wyświetlania informacji, takich jak statystyki dotyczące procesów. Na komputerach zdalnych nie można zamykać <xref:System.Diagnostics.Process.Kill%2A>, kończyć (używać) ani uruchamiać procesów.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącym procesie, procesach uruchomionych na komputerze lokalnym, wszystkich wystąpieniach programu Notepad uruchomionych na komputerze lokalnym i określonym procesie na komputerze lokalnym. Następnie pobiera informacje dotyczące tych samych procesów na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="machineName" /> parametru jest nieprawidłowa. Może mieć długość zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="machineName" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma systemu operacyjnego nie obsługuje tej operacji na komputerach zdalnych.</exception>
        <exception cref="T:System.InvalidOperationException">Próba nawiązania połączenia z <paramref name="machineName" /> błędem nie powiodła się.

—lub— 
Występują problemy z dostępem do interfejsu API licznika wydajności używanego do uzyskiwania informacji o procesie. Ten wyjątek dotyczy systemów Windows NT, Windows 2000 i Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił problem podczas uzyskiwania dostępu do podstawowego interfejsu API systemu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera natywne dojście skojarzonego procesu.</summary>
        <value>Dojście, które system operacyjny przypisał do skojarzonego procesu, gdy proces został uruchomiony. System używa tego uchwytu do śledzenia atrybutów procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może uzyskać dojście do procesu, który może być używany jako parametr w wielu funkcjach i informacjach o procesie. Tego uchwytu można użyć do zainicjowania <xref:System.Threading.WaitHandle> lub wywołania natywnych metod za pomocą wywołania platformy.  
  
 Ten uchwyt procesu jest prywatny dla aplikacji — innymi słowy, uchwytów procesów nie można udostępniać. Proces zawiera również proces <xref:System.Diagnostics.Process.Id%2A> , w przeciwieństwie do <xref:System.Diagnostics.Process.Handle%2A>, jest unikatowy, i dlatego jest prawidłowy w całym systemie.  
  
 Tylko procesy uruchomione przez wywołanie do <xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Handle%2A> ustawiania właściwości odpowiednich <xref:System.Diagnostics.Process> wystąpień.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony lub zakończył działanie. Nie <see cref="P:System.Diagnostics.Process.Handle" /> można odczytać właściwości, ponieważ z tym <see cref="T:System.Diagnostics.Process" /> wystąpieniem nie jest skojarzony żaden proces.  
  
—lub— 
<see cref="T:System.Diagnostics.Process" /> Wystąpienie zostało dołączone do uruchomionego procesu, ale nie masz wystarczających uprawnień do uzyskania dojścia z pełnymi prawami dostępu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Handle" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę dojść otwartych przez proces.</summary>
        <value>Liczba otwartych procesów systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty zapewniają metodę odwołującą się do obiektów. Proces może uzyskać dojścia do plików, zasobów, kolejek komunikatów i wielu innych obiektów systemu operacyjnego. System operacyjny ponownie przejmuje pamięć skojarzoną z procesem tylko wtedy, gdy liczba dojść wynosi zero.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy skojarzony proces został zakończony.</summary>
        <value><see langword="true" />Jeśli proces systemu operacyjnego, do którego odwołuje <see cref="T:System.Diagnostics.Process" /> się składnik, <see langword="false" />został zakończony; w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `true` parametru dla <xref:System.Diagnostics.Process.HasExited%2A> wskazuje, że skojarzony proces został zakończony, normalnie lub nieprawidłowo. Możesz zażądać lub wymusić zakończenie skojarzonego procesu przez wywołanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. W przypadku otwarcia dojścia do procesu system operacyjny zwalnia pamięć procesu, gdy proces zakończył pracę, ale zachowuje informacje administracyjne dotyczące procesu, takie jak dojście, kod zakończenia i czas zakończenia. Aby uzyskać te informacje, można użyć <xref:System.Diagnostics.Process.ExitCode%2A> właściwości i. <xref:System.Diagnostics.Process.ExitTime%2A> Te właściwości są wypełniane automatycznie dla procesów, które zostały uruchomione przez ten składnik. Informacje administracyjne są uwalniane, gdy wszystkie <xref:System.Diagnostics.Process> składniki, które są skojarzone z procesem systemu są niszczone i nie przechowują więcej dojść do zakończonego procesu.  
  
 Proces może zakończyć się niezależnie od kodu. Jeśli proces został uruchomiony przy użyciu tego składnika, system aktualizuje wartość <xref:System.Diagnostics.Process.HasExited%2A> automatycznie, nawet jeśli skojarzony proces jest zamykany niezależnie.  
  
> [!NOTE]
>  Gdy standardowe wyjście zostało przekierowane do obsługi zdarzeń asynchronicznych, możliwe jest, że przetwarzanie danych wyjściowych nie zostanie ukończone, gdy ta `true`właściwość zwróci wartość. Aby upewnić się, że obsługa zdarzeń asynchronicznych została ukończona, wywołaj <xref:System.Diagnostics.Process.WaitForExit> Przeciążenie, które nie przyjmuje parametru przed sprawdzeniem. <xref:System.Diagnostics.Process.HasExited%2A>  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej przez skojarzony proces w ciągu 2 sekund przez maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli nadal działa po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Z obiektem nie jest skojarzony żaden proces.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać kodu zakończenia dla procesu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.HasExited" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator skojarzonego procesu.</summary>
        <value>Wygenerowany przez system unikatowy identyfikator procesu, do którego odwołuje się to <see cref="T:System.Diagnostics.Process" /> wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten proces <xref:System.Diagnostics.Process.Id%2A> jest nieprawidłowy, jeśli skojarzony proces nie jest uruchomiony. Z tego względu należy upewnić się, że proces jest uruchomiony, przed podjęciem próby pobrania <xref:System.Diagnostics.Process.Id%2A> właściwości. Dopóki proces nie zostanie zakończony, identyfikator procesu jednoznacznie identyfikuje proces w systemie.  
  
 Proces, który jest uruchomiony na komputerze lokalnym lub zdalnym, można połączyć z nowym <xref:System.Diagnostics.Process> wystąpieniem przez przekazanie identyfikatora procesu <xref:System.Diagnostics.Process.GetProcessById%2A> do metody. <xref:System.Diagnostics.Process.GetProcessById%2A>to metoda, która tworzy nowy składnik i automatycznie <xref:System.Diagnostics.Process.Id%2A> ustawia właściwość dla nowego <xref:System.Diagnostics.Process> wystąpienia. `static`  
  
 Identyfikatory procesów mogą być ponownie używane przez system. Wartość <xref:System.Diagnostics.Process.Id%2A> właściwości jest unikatowa tylko wtedy, gdy skojarzony proces jest uruchomiony. Po zakończeniu procesu system może ponownie użyć <xref:System.Diagnostics.Process.Id%2A> wartości właściwości dla niepowiązanego procesu.  
  
 Ponieważ identyfikator jest unikatowy w systemie, można przekazać go do innych wątków jako alternatywę do przekazywania <xref:System.Diagnostics.Process> wystąpienia. Ta akcja może jeszcze zagwarantowanie, że zasoby systemowe zagwarantują, że proces jest prawidłowo zidentyfikowany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, <xref:System.Diagnostics.Process.Id%2A> jak uzyskać wszystkie uruchomione wystąpienia aplikacji. Kod tworzy nowe wystąpienie Notatnika, wyświetla wszystkie wystąpienia Notatnika, a następnie umożliwia użytkownikowi wprowadzanie <xref:System.Diagnostics.Process.Id%2A> numeru w celu usunięcia określonego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.Id" /> Właściwość procesu nie została ustawiona.  
  
—lub— 
Z tym <see cref="T:System.Diagnostics.Process" /> obiektem nie jest skojarzony żaden proces.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Kill">
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Metoda wymusza zakończenie procesu, a <xref:System.Diagnostics.Process.CloseMainWindow%2A> jedynie żąda zakończenia. `Kill` Gdy wykonywany jest proces z interfejsem graficznym, jego pętla komunikatów jest w stanie oczekiwania. Pętla komunikatów jest wykonywana za każdym razem, gdy komunikat systemu Windows jest wysyłany do procesu przez system operacyjny. Wywołanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> wysyła żądanie zamknięcia głównego okna, które w dobrze uformowanej aplikacji zamyka okna podrzędne i odwołuje wszystkie uruchomione pętle komunikatów dla aplikacji. Żądanie zakończenia procesu przez wywołanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> nie wymusza zamknięcia aplikacji.
Aplikacja może poprosił o weryfikację użytkownika przed zamknięciem lub może odmówić zamknięcia. Aby wymusić zakończenie działania aplikacji, należy `Kill` użyć metody.

Zachowanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> jest takie samo jak w przypadku użytkownika zamykającego okno główne aplikacji przy użyciu menu systemowego.
W związku z tym żądanie zakończenia procesu przez zamknięcie okna głównego nie wymusza natychmiastowego zakończenia działania aplikacji.
  
> [!NOTE]
> Metoda <xref:System.Diagnostics.Process.Kill%2A> jest wykonywana asynchronicznie. Po wywołaniu `Kill` metody <xref:System.Diagnostics.Process.WaitForExit%2A> Wywołaj metodę, aby poczekać na <xref:System.Diagnostics.Process.HasExited%2A> zakończenie procesu, lub sprawdź właściwość, aby określić, czy proces został zakończony.

> [!NOTE]
> <xref:System.Diagnostics.Process.WaitForExit%2A> Metoda<xref:System.Diagnostics.Process.HasExited%2A> i właściwość nie odzwierciedlają stanu procesów podrzędnych.
> Gdy `Kill(entireProcessTree: true)` jest używany, <xref:System.Diagnostics.Process.WaitForExit%2A> i <xref:System.Diagnostics.Process.HasExited%2A> będzie wskazywać, że zakończenie kończy się po zakończeniu danego procesu, nawet jeśli wszystkie elementy podrzędne nie zostały jeszcze zakończone.
  
W przypadku wywołania `Kill`programu dane edytowane przez proces lub zasoby przydzielone do procesu mogą zostać utracone. 
`Kill`powoduje nietypowe zakończenie procesu i powinno być używane tylko wtedy, gdy jest to konieczne.
<xref:System.Diagnostics.Process.CloseMainWindow%2A>Włącza uporządkowane zakończenie procesu i zamyka wszystkie okna, dlatego jest preferowany dla aplikacji z interfejsem. Jeśli <xref:System.Diagnostics.Process.CloseMainWindow%2A> to się nie powiedzie `Kill` , można użyć, aby zakończyć proces.
`Kill`jest jedynym sposobem zakończenia procesów, które nie mają interfejsów graficznych.
  
Można wywołać `Kill` i <xref:System.Diagnostics.Process.CloseMainWindow%2A> tylko dla procesów, które są uruchomione na komputerze lokalnym.
Nie można spowodować zakończenia procesów na komputerach zdalnych. Można wyświetlić tylko informacje dotyczące procesów uruchomionych na komputerach zdalnych.
  
> [!NOTE]
> Jeśli wywołanie `Kill` metody jest wykonywane <xref:System.ComponentModel.Win32Exception> , gdy proces jest aktualnie zakończony, zostanie zgłoszony w celu odmowy dostępu.
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Natychmiast zatrzyma skojarzony proces.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można przerwać skojarzonego procesu.  
  
 —lub—  
  
 Proces jest zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Podjęto próbę wywołania <see cref="M:System.Diagnostics.Process.Kill" /> procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został już zakończony.  
  
—lub— 
Z tym <see cref="T:System.Diagnostics.Process" /> obiektem nie jest skojarzony żaden proces.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree"><see langword="true" />Aby skasować skojarzony proces i jego elementy podrzędne; <see langword="false" /> aby skasować tylko skojarzony proces.</param>
        <summary>Natychmiast kończy skojarzony proces i opcjonalnie jego procesy podrzędne/potomne.</summary>
        <remarks>Gdy <paramref name="entireProcessTree" /> jest ustawiona na <see langword="true" />, procesy, w których wywołanie nie ma uprawnień do wyświetlania szczegółów są dyskretnie pomijane przez proces zakończenia elementu podrzędnego, ponieważ proces zakończenia nie może określić, czy te procesy są elementami podrzędnymi.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można przerwać skojarzonego procesu.  
  
 —lub—  
  
 Proces jest zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Podjęto próbę wywołania <see cref="M:System.Diagnostics.Process.Kill" /> procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został już zakończony.  
  
—lub— 
Z tym <see cref="T:System.Diagnostics.Process" /> obiektem nie jest skojarzony żaden proces.

—lub—

Proces wywołujący jest członkiem drzewa podrzędnego skojarzonego procesu.</exception>
        <exception cref="T:System.AggregateException">Nie można zakończyć wszystkich procesów w drzewie potomnym skojarzonego procesu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> Pobiera składnik z stanu, który umożliwia współdziałanie z procesami systemu operacyjnego, które są uruchamiane w trybie specjalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre procesy systemu operacyjnego są uruchamiane w trybie specjalnym. Próba odczytania właściwości lub dołączenia do tych procesów nie jest możliwa, chyba że zostanie <xref:System.Diagnostics.Process.EnterDebugMode%2A> wywołana w składniku. Wywołaj <xref:System.Diagnostics.Process.LeaveDebugMode%2A> , gdy nie potrzebujesz już dostępu do tych procesów, które są uruchamiane w trybie specjalnym.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę komputera, na którym jest uruchomiony skojarzony proces.</summary>
        <value>Nazwa komputera, na którym jest uruchomiony skojarzony proces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można wyświetlić dane statystyczne i informacje o procesie procesów uruchomionych na komputerach zdalnych, ale nie <xref:System.Diagnostics.Process.Start%2A>można <xref:System.Diagnostics.Process.CloseMainWindow%2A>wywoływać <xref:System.Diagnostics.Process.Kill%2A> , lub na komputerach zdalnych.  
  
> [!NOTE]
>  Gdy skojarzony proces jest wykonywany na komputerze lokalnym, ta właściwość zwraca kropkę (".") dla nazwy maszyny. Należy użyć <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby uzyskać poprawną nazwę komputera.  
  
   
  
## Examples  
 Aby skorzystać z poniższego przykładu, należy najpierw uruchomić co najmniej jedno wystąpienie Notatnika na komputerze zdalnym. Przykład żąda nazwy komputera zdalnego, na którym jest uruchomiony Notatnik, a następnie wyświetla odpowiednie <xref:System.Diagnostics.Process.ProcessName%2A> <xref:System.Diagnostics.Process.Id%2A> <xref:System.Diagnostics.Process.MachineName%2A> właściwości dla każdego wystąpienia.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Z tym <see cref="T:System.Diagnostics.Process" /> obiektem nie jest skojarzony żaden proces.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł główny dla skojarzonego procesu.</summary>
        <value><see cref="T:System.Diagnostics.ProcessModule" /> , Który został użyty do uruchomienia procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł procesu reprezentuje plik DLL lub exe, który jest ładowany do określonego procesu. <xref:System.Diagnostics.Process.MainModule%2A> Właściwość pozwala wyświetlić informacje o pliku wykonywalnym używanym do uruchomienia procesu, w tym nazwę modułu, nazwę pliku i szczegóły pamięci modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MainModule" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Proces 32-bitowy próbuje uzyskać dostęp do modułów procesu 64-bitowego.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> jest niedostępny.  
  
—lub— 
Proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt okna głównego w skojarzonym procesie.</summary>
        <value>Wygenerowane przez system okno główne skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno główne jest oknem otwartym przez proces, który aktualnie ma fokus ( <xref:System.Windows.Forms.Form.TopLevel%2A> formularz). Należy użyć metody, <xref:System.Diagnostics.Process.Refresh%2A> aby <xref:System.Diagnostics.Process> odświeżyć obiekt w celu uzyskania bieżącego uchwytu okna głównego, jeśli został zmieniony. Ogólnie rzecz biorąc, ze względu na to, że <xref:System.Diagnostics.Process.Refresh%2A> uchwyt okna jest buforowany, należy wcześniej użyć, aby zagwarantować pobranie bieżącego uchwytu.  
  
 <xref:System.Diagnostics.Process.MainWindowHandle%2A> Właściwość można uzyskać tylko dla procesów, które są uruchomione na komputerze lokalnym. <xref:System.Diagnostics.Process.MainWindowHandle%2A> Właściwość jest wartością, która jednoznacznie identyfikuje okno skojarzone z procesem.  
  
 Do procesu jest skojarzone główne okno, tylko wtedy, gdy proces ma interfejs graficzny. Jeśli skojarzony proces nie ma okna głównego, <xref:System.Diagnostics.Process.MainWindowHandle%2A> wartość jest równa zero. Wartość jest również zerowa dla procesów, które zostały ukryte, czyli procesów, które nie są widoczne na pasku zadań. Może to dotyczyć procesów, które są wyświetlane jako ikony w obszarze powiadomień, z prawej strony paska zadań.  
  
 Jeśli właśnie uruchomiono proces i chcesz użyć jego głównego uchwytu okna, rozważ użycie <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metody, aby zezwolić na zakończenie procesu, upewniając się, że zostało utworzone główne dojście okna. W przeciwnym razie zostanie zgłoszony wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> zdefiniowano, ponieważ proces został zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podpis głównego okna procesu.</summary>
        <value>Tytuł głównego okna procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do procesu jest skojarzone główne okno, tylko wtedy, gdy proces ma interfejs graficzny. Jeśli skojarzony proces nie ma okna głównego (w związku z czym <xref:System.Diagnostics.Process.MainWindowHandle%2A> jest równa zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> jest pustym ciągiem (""). Jeśli właśnie uruchomiono proces i chcesz użyć jego głównego tytułu, rozważ użycie <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metody, aby zezwolić na zakończenie procesu, upewniając się, że zostało utworzone główne dojście okna. W przeciwnym razie system zgłasza wyjątek.  
  
> [!NOTE]
>  Okno główne to okno, które aktualnie ma fokus; Należy zauważyć, że może to nie być okno podstawowe dla tego procesu. Należy użyć metody, <xref:System.Diagnostics.Process.Refresh%2A> aby <xref:System.Diagnostics.Process> odświeżyć obiekt w celu uzyskania bieżącego uchwytu okna głównego, jeśli został zmieniony.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika i pobiera podpis głównego okna procesu.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> nie jest zdefiniowana, ponieważ proces został zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny dopuszczalny rozmiar zestawu roboczego w bajtach dla skojarzonego procesu.</summary>
        <value>Maksymalny rozmiar zestawu roboczego, który jest dozwolony w pamięci dla procesu, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu jest zestawem stron pamięci, które są obecnie widoczne dla procesu w fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, które mają być używane bez wyzwalania błędu strony.  
  
 Zestaw roboczy zawiera dane udostępnione i prywatne. Udostępnione dane obejmują strony zawierające wszystkie instrukcje wykonywane przez aplikację, w tym strony w plikach dll i pliki System. dll. W miarę wzrostu rozmiaru zestawu roboczego zapotrzebowanie na pamięć wzrasta.  
  
 Proces ma minimalne i maksymalne rozmiary zestawu roboczego. Za każdym razem, gdy tworzony jest zasób procesu, system rezerwuje ilość pamięci równą minimalnemu rozmiarowi zestawu roboczego dla procesu. Menedżer pamięci wirtualnej próbuje zachować co najmniej minimalną ilość pamięci rezydentnej, gdy proces jest aktywny, ale nigdy nie utrzymuje więcej niż maksymalny rozmiar.  
  
 System ustawia domyślne rozmiary zestawów roboczych. Te rozmiary można modyfikować za pomocą <xref:System.Diagnostics.Process.MaxWorkingSet%2A> elementów i. <xref:System.Diagnostics.Process.MinWorkingSet%2A> Jednak ustawienie tych wartości nie gwarantuje, że pamięć zostanie zarezerwowana lub rezydentna.  
  
> [!NOTE]
>  Zwiększenie rozmiaru zestawu roboczego procesu polega na tym, że pamięć fizyczna zostanie odłożona od pozostałej części systemu. Upewnij się, że nie jest wymagana minimalna lub maksymalny rozmiar zestawu roboczego, który jest zbyt duży, ponieważ może to spowodować spadek wydajności systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Maksymalny rozmiar zestawu roboczego jest nieprawidłowy. Musi być większa lub równa minimalnej wielkości zestawu roboczego.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać informacji o zestawie roboczym ze skojarzonego zasobu procesu.  
  
 —lub—  
  
 Identyfikator procesu lub uchwyt procesu to zero, ponieważ proces nie został uruchomiony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> jest niedostępny.  
  
—lub— 
Proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia minimalny dozwolony rozmiar zestawu roboczego w bajtach dla skojarzonego procesu.</summary>
        <value>Minimalny rozmiar zestawu roboczego, który jest wymagany w pamięci dla procesu, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu jest zestawem stron pamięci, które są obecnie widoczne dla procesu w fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, które mają być używane bez wyzwalania błędu strony.  
  
 Zestaw roboczy zawiera dane udostępnione i prywatne. Udostępnione dane obejmują strony zawierające wszystkie instrukcje wykonywane przez aplikację, w tym strony w plikach dll i pliki System. dll. W miarę wzrostu rozmiaru zestawu roboczego zapotrzebowanie na pamięć wzrasta.  
  
 Proces ma minimalne i maksymalne rozmiary zestawu roboczego. Za każdym razem, gdy tworzony jest zasób procesu, system rezerwuje ilość pamięci równą minimalnemu rozmiarowi zestawu roboczego dla procesu. Menedżer pamięci wirtualnej próbuje zachować co najmniej minimalną ilość pamięci rezydentnej, gdy proces jest aktywny, ale nigdy nie utrzymuje więcej niż maksymalny rozmiar.  
  
 System ustawia domyślne rozmiary zestawów roboczych. Te rozmiary można modyfikować za pomocą <xref:System.Diagnostics.Process.MaxWorkingSet%2A> elementów i. <xref:System.Diagnostics.Process.MinWorkingSet%2A> Jednak ustawienie tych wartości nie gwarantuje, że pamięć zostanie zarezerwowana lub rezydentna.  
  
> [!NOTE]
>  Zwiększenie rozmiaru zestawu roboczego procesu polega na tym, że pamięć fizyczna zostanie odłożona od pozostałej części systemu. Upewnij się, że nie jest wymagana minimalna lub maksymalny rozmiar zestawu roboczego, który jest zbyt duży, ponieważ może to spowodować spadek wydajności systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Minimalny rozmiar zestawu roboczego jest nieprawidłowy. Musi być mniejszy lub równy rozmiarowi maksymalnego zestawu roboczego.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać informacji o zestawie roboczym ze skojarzonego zasobu procesu.  
  
 —lub—  
  
 Identyfikator procesu lub uchwyt procesu to zero, ponieważ proces nie został uruchomiony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> jest niedostępny.  
  
—lub— 
Proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduły, które zostały załadowane przez skojarzony proces.</summary>
        <value>Tablica typu <see cref="T:System.Diagnostics.ProcessModule" /> , która reprezentuje moduły, które zostały załadowane przez skojarzony proces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł procesu reprezentuje plik DLL lub exe, który jest ładowany do określonego procesu. <xref:System.Diagnostics.ProcessModule> Wystąpienie pozwala wyświetlić informacje o module, w tym nazwę modułu, nazwę pliku i szczegóły pamięci modułu.  
  
 Proces może ładować wiele modułów do pamięci. Na przykład pliki exe, które ładują dodatkowe pliki. dll, mają wiele modułów.  
  
 Po uruchomieniu procesu ta kolekcja jest pusta do momentu załadowania tego procesu przez system. Jeśli proces zawiera okno główne, można wywołać <xref:System.Diagnostics.Process.WaitForInputIdle%2A> przed pobraniem tej właściwości, aby upewnić się, że kolekcja nie jest pusta podczas uzyskiwania listy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Modules" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> jest niedostępny.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Modules" /> do właściwości procesu systemowego lub bezczynnego procesu. Te procesy nie mają modułów.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość niestronicowanej pamięci systemowej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach, system został przydzielony do skojarzonego procesu, którego nie można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość niestronicowanej pamięci systemowej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci systemowej w bajtach przydzieloną dla skojarzonego procesu, która nie może zostać zapisana w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar niestronicowanej pamięci systemowej używanej przez proces w bajtach. Pamięć systemowa to pamięć fizyczna używana przez system operacyjny i podzielona na pule stronicowane i niestronicowane. Alokacje pamięci niestronicowanej pozostają w pamięci systemowej i nie są stronicowane do pliku stronicowania pamięci wirtualnej.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna licznikowi wydajności **bajtów puli** niestronicowanej dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Diagnostics.Process.Exited" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A>jest metodą interfejsu API, która wywołuje <xref:System.Diagnostics.Process.Exited> zdarzenie. Wywołanie <xref:System.Diagnostics.Process.OnExited%2A> <xref:System.Diagnostics.Process> powoduje wystąpienie zdarzenia i jest jedynym sposobem na podnoszenie zdarzenia za pomocą składnika. <xref:System.Diagnostics.Process.Exited> <xref:System.Diagnostics.Process.OnExited%2A>jest używany głównie podczas wyprowadzania klas ze składnika.  
  
 Alternatywnie <xref:System.Diagnostics.Process.OnExited%2A>można napisać własny program obsługi zdarzeń. Tworzysz własnego delegata obsługi zdarzeń i własną metodę obsługi zdarzeń.  
  
> [!NOTE]
>  Jeśli używasz środowiska programu Visual Studio, delegat programu obsługi zdarzeń (AddOnExited) i metoda obsługi zdarzeń (Process1_Exited) są tworzone dla Ciebie po przeciągnięciu <xref:System.Diagnostics.Process> składnika na formularz i kliknij dwukrotnie ikonę. Kod tworzony do uruchomienia po <xref:System.Diagnostics.Process.Exited> wystąpieniu zdarzenia jest wprowadzany do procedury Process1_Exited. Nie musisz tworzyć <xref:System.Diagnostics.Process.OnExited%2A> składowej, ponieważ jest ona zaimplementowana.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby zapoznać się z omówieniem, zobacz temat [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Diagnostics.Process.OnExited%2A> jak używać metody w klasie pochodnej.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje za każdym razem, gdy aplikacja zapisuje wiersz w przekierowanym <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie wskazuje, że skojarzony <xref:System.Diagnostics.Process> zapisał wiersz, kończąc z znakiem nowego wiersza, do jego przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. <xref:System.Diagnostics.Process.OutputDataReceived>  
  
 Zdarzenie jest włączane podczas asynchronicznych operacji odczytu <xref:System.Diagnostics.Process.StandardOutput%2A>w. Aby rozpocząć asynchroniczne operacje odczytu <xref:System.Diagnostics.Process.StandardOutput%2A> , należy przekierować strumień <xref:System.Diagnostics.Process>obiektu, dodać obsługę zdarzenia do <xref:System.Diagnostics.Process.OutputDataReceived> zdarzenia i wywołać metodę <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Następnie Zdarzenie sygnalizuje każdorazowe zapisanie wiersza w przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumieniu do momentu zakończenia procesu lub wywołania <xref:System.Diagnostics.Process.CancelOutputRead%2A>. <xref:System.Diagnostics.Process.OutputDataReceived>  
  
> [!NOTE]
>  Aplikacja, która przetwarza asynchroniczne dane wyjściowe, powinna wywołać <xref:System.Diagnostics.Process.WaitForExit%2A> metodę, aby upewnić się, że bufor wyjściowy został opróżniony.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wykonywania asynchronicznych operacji odczytu w przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumieniu `ipconfig` polecenia.  
  
 Przykład tworzy delegata zdarzenia dla `OutputHandler` programu obsługi zdarzeń i kojarzy go <xref:System.Diagnostics.Process.OutputDataReceived> ze zdarzeniem. Program obsługi zdarzeń odbiera wiersze tekstu z przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, formatuje tekst i zapisuje je w ciągu wyjściowym, który jest później wyświetlany w oknie konsoli przykładu.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość stronicowanej pamięci (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci (w bajtach) przydzielonej przez skojarzony proces, który można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość stronicowanej pamięci (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci, w bajtach, przydzieloną w pliku stronicowania pamięci wirtualnej dla skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę właściwość reprezentuje bieżący rozmiar pamięci w pliku stronicowania pamięci wirtualnej używanej przez proces, w bajtach. System operacyjny używa pliku stronicowania pamięci wirtualnej w połączeniu z pamięcią fizyczną do zarządzania wirtualną przestrzenią adresową dla każdego procesu. Gdy Pamięć stronicowana nie jest używana, można ją przesłać do pliku stronicowania pamięci wirtualnej na dysku. Aby uzyskać rozmiar pamięci używanej przez system operacyjny dla procesu, należy użyć <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> właściwości.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna z licznikiem wydajności **bajtów pliku stronicowania** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik, a następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość stronicowanej pamięci systemowej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach, system został przydzielony do skojarzonego procesu, który można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość stronicowanej pamięci systemowej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci systemowej (w bajtach) przydzieloną dla skojarzonego procesu, który można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę wartość właściwości reprezentuje bieżący rozmiar stronicowanej pamięci systemowej używanej przez proces w bajtach. Pamięć systemowa to pamięć fizyczna używana przez system operacyjny i podzielona na pule stronicowane i niestronicowane. Gdy Pamięć stronicowana nie jest używana, można ją przesłać do pliku stronicowania pamięci wirtualnej na dysku. Aby uzyskać rozmiar pamięci aplikacji używanej przez proces, użyj <xref:System.Diagnostics.Process.PagedMemorySize64%2A> właściwości.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna licznikowi wydajności **bajtów stronicowanej puli** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci w pliku stronicowania pamięci wirtualnej (w bajtach) używanej przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci (w bajtach) przydzielonej przez skojarzony proces, który można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci w pliku stronicowania pamięci wirtualnej (w bajtach) używanej przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci (w bajtach) przydzieloną w pliku stronicowania pamięci wirtualnej dla skojarzonego procesu od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę wartość właściwości reprezentuje maksymalny rozmiar pamięci w pliku stronicowania pamięci wirtualnej używany przez proces od momentu jego uruchomienia, w bajtach. System operacyjny używa pliku stronicowania pamięci wirtualnej w połączeniu z pamięcią fizyczną do zarządzania wirtualną przestrzenią adresową dla każdego procesu. Gdy Pamięć stronicowana nie jest używana, można ją przesłać do pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna licznikowi wydajności **bajtów pliku stronicowania** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci wirtualnej (w bajtach) używaną przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci wirtualnej (w bajtach), którą żąda skojarzony proces.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci wirtualnej (w bajtach) używaną przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci wirtualnej (w bajtach) przydzieloną dla skojarzonego procesu od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę właściwość reprezentuje maksymalny rozmiar pamięci wirtualnej używanej przez proces od momentu jego uruchomienia, w bajtach. System operacyjny mapuje wirtualną przestrzeń adresową dla każdego procesu na strony ładowane w pamięci fizycznej lub do stron przechowywanych w pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna licznikowi wydajności **bajtów wirtualnych** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szczytowy rozmiar zestawu roboczego dla skojarzonego procesu, w bajtach.</summary>
        <value>Maksymalna ilość pamięci fizycznej wymaganej przez skojarzony proces w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu jest zestawem stron pamięci, które są obecnie widoczne dla procesu w fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, które mają być używane bez wyzwalania błędu strony.  
  
 Zestaw roboczy zawiera dane udostępnione i prywatne. Dane udostępnione obejmują strony zawierające wszystkie instrukcje wykonywane przez proces, w tym moduły przetwarzania i biblioteki systemowe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci fizycznej (w bajtach) używaną przez skojarzony proces.</summary>
        <value>Maksymalna ilość pamięci fizycznej (w bajtach) przydzieloną dla skojarzonego procesu od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę właściwość reprezentuje maksymalny rozmiar pamięci zestawu roboczego używany przez proces od momentu jego uruchomienia w bajtach. Zestaw roboczy procesu jest zestawem stron pamięci, które są obecnie widoczne dla procesu w fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, które mają być używane bez wyzwalania błędu strony.  
  
 Zestaw roboczy zawiera dane udostępnione i prywatne. Dane udostępnione obejmują strony zawierające wszystkie instrukcje wykonywane przez proces, w tym instrukcje z modułów przetwarzania i biblioteki systemowe.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna licznikowi wydajności **szczytu zestawu roboczego** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy skojarzony priorytet procesu powinien być tymczasowo zwiększany przez system operacyjny, gdy okno główne ma fokus.</summary>
        <value><see langword="true" />Jeśli dynamiczne zwiększanie priorytetu procesu powinno odbywać się w przypadku procesu, gdy zostanie on pobrany ze stanu oczekiwania; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek jest uruchamiany w procesie, dla którego Klasa priorytetu ma jedną z wartości wyliczenia priorytetu dynamicznego (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>lub <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), system tymczasowo zwiększa priorytet wątku, gdy jest wyłączany. Ta akcja uniemożliwia innym procesom przerwanie przetwarzania bieżącego wątku. To <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> ustawienie ma wpływ na wszystkie istniejące wątki i wszystkie wątki, które następnie zostały utworzone przez proces. Aby przywrócić normalne zachowanie, należy ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> właściwość na `false`.  
  
> [!NOTE]
>  Zwiększenie priorytetu zbyt dużej może spowodować opróżnienie zasobów z podstawowych funkcji systemu operacyjnego i sieci, co powoduje problemy z innymi zadaniami systemu operacyjnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać informacji o zwiększeniu priorytetu ze skojarzonego zasobu procesu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Identyfikator procesu lub uchwyt procesu to zero. (Proces nie został uruchomiony).</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> jest niedostępny.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ogólną kategorię priorytetu dla skojarzonego procesu.</summary>
        <value>Kategoria priorytetu skojarzonego procesu, z którego <see cref="P:System.Diagnostics.Process.BasePriority" /> jest obliczany proces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa priorytetu procesu obejmuje zakres poziomów priorytetów wątków. Wątki o różnych priorytetach, które są uruchomione w przebiegu procesu względem klasy priorytetu procesu. Win32 stosuje cztery priorytetowe klasy z siedem poziomów priorytetu podstawowego dla każdej klasy. Te klasy priorytetów procesów są przechwytywane w <xref:System.Diagnostics.ProcessPriorityClass> wyliczeniu, co umożliwia ustawienie priorytetu procesu <xref:System.Diagnostics.ProcessPriorityClass.Idle>na <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal> <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>,,, <xref:System.Diagnostics.ProcessPriorityClass.RealTime>lub. Na podstawie czasu, który upłynął lub inne usprawnienia, poziom priorytetu podstawowego może zostać zmieniony przez system operacyjny, gdy proces musi być umieszczony przed innymi w celu uzyskania dostępu do procesora. Ponadto można ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> , aby tymczasowo zwiększyć poziom priorytetu wątków, które zostały wykonane ze stanu oczekiwania. Priorytet jest resetowany, gdy proces powróci do stanu oczekiwania.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Właściwość umożliwia wyświetlenie priorytetu początkowego przypisanego do procesu. Jednak ponieważ jest tylko do odczytu, nie można użyć <xref:System.Diagnostics.Process.BasePriority%2A> właściwości w celu ustawienia priorytetu procesu. Aby zmienić priorytet, użyj <xref:System.Diagnostics.Process.PriorityClass%2A> właściwości, która pobiera lub ustawia ogólną kategorię priorytetu dla procesu.  
  
 Nie można wyświetlić klasy priorytetów przy użyciu Monitora systemu. W poniższej tabeli przedstawiono relacje między <xref:System.Diagnostics.Process.BasePriority%2A> i. <xref:System.Diagnostics.Process.PriorityClass%2A>  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można ustawić lub pobrać informacji o priorytecie procesu ze skojarzonego zasobu procesu.  
  
 —lub—  
  
 Identyfikator procesu lub uchwyt procesu to zero. (Proces nie został uruchomiony).</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PriorityClass" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> jest niedostępny.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Nie można ustawić klasy priorytetu, ponieważ nie używa ona prawidłowej wartości zdefiniowanej w <see cref="T:System.Diagnostics.ProcessPriorityClass" /> wyliczeniu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci prywatnej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Liczba bajtów przydzielonych przez skojarzony proces, które nie mogą być współużytkowane z innymi procesami.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci prywatnej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci, w bajtach, przydzielona dla skojarzonego procesu, która nie może być współdzielona z innymi procesami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci używanej przez proces w bajtach, które nie mogą być współużytkowane z innymi procesami.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna z licznikiem wydajności **bajtów prywatnych** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uprzywilejowany czas procesora dla tego procesu.</summary>
        <value>A <see cref="T:System.TimeSpan" /> , który wskazuje czas, w którym proces spędził kod w ramach rdzenia systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę procesu.</summary>
        <value>Nazwa wykorzystywana przez system do identyfikowania procesu dla użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> Właściwość zawiera nazwę pliku wykonywalnego, taką jak program Outlook, która nie zawiera rozszerzenia exe ani ścieżki. Jest to przydatne w przypadku pobierania i manipulowania wszystkimi procesami, które są skojarzone z tym samym plikiem wykonywalnym.  
  
> [!NOTE]
>  W [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] systemach<xref:System.Diagnostics.Process.ProcessName%2A> operacyjnych właściwość może zostać obcięta do 15 znaków, jeśli nie można uzyskać informacji o module procesu.  
  
 Można wywołać <xref:System.Diagnostics.Process.GetProcessesByName%2A>, przekazać mu nazwę pliku wykonywalnego, aby pobrać tablicę zawierającą każde uruchomione wystąpienie na określonym komputerze. Możesz użyć tej tablicy, na przykład, aby zamknąć wszystkie uruchomione wystąpienia pliku wykonywalnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie ma identyfikatora lub żaden proces nie jest skojarzony z <see cref="T:System.Diagnostics.Process" />.  
  
—lub— 
Skojarzony proces został zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Ten proces nie znajduje się na tym komputerze.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia procesory, w których można zaplanować uruchamianie wątków w tym procesie.</summary>
        <value>Maska bitów reprezentująca procesory, na których mogą działać wątki w skojarzonym procesie. Wartość domyślna zależy od liczby procesorów w komputerze. Wartość domyślna to 2 <sup>n</sup> -1, gdzie n jest liczbą procesorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W systemie Windows 2000 i nowszych wątek w procesie może być migrowany z procesora do procesora, podczas gdy każda migracja ponownie ładuje pamięć podręczną procesora. W obszarze duże obciążenia systemu, określając, który procesor powinien uruchamiać określony wątek, można zwiększyć wydajność, zmniejszając liczbę ponownych prób załadowania pamięci podręcznej procesora. Skojarzenie między procesorem a wątkiem jest nazywane koligacją procesora.  
  
 Każdy procesor jest reprezentowany jako bit. Bit 0 to procesor jeden, bit 1 to procesor dwa itd. Jeśli ustawisz bit na wartość 1, odpowiedni procesor jest wybierany do przypisania wątku. Po ustawieniu <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartości na zero algorytmy planowania systemu operacyjnego ustawiają koligację wątku. <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Gdy wartość jest ustawiona na dowolną wartość różną od zera, wartość jest interpretowana jako maska bitowa, która określa te procesory kwalifikujące się do wyboru.  
  
 W poniższej tabeli przedstawiono wybór <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartości dla systemu ośmiu procesorów.  
  
|Maska bitów|Wartość binarna|Kwalifikujące się procesory|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 i 2|  
|0x0007|00000000 00000111|1, 2 i 3|  
|0x0009|00000000 00001001|1 i 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 i 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" />nie można ustawić lub pobrać informacji ze skojarzonego zasobu procesu.  
  
—lub— 
Identyfikator procesu lub uchwyt procesu to zero. (Proces nie został uruchomiony).</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> był niedostępny.  
  
—lub— 
Proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odrzuca wszystkie informacje o skojarzonym procesie, który został zbuforowany wewnątrz składnika procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po <xref:System.Diagnostics.Process.Refresh%2A> wywołaniu pierwsze żądanie informacji o każdej z nich powoduje, że składnik procesu uzyskuje nową wartość ze skojarzonego procesu.  
  
 Gdy składnik jest skojarzony z zasobem procesu, wartości <xref:System.Diagnostics.Process> właściwości są natychmiast wypełniane zgodnie ze stanem skojarzonego procesu. <xref:System.Diagnostics.Process> Jeśli informacje o odpowiednim procesie zostaną zmienione, te zmiany nie zostaną odzwierciedlone w <xref:System.Diagnostics.Process> pamięci podręcznej składnika. <xref:System.Diagnostics.Process> Składnik jest migawką zasobu procesu w czasie, w którym są one skojarzone. Aby wyświetlić bieżące wartości dla skojarzonego procesu, wywołaj <xref:System.Diagnostics.Process.Refresh%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej przez skojarzony proces w ciągu 2 sekund przez maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Przykład zamyka proces, jeśli nadal działa po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy interfejs użytkownika procesu odpowiada.</summary>
        <value><see langword="true" />Jeśli interfejs użytkownika skojarzonego procesu odpowiada systemowi; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli proces ma interfejs użytkownika, <xref:System.Diagnostics.Process.Responding%2A> Właściwość kontaktuje się z interfejsem użytkownika, aby określić, czy proces odpowiada na dane wejściowe użytkownika. Jeśli interfejs nie odpowiada natychmiast, <xref:System.Diagnostics.Process.Responding%2A> Właściwość zwraca. `false` Użyj tej właściwości, aby określić, czy interfejs skojarzonego procesu przestał odpowiadać.  
  
 Jeśli proces nie ma <xref:System.Diagnostics.Process.MainWindowHandle%2A>, ta właściwość zwraca. `true`  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Z tym <see cref="T:System.Diagnostics.Process" /> obiektem nie jest skojarzony żaden proces.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Responding" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty do tego procesu.</summary>
        <value>Natywny uchwyt tego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyt jest dostępny tylko wtedy, gdy składnik wywołujący uruchomił proces.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator sesji usług terminalowych dla skojarzonego procesu.</summary>
        <value>Identyfikator sesji usług terminalowych dla skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> Właściwość identyfikuje sesję, w której aplikacja jest aktualnie uruchomiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Z tym procesem nie jest skojarzona żadna sesja.</exception>
        <exception cref="T:System.InvalidOperationException">Z tym identyfikatorem sesji nie jest skojarzony żaden proces.  
  
 —lub—  
  
 Skojarzony proces nie znajduje się na tym komputerze.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do odczytywania danych wyjściowych błędu aplikacji.</summary>
        <value><see cref="T:System.IO.StreamReader" /> , Który może być używany do odczytywania standardowego strumienia błędów aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> Gdy zapisuje tekst do standardowego strumienia błędów, ten tekst jest zwykle wyświetlany w konsoli programu. Przekierowując <xref:System.Diagnostics.Process.StandardError%2A> strumień, można manipulować lub pomijać dane wyjściowe danego procesu. Na przykład można filtrować tekst, formatować go inaczej lub zapisywać dane wyjściowe do konsoli i wyszukanego pliku dziennika.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardError%2A>, należy ustawić na <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> `false`wartość i ustawić wartość <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>. `true` W przeciwnym razie odczyt ze <xref:System.Diagnostics.Process.StandardError%2A> strumienia zgłasza wyjątek.  
  
 Przekierowany <xref:System.Diagnostics.Process.StandardError%2A> strumień można odczytywać synchronicznie lub asynchronicznie. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonują synchroniczne operacje odczytu w strumieniu wyjściowym procesu. Te synchroniczne operacje odczytu nie są wykonywane do momentu <xref:System.Diagnostics.Process> skojarzonego zapisu w <xref:System.Diagnostics.Process.StandardError%2A> jego strumieniu lub zamknięcia strumienia.  
  
 Z kolei program <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> uruchamia asynchroniczne operacje odczytu <xref:System.Diagnostics.Process.StandardError%2A> w strumieniu. Ta metoda umożliwia wyznaczeniu programu obsługi zdarzeń dla danych wyjściowych strumienia i natychmiast powraca do obiektu wywołującego, który może wykonywać inne czynności, gdy dane wyjściowe strumienia są kierowane do programu obsługi zdarzeń.  
  
 Operacje odczytu synchronicznego wprowadzają zależność między odczytem obiektu wywołującego ze <xref:System.Diagnostics.Process.StandardError%2A> strumienia i procesem podrzędnym w tym strumieniu. Te zależności mogą powodować powstanie warunków zakleszczenia. Gdy obiekt wywołujący odczytuje z przekierowanego strumienia procesu podrzędnego, zależy od elementu podrzędnego. Obiekt wywołujący czeka na operację odczytu do momentu zapisu podrzędnego w strumieniu lub zamknięcia strumienia. Gdy proces podrzędny zapisuje wystarczające dane, aby wypełnić przekierowany strumień, zależy od elementu nadrzędnego. Proces podrzędny czeka na następną operację zapisu do momentu, gdy element nadrzędny zostanie odczytany z pełnego strumienia lub zamknie strumień. Warunek zakleszczenia powstaje, gdy wywołujący i proces podrzędny zaczekają na siebie, aby ukończyć operację, i nie może wykonać żadnej operacji. Można uniknąć zakleszczenii, oceniając zależności między procesem wywołującym i podrzędnym.  

W ostatnich dwóch przykładach w tej sekcji użyto <xref:System.Diagnostics.Process.Start%2A> metody do uruchomienia pliku wykonywalnego o nazwie *Write500Lines. exe*. Poniższy przykład zawiera kod źródłowy.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

Poniższy przykład pokazuje, jak odczytywać ze strumienia błędów przekierowanych i poczekać na zakończenie procesu podrzędnego. Pozwala to uniknąć stanu zakleszczenia przez wywołanie `p.StandardError.ReadToEnd` przed `p.WaitForExit`. Warunek zakleszczenia może spowodować, że proces nadrzędny wywoła `p.WaitForExit` przed `p.StandardError.ReadToEnd` i proces podrzędny zapisze wystarczającą ilość tekstu, aby wypełnić przekierowany strumień. Proces nadrzędny czeka na zakończenie procesu podrzędnego. Proces podrzędny zaczeka w nieskończoność na odczytanie ze pełnego <xref:System.Diagnostics.Process.StandardError%2A> strumienia.   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

Podobny problem występuje w przypadku odczytywania całego tekstu zarówno ze standardowego wyjścia, jak i standardowego strumienia błędów. Poniższy przykład wykonuje operację odczytu dla obu strumieni. Pozwala to uniknąć stanu zakleszczenia przez wykonywanie asynchronicznych operacji <xref:System.Diagnostics.Process.StandardError%2A> odczytu strumienia. Warunek zakleszczenia powstaje, gdy wywołujące `p.StandardOutput.ReadToEnd` proces nadrzędny, `p.StandardError.ReadToEnd` a następnie proces podrzędny zapisuje wystarczającą ilość tekstu w celu wypełnienia strumienia błędów. Proces nadrzędny czeka na zamknięcie jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia przez proces podrzędny. Proces podrzędny zaczeka w nieskończoność na odczytanie ze pełnego <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

Można użyć asynchronicznych operacji odczytu, aby uniknąć tych zależności i ich potencjału zakleszczenia. Można też uniknąć sytuacji zakleszczenia, tworząc dwa wątki i odczytując dane wyjściowe każdego strumienia w osobnym wątku.  
  
> [!NOTE]
>  Nie można mieszać asynchronicznych i synchronicznych operacji odczytu w przekierowanym strumieniu. Gdy przekierowany strumień a <xref:System.Diagnostics.Process> zostanie otwarty w trybie asynchronicznym lub synchronicznym, wszystkie dalsze operacje odczytu w tym strumieniu muszą znajdować się w tym samym trybie. Na przykład nie należy śledzić <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wywołania do <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardError%2A> strumienia lub na odwrót. Można jednak odczytywać dwa różne strumienie w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> i wywołać <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardError%2A> strumień.  
  
   
  
## Examples  
 Poniższy przykład używa `net use` polecenia wraz z argumentem dostarczonym przez użytkownika w celu mapowania zasobu sieciowego. Następnie odczytuje standardowy strumień błędów polecenia NET i zapisuje go w konsoli programu.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="true" /> <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> <see langword="false" /> <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Strumień nie został zdefiniowany na potrzeby przekierowania; upewnij się, że jest ustawiony na. <see cref="P:System.Diagnostics.Process.StandardError" />  
  
—lub— 
Strumień został otwarty dla asynchronicznych operacji odczytu z <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />. <see cref="P:System.Diagnostics.Process.StandardError" /></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do zapisywania danych wejściowych aplikacji.</summary>
        <value>A <see cref="T:System.IO.StreamWriter" /> , który może służyć do pisania standardowego strumienia wejściowego aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> Może odczytać wejściowy tekst ze standardowego strumienia wejściowego, zazwyczaj klawiatury. Przekierowując <xref:System.Diagnostics.Process.StandardInput%2A> strumień, można programowo określić dane wejściowe. Na przykład zamiast korzystania z klawiatury wejściowej można dostarczyć tekst z zawartości określonego pliku lub danych wyjściowych z innej aplikacji.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardInput%2A>, należy ustawić na <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> `false`wartość i ustawić wartość <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>. `true` W przeciwnym razie zapis do <xref:System.Diagnostics.Process.StandardInput%2A> strumienia zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób przekierowania <xref:System.Diagnostics.Process.StandardInput%2A> strumienia procesu. Przykład uruchamia `sort` polecenie z przekierowanymi danymi wejściowymi. Następnie użytkownik jest monitowany o tekst i przekazuje go do `sort` procesu za pomocą przekierowanego <xref:System.Diagnostics.Process.StandardInput%2A> strumienia. `sort` Wyniki są wyświetlane użytkownikowi w konsoli programu.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Strumień <see cref="P:System.Diagnostics.Process.StandardInput" /> nie został zdefiniowany, ponieważ <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> jest ustawiony na <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do odczytywania tekstowych danych wyjściowych aplikacji.</summary>
        <value><see cref="T:System.IO.StreamReader" /> , Który może być używany do odczytywania standardowego strumienia wyjściowego aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> Gdy zapisuje tekst w standardowym strumieniu, ten tekst jest zwykle wyświetlany w konsoli programu. Przekierowując <xref:System.Diagnostics.Process.StandardOutput%2A> strumień, można manipulować lub pomijać dane wyjściowe procesu. Na przykład można filtrować tekst, formatować go inaczej lub zapisywać dane wyjściowe do konsoli i wyszukanego pliku dziennika.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardOutput%2A>, należy ustawić na <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> `false`wartość i ustawić wartość <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>. `true` W przeciwnym razie odczyt ze <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia zgłasza wyjątek.  
  
 Przekierowany <xref:System.Diagnostics.Process.StandardOutput%2A> strumień można odczytywać synchronicznie lub asynchronicznie. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonują synchroniczne operacje odczytu w strumieniu wyjściowym procesu. Te synchroniczne operacje odczytu nie są wykonywane do momentu <xref:System.Diagnostics.Process> skojarzonego zapisu w <xref:System.Diagnostics.Process.StandardOutput%2A> jego strumieniu lub zamknięcia strumienia.  
  
 Z kolei program <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> uruchamia asynchroniczne operacje odczytu <xref:System.Diagnostics.Process.StandardOutput%2A> w strumieniu. Ta metoda umożliwia wyznaczeniu programu obsługi zdarzeń dla danych wyjściowych strumienia i natychmiast powraca do obiektu wywołującego, który może wykonywać inne czynności, gdy dane wyjściowe strumienia są kierowane do programu obsługi zdarzeń.  
  
 Operacje odczytu synchronicznego wprowadzają zależność między odczytem obiektu wywołującego ze <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia i procesem podrzędnym w tym strumieniu. Te zależności mogą powodować powstanie warunków zakleszczenia. Gdy obiekt wywołujący odczytuje z przekierowanego strumienia procesu podrzędnego, zależy od elementu podrzędnego. Obiekt wywołujący czeka na operację odczytu do momentu zapisu podrzędnego w strumieniu lub zamknięcia strumienia. Gdy proces podrzędny zapisuje wystarczające dane, aby wypełnić przekierowany strumień, zależy od elementu nadrzędnego. Proces podrzędny czeka na następną operację zapisu do momentu, gdy element nadrzędny zostanie odczytany z pełnego strumienia lub zamknie strumień. Warunek zakleszczenia powstaje, gdy wywołujący i proces podrzędny zaczekają na siebie, aby ukończyć operację, i nie może wykonać żadnej operacji. Można uniknąć zakleszczenii, oceniając zależności między procesem wywołującym i podrzędnym.  

W ostatnich dwóch przykładach w tej sekcji użyto <xref:System.Diagnostics.Process.Start%2A> metody do uruchomienia pliku wykonywalnego o nazwie *Write500Lines. exe*. Poniższy przykład zawiera kod źródłowy.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

Poniższy przykład pokazuje, jak odczytywać ze strumienia przekierowanego i poczekać na zakończenie procesu podrzędnego. Przykład pozwala uniknąć stanu zakleszczenia przez wywołanie `p.StandardOutput.ReadToEnd` przed. `p.WaitForExit` Warunek zakleszczenia może spowodować, że proces nadrzędny wywoła `p.WaitForExit` przed `p.StandardOutput.ReadToEnd` i proces podrzędny zapisze wystarczającą ilość tekstu, aby wypełnić przekierowany strumień. Proces nadrzędny czeka na zakończenie procesu podrzędnego. Proces podrzędny zaczeka w nieskończoność na odczytanie ze pełnego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

Podobny problem występuje w przypadku odczytywania całego tekstu zarówno ze standardowego wyjścia, jak i standardowego strumienia błędów. Poniższy przykład wykonuje operację odczytu dla obu strumieni. Pozwala to uniknąć stanu zakleszczenia przez wykonywanie asynchronicznych operacji <xref:System.Diagnostics.Process.StandardError%2A> odczytu strumienia. Warunek zakleszczenia powstaje, gdy wywołujące `p.StandardOutput.ReadToEnd` proces nadrzędny, `p.StandardError.ReadToEnd` a następnie proces podrzędny zapisuje wystarczającą ilość tekstu w celu wypełnienia strumienia błędów. Proces nadrzędny czeka na zamknięcie jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia przez proces podrzędny. Proces podrzędny zaczeka w nieskończoność na odczytanie ze pełnego <xref:System.Diagnostics.Process.StandardError%2A> strumienia.   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 Można użyć asynchronicznych operacji odczytu, aby uniknąć tych zależności i ich potencjału zakleszczenia. Można też uniknąć sytuacji zakleszczenia, tworząc dwa wątki i odczytując dane wyjściowe każdego strumienia w osobnym wątku.  
  
> [!NOTE]
>  Nie można mieszać asynchronicznych i synchronicznych operacji odczytu w przekierowanym strumieniu. Gdy przekierowany strumień a <xref:System.Diagnostics.Process> zostanie otwarty w trybie asynchronicznym lub synchronicznym, wszystkie dalsze operacje odczytu w tym strumieniu muszą znajdować się w tym samym trybie. Na przykład nie należy śledzić <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wywołania do <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia lub na odwrót. Można jednak odczytywać dwa różne strumienie w różnych trybach. Na przykład można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> i wywołać <xref:System.IO.StreamReader.ReadLine%2A> <xref:System.Diagnostics.Process.StandardError%2A> strumień.  
  
   
  
## Examples  
 Poniższy przykład uruchamia polecenie ipconfig. exe i przekierowuje jego standardowe dane wyjściowe do okna konsoli przykładu.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="true" /> <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> <see langword="false" /> <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Strumień nie został zdefiniowany na potrzeby przekierowania; upewnij się, że jest ustawiony na. <see cref="P:System.Diagnostics.Process.StandardOutput" />  
  
—lub— 
Strumień został otwarty dla asynchronicznych operacji odczytu z <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />. <see cref="P:System.Diagnostics.Process.StandardOutput" /></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia zasób procesu i kojarzy go ze <see cref="T:System.Diagnostics.Process" /> składnikiem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia (lub ponownie używa) zasób procesu, który jest określony przez <see cref="P:System.Diagnostics.Process.StartInfo" /> Właściwość tego <see cref="T:System.Diagnostics.Process" /> składnika i kojarzy go ze składnikiem.</summary>
        <returns><see langword="true" />Jeśli zasób procesu został uruchomiony; <see langword="false" /> Jeśli nowy zasób procesu nie zostanie uruchomiony (na przykład jeśli istniejący proces jest ponownie używany).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić zasób procesu i skojarzyć go z bieżącym <xref:System.Diagnostics.Process> składnikiem. Wartość `true` zwracana wskazuje, że nowy zasób procesu został uruchomiony. Jeśli zasób procesu określony przez <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> element członkowski <xref:System.Diagnostics.Process.StartInfo%2A> właściwości jest już uruchomiony na komputerze, żaden dodatkowy zasób procesu nie zostanie uruchomiony. Zamiast tego zasób uruchomionego procesu jest ponownie używany i `false` zwracany.  
  
 Aplikację ClickOnce można uruchomić, określając lokalizację (na przykład adres sieci Web), z której pierwotnie zainstalowano aplikację. Nie uruchamiaj aplikacji ClickOnce przez określenie jej zainstalowanej lokalizacji na dysku twardym.  
  
> [!NOTE]
>  Jeśli używasz programu Visual Studio, to Przeciążenie <xref:System.Diagnostics.Process.Start%2A> metody jest to, która jest wstawiana do kodu po <xref:System.Diagnostics.Process> przeciągnięciu składnika do projektanta. Za pomocą `StartInfo` `FileName` okna rozwiń kategorię i Zapisz odpowiednią wartość we właściwości. `Properties` Zmiany zostaną wyświetlone w `InitializeComponent` procedurze formularza.  
  
 To Przeciążenie <xref:System.Diagnostics.Process.Start%2A> `static` nie jest metodą. Należy wywołać go z wystąpienia <xref:System.Diagnostics.Process> klasy. Przed wywołaniem <xref:System.Diagnostics.Process.Start%2A>należy najpierw określić <xref:System.Diagnostics.Process.StartInfo%2A> informacje o właściwościach dla <xref:System.Diagnostics.Process> tego wystąpienia, ponieważ te informacje są używane do określenia zasobu procesu do uruchomienia.  
  
 Inne przeciążenia <xref:System.Diagnostics.Process.Start%2A> metody są `static` elementami członkowskimi. Nie trzeba tworzyć wystąpienia <xref:System.Diagnostics.Process> składnika przed wywołaniem tych przeciążeń metody. Zamiast tego można wywołać <xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process> dla samej klasy i utworzyć nowy <xref:System.Diagnostics.Process> składnik, jeśli proces został uruchomiony. Lub, `null` jest zwracany, jeśli proces został ponownie użyty. Zasób procesu jest automatycznie kojarzony z nowym <xref:System.Diagnostics.Process> składnikiem zwracanym <xref:System.Diagnostics.Process.Start%2A> przez metodę.  
  
 Elementy członkowskie mogą służyć do duplikowania funkcjonalności `Run` okna dialogowego menu systemu Windows `Start`. <xref:System.Diagnostics.Process.StartInfo%2A> Wszystkie elementy, które można wpisać w wierszu polecenia, można uruchomić, ustawiając odpowiednie wartości we <xref:System.Diagnostics.Process.StartInfo%2A> właściwości. Jedyną <xref:System.Diagnostics.Process.StartInfo%2A> właściwością, która musi być ustawiona, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> jest właściwość. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Właściwość nie musi być plikiem wykonywalnym. Może to być dowolny typ pliku, dla którego rozszerzenie zostało skojarzone z aplikacją, która jest zainstalowana w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość może mieć rozszerzenie txt, jeśli masz skojarzone pliki tekstowe z edytorem, takim jak Notatnik, lub jeśli masz skojarzone pliki doc za pomocą narzędzia do przetwarzania słów, takiego jak Microsoft Word, może być ono rozszerzeniem. doc.  
  
 W wierszu polecenia można określić akcje do wykonania dla niektórych typów plików. Na przykład można wydrukować dokumenty lub edytować pliki tekstowe. Określ te akcje przy użyciu <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> elementu członkowskiego <xref:System.Diagnostics.Process.StartInfo%2A> właściwości. W przypadku innych typów plików można określić argumenty wiersza polecenia podczas uruchamiania pliku z `Run` okna dialogowego. Na przykład, można przekazać adres URL jako argument, jeśli określisz przeglądarkę jako <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Te argumenty można określić w <xref:System.Diagnostics.Process.StartInfo%2A> <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> składowej właściwości.  
  
 Jeśli masz zmienną PATH zadeklarowaną w systemie przy użyciu cudzysłowów, musisz w pełni zakwalifikować tę ścieżkę podczas uruchamiania dowolnego procesu znajdującego się w tej lokalizacji. W przeciwnym razie system nie znajdzie ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce i dodasz ją przy użyciu cudzysłowu: `path = %path%;"c:\mypath"`, należy w `c:\mypath` pełni zakwalifikować każdy proces podczas jego uruchamiania.  
  
> [!NOTE]
>  ASP.NET stronę sieci Web i kod sterujący serwera wykonywane w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metody na stronie sieci Web ASP.NET lub kontrolce serwera, nowy proces jest wykonywany na serwerze sieci Web z ograniczonymi uprawnieniami. Ten proces nie jest uruchamiany w tym samym kontekście co przeglądarka klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Za każdym razem <xref:System.Diagnostics.Process.Start%2A> , gdy używasz do uruchamiania procesu, może być konieczne jego zamknięcie lub ryzyko utraty zasobów systemowych. Zamknij procesy przy <xref:System.Diagnostics.Process.CloseMainWindow%2A> użyciu <xref:System.Diagnostics.Process.Kill%2A>lub. Możesz sprawdzić, czy proces został już zamknięty, używając jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 W tym miejscu należy zauważyć, że w zarządzanych wątkach są wymagane informacje o Stanach Apartment. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> znajduje `true` się `[STAThread]` we właściwości składnika procesu, upewnij się, że ustawiono model wątkowości w aplikacji przez ustawienie atrybutu w `main()` metodzie. <xref:System.Diagnostics.Process.StartInfo%2A> W przeciwnym razie wątek zarządzany może być `unknown` w stanie lub znajdować się `MTA` w stanie, w którym wystąpił konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Niektóre metody wymagają, aby stan apartamentu nie `unknown`był. Jeśli stan nie jest jawnie ustawiony, gdy aplikacja napotka taką metodę, domyślnie `MTA`jest to, a po ustawieniu nie można zmienić stanu apartamentu. Jednak powoduje `MTA` , że wyjątek jest zgłaszany, gdy powłoka systemu operacyjnego zarządza wątkiem.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano wystąpienie <xref:System.Diagnostics.Process> klasy do uruchomienia procesu.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.Process" /> W<see cref="P:System.Diagnostics.Process.StartInfo" />składniku nie określono nazwy pliku.
- <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> lub-element członkowski <see cref="P:System.Diagnostics.Process.StartInfo" /> właściwości jest <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, lub <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> jest. <see langword="true" /></exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzonego pliku.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt procesu został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemach operacyjnych bez obsługi powłoki, takiej jak nano Server (tylko platforma .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo"><see cref="T:System.Diagnostics.ProcessStartInfo" /> Zawiera informacje, które są używane do uruchamiania procesu, łącznie z nazwą pliku i wszystkimi argumentami wiersza polecenia.</param>
        <summary>Uruchamia zasób procesu, który jest określony przez parametr zawierający informacje o uruchomieniu procesu (na przykład nazwę pliku procesu do uruchomienia) i kojarzy zasób z nowym <see cref="T:System.Diagnostics.Process" /> składnikiem.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> , który jest skojarzony z zasobem procesu lub <see langword="null" /> nie został uruchomiony żaden zasób procesu. Należy zauważyć, że nowy proces, który jest uruchamiany wraz z już uruchomionymi wystąpieniami tego samego procesu, będzie niezależny od innych. Ponadto polecenie Start może zwrócić proces o wartości innej niż null z <see cref="P:System.Diagnostics.Process.HasExited" /> właściwością już ustawioną na. <see langword="true" /> W takim przypadku uruchomiony proces mógł aktywować istniejące wystąpienie samego siebie, a następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić zasób procesu przez określenie <xref:System.Diagnostics.ProcessStartInfo> wystąpienia. Przeciążenie kojarzy zasób z nowym <xref:System.Diagnostics.Process> obiektem.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adresem URL, proces nie zostanie uruchomiony i `null` jest zwracany.  
  
 To Przeciążenie pozwala uruchomić proces bez wcześniejszego utworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. <xref:System.Diagnostics.ProcessStartInfo> Użycie tego przeciążenia z parametrem jest alternatywą dla jawnych kroków tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia, ustawiania jego <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla tego <xref:System.Diagnostics.Process> wystąpienia.  
  
 Użycie wystąpienia jako parametru umożliwia wywoływanie <xref:System.Diagnostics.Process.Start%2A> z największą kontrolę nad tym, co jest przesyłane do wywołania w celu uruchomienia procesu. <xref:System.Diagnostics.ProcessStartInfo> Jeśli konieczne jest przekazanie tylko nazwy pliku lub nazwy pliku i argumentów, nie trzeba tworzyć nowego <xref:System.Diagnostics.ProcessStartInfo> wystąpienia, chociaż jest to opcja. Jedyną <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> właściwością, która musi być ustawiona, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> jest właściwość. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Właściwość nie musi reprezentować pliku wykonywalnego. Może to być dowolny typ pliku, dla którego rozszerzenie zostało skojarzone z aplikacją, która jest zainstalowana w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość może mieć rozszerzenie txt, jeśli masz skojarzone pliki tekstowe z edytorem, takim jak Notatnik, lub jeśli masz skojarzone pliki doc za pomocą narzędzia do przetwarzania słów, takiego jak Microsoft Word, może być ono rozszerzeniem. doc.  
  
 Aplikację ClickOnce można uruchomić, określając lokalizację (na przykład adres sieci Web), z której pierwotnie zainstalowano aplikację. Nie uruchamiaj aplikacji ClickOnce przez określenie jej zainstalowanej lokalizacji na dysku twardym.  
  
 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> `true` `CreateProcessWithLogonW` <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> Jeśli właściwości <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> iwystąpieniasąustawione,wywoływanajestfunkcjaniezarządzana,którauruchamiaproceswnowym<xref:System.Diagnostics.Process.StartInfo%2A> oknie, nawet jeśli wartość właściwości jest lub <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> wartość właściwości to <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. `null` <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> **@** Jeśli właściwość ma wartość, właściwość musi być w formacie UPN, User DNS_domain_name. <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>   
  
 W przeciwieństwie do innych przeciążeń, <xref:System.Diagnostics.Process.Start%2A> Przeciążenie, które nie ma parametrów, `static` nie jest elementem członkowskim. Użyj tego przeciążenia, gdy już utworzono <xref:System.Diagnostics.Process> wystąpienie, określone informacje o uruchomieniu (w tym nazwa pliku) i chcesz uruchomić zasób procesu i skojarzyć go z istniejącym <xref:System.Diagnostics.Process> wystąpieniem. Użyj jednego z `static` przeciążeń, jeśli chcesz utworzyć nowy <xref:System.Diagnostics.Process> składnik zamiast uruchamiać proces dla istniejącego składnika. Zarówno to Przeciążenie, jak i Przeciążenie, które nie ma parametrów, umożliwiają określenie informacji startowych dla zasobu procesu za pomocą <xref:System.Diagnostics.ProcessStartInfo> wystąpienia.  
  
 Jeśli masz zmienną PATH zadeklarowaną w systemie przy użyciu cudzysłowów, musisz w pełni zakwalifikować tę ścieżkę podczas uruchamiania dowolnego procesu znajdującego się w tej lokalizacji. W przeciwnym razie system nie znajdzie ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce i dodasz ją przy użyciu cudzysłowu: `path = %path%;"c:\mypath"`, należy w `c:\mypath` pełni zakwalifikować każdy proces podczas jego uruchamiania.  
  
> [!NOTE]
>  ASP.NET stronę sieci Web i kod sterujący serwera wykonywane w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metody na stronie sieci Web ASP.NET lub kontrolce serwera, nowy proces jest wykonywany na serwerze sieci Web z ograniczonymi uprawnieniami. Ten proces nie jest uruchamiany w tym samym kontekście co przeglądarka klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Za każdym razem <xref:System.Diagnostics.Process.Start%2A> , gdy używasz do uruchamiania procesu, może być konieczne jego zamknięcie lub ryzyko utraty zasobów systemowych. Zamknij procesy przy <xref:System.Diagnostics.Process.CloseMainWindow%2A> użyciu <xref:System.Diagnostics.Process.Kill%2A>lub. Możesz sprawdzić, czy proces został już zamknięty, używając jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 W tym miejscu należy zauważyć, że w zarządzanych wątkach są wymagane informacje o Stanach Apartment. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> znajduje `true` się na `startInfo` parametrze, upewnij się, że ustawiono model wątkowości w aplikacji przez ustawienie atrybutu `[STAThread]` w `main()` metodzie. W przeciwnym razie wątek zarządzany może być `unknown` w stanie lub znajdować się `MTA` w stanie, w którym wystąpił konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Niektóre metody wymagają, aby stan apartamentu nie `unknown`był. Jeśli stan nie jest jawnie ustawiony, gdy aplikacja napotka taką metodę, domyślnie `MTA`jest to, a po ustawieniu nie można zmienić stanu apartamentu. Jednak powoduje `MTA` , że wyjątek jest zgłaszany, gdy powłoka systemu operacyjnego zarządza wątkiem.  
  
   
  
## Examples  
 Poniższy przykład najpierw duplikuje wystąpienie programu Internet Explorer i wyświetli zawartość folderu Ulubione w przeglądarce. Następnie uruchamia inne wystąpienia programu Internet Explorer i wyświetla określone strony lub witryny. Na koniec program Internet Explorer zostanie uruchomiony z zminimalizowanym oknem podczas nawigowania do określonej lokacji.  
  
 Aby uzyskać dodatkowe przykłady innych zastosowań tej metody, zobacz poszczególne właściwości <xref:System.Diagnostics.ProcessStartInfo> klasy.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">W <paramref name="startInfo" /> właściwości<see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> parametru nie określono nazwy pliku.  
  
—lub— 
<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Właściwość parametruma<see langword="true" /> również Właściwość,<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />,lub .<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> <paramref name="startInfo" /> <see langword="true" />  
  
—lub— 
<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> Właściwość parametru ma <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> <see langword="null" />wartość, a właściwość nie<see langword="null" /> jest pusta lub właściwość nie jest. <see langword="true" /> <paramref name="startInfo" /></exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="startInfo" /></exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt procesu został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku określonego <paramref name="startInfo" /> we <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> właściwości parametru.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzonego pliku.  
  
 —lub—  
  
 Suma długości argumentów i długość pełnej ścieżki do procesu przekracza 2080. Komunikat o błędzie skojarzony z tym wyjątkiem może być jednym z następujących: "Obszar danych przesłany do wywołania systemowego jest za mały". lub "odmowa dostępu".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemach operacyjnych bez obsługi powłoki, takiej jak nano Server (tylko platforma .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa dokumentu lub pliku aplikacji do uruchomienia w procesie.</param>
        <summary>Uruchamia zasób procesu, określając nazwę dokumentu lub pliku aplikacji i kojarzy zasób z nowym <see cref="T:System.Diagnostics.Process" /> składnikiem.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> , który jest skojarzony z zasobem procesu lub <see langword="null" /> nie został uruchomiony żaden zasób procesu. Należy zauważyć, że nowy proces, który jest uruchamiany wraz z już uruchomionymi wystąpieniami tego samego procesu, będzie niezależny od innych. Ponadto polecenie Start może zwrócić proces o wartości innej niż null z <see cref="P:System.Diagnostics.Process.HasExited" /> właściwością już ustawioną na. <see langword="true" /> W takim przypadku uruchomiony proces mógł aktywować istniejące wystąpienie samego siebie, a następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić zasób procesu, określając jego nazwę pliku. Przeciążenie kojarzy zasób z nowym <xref:System.Diagnostics.Process> obiektem.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adresem URL, proces nie zostanie uruchomiony i `null` jest zwracany.  
  
 To Przeciążenie pozwala uruchomić proces bez wcześniejszego utworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie jest alternatywą <xref:System.Diagnostics.Process> dla jawnych kroków tworzenia nowego wystąpienia, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> ustawiania elementu członkowskiego <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla tego <xref:System.Diagnostics.Process> wystąpienia.  
  
 Aplikację ClickOnce można uruchomić przez ustawienie `fileName` parametru na lokalizację (na przykład adres sieci Web), z której pierwotnie zainstalowano aplikację. Nie uruchamiaj aplikacji ClickOnce przez określenie jej zainstalowanej lokalizacji na dysku twardym.  
  
 Uruchamianie procesu przez określenie jego nazwy pliku jest podobne do wpisywania informacji w `Run` oknie dialogowym menu systemu Windows. `Start` W związku z tym nazwa pliku nie musi reprezentować pliku wykonywalnego. Może to być dowolny typ pliku, dla którego rozszerzenie zostało skojarzone z aplikacją zainstalowaną w systemie. Na przykład nazwa pliku może mieć rozszerzenie txt, jeśli masz skojarzone pliki tekstowe z edytorem, takim jak Notatnik, lub jeśli masz skojarzone pliki doc za pomocą narzędzia do przetwarzania słów, takiego jak Microsoft Word. Podobnie w taki sam sposób, w jaki `Run` okno dialogowe może akceptować nazwę pliku wykonywalnego z rozszerzeniem. exe lub bez niego, rozszerzenie. exe jest opcjonalne `fileName` w parametrze. Na przykład można ustawić `fileName` parametr na "Notepad. exe" lub "Notepad".  
  
 To Przeciążenie nie zezwala na używanie argumentów wiersza polecenia dla procesu. Jeśli musisz określić jeden lub więcej argumentów wiersza polecenia dla procesu, użyj <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> lub <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overloads.  
  
 W przeciwieństwie do innych przeciążeń, <xref:System.Diagnostics.Process.Start%2A> Przeciążenie, które nie ma parametrów, `static` nie jest elementem członkowskim. Użyj tego przeciążenia, gdy już utworzono <xref:System.Diagnostics.Process> wystąpienie, określone informacje o uruchomieniu (w tym nazwa pliku) i chcesz uruchomić zasób procesu i skojarzyć go z istniejącym <xref:System.Diagnostics.Process> wystąpieniem. Użyj jednego z `static` przeciążeń, jeśli chcesz utworzyć nowy <xref:System.Diagnostics.Process> składnik zamiast uruchamiać proces dla istniejącego składnika. Zarówno to Przeciążenie, jak i Przeciążenie, które nie ma parametrów, umożliwiają określenie nazwy pliku zasobu procesu do uruchomienia.  
  
 Jeśli masz zmienną PATH zadeklarowaną w systemie przy użyciu cudzysłowów, musisz w pełni zakwalifikować tę ścieżkę podczas uruchamiania dowolnego procesu znajdującego się w tej lokalizacji. W przeciwnym razie system nie znajdzie ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce i dodasz ją przy użyciu cudzysłowu: `path = %path%;"c:\mypath"`, należy w `c:\mypath` pełni zakwalifikować każdy proces podczas jego uruchamiania.  
  
> [!NOTE]
>  ASP.NET stronę sieci Web i kod sterujący serwera wykonywane w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metody na stronie sieci Web ASP.NET lub kontrolce serwera, nowy proces jest wykonywany na serwerze sieci Web z ograniczonymi uprawnieniami. Ten proces nie jest uruchamiany w tym samym kontekście co przeglądarka klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Za każdym razem <xref:System.Diagnostics.Process.Start%2A> , gdy używasz do uruchamiania procesu, może być konieczne jego zamknięcie lub ryzyko utraty zasobów systemowych. Zamknij procesy przy <xref:System.Diagnostics.Process.CloseMainWindow%2A> użyciu <xref:System.Diagnostics.Process.Kill%2A>lub. Możesz sprawdzić, czy proces został już zamknięty, używając jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 W tym miejscu należy zauważyć, że w zarządzanych wątkach są wymagane informacje o Stanach Apartment. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> znajduje `true` się `[STAThread]` we właściwości składnika procesu, upewnij się, że ustawiono model wątkowości w aplikacji przez ustawienie atrybutu w `main()` metodzie. <xref:System.Diagnostics.Process.StartInfo%2A> W przeciwnym razie wątek zarządzany może być `unknown` w stanie lub znajdować się `MTA` w stanie, w którym wystąpił konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Niektóre metody wymagają, aby stan apartamentu nie `unknown`był. Jeśli stan nie jest jawnie ustawiony, gdy aplikacja napotka taką metodę, domyślnie `MTA`jest to, a po ustawieniu nie można zmienić stanu apartamentu. Jednak powoduje `MTA` , że wyjątek jest zgłaszany, gdy powłoka systemu operacyjnego zarządza wątkiem.  
  
   
  
## Examples  
 Poniższy przykład najpierw duplikuje wystąpienie programu Internet Explorer i wyświetli zawartość folderu Ulubione w przeglądarce. Następnie uruchamia inne wystąpienia programu Internet Explorer i wyświetla określone strony lub witryny. Na koniec program Internet Explorer zostanie uruchomiony z zminimalizowanym oknem podczas nawigowania do określonej lokacji.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzonego pliku.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt procesu został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zmienna środowiskowa PATH ma ciąg zawierający cudzysłowy.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchomienia w procesie.</param>
        <param name="arguments">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Uruchamia zasób procesu przez określenie nazwy aplikacji i zestawu argumentów wiersza polecenia i skojarzenie zasobu z nowym <see cref="T:System.Diagnostics.Process" /> składnikiem.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> , który jest skojarzony z zasobem procesu lub <see langword="null" /> nie został uruchomiony żaden zasób procesu. Należy zauważyć, że nowy proces, który jest uruchamiany wraz z już uruchomionymi wystąpieniami tego samego procesu, będzie niezależny od innych. Ponadto polecenie Start może zwrócić proces o wartości innej niż null z <see cref="P:System.Diagnostics.Process.HasExited" /> właściwością już ustawioną na. <see langword="true" /> W takim przypadku uruchomiony proces mógł aktywować istniejące wystąpienie samego siebie, a następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić zasób procesu przez określenie jego nazwy pliku i argumentów wiersza polecenia. Przeciążenie kojarzy zasób z nowym <xref:System.Diagnostics.Process> obiektem.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adresem URL, proces nie zostanie uruchomiony i `null` jest zwracany.  
  
 To Przeciążenie pozwala uruchomić proces bez wcześniejszego utworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie <xref:System.Diagnostics.Process> jest alternatywą dla jawnych kroków tworzenia nowego wystąpienia, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> ustawiania elementów członkowskich <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> wywoływania <xref:System.Diagnostics.Process.Start%2A> dla tego <xref:System.Diagnostics.Process> wystąpienia.  
  
 Uruchamianie procesu przez określenie jego nazwy pliku i argumentów jest podobne do wpisywania nazwy pliku i argumentów wiersza polecenia w `Run` oknie dialogowym menu systemu Windows. `Start` W związku z tym nazwa pliku nie musi reprezentować pliku wykonywalnego. Może to być dowolny typ pliku, dla którego rozszerzenie zostało skojarzone z aplikacją zainstalowaną w systemie. Na przykład nazwa pliku może mieć rozszerzenie txt, jeśli masz skojarzone pliki tekstowe z edytorem, takim jak Notatnik, lub jeśli masz skojarzone pliki doc za pomocą narzędzia do przetwarzania słów, takiego jak Microsoft Word. Podobnie w taki sam sposób, w jaki `Run` okno dialogowe może akceptować nazwę pliku wykonywalnego z rozszerzeniem. exe lub bez niego, rozszerzenie. exe jest opcjonalne `fileName` w parametrze. Na przykład można ustawić `fileName` parametr na "Notepad. exe" lub "Notepad". Jeśli parametr reprezentuje plik wykonywalny `arguments` , parametr może reprezentować plik do działania, na przykład plik tekstowy w `Notepad.exe myfile.txt`. `fileName` Jeśli parametr reprezentuje plik polecenia (. cmd) `arguments` , parametr musi zawierać argument "`/c`" lub "`/k`", aby określić, czy okno polecenia zostanie zakończone, czy pozostanie po zakończeniu. `fileName`  
  
 W przeciwieństwie do innych przeciążeń, <xref:System.Diagnostics.Process.Start%2A> Przeciążenie, które nie ma parametrów, `static` nie jest elementem członkowskim. Użyj tego przeciążenia, gdy już utworzono <xref:System.Diagnostics.Process> wystąpienie, określone informacje o uruchomieniu (w tym nazwa pliku) i chcesz uruchomić zasób procesu i skojarzyć go z istniejącym <xref:System.Diagnostics.Process> wystąpieniem. Użyj jednego z `static` przeciążeń, jeśli chcesz utworzyć nowy <xref:System.Diagnostics.Process> składnik zamiast uruchamiać proces dla istniejącego składnika. Zarówno to Przeciążenie, jak i Przeciążenie, które nie ma parametrów, umożliwiają określenie nazwy pliku zasobu procesu do uruchomienia i argumentów wiersza polecenia do przekazania.  
  
 Jeśli masz zmienną PATH zadeklarowaną w systemie przy użyciu cudzysłowów, musisz w pełni zakwalifikować tę ścieżkę podczas uruchamiania dowolnego procesu znajdującego się w tej lokalizacji. W przeciwnym razie system nie znajdzie ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce i dodasz ją przy użyciu cudzysłowu: `path = %path%;"c:\mypath"`, należy w `c:\mypath` pełni zakwalifikować każdy proces podczas jego uruchamiania.  
  
> [!NOTE]
>  ASP.NET stronę sieci Web i kod sterujący serwera wykonywane w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metody na stronie sieci Web ASP.NET lub kontrolce serwera, nowy proces jest wykonywany na serwerze sieci Web z ograniczonymi uprawnieniami. Ten proces nie jest uruchamiany w tym samym kontekście co przeglądarka klienta i nie ma dostępu do pulpitu użytkownika.  
  
 Za każdym razem <xref:System.Diagnostics.Process.Start%2A> , gdy używasz do uruchamiania procesu, może być konieczne jego zamknięcie lub ryzyko utraty zasobów systemowych. Zamknij procesy przy <xref:System.Diagnostics.Process.CloseMainWindow%2A> użyciu <xref:System.Diagnostics.Process.Kill%2A>lub. Możesz sprawdzić, czy proces został już zamknięty, używając jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości. 
  
 W tym miejscu należy zauważyć, że w zarządzanych wątkach są wymagane informacje o Stanach Apartment. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> znajduje `true` się `[STAThread]` we właściwości składnika procesu, upewnij się, że ustawiono model wątkowości w aplikacji przez ustawienie atrybutu w `main()` metodzie. <xref:System.Diagnostics.Process.StartInfo%2A> W przeciwnym razie wątek zarządzany może być `unknown` w stanie lub znajdować się `MTA` w stanie, w którym wystąpił konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`. Niektóre metody wymagają, aby stan apartamentu nie `unknown`był. Jeśli stan nie jest jawnie ustawiony, gdy aplikacja napotka taką metodę, domyślnie `MTA`jest to, a po ustawieniu nie można zmienić stanu apartamentu. Jednak powoduje `MTA` , że wyjątek jest zgłaszany, gdy powłoka systemu operacyjnego zarządza wątkiem.  
  
   
  
## Examples  
 Poniższy przykład najpierw duplikuje wystąpienie programu Internet Explorer i wyświetli zawartość folderu Ulubione w przeglądarce. Następnie uruchamia inne wystąpienia programu Internet Explorer i wyświetla określone strony lub witryny. Na koniec program Internet Explorer zostanie uruchomiony z zminimalizowanym oknem podczas nawigowania do określonej lokacji.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Parametr <paramref name="fileName" /> lub <paramref name="arguments" /> jest .<see langword="null" /></exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzonego pliku.  
  
 —lub—  
  
 Suma długości argumentów i długość pełnej ścieżki do procesu przekracza 2080. Komunikat o błędzie skojarzony z tym wyjątkiem może być jednym z następujących: "Obszar danych przesłany do wywołania systemowego jest za mały". lub "odmowa dostępu".</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt procesu został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zmienna środowiskowa PATH ma ciąg zawierający cudzysłowy.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchomienia w procesie.</param>
        <param name="userName">Nazwa użytkownika, która ma być używana podczas uruchamiania procesu.</param>
        <param name="password">Zawierający <see cref="T:System.Security.SecureString" /> hasło, które ma być używane podczas uruchamiania procesu.</param>
        <param name="domain">Domena, która ma być używana podczas uruchamiania procesu.</param>
        <summary>Uruchamia zasób procesu, określając nazwę aplikacji, nazwę użytkownika, hasło i domenę i kojarzy zasób z nowym <see cref="T:System.Diagnostics.Process" /> składnikiem.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> , który jest skojarzony z zasobem procesu lub <see langword="null" /> nie został uruchomiony żaden zasób procesu. Należy zauważyć, że nowy proces, który jest uruchamiany wraz z już uruchomionymi wystąpieniami tego samego procesu, będzie niezależny od innych. Ponadto polecenie Start może zwrócić proces o wartości innej niż null z <see cref="P:System.Diagnostics.Process.HasExited" /> właściwością już ustawioną na. <see langword="true" /> W takim przypadku uruchomiony proces mógł aktywować istniejące wystąpienie samego siebie, a następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowy proces i jego wątek podstawowy przez określenie jego nazwy pliku, nazwy użytkownika, hasła i domeny. Nowy proces uruchamia następnie określony plik wykonywalny w kontekście zabezpieczeń określonych poświadczeń (użytkownika, domeny i hasła).  
  
> [!NOTE]
>  Gdy plik wykonywalny znajduje się na dysku zdalnym, należy zidentyfikować udział sieciowy przy użyciu identyfikatora URI (Uniform Resource Identifier), a nie litery dysku połączonego.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adresem URL, proces nie zostanie uruchomiony i `null` jest zwracany.  
  
 To Przeciążenie pozwala uruchomić proces bez wcześniejszego utworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie jest <xref:System.Diagnostics.Process> alternatywą dla jawnych kroków tworzenia nowego wystąpienia, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>ustawiania <xref:System.Diagnostics.Process.StartInfo%2A> <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> <xref:System.Diagnostics.ProcessStartInfo.Password%2A>właściwości właściwości,,, i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienie.  
  
 Podobnie w taki sam sposób, w jaki okno dialogowe **uruchamiania** może akceptować nazwę pliku wykonywalnego z rozszerzeniem. exe lub bez niego, rozszerzenie. exe jest opcjonalne w `fileName` parametrze. Na przykład można ustawić `fileName` parametr na "Notepad. exe" lub "Notepad". Jeśli parametr reprezentuje plik wykonywalny `arguments` , parametr może reprezentować plik do działania, na przykład plik tekstowy w `Notepad.exe myfile.txt`. `fileName`  
  
> [!NOTE]
>  Nazwa pliku musi reprezentować plik wykonywalny w <xref:System.Diagnostics.Process.Start%2A> przeciążeniach, `userName`które `password`mają parametry `domain` , i.  
  
 Za każdym razem <xref:System.Diagnostics.Process.Start%2A> , gdy używasz do uruchamiania procesu, może być konieczne jego zamknięcie lub ryzyko utraty zasobów systemowych. Zamknij procesy przy <xref:System.Diagnostics.Process.CloseMainWindow%2A> użyciu <xref:System.Diagnostics.Process.Kill%2A>lub. Możesz sprawdzić, czy proces został już zamknięty, używając jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości. 
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego przeciążenia do uruchomienia pliku wykonywalnego, a także demonstruje wyrzucanie <xref:System.ComponentModel.Win32Exception> podczas próby uruchomienia aplikacji skojarzonej z plikiem niewykonywalnym.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie określono nazwy pliku.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzonego pliku.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt procesu został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ten element członkowski nie jest obsługiwany w systemie Linux lub macOS (tylko platforma .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchomienia w procesie.</param>
        <param name="arguments">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <param name="userName">Nazwa użytkownika, która ma być używana podczas uruchamiania procesu.</param>
        <param name="password">Zawierający <see cref="T:System.Security.SecureString" /> hasło, które ma być używane podczas uruchamiania procesu.</param>
        <param name="domain">Domena, która ma być używana podczas uruchamiania procesu.</param>
        <summary>Uruchamia zasób procesu, określając nazwę aplikacji, zestaw argumentów wiersza polecenia, nazwę użytkownika, hasło i domenę i kojarzy zasób z nowym <see cref="T:System.Diagnostics.Process" /> składnikiem.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> , który jest skojarzony z zasobem procesu lub <see langword="null" /> nie został uruchomiony żaden zasób procesu. Należy zauważyć, że nowy proces, który jest uruchamiany wraz z już uruchomionymi wystąpieniami tego samego procesu, będzie niezależny od innych. Ponadto polecenie Start może zwrócić proces o wartości innej niż null z <see cref="P:System.Diagnostics.Process.HasExited" /> właściwością już ustawioną na. <see langword="true" /> W takim przypadku uruchomiony proces mógł aktywować istniejące wystąpienie samego siebie, a następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowy proces i jego wątek podstawowy przez określenie jego nazwy pliku, argumentów wiersza polecenia, nazwy użytkownika, hasła i domeny. Nowy proces uruchamia następnie określony plik wykonywalny w kontekście zabezpieczeń określonych poświadczeń (użytkownika, domeny i hasła).  
  
> [!NOTE]
>  Gdy plik wykonywalny znajduje się na dysku zdalnym, należy zidentyfikować udział sieciowy przy użyciu identyfikatora URI (Uniform Resource Identifier), a nie litery dysku połączonego.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adresem URL, proces nie zostanie uruchomiony i `null` jest zwracany.  
  
 To Przeciążenie pozwala uruchomić proces bez wcześniejszego utworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie jest <xref:System.Diagnostics.Process> alternatywą dla jawnych kroków tworzenia nowego wystąpienia, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>ustawiania właściwości <xref:System.Diagnostics.Process.StartInfo%2A> właściwości, <xref:System.Diagnostics.ProcessStartInfo.Password%2A> <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>,,, i <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> wywołania <xref:System.Diagnostics.Process.Start%2A> dla tego<xref:System.Diagnostics.Process> wystąpienia.  
  
 Podobnie w taki sam sposób, w jaki okno dialogowe **uruchamiania** może akceptować nazwę pliku wykonywalnego z rozszerzeniem. exe lub bez niego, rozszerzenie. exe jest opcjonalne w `fileName` parametrze. Na przykład można ustawić `fileName` parametr na "Notepad. exe" lub "Notepad". Jeśli parametr reprezentuje plik wykonywalny `arguments` , parametr może reprezentować plik do działania, na przykład plik tekstowy w `Notepad.exe myfile.txt`. `fileName`  
  
> [!NOTE]
>  Nazwa pliku musi reprezentować plik wykonywalny w <xref:System.Diagnostics.Process.Start%2A> przeciążeniach, `userName`które `password`mają parametry `domain` , i.  
  
 Za każdym razem <xref:System.Diagnostics.Process.Start%2A> , gdy używasz do uruchamiania procesu, może być konieczne jego zamknięcie lub ryzyko utraty zasobów systemowych. Zamknij procesy przy <xref:System.Diagnostics.Process.CloseMainWindow%2A> użyciu <xref:System.Diagnostics.Process.Kill%2A>lub. Możesz sprawdzić, czy proces został już zamknięty, używając jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie określono nazwy pliku.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzonego pliku.  
  
 —lub—  
  
 Suma długości argumentów i długość pełnej ścieżki do skojarzonego pliku przekracza 2080. Komunikat o błędzie skojarzony z tym wyjątkiem może być jednym z następujących: "Obszar danych przesłany do wywołania systemowego jest za mały". lub "odmowa dostępu".</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt procesu został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ten element członkowski nie jest obsługiwany w systemie Linux lub macOS (tylko platforma .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwości, które mają zostać przekazane <see cref="M:System.Diagnostics.Process.Start" /> do metody. <see cref="T:System.Diagnostics.Process" /></summary>
        <value><see cref="T:System.Diagnostics.ProcessStartInfo" /> Reprezentuje dane, z których ma zostać uruchomiony proces. Te argumenty obejmują nazwę pliku wykonywalnego lub dokumentu używanego do uruchamiania procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A>reprezentuje zestaw parametrów, które mają zostać użyte do uruchomienia procesu. Gdy <xref:System.Diagnostics.Process.Start%2A> jest wywoływana <xref:System.Diagnostics.Process.StartInfo%2A> , służy do określenia procesu, który ma zostać uruchomiony. Jedyną wymaganą <xref:System.Diagnostics.Process.StartInfo%2A> składową do ustawienia <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> jest właściwość. Uruchamianie procesu przez określenie <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości jest podobne do wpisywania informacji w oknie dialogowym **Uruchamianie** w menu **Start** systemu Windows. W związku z <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> tym właściwość nie musi reprezentować pliku wykonywalnego. Może to być dowolny typ pliku, dla którego rozszerzenie zostało skojarzone z aplikacją zainstalowaną w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> może mieć rozszerzenie txt, jeśli masz skojarzone pliki tekstowe z edytorem, takim jak Notatnik, lub jeśli masz skojarzone pliki doc za pomocą narzędzia do przetwarzania tekstów, takiego jak Microsoft Word. Podobnie w taki sam sposób, w jaki okno dialogowe **uruchamiania** może akceptować nazwę pliku wykonywalnego z rozszerzeniem exe lub bez niego, rozszerzenie. exe jest opcjonalne w <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> składowej. Na przykład można ustawić <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość na "Notepad. exe" lub "Notepad".  
  
 Aplikację ClickOnce można uruchomić przez ustawienie <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości na lokalizację (na przykład adres sieci Web), z której pierwotnie zainstalowano aplikację. Nie uruchamiaj aplikacji ClickOnce przez określenie jej zainstalowanej lokalizacji na dysku twardym.  
  
 Jeśli nazwa pliku zawiera plik niewykonywalny, taki jak plik. doc, można dołączyć czasownik określający akcję do wykonania na pliku. Na przykład można ustawić <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> na "Print" dla pliku kończącego się rozszerzeniem. doc. Nazwa pliku określona we <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości nie musi mieć rozszerzenia, jeśli ręcznie wprowadzisz wartość <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> właściwości. Jeśli jednak użyjesz <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> właściwości, aby określić, jakie zlecenia są dostępne, musisz uwzględnić rozszerzenie.  
  
 Można zmienić parametry określone we <xref:System.Diagnostics.Process.StartInfo%2A> właściwości do momentu <xref:System.Diagnostics.Process.Start%2A> wywołania metody w procesie. Po rozpoczęciu procesu zmiany <xref:System.Diagnostics.Process.StartInfo%2A> wartości nie wpływają na ani nie uruchamiają ponownie skojarzonego procesu. Jeśli wywołasz <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> metodę `true` `CreateProcessWithLogonW` <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> z zestawem właściwości <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> i, wywoływana jest funkcja niezarządzana, <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> która uruchamia proces w nowym oknie, nawet jeśli wartość właściwości jest lub <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> wartość właściwości to <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Należy uzyskać dostęp <xref:System.Diagnostics.Process.StartInfo%2A> do właściwości tylko <xref:System.Diagnostics.Process> dla obiektu zwróconego przez <xref:System.Diagnostics.Process.Start%2A> metodę. Na przykład nie należy uzyskiwać dostępu <xref:System.Diagnostics.Process.StartInfo%2A> do właściwości <xref:System.Diagnostics.Process> obiektu zwróconego przez <xref:System.Diagnostics.Process.GetProcesses%2A>. W przeciwnym razie w środowisku .NET <xref:System.Diagnostics.Process.StartInfo%2A> Core właściwość będzie <xref:System.InvalidOperationException> generować obiekt fikcyjny <xref:System.Diagnostics.ProcessStartInfo> i na .NET Framework.
  
 Po uruchomieniu procesu nazwa pliku jest plikiem, który wypełnia Właściwość (tylko do odczytu) <xref:System.Diagnostics.Process.MainModule%2A> . Jeśli chcesz pobrać plik wykonywalny, który jest skojarzony z procesem po rozpoczęciu procesu, użyj <xref:System.Diagnostics.Process.MainModule%2A> właściwości. Jeśli chcesz ustawić plik <xref:System.Diagnostics.Process> wykonywalny wystąpienia, dla którego skojarzony proces nie został uruchomiony, <xref:System.Diagnostics.Process.StartInfo%2A> Użyj <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> elementu członkowskiego właściwości. Ponieważ elementy członkowskie <xref:System.Diagnostics.Process.StartInfo%2A> właściwości są argumentami, które są przekazane <xref:System.Diagnostics.Process.Start%2A> do metody procesu, zmiana <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości po rozpoczęciu <xref:System.Diagnostics.Process.MainModule%2A> skojarzonego procesu nie spowoduje zresetowania właściwości. Te właściwości są używane tylko w celu zainicjowania skojarzonego procesu.  
  
   
  
## Examples  
 Poniższy przykład wypełnia <xref:System.Diagnostics.Process.StartInfo%2A> plik, który ma zostać wykonany, wykonaną akcję i niezależnie od tego, czy powinien on wyświetlać interfejs użytkownika. Dodatkowe przykłady można znaleźć na stronach referencyjnych właściwości <xref:System.Diagnostics.ProcessStartInfo> klasy.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość, która określa <see cref="P:System.Diagnostics.Process.StartInfo" />. <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Diagnostics.Process.Start" /> Metoda nie została użyta do uruchomienia procesu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas uruchomienia skojarzonego procesu.</summary>
        <value>Obiekt, który wskazuje, kiedy proces został uruchomiony. Wyjątek jest generowany, jeśli proces nie jest uruchomiony.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.StartTime" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został zakończony.  
  
 —lub—  
  
 Proces nie został uruchomiony.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd w wywołaniu funkcji systemu Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane w wyniku zdarzenia zakończenia procesu.</summary>
        <value>Służy do organizowania wywołań obsługi zdarzeń, które są wydawane w wyniku <see cref="E:System.Diagnostics.Process.Exited" /> zdarzenia w procesie. <see cref="T:System.ComponentModel.ISynchronizeInvoke" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> tak `null` jest<xref:System.Diagnostics.Process.Exited> , metody obsługujące zdarzenie są wywoływane w wątku z puli wątków systemowych. Aby uzyskać więcej informacji na temat pul wątków systemowych <xref:System.Threading.ThreadPool>, zobacz.  
  
 Gdy zdarzenie jest obsługiwane przez składnik Visual Windows Forms, <xref:System.Windows.Forms.Button>na przykład, uzyskanie dostępu do składnika za pomocą puli wątków systemowych może nie zadziałać lub może spowodować wyjątek. <xref:System.Diagnostics.Process.Exited> W tym celu należy <xref:System.Diagnostics.Process.SynchronizingObject%2A> to zrobić, ustawiając składnik Windows Forms, co powoduje, że <xref:System.Diagnostics.Process.Exited> metody obsługujące zdarzenie mają być wywoływane w tym samym wątku, w którym został utworzony składnik.  
  
 Jeśli jest używana wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w projektancie Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> jest <xref:System.Diagnostics.Process>automatycznie ustawiana na kontrolkę zawierającą. <xref:System.Diagnostics.Process> Na przykład, jeśli <xref:System.Diagnostics.Process> umieścisz w projektancie dla `Form1` ( <xref:System.Diagnostics.Process.SynchronizingObject%2A> który dziedziczy <xref:System.Diagnostics.Process> z <xref:System.Windows.Forms.Form>) właściwość jest ustawiona na wystąpienie `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Zazwyczaj ta właściwość jest ustawiana, gdy składnik jest umieszczony wewnątrz kontrolki lub formularza, ponieważ te składniki są powiązane z określonym wątkiem.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw wątków, które są uruchomione w skojarzonym procesie.</summary>
        <value>Tablica typu <see cref="T:System.Diagnostics.ProcessThread" /> reprezentująca wątki systemu operacyjnego aktualnie uruchomione w skojarzonym procesie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek wykonuje kod w procesie. Każdy proces jest uruchamiany z pojedynczym wątkiem, jego podstawowym wątkiem. Dowolny wątek może tworzyć dodatkowe wątki. Wątki w procesie współdzielą przestrzeń adresową procesu.  
  
 Użyj <xref:System.Diagnostics.ProcessThread> , aby pobrać wszystkie wątki skojarzone z bieżącym procesem. Wątek podstawowy nie musi mieć indeksu zero w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Proces nie ma <see cref="P:System.Diagnostics.Process.Id" />lub nie jest skojarzony <see cref="T:System.Diagnostics.Process" /> z wystąpieniem.  
  
—lub— 
Skojarzony proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formatuje nazwę procesu jako ciąg, w połączeniu z nadrzędnym typem składnika, jeśli ma zastosowanie.</summary>
        <returns>, <see cref="P:System.Diagnostics.Process.ProcessName" />W połączeniu z wartością <see cref="M:System.Object.ToString" /> zwracaną przez składnik podstawowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączny czas procesora dla tego procesu.</summary>
        <value><see cref="T:System.TimeSpan" /> Wskazuje czas, przez jaki skojarzony proces korzysta z procesora CPU. Ta wartość jest sumą <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />i.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas procesora użytkownika dla tego procesu.</summary>
        <value>Wskazuje <see cref="T:System.TimeSpan" /> , ile czasu skojarzony proces spędził kod w części aplikacji procesu (nie wewnątrz rdzenia systemu operacyjnego).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> do właściwości dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar pamięci wirtualnej procesu, w bajtach.</summary>
        <value>Ilość pamięci wirtualnej (w bajtach), którą żąda skojarzony proces.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci wirtualnej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci wirtualnej (w bajtach) przydzieloną dla skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę właściwość reprezentuje bieżący rozmiar pamięci wirtualnej używanej przez proces w bajtach. System operacyjny mapuje wirtualną przestrzeń adresową dla każdego procesu na strony ładowane w pamięci fizycznej lub do stron przechowywanych w pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna z licznikiem wydajności **bajtów wirtualnych** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia okres czasu oczekiwania na zakończenie skojarzonego procesu i blokuje bieżący wątek wykonywania, dopóki czas nie upłynie lub proces zakończy się. Aby uniknąć blokowania bieżącego wątku, użyj <see cref="E:System.Diagnostics.Process.Exited" /> zdarzenia.  
  
Aby zapoznać się z przykładami <see cref="P:System.Diagnostics.Process.StandardError" /> kodu, <see cref="P:System.Diagnostics.Process.ExitCode" /> Zobacz i strony odwołania do właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnik oczekuje na zakończenie skojarzonego procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit>sprawia, że bieżący wątek czeka na zakończenie skojarzonego procesu.  Powinien być wywoływany po wywołaniu wszystkich innych metod w procesie. Aby uniknąć blokowania bieżącego wątku, użyj <xref:System.Diagnostics.Process.Exited> zdarzenia.  
  
 Ta metoda nakazuje <xref:System.Diagnostics.Process> składnikowi odczekanie nieskończonej ilości czasu na zakończenie obsługi procesów i zdarzeń. Może to spowodować, że aplikacja przestanie odpowiadać. Na przykład jeśli wywołasz <xref:System.Diagnostics.Process.CloseMainWindow%2A> dla procesu, który ma interfejs użytkownika, żądanie do systemu operacyjnego, aby zakończyć skojarzony proces, może nie zostać obsłużone, jeśli proces jest zapisywana w taki sposób, aby nigdy nie wprowadzał swojej pętli komunikatów.  
  
> [!NOTE]
>  W programie <xref:System.Diagnostics.Process.WaitForExit> <xref:System.Int32.MaxValue> i starszych wersjach Przeciążenie zaczekało na milisekundy (około 24 dni), a nie na czas nieokreślony. [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] Ponadto poprzednie wersje nie czekały na zakończenie obsługi zdarzeń w przypadku osiągnięcia pełnego <xref:System.Int32.MaxValue> czasu.  
  
 To Przeciążenie zapewnia, że wszystkie operacje przetwarzania zostały ukończone, łącznie z obsługą zdarzeń asynchronicznych dla przekierowanych standardowych danych wyjściowych. Tego przeciążenia należy używać po wywołaniu przeciążenia, <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> gdy standardowe wyjście zostało przekierowane do obsługi zdarzeń asynchronicznych.  
  
 Po zakończeniu skojarzonego procesu (czyli gdy jest on zamykany przez system operacyjny przez normalne lub nietypowe zakończenie), system przechowuje informacje administracyjne o procesie i zwraca do składnika, który został wywołany <xref:System.Diagnostics.Process.WaitForExit>. Składnik <xref:System.Diagnostics.Process> ten może następnie uzyskiwać dostęp do informacji, <xref:System.Diagnostics.Process.ExitTime%2A>w tym za pomocą <xref:System.Diagnostics.Process.Handle%2A> do zakończonego procesu.  
  
 Ze względu na to, że skojarzony proces <xref:System.Diagnostics.Process.Handle%2A> został zakończony, właściwość składnika nie wskazuje już na istniejący zasób procesu. Zamiast tego uchwyt może być używany tylko w celu uzyskania dostępu do informacji o zasobie procesu. System ma świadomość dojść do zakończonych procesów, <xref:System.Diagnostics.Process> które nie zostały zwolnione przez składniki, więc <xref:System.Diagnostics.Process.ExitTime%2A> utrzymuje i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci, dopóki <xref:System.Diagnostics.Process> składnik nie zwolni zasobów. Z tego powodu, za każdym razem, <xref:System.Diagnostics.Process.Start%2A> gdy wywołasz <xref:System.Diagnostics.Process> wystąpienie, <xref:System.Diagnostics.Process.Close%2A> Wywołaj po zakończeniu skojarzonego procesu i nie potrzebujesz już żadnych informacji administracyjnych o nim. <xref:System.Diagnostics.Process.Close%2A>zwalnia pamięć przydzieloną do zakończonego procesu.  
  
   
  
## Examples  
 Zobacz sekcję uwagi na stronie odwołania <xref:System.Diagnostics.Process.StandardError%2A> do właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można uzyskać dostępu do ustawienia oczekiwania.</exception>
        <exception cref="T:System.SystemException">Żaden proces <see cref="P:System.Diagnostics.Process.Id" /> nie został ustawiony <see cref="P:System.Diagnostics.Process.Handle" /> i od którego <see cref="P:System.Diagnostics.Process.Id" /> można określić właściwość nie istnieje.  
  
—lub— 
Z tym <see cref="T:System.Diagnostics.Process" /> obiektem nie jest skojarzony żaden proces.  
  
—lub— 
Podjęto próbę wywołania <see cref="M:System.Diagnostics.Process.WaitForExit" /> procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Ilość czasu (w milisekundach) oczekiwania na zakończenie skojarzonego procesu. Maksimum to największa możliwa wartość 32-bitowej liczby całkowitej, która reprezentuje nieskończoność systemu operacyjnego.</param>
        <summary>Instruuje <see cref="T:System.Diagnostics.Process" /> składnik, aby czekał określoną liczbę milisekund dla zakończenia skojarzonego procesu.</summary>
        <returns><see langword="true" />Jeśli skojarzony proces został zakończony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>sprawia, że bieżący wątek czeka na zakończenie skojarzonego procesu. Powinien być wywoływany po wywołaniu wszystkich innych metod w procesie. Aby uniknąć blokowania bieżącego wątku, użyj <xref:System.Diagnostics.Process.Exited> zdarzenia.  
  
 Ta metoda nakazuje <xref:System.Diagnostics.Process> składnikowi odczekanie skończonego czasu na zakończenie procesu. Jeśli skojarzony proces nie zostanie zakończony przed końcem interwału, ponieważ żądanie zakończenia jest odrzucane, `false` jest zwracana do procedury wywołującej. Można określić <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> <xref:System.Diagnostics.Process.WaitForExit> dla `milliseconds` i<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> będzie zachowywać się tak samo jak Przeciążenie. Jeśli przejdziesz do metody 0 (zero), zwraca `true` tylko wtedy, gdy proces został już zakończony; w przeciwnym razie natychmiast zwraca wartość. `false`  
  
> [!NOTE]
>  W wersjach `milliseconds` <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> i starszych, jeśli była-1, Przeciążenie zaczekało na milisekundy (około 24 dni), a nie na <xref:System.Int32.MaxValue> czas nieokreślony. [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]  
  
 Gdy standardowe wyjście zostało przekierowane do obsługi zdarzeń asynchronicznych, istnieje możliwość, że przetwarzanie danych wyjściowych nie zostanie ukończone, gdy ta metoda zwróci wartość. Aby upewnić się, że obsługa zdarzeń asynchronicznych została ukończona, wywołaj <xref:System.Diagnostics.Process.WaitForExit> Przeciążenie, które nie przyjmuje żadnych parametrów po `true` odebraniu z tego przeciążenia. Aby upewnić się, <xref:System.Diagnostics.Process.Exited> że zdarzenie jest prawidłowo obsługiwane w aplikacjach Windows Forms, należy <xref:System.Diagnostics.Process.SynchronizingObject%2A> ustawić właściwość.  
  
 Po zakończeniu skojarzonego procesu (jest on zamykany przez system operacyjny za pomocą normalnego lub nieprawidłowego zakończenia) system zapisuje informacje administracyjne o procesie i zwraca do składnika, który został wywołany <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. Składnik <xref:System.Diagnostics.Process> ten może następnie uzyskiwać dostęp do informacji, <xref:System.Diagnostics.Process.ExitTime%2A>w tym za pomocą <xref:System.Diagnostics.Process.Handle%2A> do zakończonego procesu.  
  
 Ze względu na to, że skojarzony proces <xref:System.Diagnostics.Process.Handle%2A> został zakończony, właściwość składnika nie wskazuje już na istniejący zasób procesu. Zamiast tego uchwyt może być używany tylko w celu uzyskania dostępu do informacji o zasobie procesu. System ma świadomość dojść do zakończonych procesów, <xref:System.Diagnostics.Process> które nie zostały zwolnione przez składniki, więc <xref:System.Diagnostics.Process.ExitTime%2A> utrzymuje i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci, dopóki <xref:System.Diagnostics.Process> składnik nie zwolni zasobów. Z tego powodu, za każdym razem, <xref:System.Diagnostics.Process.Start%2A> gdy wywołasz <xref:System.Diagnostics.Process> wystąpienie, <xref:System.Diagnostics.Process.Close%2A> Wywołaj po zakończeniu skojarzonego procesu i nie potrzebujesz już żadnych informacji administracyjnych o nim. <xref:System.Diagnostics.Process.Close%2A>zwalnia pamięć przydzieloną do zakończonego procesu.  
  
   
  
## Examples  
 Zobacz przykład kodu dla <xref:System.Diagnostics.Process.ExitCode%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można uzyskać dostępu do ustawienia oczekiwania.</exception>
        <exception cref="T:System.SystemException">Żaden proces <see cref="P:System.Diagnostics.Process.Id" /> nie został ustawiony <see cref="P:System.Diagnostics.Process.Handle" /> i od którego <see cref="P:System.Diagnostics.Process.Id" /> można określić właściwość nie istnieje.  
  
—lub— 
Z tym <see cref="T:System.Diagnostics.Process" /> obiektem nie jest skojarzony żaden proces.  
  
—lub— 
Podjęto próbę wywołania <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów, które są uruchomione na komputerze lokalnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, <see cref="T:System.Diagnostics.Process" /> że składnik oczekuje na wprowadzenie stanu bezczynności przez skojarzony proces.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, <see cref="T:System.Diagnostics.Process" /> że składnik oczekuje na przekroczenie stanu bezczynności w skojarzonym procesie. To przeciążenie dotyczy tylko procesów z interfejsem użytkownika, w związku z czym pętla komunikatów.</summary>
        <returns><see langword="true" />Jeśli skojarzony proces osiągnął stan bezczynności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.WaitForInputIdle> , aby wymusić, że przetwarzanie aplikacji ma oczekiwać do momentu powrotu pętli do stanu bezczynności. Podczas wykonywania procesu z interfejsem użytkownika pętla komunikatów jest wykonywana za każdym razem, gdy komunikat systemu Windows jest wysyłany do procesu przez system operacyjny. Następnie proces wraca do pętli komunikatów. Proces jest nazywany stanem bezczynności, gdy oczekuje na komunikaty wewnątrz pętli komunikatów. Ten stan jest przydatny na przykład wtedy, gdy aplikacja wymaga poczekania na zakończenie procesu tworzenia głównego okna przez aplikację, zanim aplikacja komunikuje się z tym oknem.  
  
 Jeśli proces nie ma pętli komunikatów, <xref:System.Diagnostics.Process.WaitForInputIdle> <xref:System.InvalidOperationException>zgłasza.  
  
 Przeciążenie nakazuje <xref:System.Diagnostics.Process> składnikowi odczekanie, aż proces stanie się bezczynny w pętli komunikatów. <xref:System.Diagnostics.Process.WaitForInputIdle> Ta instrukcja może spowodować, że aplikacja przestanie odpowiadać. Na przykład jeśli proces jest zapisywana w celu natychmiastowego zakończenia jego pętli komunikatów, jak w fragmencie `while(true)`kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie ma interfejsu graficznego.  
  
—lub— 
Wystąpił nieznany błąd. Proces nie może wprowadzić stanu bezczynności.  
  
—lub— 
Proces został już zakończony.  
  
—lub— 
Żaden proces nie jest skojarzony z <see cref="T:System.Diagnostics.Process" /> tym obiektem.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Wartość z przedziału <see cref="F:System.Int32.MaxValue" /> od 1 do określa czas (w milisekundach) oczekiwania na przekroczenie skojarzonego procesu. Wartość 0 określa natychmiastową zwrot, a wartość-1 określa nieskończony czas oczekiwania.</param>
        <summary>Powoduje, <see cref="T:System.Diagnostics.Process" /> że składnik odczeka określoną liczbę milisekund, przez który skojarzony proces wejdzie w stan bezczynności. To przeciążenie dotyczy tylko procesów z interfejsem użytkownika, w związku z czym pętla komunikatów.</summary>
        <returns><see langword="true" />Jeśli skojarzony proces osiągnął stan bezczynności; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> , aby wymusić, że przetwarzanie aplikacji ma oczekiwać do momentu powrotu pętli do stanu bezczynności. Podczas wykonywania procesu z interfejsem użytkownika pętla komunikatów jest wykonywana za każdym razem, gdy komunikat systemu Windows jest wysyłany do procesu przez system operacyjny. Następnie proces wraca do pętli komunikatów. Proces jest nazywany stanem bezczynności, gdy oczekuje na komunikaty wewnątrz pętli komunikatów. Ten stan jest przydatny na przykład wtedy, gdy aplikacja wymaga poczekania na zakończenie procesu tworzenia głównego okna przez aplikację, zanim aplikacja komunikuje się z tym oknem.  
  
 Jeśli proces nie ma pętli komunikatów, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> <xref:System.InvalidOperationException>zgłasza.  
  
 Przeciążenie nakazuje <xref:System.Diagnostics.Process> składnikowi odczekanie skończonego czasu, przez który proces stanie się bezczynny w pętli komunikatów. <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Jeśli skojarzony proces nie stanie się bezczynny przed końcem interwału, ponieważ pętla nadal przetwarza komunikaty, `false` jest zwracana do procedury wywołującej.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie ma interfejsu graficznego.  
  
—lub— 
Wystąpił nieznany błąd. Proces nie może wprowadzić stanu bezczynności.  
  
—lub— 
Proces został już zakończony.  
  
—lub— 
Żaden proces nie jest skojarzony z <see cref="T:System.Diagnostics.Process" /> tym obiektem.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera użycie pamięci fizycznej w skojarzonym procesie, w bajtach.</summary>
        <value>Całkowita ilość pamięci fizycznej używanej przez skojarzony proces, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę właściwość reprezentuje bieżący rozmiar pamięci zestawu roboczego używany przez proces w bajtach. Zestaw roboczy procesu jest zestawem stron pamięci, które są obecnie widoczne dla procesu w fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, które mają być używane bez wyzwalania błędu strony.  
  
 Zestaw roboczy zawiera dane udostępnione i prywatne. Dane udostępnione obejmują strony zawierające wszystkie instrukcje wykonywane przez proces, w tym moduły procesów i biblioteki systemowe.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa moment zakończenia procesu i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci fizycznej (w bajtach) przydzieloną dla skojarzonego procesu.</summary>
        <value>Ilość pamięci fizycznej (w bajtach) przydzieloną dla skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę właściwość reprezentuje bieżący rozmiar pamięci zestawu roboczego używany przez proces w bajtach. Zestaw roboczy procesu jest zestawem stron pamięci, które są obecnie widoczne dla procesu w fizycznej pamięci RAM. Te strony są rezydentne i dostępne dla aplikacji, które mają być używane bez wyzwalania błędu strony.  
  
 Zestaw roboczy zawiera dane udostępnione i prywatne. Dane udostępnione obejmują strony zawierające wszystkie instrukcje wykonywane przez proces, w tym instrukcje w modułach przetwarzania i bibliotekach systemowych.  
  
 Ta właściwość może służyć do monitorowania użycia pamięci na komputerach z procesorami 32-bitowymi lub procesorami 64-bitowymi. Wartość właściwości jest równoważna z licznikiem wydajności **zestawu roboczego** dla procesu.  
  
   
  
## Examples  
 Poniższy przykład kodu uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, kiedy kończy się proces, i wyświetla jego kod zakończenia oraz statystykę pamięci szczytowej.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>

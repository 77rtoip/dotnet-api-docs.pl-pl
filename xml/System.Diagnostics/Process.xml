<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f877e9571f09e703e3507d9a3489b76fa6b7a4e" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52235532" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do procesów lokalnych i zdalnych, a następnie pozwala uruchamiać i zatrzymywać procesy systemu lokalnego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.Process> składnik zapewnia dostęp do procesu, który jest uruchomiony na komputerze. Mówiąc najprościej, proces, jest uruchomiona aplikacja. Wątek jest podstawową jednostką, do której system operacyjny przydziela czas procesora. Wątek może wykonać dowolną część kodu proces, w tym części wykonywane przez inny wątek.  
  
 <xref:System.Diagnostics.Process> Składnik jest użytecznym narzędziem do uruchamianie, zatrzymywanie, kontrolowanie i monitorowanie aplikacji. Możesz użyć <xref:System.Diagnostics.Process> lub składnika, aby uzyskać listę procesów, które są uruchomione, można uruchomić nowego procesu. A <xref:System.Diagnostics.Process> składnika umożliwia dostęp do procesów systemowych. Po <xref:System.Diagnostics.Process> składnik został zainicjowany, może służyć do uzyskania informacji na temat uruchomionego procesu. Zawierają one zestaw wątków, załadowanych modułów (pliki .dll i .exe), a następnie używa informacji o wydajności, takie jak ilość pamięci procesu.  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `finally` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
> [!NOTE]
>  procesy 32-bitowe nie może uzyskać dostępu moduły procesu 64-bitowego. Jeśli spróbujesz uzyskać informacje na temat procesu 64-bitowym z proces 32-bitowy, zostanie wyświetlony <xref:System.ComponentModel.Win32Exception> wyjątku. Proces 64-bitowy, z drugiej strony, dostęp do modułów proces 32-bitowy.  
  
 Składnik procesu uzyskuje informacje o grupie właściwości wszystkie na raz. Po <xref:System.Diagnostics.Process> składnika uzyskał informacje o jednym członkiem żadnej grupy, wartości innych właściwości w tej grupie w pamięci podręcznej i nie uzyskać nowe informacje o innych członków grupy, dopóki nie zostanie wywołana <xref:System.Diagnostics.Process.Refresh%2A> metody. W związku z tym, wartość właściwości nie może być wszystkie nowsze niż ostatnie wywołanie elementu <xref:System.Diagnostics.Process.Refresh%2A> metody. Podział grupy jest zależna od systemu operacyjnego.  
  
 W przypadku ścieżki zmiennej zadeklarowanej w systemie przy użyciu ofert możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie znaleźć ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, a dodaje się go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji jakikolwiek proces w `c:\mypath` podczas jego uruchamiania.  
  
 Proces systemowy jest unikatowo identyfikowana w systemie przez jego identyfikator procesu. Podobnie jak wiele zasobów Windows proces jest również identyfikowane przez jego uchwytu, które nie muszą być unikatowe na komputerze. Dojście jest ogólny termin określający identyfikator zasobu. System operacyjny będzie się powtarzać, uchwyt procesu, który jest dostępny za pośrednictwem <xref:System.Diagnostics.Process.Handle%2A> właściwość <xref:System.Diagnostics.Process> składnika, nawet wtedy, gdy proces został zakończony. W związku z tym, można uzyskać przez proces informacje administracyjne, takie jak <xref:System.Diagnostics.Process.ExitCode%2A> (zazwyczaj jedną zero powodzenie lub kod błędu różny od zera) i <xref:System.Diagnostics.Process.ExitTime%2A>. Uchwyty są bardzo cenne zasobów, więc przeciek dojścia jest bardziej zjadliwe niż przeciek pamięci.  
  
> [!NOTE]
>  Ta klasa zawiera żądanie łącza i dziedziczenia na poziomie klasy stosowane do wszystkich składowych. Element <xref:System.Security.SecurityException> jest generowany, gdy bezpośredniego obiektu wywołującego lub Klasa pochodna nie mają uprawnień pełnego zaufania. Aby uzyskać szczegółowe informacje na temat wymaganych zabezpieczeń, zobacz [zapotrzebowania na łącza](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Informacje o  
 W .NET Framework <xref:System.Diagnostics.Process> klasy domyślnie używa <xref:System.Console> kodowania, które są zazwyczaj kodu strony kodowania, dla strumieni danych wejściowych, wyjściowych i błędów. Przykładowy kod, w systemach, w których kultura jest angielski (Stany Zjednoczone), strony kodowej 437 jest domyślne kodowanie <xref:System.Console> klasy. Jednak [!INCLUDE[net_core](~/includes/net-core-md.md)] tylko ograniczony podzestaw tych kodowaniach mogą być dostępne. Jeśli jest to możliwe, zostanie użyta <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> jako domyślnego kodowania.  
  
 Jeśli <xref:System.Diagnostics.Process> obiekt jest zależny od określonych stron kodowych, można nadal udostępnić je, wykonując następujące czynności *przed* wywołać dowolną <xref:System.Diagnostics.Process> metody:  
  
1.  Dodaj odwołanie do zestawu System.Text.Encoding.CodePages.dll do projektu.  
  
2.  Pobieranie <xref:System.Text.EncodingProvider> obiektu z <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> właściwości.  
  
3.  Przekaż <xref:System.Text.EncodingProvider> obiekt <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> metodę, aby wprowadzić dodatkowe kodowania obsługiwane przez dostawcę kodowania, która jest dostępna.  
  
 <xref:System.Diagnostics.Process> Klasy będzie automatycznie używać domyślnego kodowania systemu zamiast UTF8, pod warunkiem, że zarejestrowano dostawcę kodowania przed wywołaniem dowolnej <xref:System.Diagnostics.Process> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wystąpienia <xref:System.Diagnostics.Process> klasy w celu uruchomienia procesu.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.Diagnostics.Process> klasy sam, jak i statyczną <xref:System.Diagnostics.Process.Start%2A> metodę, aby rozpocząć proces.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 Następujące F# przykładzie zdefiniowano `runProc` funkcja, która uruchamia proces, przechwytuje wszystkie informacje z danych wyjściowych i błędów i zlicza liczbę milisekund, które zostało uruchomione przez proces.  `runProc` Funkcji ma trzy parametry: Nazwa aplikacji, które można uruchomić argumenty Dostarcz je do aplikacji, a katalog początkowy.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Kod `runProc` funkcji został napisany przez [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) i jest dostępna w ramach [Licencja publiczna Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Używanie klasy procesu platformy .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.Process" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie określisz <xref:System.Diagnostics.Process.MachineName%2A> właściwości wartość domyślna to komputer lokalny, (".").  
  
 Dostępne są dwie opcje do kojarzenia nową <xref:System.Diagnostics.Process> składnika za pomocą procesu na komputerze. Pierwszą opcją jest użycie konstruktora do utworzenia <xref:System.Diagnostics.Process> składnika, ustawić odpowiednie elementy członkowskie <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywołania <xref:System.Diagnostics.Process.Start%2A> skojarzyć <xref:System.Diagnostics.Process> z nowego procesu systemu. Druga opcja to skojarzenie <xref:System.Diagnostics.Process> z uruchomionego procesu systemu za pomocą <xref:System.Diagnostics.Process.GetProcessById%2A> lub jednego z <xref:System.Diagnostics.Process.GetProcesses%2A> zwracane wartości.  
  
 Jeśli używasz `static` przeciążenia <xref:System.Diagnostics.Process.Start%2A> metodę, aby uruchomić nowego procesu systemu, metoda tworzy nowy <xref:System.Diagnostics.Process> składnika i kojarzy ją z procesu.  
  
 Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> właściwość jest ustawiona na wartość domyślną `true`, można uruchomić aplikacji i dokumenty, które znajdują się w sposób, który jest podobne do `Run` okna dialogowego Windows `Start` menu. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> jest `false`, można uruchomić tylko pliki wykonywalne.  
  
 Plik wykonywalny, który można wywoływać z poziomu wiersza polecenia można uruchomić w jednym z dwóch sposobów: przez ustawienie odpowiednich członków <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> metody bez parametrów lub przez przekazanie odpowiedni parametr `static` <xref:System.Diagnostics.Process.Start%2A> elementu członkowskiego.  
  
 Możesz utworzyć <xref:System.Diagnostics.Process> składnika za pomocą konstruktora, jedną statyczną <xref:System.Diagnostics.Process.Start%2A> przeciążenia lub dowolnej <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, lub <xref:System.Diagnostics.Process.GetProcessesByName%2A> metody. Po wykonaniu, dzięki czemu masz wgląd w proces skojarzone. Nie jest dynamiczny widok, który aktualizuje się automatycznie, gdy zmieniono właściwości przetwarzania w pamięci. Zamiast tego należy wywołać <xref:System.Diagnostics.Process.Refresh%2A> składnika zaktualizować <xref:System.Diagnostics.Process> informacje o właściwości w aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowy priorytet skojarzonego procesu.</summary>
        <value>Priorytet podstawowy, który jest obliczany na podstawie <see cref="P:System.Diagnostics.Process.PriorityClass" /> skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> Procesu jest priorytet wyjścia utworzone w ramach procesu skojarzony wątki. Można wyświetlić informacje o priorytet podstawowy priorytet podstawowy licznik Monitora systemu.  
  
 Na podstawie czasu zwiększa upłynęło lub innego systemu operacyjnego można zmienić priorytet podstawowy, gdy proces powinny zostać umieszczone w przód od innych użytkowników.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Właściwość pozwala na wyświetlanie począwszy od priorytetu przypisanego do procesu. Jednakże, ponieważ jest tylko do odczytu, nie można użyć <xref:System.Diagnostics.Process.BasePriority%2A> można ustawić priorytetu procesu. Aby zmienić priorytet, należy użyć <xref:System.Diagnostics.Process.PriorityClass%2A> właściwości. <xref:System.Diagnostics.Process.BasePriority%2A> Można wyświetlać przy użyciu Monitora systemu, podczas gdy <xref:System.Diagnostics.Process.PriorityClass%2A> nie jest. Zarówno <xref:System.Diagnostics.Process.BasePriority%2A> i <xref:System.Diagnostics.Process.PriorityClass%2A> można programowo wyświetlać. W poniższej tabeli przedstawiono relację między <xref:System.Diagnostics.Process.BasePriority%2A> wartości i <xref:System.Diagnostics.Process.PriorityClass%2A> wartości.  
  
|BasePriority|Klasa priorytetu|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został zakończony.  
  
—lub— 
Ten proces nie została uruchomiona, więc nie ma żadnych identyfikatora procesu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> Synchronicznie lub asynchronicznie można odczytać strumienia. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonywania synchronicznych operacji odczytu na strumień dane wyjściowe błędów procesu. Te synchroniczne odczytu, nie wykonuj operacje do skojarzonego <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardError%2A> strumieniowo lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> uruchomieniu asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> strumienia. Ta metoda umożliwia programu obsługi zdarzeń wyznaczonego dla strumieni wyjściowych i natychmiast powraca do obiektu wywołującego, można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Wykonaj następujące kroki, aby wykonać asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> dla <xref:System.Diagnostics.Process> :  
  
1.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> do `false`.  
  
2.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> do `true`.  
  
3.  Dodawanie obsługi zdarzenia do <xref:System.Diagnostics.Process.ErrorDataReceived> zdarzeń. Program obsługi zdarzeń musi odpowiadać <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> podpis delegata.  
  
4.  Rozpocznij <xref:System.Diagnostics.Process>.  
  
5.  Wywołaj <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> dla <xref:System.Diagnostics.Process>. To wywołanie uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Po wywołaniu procedury obsługi zdarzeń asynchronicznych operacji odczytu start każdym skojarzonego <xref:System.Diagnostics.Process> zapisuje wiersz tekstu w jego <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Anuluj operację odczytu asynchronicznego, przez wywołanie metody <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Można anulować operacji odczytu przez obiekt wywołujący lub przez program obsługi zdarzeń. Po anulowanie, można wywołać <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ponownie, aby wznowić asynchronicznych operacji odczytu.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla przekierowanego strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchronicznego lub synchronicznego wszystkie dalsze odczytu operacji na strumieniu musi znajdować się w tym samym trybie. Na przykład, nie wykonuj <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardError%2A> strumienia, lub na odwrót. Możesz jednak przeczytać dwóch różnych strumieni w różnych trybach. Na przykład, można wywołać <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `net view` polecenie, aby wyświetlić listę zasobów sieciowych dostępnych na komputerze zdalnym. Użytkownik podaje nazwę komputera docelowego, jako argument wiersza polecenia. Użytkownik może też podawać nazwę pliku, błąd danych wyjściowych. Przykład zbiera dane wyjściowe polecenia net, w tym czasie czeka na zakończenie procesu, a następnie zapisuje dane wyjściowe wyniki do konsoli. Jeśli użytkownik poda opcjonalne błędów, przykład zapisuje błędy do pliku.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> Właściwość <see langword="false" />.  
  
\- lub — 
Operację odczytu asynchronicznego jest już w toku na <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia.  
  
\- lub — 
<see cref="P:System.Diagnostics.Process.StandardError" /> Strumień został użyty przez operację odczytu synchronicznego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> Synchronicznie lub asynchronicznie można odczytać strumienia. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonywania synchronicznych operacji odczytu na strumień wyjściowy procesu. Te synchroniczne odczytu, nie wykonuj operacje do skojarzonego <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumieniowo lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> uruchomieniu asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Ta metoda umożliwia obsługi zdarzenia wyznaczonego dla strumieni wyjściowych i natychmiast powraca do obiektu wywołującego, można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Wykonaj następujące kroki, aby wykonać asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> dla <xref:System.Diagnostics.Process> :  
  
1.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> do `false`.  
  
2.  Ustaw <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> do `true`.  
  
3.  Dodawanie obsługi zdarzenia do <xref:System.Diagnostics.Process.OutputDataReceived> zdarzeń. Program obsługi zdarzeń musi odpowiadać <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> podpis delegata.  
  
4.  Rozpocznij <xref:System.Diagnostics.Process>.  
  
5.  Wywołaj <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> dla <xref:System.Diagnostics.Process>. To wywołanie uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Po wywołaniu procedury obsługi zdarzeń asynchronicznych operacji odczytu start każdym skojarzonego <xref:System.Diagnostics.Process> zapisuje wiersz tekstu w jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
 Anuluj operację odczytu asynchronicznego, przez wywołanie metody <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Można anulować operacji odczytu przez obiekt wywołujący lub przez program obsługi zdarzeń. Po anulowanie, można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ponownie, aby wznowić asynchronicznych operacji odczytu.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla przekierowanego strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchronicznego lub synchronicznego wszystkie dalsze odczytu operacji na strumieniu musi znajdować się w tym samym trybie. Na przykład, nie wykonuj <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, lub na odwrót. Możesz jednak przeczytać dwóch różnych strumieni w różnych trybach. Na przykład, można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wykonywania asynchronicznych operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumień `sort` polecenia. `sort` Polecenie jest aplikacja konsolowa która odczytuje i sortuje wprowadzanie tekstu.  
  
 Przykład tworzy delegata zdarzenia `SortOutputHandler` programu obsługi zdarzeń i kojarzy ją z <xref:System.Diagnostics.Process.OutputDataReceived> zdarzeń. Program obsługi zdarzeń odbierze wiersze tekstu z przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, formatuje tekst i zapisuje tekst na ekranie.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> Właściwość <see langword="false" />.  
  
\- lub — 
Operację odczytu asynchronicznego jest już w toku na <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia.  
  
\- lub — 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumień został użyty przez operację odczytu synchronicznego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Asynchroniczna operacja odczytu na rozpoczyna się <xref:System.Diagnostics.Process.StandardError%2A> strumienia. <xref:System.Diagnostics.Process.CancelErrorRead%2A> kończy się asynchronicznych operacji odczytu.  
  
 Po anulowanie, możesz wznowić, wywołując operację odczytu asynchronicznego <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> ponownie.  
  
 Gdy wywołujesz <xref:System.Diagnostics.Process.CancelErrorRead%2A>, wszystkie trwające operacje odczytu dotyczące <xref:System.Diagnostics.Process.StandardError%2A> zostały wykonane, a następnie program obsługi zdarzeń jest wyłączona. Przekierowanie wszystkie dalsze dane wyjściowe do <xref:System.Diagnostics.Process.StandardError%2A> jest zapisywana w buforze. Jeśli ponownie włączyć program obsługi zdarzeń z wywołaniem <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, zapisane dane wyjściowe są wysyłane do programu obsługi zdarzeń i wznowić asynchronicznych operacji odczytu. Jeśli chcesz zmienić program obsługi zdarzeń przed wznowieniem asynchronicznych operacji odczytu, należy usunąć istniejącego programu obsługi zdarzeń przed dodaniem nowego programu obsługi zdarzeń:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardError%2A> strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchronicznego lub synchronicznego wszystkie dalsze odczytu operacji na strumieniu musi znajdować się w tym samym trybie. Jeśli anulujesz asynchroniczna operacja odczytu na <xref:System.Diagnostics.Process.StandardError%2A> , a następnie można odczytać ze strumienia ponownie, należy użyć <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wznowienie asynchronicznych operacji odczytu. Nie wykonuj <xref:System.Diagnostics.Process.CancelErrorRead%2A> z wywołaniem synchronicznej odczytu metod <xref:System.Diagnostics.Process.StandardError%2A> takich jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, lub <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Poniższy przykład rozpoczyna się `nmake` polecenia użytkownika dostarczone argumenty. Strumienie o błędach i dane wyjściowe są odczytywane asynchronicznie; wiersze tekstu zbierane są wyświetlane w konsoli także zapisywane w pliku dziennika. Jeśli dane wyjściowe polecenia przekroczy określoną liczbę wierszy, są anulowane asynchronicznych operacji odczytu.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardError" /> Strumień nie jest włączony dla asynchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje asynchronicznych operacji odczytu na przekierowanym <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Asynchroniczna operacja odczytu na rozpoczyna się <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. <xref:System.Diagnostics.Process.CancelOutputRead%2A> kończy się asynchronicznych operacji odczytu.  
  
 Po anulowanie, możesz wznowić asynchronicznych operacji odczytu przez wywołanie metody <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> ponownie.  
  
 Gdy wywołujesz <xref:System.Diagnostics.Process.CancelOutputRead%2A>, wszystkie trwające operacje odczytu dotyczące <xref:System.Diagnostics.Process.StandardOutput%2A> zostały wykonane, a następnie program obsługi zdarzeń jest wyłączona. Przekierowanie wszystkie dalsze dane wyjściowe do <xref:System.Diagnostics.Process.StandardOutput%2A> jest zapisywana w buforze. Jeśli ponownie włączyć program obsługi zdarzeń z wywołaniem <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, zapisane dane wyjściowe są wysyłane do programu obsługi zdarzeń i wznowić asynchronicznych operacji odczytu. Jeśli chcesz zmienić program obsługi zdarzeń przed wznowieniem asynchronicznych operacji odczytu, należy usunąć istniejącego programu obsługi zdarzeń przed dodaniem nowego programu obsługi zdarzeń:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchronicznego lub synchronicznego wszystkie dalsze odczytu operacji na strumieniu musi znajdować się w tym samym trybie. Jeśli anulujesz asynchroniczna operacja odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> , a następnie można odczytać ze strumienia ponownie, należy użyć <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wznowienie asynchronicznych operacji odczytu. Nie wykonuj <xref:System.Diagnostics.Process.CancelOutputRead%2A> z wywołaniem synchronicznej odczytu metod <xref:System.Diagnostics.Process.StandardOutput%2A> takich jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, lub <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Poniższy przykład rozpoczyna się `nmake` polecenia użytkownika dostarczone argumenty. Strumienie o błędach i dane wyjściowe są odczytywane asynchronicznie; wiersze tekstu zbierane są wyświetlane w konsoli także zapisywane w pliku dziennika. Jeśli dane wyjściowe polecenia przekroczy określoną liczbę wierszy, są anulowane asynchronicznych operacji odczytu.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumień nie jest włączony dla asynchronicznych operacji odczytu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby, które są skojarzone z tego składnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> Metoda powoduje, że proces Zatrzymaj oczekiwanie na zakończenia Jeśli oczekiwało, zamyka dojściem do procesu i czyści właściwości specyficzne dla procesu. <xref:System.Diagnostics.Process.Close%2A> w przypadku, gdy jest on przywoływany zewnętrznie, nie Zamknij standardowe dane wyjściowe, dane wejściowe i błąd czytników i składników zapisywania.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> Wywołania metody <xref:System.Diagnostics.Process.Close%2A>. Wprowadzenie do <xref:System.Diagnostics.Process> obiektu `using` bloku usuwa zasoby bez konieczności wywoływania <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej skojarzonego procesu w 2-sekundowych odstępach czasu, przez maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Z przykładu zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje zamknięcie procesu, który ma interfejs użytkownika, wysyłając Zamknij komunikat do głównego okna.</summary>
        <returns>
          <see langword="true" /> Jeśli Zamknij komunikat został pomyślnie wysłany; <see langword="false" /> czy skojarzony proces nie ma okno główne, czy okno główne jest wyłączona (na przykład jeśli modalne okno dialogowe jest wyświetlane).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy proces jest wykonywany, jego pętli komunikatów jest w stanie oczekiwania. Pętla komunikatów jest wykonywana za każdym razem, gdy komunikat Windows jest wysyłany do procesu przez system operacyjny. Wywoływanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> wysyła żądanie do blisko oknie głównym, które w aplikacji poprawnie sformułowany, zamyka okna podrzędne i odwołuje wszystkie uruchomione pętli komunikatów dla aplikacji. Żądanie, aby zakończyć proces, wywołując <xref:System.Diagnostics.Process.CloseMainWindow%2A> wymusza na aplikacji, aby zakończyć. Aplikacja może poprosić o weryfikacji użytkownika przed zamknięciem lub go odmówić zakończyć. Aby wymusić zakończenie aplikacji, użyj <xref:System.Diagnostics.Process.Kill%2A> metody. Zachowanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> jest identyczna z użytkownikiem zamknięcie okna głównego aplikacji, za pomocą menu systemowego. W związku z tym żądania, aby zakończyć proces przez zamknięcie okna głównego nie wymusza natychmiastowe zakończenie aplikacji.  
  
 Edytowane przez proces danych lub zasoby przydzielone do procesu mogą zostać utracone, jeśli wywołujesz <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> powoduje, że po zakończeniu procesu nietypowe i należy używać tylko wtedy, gdy jest to konieczne. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Włącza uporządkowany przerwanie procesu i zamyka wszystkie systemy windows, więc jest preferowane w przypadku aplikacji z interfejsem. Jeśli <xref:System.Diagnostics.Process.CloseMainWindow%2A> zakończy się niepowodzeniem, możesz użyć <xref:System.Diagnostics.Process.Kill%2A> aby zakończyć ten proces. <xref:System.Diagnostics.Process.Kill%2A> jest to jedyny sposób, aby zakończyć procesów, które nie mają graficznego interfejsów.  
  
 Możesz wywołać <xref:System.Diagnostics.Process.Kill%2A> i <xref:System.Diagnostics.Process.CloseMainWindow%2A> tylko dla procesów uruchomionych na komputerze lokalnym. Nie może powodować procesów na komputerach zdalnych, aby zakończyć pracę. Może wyświetlać tylko informacje dotyczące procesów uruchomionych na komputerach zdalnych.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej skojarzonego procesu odstępach drugi 2 maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Z przykładu zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został już zakończony.  
  
—lub— 
Żaden proces nie jest skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia wszelkie zasoby używane przez ten proces.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czy <see cref="E:System.Diagnostics.Process.Exited" /> powinno być generowane zdarzenie, gdy kończy proces.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="E:System.Diagnostics.Process.Exited" /> powinno być generowane zdarzenie, gdy skojarzony proces zostanie zakończony (za pośrednictwem wyjścia lub wywołanie <see cref="M:System.Diagnostics.Process.Kill" />); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />. Należy pamiętać, że <see cref="E:System.Diagnostics.Process.Exited" /> zdarzenie jest zgłaszane w nawet wtedy, gdy wartość <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> jest <see langword="false" /> gdy proces zakończy się podczas lub zanim użytkownik wykonuje <see cref="P:System.Diagnostics.Process.HasExited" /> Sprawdź.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Właściwość sugeruje to, czy składnik otrzymają powiadomienie, gdy system operacyjny został zamknięty procesu. <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Właściwość jest używana podczas przetwarzania asynchronicznego, by powiadomić aplikację, że proces został zakończony. Aby wymusić aplikację synchronicznie oczekiwania na zdarzenie zakończenia (który przerywa działanie przetwarzania aplikacji, dopóki nie wystąpiło zdarzenie zakończenia), użyj <xref:System.Diagnostics.Process.WaitForExit%2A> metody.

> [!NOTE]
> Jeśli używasz programu Visual Studio i kliknij dwukrotnie <xref:System.Diagnostics.Process> składnika w swoim projekcie <xref:System.Diagnostics.Process.Exited> delegata zdarzenia i procedury obsługi zdarzeń są generowane automatycznie. Ustawia dodatkowy kod <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość `false`. Należy zmienić tę właściwość na `true` dla Twojego programu obsługi zdarzeń do wykonania, gdy skojarzony proces kończy działanie.

Jeśli składnika <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> wartość `true`, lub gdy <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> jest `false` i <xref:System.Diagnostics.Process.HasExited%2A> wyboru jest wywoływany przez składnik, składnik mogą uzyskiwać dostęp do informacje administracyjne skojarzonego procesu, który pozostaje przechowywane przez system operacyjny. Zawierają one <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.ExitCode%2A>.

Po zakończeniu procesu skojarzony, <xref:System.Diagnostics.Process.Handle%2A> składnika nie wskazuje już istniejący zasób procesu. Zamiast tego można można używać tylko dostępu do systemu operacyjnego informacji o zasobie procesu. System operacyjny jest pamiętać, że istnieją dojścia do zakończenia procesów, które nie zostały opublikowane przez <xref:System.Diagnostics.Process> składników, dzięki czemu zapewnia <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci.

Istnieje koszt związany z oczekiwania na zakończenie procesu. Jeśli <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> jest `true`, <xref:System.Diagnostics.Process.Exited> zdarzenie jest wywoływane, gdy kończy proces skojarzone. Twoje procedury <xref:System.Diagnostics.Process.Exited> Zdarzenie uruchamiane w tym momencie.

Czasami aplikacja rozpoczyna się proces, ale nie wymaga powiadomienie o jej zamknięcia. Na przykład aplikację można uruchomić program Notatnik, aby umożliwić użytkownikowi edycji tekstu, ale wykorzystać żadne dodatkowe aplikację Notatnik. Można uniknąć powiadomienie, gdy proces kończy działanie, ponieważ nie została uwzględniona w nieprzerwanego działania aplikacji. Ustawienie <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> do `false` można zapisać zasobów systemowych.

## Examples  
Poniższy przykład kodu tworzy proces, który drukuje plik. Ustawia <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość, aby spowodować, że proces pozyskiwania <xref:System.Diagnostics.Process.Exited> zdarzenie, kiedy kończy działanie. <xref:System.Diagnostics.Process.Exited> Program obsługi zdarzeń wyświetla informacje o procesach.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umieszcza <see cref="T:System.Diagnostics.Process" /> składnika w stanie, aby wchodzić w interakcje z systemem operacyjnym procesy uruchamiać w specjalnym trybie, włączenie natywnego właściwości <see langword="SeDebugPrivilege" /> w bieżącym wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre procesy systemu operacyjnego są uruchamiane w specjalnym trybie. Nie jest możliwe próby odczytu właściwości lub dołączanie do procesów, chyba że wywołujesz <xref:System.Diagnostics.Process.EnterDebugMode%2A> w składniku. Wywołaj <xref:System.Diagnostics.Process.LeaveDebugMode%2A> gdy już nie potrzebujesz dostępu do tych procesów, które działają w specjalnym trybie.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zapisuje jego przekierowanego <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> Zdarzenie oznacza, że skojarzony proces zapisane na jego przekierowanego <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Zdarzenie występuje tylko podczas asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A>. Aby rozpocząć asynchronicznych operacji odczytu, należy przekierować <xref:System.Diagnostics.Process.StandardError%2A> strumień <xref:System.Diagnostics.Process>, obsługi zdarzenia, aby dodać <xref:System.Diagnostics.Process.ErrorDataReceived> zdarzenia i wywołania <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Po tej dacie <xref:System.Diagnostics.Process.ErrorDataReceived> sygnały zdarzeń każdorazowo proces zapisuje linię przekierowanego <xref:System.Diagnostics.Process.StandardError%2A> przesyłać strumieniowo, dopóki proces kończy działanie lub wywołuje <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Aplikacji, która przetwarza asynchronicznego dane wyjściowe powinny wywoływać <xref:System.Diagnostics.Process.WaitForExit> metodę, aby upewnić się, że bufor wyjściowy został opróżniony. Należy pamiętać, ten limit czasu określanie za pomocą <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> przeciążenie jest *nie* upewnij się, został opróżniony bufor wyjściowy.
  
   
  
## Examples  
 W poniższym przykładzie użyto `net view` polecenie, aby wyświetlić listę zasobów sieciowych dostępnych na komputerze zdalnym. Użytkownik podaje nazwę komputera docelowego, jako argument wiersza polecenia. Użytkownik może też podawać nazwę pliku, błąd danych wyjściowych. Przykład zbiera dane wyjściowe polecenia net, w tym czasie czeka na zakończenie procesu, a następnie zapisuje dane wyjściowe wyniki do konsoli. Jeśli użytkownik poda opcjonalne błędów, przykład zapisuje błędy do pliku.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość która skojarzonego procesu określona, kiedy zakończone.</summary>
        <value>Kod skojarzony proces określić, kiedy zakończone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.ExitCode%2A> można pobrać stanu, zwróconą przez proces systemowy, gdy został zakończony. Można użyć kod zakończenia znacznie, takie jak liczba całkowita, zwracać wartość `main()` procedury.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> Wartość dla procesu odzwierciedla określonych konwencji implementowany przez dewelopera aplikacji dla tego procesu. Jeśli wartość kodu zakończenia można użyć do podejmowania decyzji w kodzie, należy znać Konwencji kod zakończenia, które są używane w procesie aplikacji.  
  
 Deweloperzy zazwyczaj wskazują pomyślnego zakończenia przez <xref:System.Diagnostics.Process.ExitCode%2A> wartość zero i błędy wyznaczonej przez niezerowe wartości, które wywoływania metody można użyć do zidentyfikowania przyczyny zakończenia procesu nietypowe. Nie jest konieczne przestrzegać następujących wytycznych, ale są one Konwencji.  
  
 Jeśli spróbujesz uzyskać <xref:System.Diagnostics.Process.ExitCode%2A> zgłasza wyjątek, zanim proces został zakończony, próba. Sprawdź <xref:System.Diagnostics.Process.HasExited%2A> właściwości, aby sprawdzić, czy skojarzony proces został zakończony.  
  
> [!NOTE]
>  Gdy standardowe dane wyjściowe został przekierowany do procedury obsługi zdarzeń asynchronicznych, jest to możliwe, że przetwarzanie danych wyjściowych zostanie nie zostały ukończone kiedy <xref:System.Diagnostics.Process.HasExited%2A> zwraca `true`. Aby upewnić się, że obsługi zdarzeń asynchronicznych zostało ukończone, należy wywołać <xref:System.Diagnostics.Process.WaitForExit> przeciążenia, które przyjmuje żadnego parametru przed sprawdzeniem <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Możesz użyć <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A> metodę, aby spowodować zakończenie procesu skojarzone.  
  
 Istnieją dwa sposoby bycia powiadamianym, gdy skojarzony proces zakończy: synchronicznie i asynchronicznie. Synchroniczne powiadomień opiera się na wywołanie <xref:System.Diagnostics.Process.WaitForExit%2A> metodę, aby wstrzymać przetwarzanie aplikacji, dopóki nie opuszcza składnik skojarzony. Asynchroniczne powiadomienie opiera się na <xref:System.Diagnostics.Process.Exited> zdarzeń. Korzystając z powiadomień asynchronicznych <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> musi być równa `true` dla <xref:System.Diagnostics.Process> składnika, aby otrzymać powiadomienie, że proces został zakończony.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie został zakończony.  
  
—lub— 
Proces <see cref="P:System.Diagnostics.Process.Handle" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.ExitCode" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kończy proces.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> Zdarzenie oznacza, że skojarzony proces został zakończony. To zdarzenie oznacza, że proces zakończone (anulowane) lub pomyślnie zamknięte. To zdarzenie może wystąpić tylko wtedy, gdy wartość <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość `true`.  
  
 Istnieją dwa sposoby bycia powiadamianym, gdy skojarzony proces zakończy: synchronicznie i asynchronicznie. Synchroniczne powiadomienia oznacza, że wywołanie <xref:System.Diagnostics.Process.WaitForExit%2A> metody blokują bieżący wątek, dopóki nie kończy procesu. Korzysta z asynchronicznego powiadomienia <xref:System.Diagnostics.Process.Exited> zdarzenie, które umożliwia wątek wywołujący kontynuować wykonywanie w tym samym czasie. W tym ostatnim przypadku <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> musi być równa `true` dla aplikacji wywołującej do odbierania zdarzeń zakończył działanie.  
  
 System operacyjny zamknięcie procesu, powiadamia o wszystkich procesów, które zostały zarejestrowane programy obsługi zdarzeń zakończył działanie. W tej chwili uchwytu procesu, który właśnie został zakończony, może służyć do dostępu do niektórych właściwości, takich jak <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.HasExited%2A> , system operacyjny obsługuje dopóki nie zwolni dojścia całkowicie.  
  
> [!NOTE]
>  Nawet jeśli masz dojścia do zakończenia procesu, nie można wywołać <xref:System.Diagnostics.Process.Start%2A> ponownie, aby ponownie połączyć się z tym samym procesie. Wywoływanie <xref:System.Diagnostics.Process.Start%2A> automatycznie zwalnia skojarzonego procesu i łączy do procesu za pomocą tego samego pliku, ale korzystając z zupełnie nowych <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Aby uzyskać więcej informacji na temat użytkowania <xref:System.Diagnostics.Process.Exited> zdarzeń w aplikacjach Windows Forms, zobacz <xref:System.Diagnostics.Process.SynchronizingObject%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy proces, który drukuje plik. Zgłasza <xref:System.Diagnostics.Process.Exited> zdarzenie, kiedy proces kończy działanie, ponieważ <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> właściwość została ustawiona, gdy proces został utworzony. <xref:System.Diagnostics.Process.Exited> Program obsługi zdarzeń wyświetla informacje o procesach.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas zakończenia skojarzonego procesu.</summary>
        <value>A <see cref="T:System.DateTime" /> oznacza to, gdy skojarzony proces został zakończony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli proces nie został zakończony, próby pobrania <xref:System.Diagnostics.Process.ExitTime%2A> właściwość zgłasza wyjątek. Użyj <xref:System.Diagnostics.Process.HasExited%2A> przed pobraniem <xref:System.Diagnostics.Process.ExitTime%2A> właściwości w celu określenia, czy skojarzony proces został zakończony.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy proces, który drukuje plik. Zgłasza proces <xref:System.Diagnostics.Process.Exited> zdarzenie, kiedy kończy działanie i wyświetla procedury obsługi zdarzeń <xref:System.Diagnostics.Process.ExitTime%2A> właściwości i inne przetwarzania informacji.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.ExitTime" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nową <see cref="T:System.Diagnostics.Process" /> składnika i kojarzy ją z aktualnie aktywny proces.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> składnik skojarzony zasób procesu, który jest uruchomiony aplikacji wywołującej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia i skojarz go z zasobem procesu na komputerze lokalnym.  
  
 Takich jak podobny <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, i <xref:System.Diagnostics.Process.GetProcesses%2A> metod <xref:System.Diagnostics.Process.GetCurrentProcess%2A> kojarzy istniejący zasób z nową <xref:System.Diagnostics.Process> składnika.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącego procesu procesów uruchomionych na komputerze lokalnym, a wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera informacje dotyczące tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Diagnostics.Process" /> składnik i kojarzy ją z istniejącym przetwarzania zasobów, które określisz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">System Unikatowy identyfikator zasobu procesu.</param>
        <summary>Zwraca nowy <see cref="T:System.Diagnostics.Process" /> składnika, podany identyfikator procesu na komputerze lokalnym.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> składnika, który jest skojarzony z zasobu lokalnego procesu określonego przez <paramref name="processId" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> składnika i skojarzyć go z zasobem procesu na komputerze lokalnym. Zasób procesu musi już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> nie tworzy zasób systemowy, ale raczej kojarzy zasobu z wygenerowanymi <xref:System.Diagnostics.Process> składnika. Proces <xref:System.Diagnostics.Process.Id%2A> mogą być pobierane tylko dla procesu, które jest aktualnie uruchomione na komputerze. Po kończy proces, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> zgłasza wyjątek, jeśli przekazywać wygasłe identyfikatora.  
  
 Na dowolnym komputerze określonym identyfikator procesu jest unikatowa. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Zwraca co najwyżej jeden proces. Jeśli chcesz pobrać wszystkie procesy, które są uruchomione określonej aplikacji, użyj <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Jeśli istnieje wiele procesów, na komputerze z uruchomionym określona aplikacja <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> zwraca tablicę zawierającą skojarzonych z nimi procesów. Można tworzyć zapytania w każdej z tych procesów, które z kolei dla jego identyfikator. Identyfikator procesu mogą być wyświetlane w `Processes` panelu Menedżera zadań Windows. `PID` Kolumna Wyświetla identyfikator procesu, który jest przypisany do procesu.  
  
 `processId` Parametr jest <xref:System.Int32> (32-bitowych całkowita), mimo że używa podstawowego interfejsu API Windows `DWORD` (32-bitowa liczba całkowita bez znaku) podobne interfejsy API. Jest to ze względów historycznych.
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącego procesu procesów uruchomionych na komputerze lokalnym, a wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera informacje dotyczące tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Proces określony przez <paramref name="processId" /> parametr nie jest uruchomiona. Identyfikator mógł wygasnąć.</exception>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony przez ten obiekt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">System Unikatowy identyfikator zasobu procesu.</param>
        <param name="machineName">Nazwa komputera w sieci.</param>
        <summary>Zwraca nowy <see cref="T:System.Diagnostics.Process" /> składnika, biorąc pod uwagę identyfikatora procesu i nazwę komputera w sieci.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> składnika, który jest skojarzony z procesu zdalnego zasobu zidentyfikowanego z użyciem <paramref name="processId" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowego <xref:System.Diagnostics.Process> składnika i skojarzyć go z zasobem procesu na komputerze zdalnym w sieci. Zasób procesu musi już istnieć na określonym komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> nie tworzy zasób systemowy, ale raczej kojarzy zasobu z wygenerowanymi <xref:System.Diagnostics.Process> składnika. Proces <xref:System.Diagnostics.Process.Id%2A> mogą być pobierane tylko dla procesu, które jest aktualnie uruchomione na komputerze. Po kończy proces, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> zgłasza wyjątek, jeśli przekazywać wygasłe identyfikatora.  
  
 Na dowolnym komputerze określonym identyfikator procesu jest unikatowa. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Zwraca co najwyżej jeden proces. Jeśli chcesz pobrać wszystkie procesy, które są uruchomione określonej aplikacji, użyj <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Jeśli istnieje wiele procesów, na komputerze z uruchomionym określona aplikacja <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> zwraca tablicę zawierającą skojarzonych z nimi procesów. Można tworzyć zapytania w każdej z tych procesów, które z kolei dla jego identyfikator. Identyfikator procesu mogą być wyświetlane w `Processes` panelu Menedżera zadań Windows. `PID` Kolumna Wyświetla identyfikator procesu, który jest przypisany do procesu.  
  
 Jeśli nie określisz `machineName`, używany jest komputer lokalny. Alternatywnie można określić komputer lokalny, ustawiając `machineName` na wartość "." lub ciąg pusty ("").  
  
 `processId` Parametr jest <xref:System.Int32> (32-bitowych całkowita), mimo że używa podstawowego interfejsu API Windows `DWORD` (32-bitowa liczba całkowita bez znaku) podobne interfejsy API. Jest to ze względów historycznych.   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącego procesu procesów uruchomionych na komputerze lokalnym, a wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera informacje dotyczące tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Proces określony przez <paramref name="processId" /> parametr nie jest uruchomiona. Identyfikator mógł wygasnąć.  
  
—lub— 
<paramref name="machineName" /> Składnia parametru jest nieprawidłowa. Nazwa może mieć długości zerowej (0).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony przez ten obiekt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę o nowe <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je z istniejącymi zasobami procesu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Diagnostics.Process" /> składnika dla każdego zasobu procesu na komputerze lokalnym.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący wszystkie zasoby proces uruchomiony na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je ze wszystkimi zasobami procesu na komputerze lokalnym. Zasoby procesu musi już istnieć na komputerze lokalnym, ponieważ <xref:System.Diagnostics.Process.GetProcesses%2A> nie powoduje utworzenia zasobów systemowych, ale raczej kojarzy zasoby z wygenerowanymi <xref:System.Diagnostics.Process> składników. Ponieważ sam system operacyjny jest uruchomione procesy w tle, ta tablica nigdy nie jest pusty.  
  
 Jeśli nie chcesz pobrać wszystkie procesy uruchomione na komputerze, można ograniczyć ich liczbę za pomocą <xref:System.Diagnostics.Process.GetProcessById%2A> lub <xref:System.Diagnostics.Process.GetProcessesByName%2A> metody. <xref:System.Diagnostics.Process.GetProcessById%2A> Tworzy <xref:System.Diagnostics.Process> składnik, który jest skojarzony z procesem identyfikowane w systemie przez identyfikator procesu, który jest przekazywany do metody. <xref:System.Diagnostics.Process.GetProcessesByName%2A> tworzy tablicę <xref:System.Diagnostics.Process> składników, którego zasoby skojarzony proces udostępniania pliku wykonywalnego, możesz przekazać do metody.  
  
> [!NOTE]
>  Wiele usług Windows może być załadowany w ramach tego samego wystąpienia procesu hosta usługi (svchost.exe). GetProcesses nie identyfikuje tych poszczególnych usług; w tym temacie <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącego procesu procesów uruchomionych na komputerze lokalnym, a wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera informacje dotyczące tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, z którego można odczytać listy procesów.</param>
        <summary>Tworzy nową <see cref="T:System.Diagnostics.Process" /> składnika dla każdego zasobu procesu na określonym komputerze.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący wszystkie zasoby proces uruchomiony na określonym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je ze wszystkimi zasobami procesu na określonym komputerze (zazwyczaj zdalnego). Zasoby procesu musi już istnieć na komputerze lokalnym, ponieważ <xref:System.Diagnostics.Process.GetProcesses%2A> nie powoduje utworzenia zasobów systemowych, ale raczej kojarzy zasoby z wygenerowanymi <xref:System.Diagnostics.Process> składników. Ponieważ sam system operacyjny jest uruchomione procesy w tle, ta tablica nigdy nie jest pusty.  
  
 Jeśli nie chcesz pobrać wszystkie procesy uruchomione na komputerze, można ograniczyć ich liczbę za pomocą <xref:System.Diagnostics.Process.GetProcessById%2A> lub <xref:System.Diagnostics.Process.GetProcessesByName%2A> metody. <xref:System.Diagnostics.Process.GetProcessById%2A> Tworzy <xref:System.Diagnostics.Process> składnik, który jest skojarzony z procesem identyfikowane w systemie przez identyfikator procesu, który jest przekazywany do metody. <xref:System.Diagnostics.Process.GetProcessesByName%2A> tworzy tablicę <xref:System.Diagnostics.Process> składników, którego zasoby skojarzony proces udostępniania pliku wykonywalnego, możesz przekazać do metody.  
  
 To przeciążenie <xref:System.Diagnostics.Process.GetProcesses%2A> metoda zazwyczaj służy do pobierania listy zasobów proces uruchomiony na komputerze zdalnym w sieci, ale można określić komputer lokalny, przekazując ".".  
  
> [!NOTE]
>  Wiele usług Windows może być załadowany w ramach tego samego wystąpienia procesu hosta usługi (svchost.exe). GetProcesses nie identyfikuje tych poszczególnych usług; w tym temacie <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącego procesu procesów uruchomionych na komputerze lokalnym, a wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera informacje dotyczące tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Składnia parametru jest nieprawidłowa. Może mieć długości zerowej (0).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma systemu operacyjnego nie obsługuje tej operacji na komputerach zdalnych.</exception>
        <exception cref="T:System.InvalidOperationException">Brak problemów z dostępem do liczników wydajności, które interfejsy API używane do uzyskania informacji o procesie. Ten wyjątek dotyczy systemu Windows NT, Windows 2000 i Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił problem podczas uzyskiwania dostępu do podstawowego interfejsu API systemu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę o nowe <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je z istniejącymi zasobami procesów mających określona nazwa procesu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Przyjazna nazwa procesu.</param>
        <summary>Tworzy tablicę o nowe <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je ze wszystkimi zasobami procesu na komputerze lokalnym, które mają taką nazwę określonego procesu.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący z procesu zasobów określonej aplikacji lub pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je ze wszystkimi zasobami procesów uruchomionych na tym samym pliku wykonywalnego na komputerze lokalnym. Zasoby procesu musi już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessesByName%2A> nie powoduje utworzenia zasobów systemowych, ale raczej kojarzy je z wygenerowanymi <xref:System.Diagnostics.Process> składników. Element `processName` może zostać określony dla pliku wykonywalnego, który nie jest uruchomiony na komputerze lokalnym, więc tablicy, metoda zwraca wartość może być pusta.  
  
 Nazwa procesu jest przyjazna nazwa dla procesu, takich jak Outlook, w którym nie ma rozszerzenia .exe lub ścieżkę. <xref:System.Diagnostics.Process.GetProcessesByName%2A> jest przydatne do pobierania i manipulowania wszystkie procesy, które są skojarzone z tym samym pliku wykonywalnego. Na przykład, można przekazać nazwę pliku wykonywalnego jako `processName` parametru, aby zamknąć wszystkich uruchomionych wystąpieniach tego pliku wykonywalnego.  
  
 Mimo że proces <xref:System.Diagnostics.Process.Id%2A> jest unikatowy dla zasobu pojedynczego procesu w systemie, wiele procesów na komputerze lokalnym może być uruchomiony aplikacji określonej przez `processName` parametru. W związku z tym <xref:System.Diagnostics.Process.GetProcessById%2A> zwraca co najwyżej jeden proces, ale <xref:System.Diagnostics.Process.GetProcessesByName%2A> zwraca tablicę zawierającą skojarzonych z nimi procesów. Jeśli zachodzi potrzeba manipulowania procesu przy użyciu standardowych wywołań interfejsu API, można tworzyć zapytania, każda z tych procesów, które z kolei dla jego identyfikator. Nie można uzyskać dostęp do zasobów proces, za pomocą sama nazwa procesu, ale po pobraniu tablicę <xref:System.Diagnostics.Process> składniki, które zostały skojarzone z zasobami procesu można uruchomić, zakończenia i manipulować w przeciwnym razie zasobów systemowych.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącego procesu procesów uruchomionych na komputerze lokalnym, a wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera informacje dotyczące tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Brak problemów z dostępem do liczników wydajności, które interfejsy API używane do uzyskania informacji o procesie. Ten wyjątek dotyczy systemu Windows NT, Windows 2000 i Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Przyjazna nazwa procesu.</param>
        <param name="machineName">Nazwa komputera w sieci.</param>
        <summary>Tworzy tablicę o nowe <see cref="T:System.Diagnostics.Process" /> składników i kojarzy je ze wszystkimi zasobami procesu na komputerze zdalnym, które mają taką nazwę określonego procesu.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.Process" /> reprezentujący z procesu zasobów określonej aplikacji lub pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do tworzenia nowych tablicę <xref:System.Diagnostics.Process> składników i skojarzyć je ze wszystkimi zasobami procesów uruchomionych na tym samym pliku wykonywalnego na określonym komputerze. Zasoby procesu musi już istnieć na komputerze, ponieważ <xref:System.Diagnostics.Process.GetProcessesByName%2A> nie powoduje utworzenia zasobów systemowych, ale raczej kojarzy je z wygenerowanymi <xref:System.Diagnostics.Process> składników. Element `processName` może zostać określony dla pliku wykonywalnego, który nie jest uruchomiony na komputerze lokalnym, więc tablicy, metoda zwraca wartość może być pusta.  
  
 Nazwa procesu jest przyjazna nazwa dla procesu, takich jak Outlook, w którym nie ma rozszerzenia .exe lub ścieżkę. <xref:System.Diagnostics.Process.GetProcessesByName%2A> jest przydatne do pobierania i manipulowania wszystkie procesy, które są skojarzone z tym samym pliku wykonywalnego. Na przykład, można przekazać nazwę pliku wykonywalnego jako `processName` parametru, aby zamknąć wszystkich uruchomionych wystąpieniach tego pliku wykonywalnego.  
  
 Mimo że proces <xref:System.Diagnostics.Process.Id%2A> jest unikatowy dla zasobu pojedynczego procesu w systemie, wiele procesów na komputerze lokalnym może być uruchomiony aplikacji określonej przez `processName` parametru. W związku z tym <xref:System.Diagnostics.Process.GetProcessById%2A> zwraca co najwyżej jeden proces, ale <xref:System.Diagnostics.Process.GetProcessesByName%2A> zwraca tablicę zawierającą skojarzonych z nimi procesów. Jeśli zachodzi potrzeba manipulowania procesu przy użyciu standardowych wywołań interfejsu API, można tworzyć zapytania, każda z tych procesów, które z kolei dla jego identyfikator. Nie można uzyskać dostęp do zasobów proces, za pomocą sama nazwa procesu, ale po pobraniu tablicę <xref:System.Diagnostics.Process> składniki, które zostały skojarzone z zasobami procesu można uruchomić, zakończenia i manipulować w przeciwnym razie zasobów systemowych.  
  
 Można użyć tego przeciążenia można pobrać procesów na komputerze lokalnym, a także na komputerze zdalnym. Użyj ".", aby określić komputer lokalny. Istnieje innego przeciążenia metody, która domyślnie używa komputera lokalnego.  
  
 Możesz uzyskać dostęp do procesów na komputerach zdalnych tylko po to, aby wyświetlić informacje, takie jak statystyki dotyczące procesów. Nie można zamknąć, należy zakończyć (przy użyciu <xref:System.Diagnostics.Process.Kill%2A>), lub uruchamiania procesów na komputerach zdalnych.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o bieżącego procesu procesów uruchomionych na komputerze lokalnym, a wszystkie wystąpienia Notatnika uruchomionej na komputerze lokalnym i określonego procesu na komputerze lokalnym. Pobiera informacje dotyczące tego samego procesu na komputerze zdalnym.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Składnia parametru jest nieprawidłowa. Może mieć długości zerowej (0).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma systemu operacyjnego nie obsługuje tej operacji na komputerach zdalnych.</exception>
        <exception cref="T:System.InvalidOperationException">Próba połączenia <paramref name="machineName" /> nie powiodło się.

—lub— 
Brak problemów z dostępem do liczników wydajności, które interfejsy API używane do uzyskania informacji o procesie. Ten wyjątek dotyczy systemu Windows NT, Windows 2000 i Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił problem podczas uzyskiwania dostępu do podstawowego interfejsu API systemu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty skojarzonego procesu.</summary>
        <value>Dojście systemu operacyjnego przypisane do skojarzonego procesu, gdy proces został uruchomiony. System używa tego dojścia do śledzenia procesu atrybutów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikację można uzyskać dojścia do procesu, który może służyć jako parametr do wielu funkcji informacji o procesie i kontroli. Aby zainicjować można użyć tego dojścia <xref:System.Threading.WaitHandle> lub do wywołania wywołania metod macierzystych z platformą.  
  
 Dojście do tego procesu jest prywatny z aplikacją — innymi słowy, proces, który obsługuje nie może być współużytkowana. Proces ma również proces <xref:System.Diagnostics.Process.Id%2A> którego, w przeciwieństwie do <xref:System.Diagnostics.Process.Handle%2A>, jest unikatowa, a więc prawidłowy w całym systemie.  
  
 Tylko procesy uruchomione przez wywołanie <xref:System.Diagnostics.Process.Start%2A> ustaw <xref:System.Diagnostics.Process.Handle%2A> właściwości odpowiadającego <xref:System.Diagnostics.Process> wystąpień.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces nie został uruchomiony lub został zakończony. <see cref="P:System.Diagnostics.Process.Handle" /> Nie można odczytać właściwości, ponieważ nie ma żadnych procesów skojarzony z tym <see cref="T:System.Diagnostics.Process" /> wystąpienia.  
  
—lub— 
<see cref="T:System.Diagnostics.Process" /> Wystąpienia został dołączony do uruchomionego procesu, ale nie masz wystarczających uprawnień, aby pobrać uchwytu z pełnych praw dostępu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Handle" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczba dojść otwartych przez proces.</summary>
        <value>Liczba dojść systemu operacyjnego, który otworzył procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty umożliwiają procesu do odwoływania się do obiektów. Proces można uzyskać dojścia do plików, zasoby, kolejki komunikatów i wiele innych obiektów systemu operacyjnego. System operacyjny odzyskuje pamięć skojarzonego z procesem tylko wtedy, gdy liczba uchwyt jest równa zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy skojarzony proces został zakończony.</summary>
        <value>
          <see langword="true" /> Jeśli odwołuje się do niego procesu systemu operacyjnego <see cref="T:System.Diagnostics.Process" /> składnik został zakończony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `true` dla <xref:System.Diagnostics.Process.HasExited%2A> wskazuje, że skojarzony proces został zakończony, zwykle lub nieprawidłowo. Można zażądać lub wymusić skojarzony proces się zakończy, wywołując <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Jeśli uchwyt jest otwarty do procesu, system operacyjny zwalnia pamięć procesu, gdy proces został zakończony, ale zachowuje informacje administracyjne dotyczące procesu, takie jak dojście, kod zakończenia i czas zakończenia. Aby uzyskać te informacje, można użyć <xref:System.Diagnostics.Process.ExitCode%2A> i <xref:System.Diagnostics.Process.ExitTime%2A> właściwości. Te właściwości są wypełniane automatycznie dla procesów, które zostały uruchomione przez ten składnik. Informacje administracyjne jest zwalniany. gdy wszystkie <xref:System.Diagnostics.Process> składniki, które są skojarzone z procesu systemu są niszczone, a także przechowywać nie ma więcej dojść do zakończenia procesu.  
  
 Proces może zakończyć się niezależnie od kodu. Jeśli rozpoczęto proces, korzystając z tego składnika, system aktualizuje wartość <xref:System.Diagnostics.Process.HasExited%2A> automatycznie, nawet wtedy, gdy skojarzony proces kończy działanie niezależnie.  
  
> [!NOTE]
>  Gdy standardowe dane wyjściowe został przekierowany do procedury obsługi zdarzeń asynchronicznych, jest to możliwe, że dane wyjściowe przetwarzania nie będzie zostały ukończone, gdy ta właściwość zwraca `true`. Aby upewnić się, że obsługi zdarzeń asynchronicznych zostało ukończone, należy wywołać <xref:System.Diagnostics.Process.WaitForExit> przeciążenia, które przyjmuje żadnego parametru przed sprawdzeniem <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej skojarzonego procesu odstępach drugi 2 maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Z przykładu zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Brak procesu skojarzony z obiektem.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać kod zakończenia procesu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.HasExited" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla skojarzonego procesu.</summary>
        <value>Wygenerowana przez system Unikatowy identyfikator procesu, który odwołuje się do niej to <see cref="T:System.Diagnostics.Process" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proces <xref:System.Diagnostics.Process.Id%2A> jest nieprawidłowy, jeśli skojarzony proces nie jest uruchomiona. W związku z tym, należy upewnić się, że proces jest uruchomiony przed podjęciem próby pobrania <xref:System.Diagnostics.Process.Id%2A> właściwości. Aż do zakończenia procesu, identyfikator procesu unikatowo identyfikuje proces w całym systemie.  
  
 Możesz połączyć z procesu, który jest uruchomiony na komputerze lokalnym lub zdalnym, do nowego <xref:System.Diagnostics.Process> wystąpienia, przekazując identyfikator procesu <xref:System.Diagnostics.Process.GetProcessById%2A> metody. <xref:System.Diagnostics.Process.GetProcessById%2A> jest `static` metodę umożliwiającą utworzenie nowego składnika i ustawia <xref:System.Diagnostics.Process.Id%2A> właściwości dla nowego <xref:System.Diagnostics.Process> wystąpienia automatycznie.  
  
 Identyfikatory procesu mogą być ponownie używane przez system. <xref:System.Diagnostics.Process.Id%2A> Wartości właściwości są unikatowe, tylko w przypadku, gdy skojarzony proces jest uruchomiony. Po zakończeniu procesu, można ponownie użyć systemu <xref:System.Diagnostics.Process.Id%2A> wartość właściwości niepowiązanego procesu.  
  
 Identyfikator jest unikatowy w systemie, możesz przekazać go do innych wątków jako alternatywę do przekazywania <xref:System.Diagnostics.Process> wystąpienia. Ta akcja może zapisać zasobów systemowych jeszcze gwarantuje, że proces jest prawidłowo zidentyfikowany.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać <xref:System.Diagnostics.Process.Id%2A> wszystkie uruchomione wystąpienia aplikacji. Ten kod tworzy nowe wystąpienie programu Notatnik, wyświetlane są wszystkie wystąpienia Notatnika, a następnie umożliwia użytkownikowi wprowadzanie <xref:System.Diagnostics.Process.Id%2A> liczba odejmowana konkretne wystąpienie.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie ustawiono właściwości.  
  
—lub— 
Nie ma żadnych procesów skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwości <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Natychmiast zatrzymuje skojarzonego procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Wymusza przerwanie procesu, podczas gdy <xref:System.Diagnostics.Process.CloseMainWindow%2A> zażąda tylko przerwanie. Podczas wykonywania jest procesem, za pomocą interfejsu graficznego, jego pętli komunikatów jest w stanie oczekiwania. Pętla komunikatów jest wykonywana za każdym razem, gdy komunikat Windows jest wysyłany do procesu przez system operacyjny. Wywoływanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> wysyła żądanie do blisko oknie głównym, które w aplikacji poprawnie sformułowany, zamyka okna podrzędne i odwołuje wszystkie uruchomione pętli komunikatów dla aplikacji. Żądanie, aby zakończyć proces, wywołując <xref:System.Diagnostics.Process.CloseMainWindow%2A> wymusza na aplikacji, aby zakończyć. Aplikacja może poprosić o weryfikacji użytkownika przed zamknięciem lub go odmówić zakończyć. Aby wymusić zakończenie aplikacji, użyj <xref:System.Diagnostics.Process.Kill%2A> metody. Zachowanie <xref:System.Diagnostics.Process.CloseMainWindow%2A> jest identyczna z użytkownikiem zamknięcie okna głównego aplikacji, za pomocą menu systemowego. W związku z tym żądania, aby zakończyć proces przez zamknięcie okna głównego nie wymusza natychmiastowe zakończenie aplikacji.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A> Metoda jest wykonywana asynchronicznie. Po wywołaniu <xref:System.Diagnostics.Process.Kill%2A> metody, wywołanie <xref:System.Diagnostics.Process.WaitForExit%2A> metoda oczekiwania na proces zamknąć lub sprawdź <xref:System.Diagnostics.Process.HasExited%2A> właściwości w celu określenia, jeśli proces został zakończony.  
  
 Edytowane przez proces danych lub zasoby przydzielone do procesu mogą zostać utracone, jeśli wywołujesz <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> powoduje, że po zakończeniu procesu nietypowe i należy używać tylko wtedy, gdy jest to konieczne. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Włącza uporządkowany przerwanie procesu i zamyka wszystkie systemy windows, więc jest preferowane w przypadku aplikacji z interfejsem. Jeśli <xref:System.Diagnostics.Process.CloseMainWindow%2A> zakończy się niepowodzeniem, możesz użyć <xref:System.Diagnostics.Process.Kill%2A> aby zakończyć ten proces. <xref:System.Diagnostics.Process.Kill%2A> jest to jedyny sposób, aby zakończyć procesów, które nie mają graficznego interfejsów.  
  
 Możesz wywołać <xref:System.Diagnostics.Process.Kill%2A> i <xref:System.Diagnostics.Process.CloseMainWindow%2A> tylko dla procesów uruchomionych na komputerze lokalnym. Nie może powodować procesów na komputerach zdalnych, aby zakończyć pracę. Może wyświetlać tylko informacje dotyczące procesów uruchomionych na komputerach zdalnych.  
  
> [!NOTE]
>  Jeśli wywołanie <xref:System.Diagnostics.Process.Kill%2A> metoda składa się podczas obecnie zakończenie procesu <xref:System.ComponentModel.Win32Exception> jest generowany dla odmowa dostępu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można przerwać skojarzonego procesu.  
  
—lub— 
Zakończenie procesu.  
  
—lub— 
Skojarzony proces jest Win16 pliku wykonywalnego.</exception>
        <exception cref="T:System.NotSupportedException">Próba wywołania <see cref="M:System.Diagnostics.Process.Kill" /> dla procesu, który jest uruchomiony na komputerze zdalnym. Metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został już zakończony.  
  
—lub— 
Nie ma żadnych procesów skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Trwa <see cref="T:System.Diagnostics.Process" /> składnik poza stan, który umożliwia mu interakcję z procesami systemu operacyjnego, które działają w specjalnym trybie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre procesy systemu operacyjnego są uruchamiane w specjalnym trybie. Nie jest możliwe próby odczytu właściwości lub dołączanie do procesów, chyba że wywołujesz <xref:System.Diagnostics.Process.EnterDebugMode%2A> w składniku. Wywołaj <xref:System.Diagnostics.Process.LeaveDebugMode%2A> gdy już nie potrzebujesz dostępu do tych procesów, które działają w specjalnym trybie.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę komputera, na którym uruchomiono proces skojarzone.</summary>
        <value>Nazwa komputera, na którym uruchomiono proces skojarzone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz wyświetlać danych statystycznych oraz informacji o procesie dla procesów uruchomionych na komputerach zdalnych, ale nie można wywołać <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, lub <xref:System.Diagnostics.Process.Kill%2A> na komputerach zdalnych.  
  
> [!NOTE]
>  Gdy skojarzony proces jest wykonywany na komputerze lokalnym, ta właściwość zwraca kropką (".") dla nazwy maszyny. Należy używać <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> właściwości, aby uzyskać nazwę odpowiednią maszynę.  
  
   
  
## Examples  
 Aby użyć poniższy przykład, że należy najpierw uruchomić co najmniej jednego wystąpienia programu Notatnik na komputerze zdalnym. Przykład wymaga podania nazwy komputera zdalnego, na którym jest uruchomiony program Notatnik, a następnie wyświetla odpowiednie <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, i <xref:System.Diagnostics.Process.MachineName%2A> właściwości dla każdego wystąpienia.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ma żadnych procesów skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł główny skojarzonego procesu.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessModule" /> Który został użyty do uruchomienia procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł procesu reprezentuje pliku a.dll lub .exe, który jest ładowany do określonego procesu. <xref:System.Diagnostics.Process.MainModule%2A> Właściwość umożliwia wyświetlanie informacji o pliku wykonywalnego, używane do uruchamiania procesu, w tym nazwa modułu, nazwa pliku i szczegóły pamięci modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MainModule" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Proces 32-bitowy próbuje uzyskać dostęp moduły procesu 64-bitowego.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  
  
—lub— 
Proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt okna głównego okna skojarzonego procesu.</summary>
        <value>Uchwyt okna generowanych przez system w głównym oknie skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Główne okno jest oknem, otwarty przez proces, który aktualnie ma fokus ( <xref:System.Windows.Forms.Form.TopLevel%2A> formularza). Należy użyć <xref:System.Diagnostics.Process.Refresh%2A> metodę, aby odświeżyć <xref:System.Diagnostics.Process> obiektu można pobrać bieżącego uchwytu okna głównego, jeśli została ona zmieniona. Ogólnie rzecz biorąc, ponieważ uchwyt okna są buforowane, należy używać <xref:System.Diagnostics.Process.Refresh%2A> wyprzedzeniem, aby zagwarantować, będzie pobrać bieżącego dojście.  
  
 Możesz uzyskać <xref:System.Diagnostics.Process.MainWindowHandle%2A> właściwości tylko dla procesów uruchomionych na komputerze lokalnym. <xref:System.Diagnostics.Process.MainWindowHandle%2A> Właściwość ma wartość, która jednoznacznie identyfikuje okna, które jest skojarzone z procesem.  
  
 Proces ma okno główne skojarzonych z nim tylko wtedy, gdy proces ma interfejs graficzny. Jeśli skojarzony proces nie ma okno główne <xref:System.Diagnostics.Process.MainWindowHandle%2A> wartość wynosi zero. Wartość jest również, że zero dla procesów, które zostały ukryte, oznacza to, procesów, które nie są widoczne na pasku zadań. Może to być wymagane dla procesów, które są wyświetlane jako ikony w obszarze powiadomień na prawym końcu paska zadań.  
  
 Jeśli właśnie został uruchomiony proces, aby za pomocą jego uchwytu okna głównego należy wziąć pod uwagę przy użyciu <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodę umożliwiającą proces zakończy się uruchamianie, zapewnienie, że utworzono uchwyt okna głównego. W przeciwnym razie zostanie zgłoszony wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> Nie jest zdefiniowana, ponieważ proces został zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podpis okna głównego procesu.</summary>
        <value>Tytuł okna głównego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proces ma okno główne skojarzonych z nim tylko wtedy, gdy proces ma interfejs graficzny. Jeśli skojarzony proces nie ma okno główne (tak, aby <xref:System.Diagnostics.Process.MainWindowHandle%2A> wynosi zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> jest pustym ciągiem (""). Jeśli właśnie został uruchomiony proces i chcesz użyć jego tytuł okna głównego, należy wziąć pod uwagę przy użyciu <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodę umożliwiającą proces zakończy się uruchamianie, zapewnienie, że utworzono uchwyt okna głównego. W przeciwnym razie system zgłasza wyjątek.  
  
> [!NOTE]
>  Główne okno jest oknem, który aktualnie ma fokus; należy pamiętać, że to nie być podstawowy okna procesu. Należy użyć <xref:System.Diagnostics.Process.Refresh%2A> metodę, aby odświeżyć <xref:System.Diagnostics.Process> obiektu można pobrać bieżącego uchwytu okna głównego, jeśli została ona zmieniona.  
  
   
  
## Examples  
 Poniższy przykład powoduje uruchomienie wystąpienia programu Notatnik i pobiera podpis okna głównego procesu.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> Właściwość nie jest zdefiniowana, ponieważ proces został zakończony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny dopuszczalny rozmiar zestawu roboczego, w bajtach skojarzonego procesu.</summary>
        <value>Maksymalny rozmiar zestawu roboczego jaki jest dozwolony w pamięci dla procesu, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu to zbiór stron pamięci jest obecnie widoczna dla procesu w pamięci fizycznej RAM. Strony te są rezydentne i dostępne do użycia bez powodowania błąd strony aplikacji.  
  
 Zestaw roboczy zawiera dane elementów udostępnionych, jak i prywatnych. Udostępnione dane obejmują stron, które zawierają instrukcje, które wykonuje aplikacja, tym stron w plikach system.dll i pliki .dll. Jak zwiększa rozmiar zestawu roboczego, żądanie pamięci zwiększa się.  
  
 Proces ma rozmiary zestaw roboczy minimalną i maksymalną. Każdym razem, gdy zostanie utworzony zasób proces, system rezerwuje ilość pamięci równy minimalny rozmiar zestawu roboczego dla procesu. Menedżer pamięci wirtualnej próbuje zachować co najmniej minimalnej ilości pamięci rezydentnego podczas procesu jest aktywna, ale zachowuje nigdy nie przekracza maksymalny rozmiar.  
  
 System ustawia domyślny rozmiary zestaw roboczy. Możesz zmodyfikować te rozmiary przy użyciu <xref:System.Diagnostics.Process.MaxWorkingSet%2A> i <xref:System.Diagnostics.Process.MinWorkingSet%2A> elementów członkowskich. Jednak ustawienie te wartości nie gwarantuje, pamięć zostanie zarezerwowany lub miejsce zamieszkania.  
  
> [!NOTE]
>  Zwiększenie rozmiaru zestawu roboczego procesu, możesz skorzystać z pamięci fizycznej w kierunku od reszty systemu. Upewnij się, żąda rozmiar zestawu roboczego minimalnej lub maksymalnej, która jest zbyt duża, ponieważ może to zmniejszyć wydajność systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Maksymalny rozmiar zestawu roboczego jest nieprawidłowy. Jego musi być większa lub równa minimalny rozmiar zestawu roboczego.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Praca informacji o zestawie nie można pobrać z zasobu skojarzonego procesu.  
  
—lub— 
Identyfikator procesu lub dojściem do procesu wynosi zero, ponieważ proces nie został uruchomiony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  
  
—lub— 
Proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia minimalny dozwolony rozmiar zestawu roboczego, w bajtach skojarzonego procesu.</summary>
        <value>Minimalna pracy ustawić rozmiar, który jest wymagany w pamięci dla procesu, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu to zbiór stron pamięci jest obecnie widoczna dla procesu w pamięci fizycznej RAM. Strony te są rezydentne i dostępne do użycia bez powodowania błąd strony aplikacji.  
  
 Zestaw roboczy zawiera dane elementów udostępnionych, jak i prywatnych. Udostępnione dane obejmują stron, które zawierają instrukcje, które wykonuje aplikacja, tym stron w plikach system.dll i pliki .dll. Jak zwiększa rozmiar zestawu roboczego, żądanie pamięci zwiększa się.  
  
 Proces ma rozmiary zestaw roboczy minimalną i maksymalną. Każdym razem, gdy zostanie utworzony zasób proces, system rezerwuje ilość pamięci równy minimalny rozmiar zestawu roboczego dla procesu. Menedżer pamięci wirtualnej próbuje zachować co najmniej minimalnej ilości pamięci rezydentnego podczas procesu jest aktywna, ale zachowuje nigdy nie przekracza maksymalny rozmiar.  
  
 System ustawia domyślny rozmiary zestaw roboczy. Możesz zmodyfikować te rozmiary przy użyciu <xref:System.Diagnostics.Process.MaxWorkingSet%2A> i <xref:System.Diagnostics.Process.MinWorkingSet%2A> elementów członkowskich. Jednak ustawienie te wartości nie gwarantuje, pamięć zostanie zarezerwowany lub miejsce zamieszkania.  
  
> [!NOTE]
>  Zwiększenie rozmiaru zestawu roboczego procesu, możesz skorzystać z pamięci fizycznej w kierunku od reszty systemu. Upewnij się, żąda rozmiar zestawu roboczego minimalnej lub maksymalnej, która jest zbyt duża, ponieważ może to zmniejszyć wydajność systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Minimalny rozmiar zestawu roboczego jest nieprawidłowy. Musi być większa niż maksymalny rozmiar zestawu roboczego.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Praca informacji o zestawie nie można pobrać z zasobu skojarzonego procesu.  
  
—lub— 
Identyfikator procesu lub dojściem do procesu wynosi zero, ponieważ proces nie został uruchomiony.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  
  
—lub— 
Proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduły, które zostały załadowane przez skojarzony proces.</summary>
        <value>Tablica typu <see cref="T:System.Diagnostics.ProcessModule" /> reprezentujący moduły, które zostały załadowane przez skojarzony proces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł procesu reprezentuje pliku a.dll lub .exe, który jest ładowany do określonego procesu. A <xref:System.Diagnostics.ProcessModule> wystąpienie umożliwia wyświetlanie informacji o module, w tym nazwa modułu, nazwa pliku i szczegóły pamięci modułu.  
  
 Proces można załadować wiele modułów do pamięci. Na przykład pliki .exe, które są ładowane pliki .dll dodatkowe mieć wiele modułów.  
  
 Po rozpoczęciu procesu, ta kolekcja jest pusta, dopóki system został załadowany proces. Jeśli proces ma okno główne, można wywołać <xref:System.Diagnostics.Process.WaitForInputIdle%2A> przed pobraniem tej właściwości, aby upewnić się, czy kolekcja jest niepusty po odczytaniu listy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Modules" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Modules" /> właściwość proces systemowy lub procesu bezczynności. Te procesy nie mają modułów.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci niestronicowanej systemu, w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach, system został przydzielony skojarzonego procesu, który nie można zapisać pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci niestronicowanej systemu, w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci systemowej, w bajtach, przydzielany dla skojarzonego procesu, który nie można zapisać pliku stronicowania pamięci wirtualnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci niestronicowanej systemu używany przez proces, w bajtach. Pamięć systemowa jest pamięci fizycznej używanej przez system operacyjny i jest podzielony na pul stronicowanej i niestronicowanej. Alokacje pamięci niestronicowanej pozostają w pamięci systemowej i nie są stronicowane się do pliku stronicowania pamięci wirtualnej.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **puli niestronicowanej** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje <see cref="E:System.Diagnostics.Process.Exited" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> to metoda interfejsu API, który wywołuje <xref:System.Diagnostics.Process.Exited> zdarzeń. Wywoływanie <xref:System.Diagnostics.Process.OnExited%2A> powoduje, że <xref:System.Diagnostics.Process.Exited> zdarzeń i jest jedynym sposobem, aby zgłosić zdarzenie, przy użyciu <xref:System.Diagnostics.Process> składnika. <xref:System.Diagnostics.Process.OnExited%2A> jest używany głównie podczas wyprowadzania z klasy ze składnika.  
  
 Jako alternatywę dla <xref:System.Diagnostics.Process.OnExited%2A>, można napisać własny program obsługi zdarzeń. Tworzenie własnych delegata obsługi zdarzeń i zastosowanie własnej metody obsługi zdarzeń.  
  
> [!NOTE]
>  Jeśli używasz środowiska Visual Studio delegata obsługi zdarzeń (AddOnExited) i metody obsługi zdarzeń (Process1_Exited) są tworzone podczas przeciągania <xref:System.Diagnostics.Process> składnika w formularzu i kliknij dwukrotnie ikonę. Kod można utworzyć w celu uruchomienia podczas <xref:System.Diagnostics.Process.Exited> jest wprowadzana w procedurze Process1_Exited wystąpi zdarzenie. Nie musisz utworzyć <xref:System.Diagnostics.Process.OnExited%2A> elementu członkowskiego, ponieważ jest implementowany za Ciebie.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Diagnostics.Process.OnExited%2A> metody w klasie pochodnej.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aplikacja zapisuje linię jego przekierowanego za każdym razem <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> Zdarzeń wskazuje, że skojarzone <xref:System.Diagnostics.Process> zapisane wiersza, kończące się znakiem nowego wiersza, do jego przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
 Zdarzenie jest włączone w ramach asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A>. Aby rozpocząć asynchronicznych operacji odczytu, należy przekierować <xref:System.Diagnostics.Process.StandardOutput%2A> strumień <xref:System.Diagnostics.Process>, obsługi zdarzenia, aby dodać <xref:System.Diagnostics.Process.OutputDataReceived> zdarzenia i wywołania <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Po tej dacie <xref:System.Diagnostics.Process.OutputDataReceived> sygnały zdarzeń każdorazowo proces zapisuje linię przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> przesyłać strumieniowo, dopóki proces kończy działanie lub wywołuje <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Aplikacji, która przetwarza asynchronicznego dane wyjściowe powinny wywoływać <xref:System.Diagnostics.Process.WaitForExit%2A> metodę, aby upewnić się, że bufor wyjściowy został opróżniony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wykonywania asynchronicznych operacji odczytu na przekierowanym <xref:System.Diagnostics.Process.StandardOutput%2A> strumień `ipconfig` polecenia.  
  
 Przykład tworzy delegata zdarzenia `OutputHandler` programu obsługi zdarzeń i kojarzy ją z <xref:System.Diagnostics.Process.OutputDataReceived> zdarzeń. Program obsługi zdarzeń odbierze wiersze tekstu z przekierowanego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, formatuje tekst i zapisuje go w postaci ciągu danych wyjściowych, który później są wyświetlane w oknie konsoli w tym przykładzie.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Ilość stronicowanej pamięci w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach, przydzielany przez skojarzony proces, który można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Ilość stronicowanej pamięci w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach, przydzielany w pliku stronicowania pamięci wirtualnej skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci w pliku stronicowania pamięci wirtualnej, które są używane przez proces, w bajtach. System operacyjny używa pliku stronicowania pamięci wirtualnej, w połączeniu z pamięci fizycznej do zarządzania wirtualną przestrzenią adresową dla każdego procesu. Gdy stronicowanej pamięci nie jest używany, można przenieść pliku stronicowania pamięci wirtualnej na dysku. Aby uzyskać rozmiar pamięci używanej przez system operacyjny dla procesu, należy użyć <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> właściwości.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Licznik Bajty pliku stronicowania** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikację Notatnik i następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci stronicowanej systemu, w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach, system został przydzielony skojarzonego procesu, który można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci stronicowanej systemu, w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci systemowej, w bajtach, przydzielany dla skojarzonego procesu, który można zapisać w pliku stronicowania pamięci wirtualnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę wartość właściwości reprezentuje bieżący rozmiar pamięci stronicowanej systemu używany przez proces, w bajtach. Pamięć systemowa jest pamięci fizycznej używanej przez system operacyjny i jest podzielony na pul stronicowanej i niestronicowanej. Gdy stronicowanej pamięci nie jest używany, można przenieść pliku stronicowania pamięci wirtualnej na dysku. Aby uzyskać rozmiar pamięci aplikacji używane w procesie, użyj <xref:System.Diagnostics.Process.PagedMemorySize64%2A> właściwości.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **puli stronicowanej** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci w pliku stronicowania pamięci wirtualnej, w bajtach, używany przez proces skojarzone.</summary>
        <value>Maksymalna ilość pamięci w bajtach, przydzielany przez skojarzony proces, które mogłyby być zapisywane do pliku stronicowania pamięci wirtualnej.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci w pliku stronicowania pamięci wirtualnej, w bajtach, używany przez proces skojarzone.</summary>
        <value>Maksymalna ilość pamięci w bajtach, przydzielany w pliku stronicowania pamięci wirtualnej skojarzonego procesu od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę wartość właściwości reprezentuje maksymalny rozmiar pamięci w pliku stronicowania pamięci wirtualnej, które są używane przez proces, od momentu jego uruchomienia w bajtach. System operacyjny używa pliku stronicowania pamięci wirtualnej, w połączeniu z pamięci fizycznej do zarządzania wirtualną przestrzenią adresową dla każdego procesu. Gdy stronicowanej pamięci nie jest używany, można przenieść pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Bajty pliku stronicowania** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci wirtualnej, w bajtach, używany przez proces skojarzone.</summary>
        <value>Maksymalna ilość pamięci wirtualnej, w bajtach, które zażądał skojarzonego procesu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci wirtualnej, w bajtach, używany przez proces skojarzone.</summary>
        <value>Maksymalna ilość pamięci wirtualnej, w bajtach, przydzielany skojarzonego procesu od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje maksymalny rozmiar pamięci wirtualnej używane w procesie od momentu jego uruchomienia w bajtach. System operacyjny mapuje wirtualnej przestrzeni adresowej dla każdego procesu załadowane do strony w pamięci fizycznej lub do stron, przechowywane w pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Maksimum bajtów wirtualnych** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szczytowy rozmiar zestawu roboczego dla skojarzonego procesu w bajtach.</summary>
        <value>Maksymalna ilość pamięci fizycznej, skojarzony proces wymagany w całości w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw roboczy procesu to zbiór stron pamięci jest obecnie widoczna dla procesu w pamięci fizycznej RAM. Strony te są rezydentne i dostępne do użycia bez powodowania błąd strony aplikacji.  
  
 Zestaw roboczy zawiera dane elementów udostępnionych, jak i prywatnych. Udostępnione dane obejmują stron, które zawierają instrukcje, które wykonuje proces, w tym procesie, moduły i biblioteki systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną ilość pamięci fizycznej w bajtach, używany przez proces skojarzone.</summary>
        <value>Maksymalna ilość pamięci fizycznej w bajtach, przydzielany skojarzonego procesu od momentu jego uruchomienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje pracę zestawu użycie pamięci przez proces od momentu jego uruchomienia w bajtach maksymalny rozmiar. Zestaw roboczy procesu to zbiór stron pamięci jest obecnie widoczna dla procesu w pamięci fizycznej RAM. Strony te są rezydentne i dostępne do użycia bez powodowania błąd strony aplikacji.  
  
 Zestaw roboczy zawiera dane elementów udostępnionych, jak i prywatnych. Udostępnione dane obejmują stron, które zawierają instrukcje, które wykonuje proces, łącznie z instrukcjami z modułów procesów i bibliotek systemowych.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Maksimum bajtów zestawu roboczego** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy priorytet skojarzony proces tymczasowo powinien wzmocnione przez system operacyjny, po aktywowaniu głównego okna.</summary>
        <value>
          <see langword="true" /> Jeśli dynamiczne zwiększania wyniku priorytetu procesu powinno mieć miejsce dla procesu, gdy jest ona wykluczana z stan oczekiwania; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wątku w procesie, dla której priorytet ma jedną z wartości wyliczenia priorytetu dynamicznych (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, lub <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), system tymczasowo zwiększa priorytet wątku, jest ona pobierana z stan oczekiwania. Ta akcja uniemożliwia innym procesom przerywania przetwarzania bieżącego wątku. <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Ustawienie ma wpływ na wszystkie istniejące wątki i wszelkie wątki, które następnie są tworzone przez proces. Aby przywrócić normalne działanie, należy ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> właściwość `false`.  
  
> [!NOTE]
>  Ulepszanie zbyt wysoki priorytet może wyczerpać zasoby z podstawowych systemu operacyjnego i funkcji sieciowych, powoduje problemy z innymi zadaniami systemu operacyjnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać informacji o priorytecie boost z zasobu skojarzonego procesu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.  
  
—lub— 
Identyfikator procesu lub dojściem do procesu wynosi zero. (Ten proces nie została uruchomiona.)</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ogólnej kategorii priorytet skojarzonego procesu.</summary>
        <value>Kategoria priorytet skojarzonego procesu, z którego <see cref="P:System.Diagnostics.Process.BasePriority" /> procesu jest obliczana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa priorytetu procesu obejmuje szeroką gamę poziomów priorytetu wątku. Wątki o różnych priorytetach, które działają w procesie uruchamiania względem klasy priorytetu procesu. Win32 używa cztery klasy priorytet siedem poziomów podstawowy priorytet dla klasy. W ramach tych zajęć priorytetu procesu są przechwytywane <xref:System.Diagnostics.ProcessPriorityClass> wyliczenia, które umożliwia ustawiać priorytetu procesu na <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, lub <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Na podstawie czasu, które upłynęło lub innych, zwiększa poziom priorytetu podstawowego mogą zostać zmienione przez system operacyjny, gdy proces musi zostać wprowadzone w przód od innych użytkowników dla dostępu do procesora. Ponadto można ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> tymczasowo zwiększyć poziom priorytetu wątki, które zostały podjęte poza stan oczekiwania. Priorytet jest resetowany, gdy proces powróci do stanu oczekiwania.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Właściwość pozwala na wyświetlanie począwszy od priorytetu, który jest przypisany do procesu. Jednakże, ponieważ jest tylko do odczytu, nie można użyć <xref:System.Diagnostics.Process.BasePriority%2A> właściwość umożliwiająca ustawienie priorytetu procesu. Aby zmienić priorytet, należy użyć <xref:System.Diagnostics.Process.PriorityClass%2A> właściwość, która pobiera lub ustawia ogólnej kategorii priorytetu procesu.  
  
 Klasa priorytetu nie można wyświetlić za pomocą Monitora systemu. W poniższej tabeli przedstawiono relację między <xref:System.Diagnostics.Process.BasePriority%2A> i <xref:System.Diagnostics.Process.PriorityClass%2A> wartości.  
  
|BasePriority|Klasa priorytetu|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Informacje o priorytetu procesu nie można ustawić lub pobierane z zasobu skojarzonego procesu.  
  
—lub— 
Identyfikator procesu lub dojściem do procesu wynosi zero. (Ten proces nie została uruchomiona.)</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PriorityClass" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ustawiono <see cref="P:System.Diagnostics.Process.PriorityClass" /> do <see langword="AboveNormal" /> lub <see langword="BelowNormal" /> podczas korzystania z Windows 98 lub Windows Millennium Edition (Windows Me). Dla klasy priorytet tych platform nie obsługują tych wartości.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Klasa priorytetu nie można ustawić, ponieważ nie używa prawidłową wartość, zgodnie z definicją w <see cref="T:System.Diagnostics.ProcessPriorityClass" /> wyliczenia.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci prywatnej, w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Liczba bajtów przydzielonych przez skojarzony proces, który nie może być współużytkowana z innymi procesami.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci prywatnej, w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci w bajtach, przydzielany dla skojarzonego procesu, który nie może być współużytkowana z innymi procesami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci używanej przez proces, w bajtach, które nie może być współużytkowana z innymi procesami.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Bajty prywatne** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas uprzywilejowany procesora dla tego procesu.</summary>
        <value>A <see cref="T:System.TimeSpan" /> który wskazuje czas spędzony proces uruchomiony kod wewnątrz core systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę procesu.</summary>
        <value>Nazwa, wówczas system używa do identyfikacji procesów do użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> Właściwości jest przechowywana nazwa pliku wykonywalnego, takich jak Outlook, w którym nie ma rozszerzenia .exe lub ścieżkę. Jest to przydatne do pobierania i manipulowania wszystkie procesy, które są skojarzone z tym samym pliku wykonywalnego.  
  
> [!NOTE]
>  Na [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] systemów operacyjnych <xref:System.Diagnostics.Process.ProcessName%2A> właściwość może zostać obcięty do 15 znaków, jeśli nie można uzyskać informacji o module procesu.  
  
 Możesz wywołać <xref:System.Diagnostics.Process.GetProcessesByName%2A>, podając mu nazwa pliku wykonywalnego, aby pobrać tablicę zawierającą każdy uruchomionego wystąpienia na określonym komputerze. Tej tablicy, na przykład, umożliwia wyłączenie wszystkich wystąpień uruchomionego pliku wykonywalnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten proces nie ma identyfikatora lub żaden proces nie jest skojarzona z <see cref="T:System.Diagnostics.Process" />.  
  
—lub— 
Skojarzony proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">Proces nie jest na tym komputerze.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia procesorów, na których wątki tego procesu może być zaplanowane do uruchomienia.</summary>
        <value>Maska bitów reprezentujący procesorów, które wątki w procesie skojarzone można uruchamiać na. Wartość domyślna jest zależna od liczby procesorów w komputerze. Wartość domyślna to 2 <sup>n</sup> -1, gdzie n to liczba procesorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 i nowszych wątek w procesie można migrować z procesora do procesora, z każdą migrację ponownego ładowania pamięci podręcznej procesora. W obszarze system dużymi obciążeniami określania, który procesor powinno być ono uruchomione określonym wątku może poprawić wydajność dzięki zmniejszeniu liczby przypadków, gdy jego pamięci podręcznej zostanie ponownie załadowana. Skojarzenie między procesor i wątku jest wywoływana koligacji procesora.  
  
 Każdemu procesorowi jest reprezentowany jako chwilę. Bit 0 jest procesor, jeden, bit 1 procesor dwóch i tak dalej. Jeśli ustawisz wartość 1 bit procesora odpowiednie został wybrany do przypisania wątku. Po ustawieniu <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartość zero, system operacyjny użytkownika planowania zestawu algorytmów koligacji wątku. Gdy <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartość jest ustawiona na jakąkolwiek wartość różną od zera, wartość jest interpretowana jako maski bitów, która określa te kwalifikuje się do wyboru procesorami.  
  
 W poniższej tabeli przedstawiono szereg <xref:System.Diagnostics.Process.ProcessorAffinity%2A> wartości 8 procesorowe systemu.  
  
|Maska bitowa|Wartość binarna|Kwalifikujące się procesorów|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 i 2|  
|0x0007|00000000 00000111|1, 2 i 3|  
|0x0009|00000000 00001001|1 i 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 i 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> informacje, nie można ustawić lub pobierane z zasobu skojarzonego procesu.  
  
—lub— 
Identyfikator procesu lub dojściem do procesu wynosi zero. (Ten proces nie została uruchomiona.)</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces <see cref="P:System.Diagnostics.Process.Id" /> nie jest dostępna.  
  
—lub— 
Proces został zakończony.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odrzuca żadnych informacji na temat skojarzony proces, który ma pamięci podręcznej wewnątrz składnika procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po <xref:System.Diagnostics.Process.Refresh%2A> jest wywoływana, pierwsze żądanie informacji na temat każdej właściwości powoduje, że składnik przetwarzania, należy uzyskać nową wartość z skojarzonego procesu.  
  
 Gdy <xref:System.Diagnostics.Process> składnik jest skojarzony z zasobem procesu wartości właściwości <xref:System.Diagnostics.Process> natychmiast są wypełniane zgodnie ze stanu skojarzonego procesu. Jeśli informacje o procesie skojarzone zmieni się później, zmiany te nie są odzwierciedlane w <xref:System.Diagnostics.Process> składnika pamięci podręcznej wartości. <xref:System.Diagnostics.Process> Składnik to migawka zasobów procesu w czasie są skojarzone. Aby wyświetlić bieżące wartości dla skojarzonego procesu, należy wywołać <xref:System.Diagnostics.Process.Refresh%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Następnie pobiera użycie pamięci fizycznej skojarzonego procesu odstępach drugi 2 maksymalnie 10 sekund. Przykład wykrywa, czy proces kończy się przed upływem 10 sekund. Z przykładu zamyka proces, jeśli jest nadal uruchomiona po 10 sekundach.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy interfejs użytkownika procesu odpowiada.</summary>
        <value>
          <see langword="true" /> Jeśli interfejs użytkownika skojarzonego procesu odpowiada na żądania systemu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli proces składa się z interfejsem użytkownika <xref:System.Diagnostics.Process.Responding%2A> właściwość skontaktuje się z interfejsu użytkownika, aby ustalić, czy Proces odpowiada na żądania danych wejściowych użytkownika. Jeśli interfejs nie odpowie natychmiast, <xref:System.Diagnostics.Process.Responding%2A> właściwość zwraca `false`. Ta właściwość służy do określenia, czy interfejs skojarzonego procesu przestała odpowiadać.  
  
 Jeśli proces nie ma <xref:System.Diagnostics.Process.MainWindowHandle%2A>, właściwość ta zwraca `true`.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma żadnych procesów skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.Responding" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera natywne dojście do tego procesu.</summary>
        <value>Natywne dojście do tego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojście jest dostępna tylko w przypadku wywoływania składnika uruchomieniem procesu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator sesji usług terminalowych skojarzonego procesu.</summary>
        <value>Identyfikator sesji usług terminalowych skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> Właściwość identyfikuje sesji, w którym aplikacja jest obecnie uruchomiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Nie istnieje żadna sesja skojarzone z tym procesem.</exception>
        <exception cref="T:System.InvalidOperationException">Brak skojarzonych z identyfikatorem sesji procesu.  
  
—lub— 
Skojarzony proces nie jest na tym komputerze.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="P:System.Diagnostics.Process.SessionId" /> Właściwość nie jest obsługiwana w systemach Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do odczytywania danych wyjściowych błędu aplikacji.</summary>
        <value>Element <see cref="T:System.IO.StreamReader" /> można odczytać Standardowy strumień błędów aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.Process> zapisuje tekst jego Standardowy strumień błędów, czy tekst jest zwykle wyświetlany na konsoli. Przekierowując <xref:System.Diagnostics.Process.StandardError%2A> strumienia, można manipulować lub Pomiń błędów wyjścia procesu. Na przykład można filtrować tekst, sformatować je w inny sposób lub zapisać dane wyjściowe do konsoli i pliku dziennika wyznaczonym.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardError%2A>, należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> do `false`, i należy ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> do `true`. W przeciwnym razie podczas odczytywania z <xref:System.Diagnostics.Process.StandardError%2A> strumienia zgłasza wyjątek.  
  
 Przekierowane <xref:System.Diagnostics.Process.StandardError%2A> synchronicznie lub asynchronicznie można odczytać strumienia. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonywania synchronicznych operacji odczytu na strumień dane wyjściowe błędów procesu. Te synchroniczne odczytu, nie wykonuj operacje do skojarzonego <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardError%2A> strumieniowo lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> uruchomieniu asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> strumienia. Ta metoda umożliwia obsługi zdarzenia wyznaczonego dla strumieni wyjściowych i natychmiast powraca do obiektu wywołującego, można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Synchroniczne odczytu operacji wprowadzają zależność między wywołującego podczas odczytywania z <xref:System.Diagnostics.Process.StandardError%2A> strumienia i podrzędne procesu zapisu do tego strumienia. Te zależności, może spowodować warunki zakleszczenia. Odczytuje obiekt wywołujący z przekierowanego strumienia proces podrzędny, jest zależny od elementu podrzędnego. Obiekt wywołujący będzie czekał na operacje odczytu elementu podrzędnego zapisuje w strumieniu lub zamyka strumienia. Proces podrzędny zapisuje wystarczającej ilości danych do wypełnienia jego przekierowanego strumienia, jest zależne od nadrzędnego. Proces podrzędny czeka na następną operację zapisu, aż do nadrzędnego odczytuje ze strumienia pełnego lub zamyka strumienia. Zakleszczenia powoduje obiektami wywołującym i proces podrzędny czekać na siebie, aby zakończyć operację, gdy nie można kontynuować. Możesz uniknąć zakleszczenia poprzez ocenę zależności między obiektami wywołującym i procesu podrzędnego.  
  
 Poniższy kod C#, na przykład pokazuje, jak odczytać ze strumienia przekierowanych i poczekaj na zakończenie procesu podrzędnego.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 W przykładzie kodu unika zakleszczenie przez wywołanie metody `p.StandardError.ReadToEnd` przed `p.WaitForExit`. Zakleszczenie może spowodować, jeśli element nadrzędny procesu wywołania `p.WaitForExit` przed `p.StandardError.ReadToEnd` , a proces podrzędny zapisuje wystarczającą ilość tekstu do wypełnienia przekierowanego strumienia. Proces nadrzędny będzie czekać w nieskończoność na zakończenie procesu podrzędnego. Proces podrzędny będzie czekać w nieskończoność na element nadrzędny można odczytać z pełną <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Istnieje podobny problem podczas odczytywania cały tekst z wyjście standardowe i błąd standardowy strumieni. Poniższy kod C#, na przykład wykonuje operacji odczytu dla obu strumieni.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 W przykładzie kodu unika zakleszczenia przez wykonywanie asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Zakleszczenie wyniki, jeśli element nadrzędny procesu wywołania `p.StandardOutput.ReadToEnd` następuje `p.StandardError.ReadToEnd` , a proces podrzędny zapisuje wystarczającą ilość tekstu do wypełnienia jego strumień błędów. Proces nadrzędny będzie czekać w nieskończoność na proces podrzędny zamknąć jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Proces podrzędny będzie czekać w nieskończoność na element nadrzędny można odczytać z pełną <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Można użyć asynchronicznych operacji odczytu, aby uniknąć tych zależności i ich potencjalne zakleszczenia. Alternatywnie możesz uniknąć zakleszczenia, tworząc dwoma wątkami i odczytywania danych wyjściowych każdego strumienia w oddzielnym wątku.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla przekierowanego strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchronicznego lub synchronicznego wszystkie dalsze odczytu operacji na strumieniu musi znajdować się w tym samym trybie. Na przykład, nie wykonuj <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardError%2A> strumienia, lub na odwrót. Możesz jednak przeczytać dwóch różnych strumieni w różnych trybach. Na przykład, można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `net use` polecenie wraz z użytkownikiem podany argument do mapowania do zasobu sieciowego. Następnie Standardowy strumień błędów polecenia net odczytuje i zapisuje go w konsoli.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardError" /> Strumienia nie został zdefiniowany dla przekierowania; upewnij się, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> ustawiono <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ustawiono <see langword="false" />.  
  
\- lub — 
<see cref="P:System.Diagnostics.Process.StandardError" /> Strumień został otwarty dla asynchronicznych operacji odczytu z <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do zapisywania danych wejściowych w aplikacji.</summary>
        <value>Element <see cref="T:System.IO.StreamWriter" /> można napisać standardowego strumienia wejściowego w aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.Process> tekst może zostać odczytany danych wejściowych z jego standardowego strumienia wejściowego, zazwyczaj klawiatury. Przekierowując <xref:System.Diagnostics.Process.StandardInput%2A> strumienia, można programowo określić dane wejściowe. Na przykład zamiast przy użyciu danych wprowadzonych z klawiatury, możesz podać tekst z zawartości pliku wyznaczonym lub danych wyjściowych z innej aplikacji.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardInput%2A>, należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> do `false`, i należy ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> do `true`. W przeciwnym razie zapisywania <xref:System.Diagnostics.Process.StandardInput%2A> strumienia zgłasza wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób przekierowywania <xref:System.Diagnostics.Process.StandardInput%2A> strumienia procesu. W przykładzie uruchomiono `sort` polecenia przekierowanego danych wejściowych. Następnie monit o wprowadzenie tekstu i przekazuje ją do `sort` procesu za pomocą przekierowanego <xref:System.Diagnostics.Process.StandardInput%2A> strumienia. `sort` Wyniki są wyświetlane użytkownikowi w konsoli.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardInput" /> Stream nie została zdefiniowana, ponieważ <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> ustawiono <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera strumień używany do odczytu tekstowe dane wyjściowe aplikacji.</summary>
        <value>Element <see cref="T:System.IO.StreamReader" /> można przeczytać w standardowym strumieniu wyjściowym aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.Process> zapisuje tekst jego standardowego strumienia tekstu jest normalnie wyświetlany na konsoli. Przekierowując <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, można manipulować lub Pomiń wyjścia procesu. Na przykład można filtrować tekst, sformatować je w inny sposób lub zapisać dane wyjściowe do konsoli i pliku dziennika wyznaczonym.  
  
> [!NOTE]
>  Aby użyć <xref:System.Diagnostics.Process.StandardOutput%2A>, należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> do `false`, i należy ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> do `true`. W przeciwnym razie podczas odczytywania z <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia zgłasza wyjątek.  
  
 Przekierowane <xref:System.Diagnostics.Process.StandardOutput%2A> synchronicznie lub asynchronicznie można odczytać strumienia. Metody takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> wykonywania synchronicznych operacji odczytu na strumień wyjściowy procesu. Te synchroniczne odczytu, nie wykonuj operacje do skojarzonego <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumieniowo lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> uruchomieniu asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Ta metoda umożliwia obsługi zdarzenia wyznaczonego dla strumieni wyjściowych i natychmiast powraca do obiektu wywołującego, można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
 Synchroniczne odczytu operacji wprowadzają zależność między wywołującego podczas odczytywania z <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia i podrzędne procesu zapisu do tego strumienia. Te zależności, może spowodować warunki zakleszczenia. Odczytuje obiekt wywołujący z przekierowanego strumienia proces podrzędny, jest zależny od elementu podrzędnego. Obiekt wywołujący będzie czekał na operacje odczytu elementu podrzędnego zapisuje w strumieniu lub zamyka strumienia. Proces podrzędny zapisuje wystarczającej ilości danych do wypełnienia jego przekierowanego strumienia, jest zależne od nadrzędnego. Proces podrzędny czeka na następną operację zapisu, aż do nadrzędnego odczytuje ze strumienia pełnego lub zamyka strumienia. Zakleszczenia powoduje obiektami wywołującym i proces podrzędny czekać na siebie, aby zakończyć operację, gdy nie można kontynuować. Możesz uniknąć zakleszczenia poprzez ocenę zależności między obiektami wywołującym i procesu podrzędnego.  
  
 Poniższy kod C#, na przykład pokazuje, jak odczytać ze strumienia przekierowanych i poczekaj na zakończenie procesu podrzędnego.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 W przykładzie kodu unika zakleszczenie przez wywołanie metody `p.StandardOutput.ReadToEnd` przed `p.WaitForExit`. Zakleszczenie może spowodować, jeśli element nadrzędny procesu wywołania `p.WaitForExit` przed `p.StandardOutput.ReadToEnd` , a proces podrzędny zapisuje wystarczającą ilość tekstu do wypełnienia przekierowanego strumienia. Proces nadrzędny będzie czekać w nieskończoność na zakończenie procesu podrzędnego. Proces podrzędny będzie czekać w nieskończoność na element nadrzędny można odczytać z pełną <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
 Istnieje podobny problem podczas odczytywania cały tekst z wyjście standardowe i błąd standardowy strumieni. Poniższy kod C#, na przykład wykonuje operacji odczytu dla obu strumieni.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 W przykładzie kodu unika zakleszczenia przez wykonywanie asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Zakleszczenie wyniki, jeśli element nadrzędny procesu wywołania `p.StandardOutput.ReadToEnd` następuje `p.StandardError.ReadToEnd` , a proces podrzędny zapisuje wystarczającą ilość tekstu do wypełnienia jego strumień błędów. Proces nadrzędny będzie czekać w nieskończoność na proces podrzędny zamknąć jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Proces podrzędny będzie czekać w nieskończoność na element nadrzędny można odczytać z pełną <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Można użyć asynchronicznych operacji odczytu, aby uniknąć tych zależności i ich potencjalne zakleszczenia. Alternatywnie możesz uniknąć zakleszczenia, tworząc dwoma wątkami i odczytywania danych wyjściowych każdego strumienia w oddzielnym wątku.  
  
> [!NOTE]
>  Nie można mieszać synchronicznego i asynchronicznego operacji odczytu dla przekierowanego strumienia. Raz przekierowanego strumień <xref:System.Diagnostics.Process> jest otwarty w trybie asynchronicznego lub synchronicznego wszystkie dalsze odczytu operacji na strumieniu musi znajdować się w tym samym trybie. Na przykład, nie wykonuj <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> wywołaniem <xref:System.IO.StreamReader.ReadLine%2A> na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, lub na odwrót. Możesz jednak przeczytać dwóch różnych strumieni w różnych trybach. Na przykład, można wywołać <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> , a następnie wywołać <xref:System.IO.StreamReader.ReadLine%2A> dla <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
   
  
## Examples  
 Poniższy przykład wykonuje polecenie ipconfig.exe i przekierowuje jego standardowe dane wyjściowe do okna konsoli omawianego w przykładzie.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumienia nie został zdefiniowany dla przekierowania; upewnij się, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ustawiono <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> ustawiono <see langword="false" />.  
  
\- lub — 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> Strumień został otwarty dla asynchronicznych operacji odczytu z <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się proces zasobu i kojarzy ją z <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się (lub ponownie używa) zasobu procesu, który jest określony przez <see cref="P:System.Diagnostics.Process.StartInfo" /> właściwość to <see cref="T:System.Diagnostics.Process" /> składnika i kojarzy ją za pomocą składnika.</summary>
        <returns>
          <see langword="true" /> Jeśli zasób proces zostanie uruchomiony; <see langword="false" /> Jeśli żaden z zasobów nowy proces jest uruchomiona, (na przykład, jeśli zostanie ponownie użyty istniejący proces).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia do uruchomienia procesu zasobu i skojarzyć go z bieżącą <xref:System.Diagnostics.Process> składnika. Wartość zwracana `true` wskazuje, że nowy zasób procesu została uruchomiona. Jeśli zasób proces określony przez <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> członkiem <xref:System.Diagnostics.Process.StartInfo%2A> właściwość jest już uruchomiona na komputerze, nie dodatkowych procesów zasób zostanie uruchomiony. Zamiast tego uruchamianie przetwarzania zasobów jest ponownie i `false` jest zwracana.  
  
 Określanie lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację można uruchomić aplikacji ClickOnce. Nie należy uruchamiać aplikacji ClickOnce, określając jej lokalizacja instalacji na dysku twardym.  
  
> [!NOTE]
>  Jeśli używasz programu Visual Studio to przeciążenie <xref:System.Diagnostics.Process.Start%2A> metody jest wstawiany do kodu, po przeciągnięciu <xref:System.Diagnostics.Process> składnik do projektanta. Użyj `Properties` okna, aby rozwinąć `StartInfo` kategorii i Zapisz wartość odpowiednią do `FileName` właściwości. Wprowadzone zmiany zostaną wyświetlone w postaci `InitializeComponent` procedury.  
  
 To przeciążenie <xref:System.Diagnostics.Process.Start%2A> nie `static` metody. Należy wywołać go z wystąpienia <xref:System.Diagnostics.Process> klasy. Przed wywołaniem <xref:System.Diagnostics.Process.Start%2A>, należy najpierw określić <xref:System.Diagnostics.Process.StartInfo%2A> właściwość informacje na temat tego <xref:System.Diagnostics.Process> wystąpienia, ponieważ te informacje służy do określania zasobów procesu, aby rozpocząć.  
  
 Inne przeciążenia <xref:System.Diagnostics.Process.Start%2A> metoda są `static` elementów członkowskich. Nie musisz utworzyć wystąpienie <xref:System.Diagnostics.Process> składnik przed wywołaniem te przeciążenia metody. Zamiast tego możesz wywołać <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> klasy sama i nowe <xref:System.Diagnostics.Process> składnik jest tworzony, jeśli proces został uruchomiony. Ewentualnie `null` jest zwracany, jeśli proces został użyty ponownie. Zasób procesu jest automatycznie kojarzony z nowym <xref:System.Diagnostics.Process> składnika, który jest zwracany przez <xref:System.Diagnostics.Process.Start%2A> metody.  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> Elementów członkowskich może służyć do zduplikowane funkcjonalność `Run` okna dialogowego Windows `Start` menu. Wszystkie elementy, które można wpisać w wierszu polecenia można uruchomić, ustawiając odpowiednie wartości w <xref:System.Diagnostics.Process.StartInfo%2A> właściwości. Tylko <xref:System.Diagnostics.Process.StartInfo%2A> właściwość, która musi być ustawiona jest <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Właściwość musi być plikiem wykonywalnym. Może być dowolnego typu pliku, dla której rozszerzenie został skojarzony z aplikacją, która jest zainstalowana w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość może mieć rozszerzenie .txt, jeśli mają skojarzone pliki tekstowe z edytora, takiego jak Notatnik, lub może mieć rozszerzenie .doc, jeśli masz pliki associated.doc za pomocą narzędzia do edytora tekstów, takiego jak Microsoft Word.  
  
 W wierszu polecenia można określić akcje do wykonania dla niektórych typów plików. Można na przykład, drukowanie dokumentów lub edytowania plików tekstowych. Określ te akcje przy użyciu <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> członkiem <xref:System.Diagnostics.Process.StartInfo%2A> właściwości. Dla innych typów plików, można określić argumenty wiersza polecenia, po uruchomieniu pliku z `Run` okno dialogowe. Na przykład, można przekazać adres URL jako argument w przypadku określenia przeglądarkę jako <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Te argumenty można określić w <xref:System.Diagnostics.Process.StartInfo%2A> właściwości <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> elementu członkowskiego.  
  
 W przypadku ścieżki zmiennej zadeklarowanej w systemie przy użyciu ofert możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie znaleźć ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, a dodaje się go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji jakikolwiek proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web platformy ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda w stronę sieci Web ASP.NET lub formant serwera, nowy proces jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do komputera użytkownika.  
  
 Zawsze, gdy używasz <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, może być konieczne je zamknąć lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 Uwaga dotycząca stany apartamentu w zarządzanych wątkach jest tutaj. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` w składniku procesu <xref:System.Diagnostics.Process.StartInfo%2A> właściwości, upewnij się, ustawiając atrybut ustawiono modelu wątkowości w swojej aplikacji `[STAThread]` na `main()` metody. W przeciwnym razie wątek może znajdować się w `unknown` stanu lub umieszczania w `MTA` stanu jego który powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> trwa `true`. Niektóre metody wymagają, że stan apartamentu nie być `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotyka takie metody, jego wartość domyślna to `MTA`, gdy zostanie ustawiona, stan apartamentu można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku w przypadku powłoki systemu operacyjnego jest zarządzania wątku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wystąpienia <xref:System.Diagnostics.Process> klasy w celu uruchomienia procesu.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku nie została określona w <see cref="T:System.Diagnostics.Process" /> składnika <see cref="P:System.Diagnostics.Process.StartInfo" />.
- lub - <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> członkiem <see cref="P:System.Diagnostics.Process.StartInfo" /> właściwość <see langword="true" /> podczas <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, lub <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemach operacyjnych, które nie obsługują powłoki, takich jak Nano Server (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> Zawierający informacje, które są używane do uruchamiania procesu, takie jak nazwa pliku i argumenty wiersza polecenia.</param>
        <summary>Uruchamia zasobów procesu, który jest określony przez parametr zawierający informacje do rozpoczęcia procesu (na przykład nazwę pliku do rozpoczęcia procesu) i kojarzy zasoby z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzony z zasobem procesu lub <see langword="null" /> Jeśli zasób nie proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle już uruchomione wystąpienia tego samego procesu będą niezależne od innych. Ponadto Start może zwrócić procesu inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną na <see langword="true" />. W tym przypadku uruchomienia procesu może mieć aktywowana istniejącego wystąpienia samej siebie i następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić proces zasobu, określając <xref:System.Diagnostics.ProcessStartInfo> wystąpienia. Przeciążenie kojarzy zasoby z nową <xref:System.Diagnostics.Process> obiektu.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adres URL, ten proces nie jest uruchomiona i `null` jest zwracana.  
  
 To przeciążenie umożliwia uruchamianie procesu bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Za pomocą tego przeciążenia z <xref:System.Diagnostics.ProcessStartInfo> parametru stanowi alternatywę dla jawnego kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia, ustawiając jego <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Za pomocą <xref:System.Diagnostics.ProcessStartInfo> wystąpienia jako parametr pozwala wywoływać <xref:System.Diagnostics.Process.Start%2A> największą kontrolę nad czym jest przekazywany do wywołania, aby rozpocząć proces. Jeśli musisz przekazać nazwę pliku lub nazwę pliku i argumenty, nie jest konieczne utworzyć nowy <xref:System.Diagnostics.ProcessStartInfo> wystąpienia, ale jest opcjonalnym. Tylko <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> właściwość, która musi być ustawiona jest <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Właściwość nie jest konieczne reprezentują pliku wykonywalnego. Może być dowolnego typu pliku, dla której rozszerzenie został skojarzony z aplikacją, która jest zainstalowana w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość może mieć rozszerzenie .txt, jeśli mają skojarzone pliki tekstowe z edytora, takiego jak Notatnik, lub może mieć rozszerzenie .doc, jeśli masz pliki associated.doc za pomocą narzędzia do edytora tekstów, takiego jak Microsoft Word.  
  
 Określanie lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację można uruchomić aplikacji ClickOnce. Nie należy uruchamiać aplikacji ClickOnce, określając jej lokalizacja instalacji na dysku twardym.  
  
 Jeśli <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> właściwości <xref:System.Diagnostics.Process.StartInfo%2A> wystąpienia są ustawione, niezarządzaną `CreateProcessWithLogonW` funkcja jest wywoływana, który uruchamia proces w nowe okno nawet wtedy, gdy <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> wartość właściwości jest `true` lub <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> wartość właściwości jest <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Jeśli <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> właściwość `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> właściwość musi być w formacie UPN *użytkownika*@*DNS_domain_name*.   
  
 W przeciwieństwie do innych przeciążeniach przeciążenia <xref:System.Diagnostics.Process.Start%2A> , nie ma parametrów nie jest `static` elementu członkowskiego. Użyj przeciążenia, gdy masz już utworzoną <xref:System.Diagnostics.Process> wystąpienia informacji początkową (w tym nazwę pliku) i utworzyć zasób procesu i skojarzyć ją z istniejącym <xref:System.Diagnostics.Process> wystąpienia. Użyj jednej z `static` przeciążenia, jeśli chcesz utworzyć nowy <xref:System.Diagnostics.Process> składnika, zamiast uruchamiania procesu dla istniejącego składnika. To przeciążenie i przeciążeń, które nie ma parametrów pozwalają na określenie informacje rozpoczęcia dla zasobu procesu przy użyciu <xref:System.Diagnostics.ProcessStartInfo> wystąpienia.  
  
 W przypadku ścieżki zmiennej zadeklarowanej w systemie przy użyciu ofert możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie znaleźć ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, a dodaje się go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji jakikolwiek proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web platformy ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda w stronę sieci Web ASP.NET lub formant serwera, nowy proces jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do komputera użytkownika.  
  
 Zawsze, gdy używasz <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, może być konieczne je zamknąć lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 Uwaga dotycząca stany apartamentu w zarządzanych wątkach jest tutaj. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` na `startInfo` parametru, upewnij się, ustawiając atrybut ustawiono modelu wątkowości w swojej aplikacji `[STAThread]` na `main()` metody. W przeciwnym razie wątek może znajdować się w `unknown` stanu lub umieszczania w `MTA` stanu jego który powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> trwa `true`. Niektóre metody wymagają, że stan apartamentu nie być `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotyka takie metody, jego wartość domyślna to `MTA`, gdy zostanie ustawiona, stan apartamentu można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku w przypadku powłoki systemu operacyjnego jest zarządzania wątku.  
  
   
  
## Examples  
 Poniższy przykład najpierw spowoduje utworzenie wystąpienia programu Internet Explorer i wyświetla zawartość folderu Ulubione w przeglądarce. Następnie rozpoczyna się kilka innych wystąpień programu Internet Explorer i przedstawia niektóre strony lub witryny. Na koniec uruchomienie programu Internet Explorer z oknem minimalizowanie podczas nawigowania do określonej lokacji.  
  
 Dodatkowe przykłady inne zastosowania tej metody można znaleźć w poszczególnych właściwości <xref:System.Diagnostics.ProcessStartInfo> klasy.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku nie została określona w <paramref name="startInfo" /> parametru <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> właściwości.  
  
—lub— 
<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Właściwość <paramref name="startInfo" /> parametr jest <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, lub <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> właściwość jest również <see langword="true" />.  
  
—lub— 
<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Właściwość <paramref name="startInfo" /> parametr jest <see langword="true" /> i <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> właściwość nie jest <see langword="null" /> lub jest pusta lub <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> właściwość nie jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startInfo" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="startInfo" /> parametru <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> nie można odnaleźć właściwości.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania pliku skojarzone.  
  
—lub— 
Suma długość argumentów i długość pełnej ścieżki do procesu przekracza 2080. Komunikat o błędzie skojarzony z tym wyjątkiem może być jedną z następujących: "w obszarze danych przekazany do wywołania systemowego jest za mały." lub "Odmowa dostępu".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemach operacyjnych, które nie obsługują powłoki, takich jak Nano Server (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku dokumentu lub aplikacji do uruchomienia w procesie.</param>
        <summary>Rozpoczyna się proces zasobu, określając nazwę pliku dokumentu lub aplikacji i kojarzy zasoby z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzony z zasobem procesu lub <see langword="null" /> Jeśli zasób nie proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle już uruchomione wystąpienia tego samego procesu będą niezależne od innych. Ponadto Start może zwrócić procesu inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną na <see langword="true" />. W tym przypadku uruchomienia procesu może mieć aktywowana istniejącego wystąpienia samej siebie i następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić proces zasobu, określając jego nazwa pliku. Przeciążenie kojarzy zasoby z nową <xref:System.Diagnostics.Process> obiektu.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adres URL, ten proces nie jest uruchomiona i `null` jest zwracana.  
  
 To przeciążenie umożliwia uruchamianie procesu bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie to metoda alternatywna do jawnego kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia, ustawiając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> członkiem <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Można uruchomić aplikacji ClickOnce, ustawiając `fileName` parametr do lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację. Nie należy uruchamiać aplikacji ClickOnce, określając jej lokalizacja instalacji na dysku twardym.  
  
 Uruchamianie procesu, określając jego nazwa pliku jest podobny do wpisywania informacji w `Run` okna dialogowego Windows `Start` menu. W związku z tym nazwa pliku nie musi reprezentować pliku wykonywalnego. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją, który został zainstalowany w systemie. Na przykład nazwa pliku może mieć rozszerzenie .txt, czy skojarzony plików tekstowych za pomocą edytora, takiego jak Notatnik, może mieć .doc, jeśli masz pliki associated.doc za pomocą narzędzia do edytora tekstów, takiego jak Microsoft Word. Podobnie, w taki sam sposób `Run` okno dialogowe może zaakceptować, nazwa pliku wykonywalnego z lub bez rozszerzenia .exe, rozszerzenie .exe jest opcjonalne w `fileName` parametru. Na przykład można ustawić `fileName` parametr "Notepad.exe" lub "Notatnik".  
  
 To przeciążenie nie zezwala na argumenty wiersza polecenia do procesu. Jeśli musisz określić jeden lub więcej argumentów wiersza polecenia do procesu, należy użyć <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> lub <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> przeciążenia.  
  
 W przeciwieństwie do innych przeciążeniach przeciążenia <xref:System.Diagnostics.Process.Start%2A> , nie ma parametrów nie jest `static` elementu członkowskiego. Użyj przeciążenia, gdy masz już utworzoną <xref:System.Diagnostics.Process> wystąpienia informacji początkową (w tym nazwę pliku) i utworzyć zasób procesu i skojarzyć ją z istniejącym <xref:System.Diagnostics.Process> wystąpienia. Użyj jednej z `static` przeciążenia, jeśli chcesz utworzyć nowy <xref:System.Diagnostics.Process> składnika, zamiast uruchamiania procesu dla istniejącego składnika. To przeciążenie i przeciążeń, które nie ma parametrów pozwalają określić nazwę pliku zasobu procesu, aby rozpocząć.  
  
 W przypadku ścieżki zmiennej zadeklarowanej w systemie przy użyciu ofert możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie znaleźć ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, a dodaje się go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji jakikolwiek proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web platformy ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda w stronę sieci Web ASP.NET lub formant serwera, nowy proces jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do komputera użytkownika.  
  
 Zawsze, gdy używasz <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, może być konieczne je zamknąć lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości.  
  
 Uwaga dotycząca stany apartamentu w zarządzanych wątkach jest tutaj. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` w składniku procesu <xref:System.Diagnostics.Process.StartInfo%2A> właściwości, upewnij się, ustawiając atrybut ustawiono modelu wątkowości w swojej aplikacji `[STAThread]` na `main()` metody. W przeciwnym razie wątek może znajdować się w `unknown` stanu lub umieszczania w `MTA` stanu jego który powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> trwa `true`. Niektóre metody wymagają, że stan apartamentu nie być `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotyka takie metody, jego wartość domyślna to `MTA`, gdy zostanie ustawiona, stan apartamentu można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku w przypadku powłoki systemu operacyjnego jest zarządzania wątku.  
  
   
  
## Examples  
 Poniższy przykład najpierw spowoduje utworzenie wystąpienia programu Internet Explorer i wyświetla zawartość folderu Ulubione w przeglądarce. Następnie rozpoczyna się kilka innych wystąpień programu Internet Explorer i przedstawia niektóre strony lub witryny. Na koniec uruchomienie programu Internet Explorer z oknem minimalizowanie podczas nawigowania do określonej lokacji.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania pliku skojarzone.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zmiennej środowiskowej PATH ma ciąg zawierający cudzysłowów.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchomienia w procesie.</param>
        <param name="arguments">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <summary>Rozpoczyna się proces zasobu, określając nazwę aplikacji i zestawu argumentów wiersza polecenia i kojarzy zasoby z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzony z zasobem procesu lub <see langword="null" /> Jeśli zasób nie proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle już uruchomione wystąpienia tego samego procesu będą niezależne od innych. Ponadto Start może zwrócić procesu inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną na <see langword="true" />. W tym przypadku uruchomienia procesu może mieć aktywowana istniejącego wystąpienia samej siebie i następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby uruchomić proces zasobu, określając jej nazwę pliku i argumenty wiersza polecenia. Przeciążenie kojarzy zasoby z nową <xref:System.Diagnostics.Process> obiektu.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adres URL, ten proces nie jest uruchomiona i `null` jest zwracana.  
  
 To przeciążenie umożliwia uruchamianie procesu bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie to metoda alternatywna do jawnego kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia, ustawiając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> i <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> członkowie <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Uruchamianie procesu, określając jej nazwę pliku i argumentów jest podobny do wpisywania nazwy pliku i argumenty wiersza poleceń w `Run` okna dialogowego Windows `Start` menu. W związku z tym nazwa pliku nie musi reprezentować pliku wykonywalnego. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją, który został zainstalowany w systemie. Na przykład nazwa pliku może mieć rozszerzenie .txt, czy skojarzony plików tekstowych za pomocą edytora, takiego jak Notatnik, może mieć .doc, jeśli masz pliki associated.doc za pomocą narzędzia do edytora tekstów, takiego jak Microsoft Word. Podobnie, w taki sam sposób `Run` okno dialogowe może zaakceptować, nazwa pliku wykonywalnego z lub bez rozszerzenia .exe, rozszerzenie .exe jest opcjonalne w `fileName` parametru. Na przykład można ustawić `fileName` parametr "Notepad.exe" lub "Notatnik". Jeśli `fileName` parametr reprezentuje plik wykonywalny `arguments` parametr może reprezentować pliku działanie, np. w pliku tekstowym w `Notepad.exe myfile.txt`. Jeśli `fileName` parametru reprezentuje plik poleceń (.cmd) `arguments` parametr musi zawierać albo "`/c`"or"`/k`" argument określający, czy okno polecenia kończy działanie, czy pozostaje po zakończeniu.  
  
 W przeciwieństwie do innych przeciążeniach przeciążenia <xref:System.Diagnostics.Process.Start%2A> , nie ma parametrów nie jest `static` elementu członkowskiego. Użyj przeciążenia, gdy masz już utworzoną <xref:System.Diagnostics.Process> wystąpienia informacji początkową (w tym nazwę pliku) i utworzyć zasób procesu i skojarzyć ją z istniejącym <xref:System.Diagnostics.Process> wystąpienia. Użyj jednej z `static` przeciążenia, jeśli chcesz utworzyć nowy <xref:System.Diagnostics.Process> składnika, zamiast uruchamiania procesu dla istniejącego składnika. To przeciążenie i przeciążeń, które nie ma parametrów pozwalają określić nazwę pliku zasobu procesu, można uruchomić i argumenty wiersza polecenia do przekazania.  
  
 W przypadku ścieżki zmiennej zadeklarowanej w systemie przy użyciu ofert możesz pełnej kwalifikacji tej ścieżki, podczas uruchamiania żaden proces, w tym miejscu. W przeciwnym razie system nie znaleźć ścieżki. Na przykład jeśli `c:\mypath` nie znajduje się w ścieżce, a dodaje się go przy użyciu znaków cudzysłowu: `path = %path%;"c:\mypath"`, musi pełnej kwalifikacji jakikolwiek proces w `c:\mypath` podczas jego uruchamiania.  
  
> [!NOTE]
>  Wykonuje kod sterujący strony i serwera sieci Web platformy ASP.NET w kontekście procesu roboczego ASP.NET na serwerze sieci Web.  Jeśli używasz <xref:System.Diagnostics.Process.Start%2A> metoda w stronę sieci Web ASP.NET lub formant serwera, nowy proces jest wykonywana na serwerze sieci Web z ograniczonymi uprawnieniami. Proces nie uruchamia się w tym samym kontekście co w przeglądarce klienta i nie ma dostępu do komputera użytkownika.  
  
 Zawsze, gdy używasz <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, może być konieczne je zamknąć lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości...  
  
 Uwaga dotycząca stany apartamentu w zarządzanych wątkach jest tutaj. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` w składniku procesu <xref:System.Diagnostics.Process.StartInfo%2A> właściwości, upewnij się, ustawiając atrybut ustawiono modelu wątkowości w swojej aplikacji `[STAThread]` na `main()` metody. W przeciwnym razie wątek może znajdować się w `unknown` stanu lub umieszczania w `MTA` stanu jego który powoduje konflikt z <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> trwa `true`. Niektóre metody wymagają, że stan apartamentu nie być `unknown`. Jeśli stan nie jest jawnie ustawiona, gdy aplikacja napotyka takie metody, jego wartość domyślna to `MTA`, gdy zostanie ustawiona, stan apartamentu można zmienić. Jednak `MTA` powoduje zgłoszenie wyjątku w przypadku powłoki systemu operacyjnego jest zarządzania wątku.  
  
   
  
## Examples  
 Poniższy przykład najpierw spowoduje utworzenie wystąpienia programu Internet Explorer i wyświetla zawartość folderu Ulubione w przeglądarce. Następnie rozpoczyna się kilka innych wystąpień programu Internet Explorer i przedstawia niektóre strony lub witryny. Na koniec uruchomienie programu Internet Explorer z oknem minimalizowanie podczas nawigowania do określonej lokacji.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="fileName" /> Lub <paramref name="arguments" /> parametr <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania pliku skojarzone.  
  
—lub— 
Suma długość argumentów i długość pełnej ścieżki do procesu przekracza 2080. Komunikat o błędzie skojarzony z tym wyjątkiem może być jedną z następujących: "w obszarze danych przekazany do wywołania systemowego jest za mały." lub "Odmowa dostępu".</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zmiennej środowiskowej PATH ma ciąg zawierający cudzysłowów.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchomienia w procesie.</param>
        <param name="userName">Nazwa użytkownika do użycia podczas uruchamiania procesu.</param>
        <param name="password">Element <see cref="T:System.Security.SecureString" /> zawiera hasło do użycia podczas uruchamiania procesu.</param>
        <param name="domain">Domena do użycia podczas uruchamiania procesu.</param>
        <summary>Rozpoczyna się proces zasobu, określając nazwę aplikacji, nazwę użytkownika, hasło i domenę i kojarzy zasoby z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzony z zasobem procesu lub <see langword="null" /> Jeśli zasób nie proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle już uruchomione wystąpienia tego samego procesu będą niezależne od innych. Ponadto Start może zwrócić procesu inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną na <see langword="true" />. W tym przypadku uruchomienia procesu może mieć aktywowana istniejącego wystąpienia samej siebie i następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia utworzenie nowego procesu i wątku podstawowym, określając nazwę pliku, nazwę użytkownika, hasła i domeny. Nowy proces następnie uruchamia określony plik wykonywalny w kontekście zabezpieczeń określonych poświadczeń (użytkownika, domenę i hasło).  
  
> [!NOTE]
>  Jeśli plik wykonywalny znajduje się na dysku zdalnym, należy zidentyfikować udziału sieciowego przy użyciu identyfikatora uniform resource identifier (URI), nie połączonych literę.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adres URL, ten proces nie jest uruchomiona i `null` jest zwracana.  
  
 To przeciążenie umożliwia uruchamianie procesu bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie to metoda alternatywna do jawnego kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia, ustawiając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, i <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> właściwości <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Podobnie, w taki sam sposób **Uruchom** okno dialogowe może zaakceptować, nazwa pliku wykonywalnego z lub bez rozszerzenia .exe, rozszerzenie .exe jest opcjonalne w `fileName` parametru. Na przykład można ustawić `fileName` parametr "Notepad.exe" lub "Notatnik". Jeśli `fileName` parametr reprezentuje plik wykonywalny `arguments` parametr może reprezentować pliku działanie, np. w pliku tekstowym w `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Nazwa pliku musi reprezentować pliku wykonywalnego w <xref:System.Diagnostics.Process.Start%2A> przeciążenia, które mają `userName`, `password`, i `domain` parametrów.  
  
 Zawsze, gdy używasz <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, może być konieczne je zamknąć lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości...  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano sposób użycia tego przeciążenia można uruchomić pliku wykonywalnego i przedstawia również zgłaszanie z <xref:System.ComponentModel.Win32Exception> gdy podejmowana jest próba uruchomienia aplikacji skojarzonych z plikiem niewykonywalne.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku nie została określona.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania skojarzony plik.</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemie Linux lub macOS (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku aplikacji do uruchomienia w procesie.</param>
        <param name="arguments">Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu.</param>
        <param name="userName">Nazwa użytkownika do użycia podczas uruchamiania procesu.</param>
        <param name="password">Element <see cref="T:System.Security.SecureString" /> zawiera hasło do użycia podczas uruchamiania procesu.</param>
        <param name="domain">Domena do użycia podczas uruchamiania procesu.</param>
        <summary>Rozpoczyna się proces zasobu, określając nazwę aplikacji, zestawu argumentów wiersza polecenia, nazwę użytkownika, hasło i domenę i kojarzy zasoby z nową <see cref="T:System.Diagnostics.Process" /> składnika.</summary>
        <returns>Nowy <see cref="T:System.Diagnostics.Process" /> skojarzony z zasobem procesu lub <see langword="null" /> Jeśli zasób nie proces zostanie uruchomiony. Należy pamiętać, że nowy proces, który jest uruchamiany równolegle już uruchomione wystąpienia tego samego procesu będą niezależne od innych. Ponadto Start może zwrócić procesu inną niż null z jego <see cref="P:System.Diagnostics.Process.HasExited" /> już ustawioną na <see langword="true" />. W tym przypadku uruchomienia procesu może mieć aktywowana istniejącego wystąpienia samej siebie i następnie zakończył działanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia utworzenie nowego procesu i wątku podstawowym, określając nazwę pliku, argumenty wiersza polecenia, nazwę użytkownika, hasła i domeny. Nowy proces następnie uruchamia określony plik wykonywalny w kontekście zabezpieczeń określonych poświadczeń (użytkownika, domenę i hasło).  
  
> [!NOTE]
>  Jeśli plik wykonywalny znajduje się na dysku zdalnym, należy zidentyfikować udziału sieciowego przy użyciu identyfikatora uniform resource identifier (URI), nie połączonych literę.  
  
> [!NOTE]
>  Jeśli adres pliku wykonywalnego do uruchomienia jest adres URL, ten proces nie jest uruchomiona i `null` jest zwracana.  
  
 To przeciążenie umożliwia uruchamianie procesu bez tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia. Przeciążenie to metoda alternatywna do jawnego kroki tworzenia nowego <xref:System.Diagnostics.Process> wystąpienia, ustawiając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, i <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> właściwości <xref:System.Diagnostics.Process.StartInfo%2A> właściwości i wywoływania <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia.  
  
 Podobnie, w taki sam sposób **Uruchom** okno dialogowe może zaakceptować, nazwa pliku wykonywalnego z lub bez rozszerzenia .exe, rozszerzenie .exe jest opcjonalne w `fileName` parametru. Na przykład można ustawić `fileName` parametr "Notepad.exe" lub "Notatnik". Jeśli `fileName` parametr reprezentuje plik wykonywalny `arguments` parametr może reprezentować pliku działanie, np. w pliku tekstowym w `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Nazwa pliku musi reprezentować pliku wykonywalnego w <xref:System.Diagnostics.Process.Start%2A> przeciążenia, które mają `userName`, `password`, i `domain` parametrów.  
  
 Zawsze, gdy używasz <xref:System.Diagnostics.Process.Start%2A> do uruchomienia procesu, może być konieczne je zamknąć lub istnieje ryzyko utraty zasobów systemowych. Zamknij procesów przy użyciu <xref:System.Diagnostics.Process.CloseMainWindow%2A> lub <xref:System.Diagnostics.Process.Kill%2A>. Możesz sprawdzić, czy Proces został już zamknięty przy użyciu jego <xref:System.Diagnostics.Process.HasExited%2A> właściwości...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nazwa pliku nie została określona.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas otwierania pliku skojarzone.  
  
—lub— 
Suma długość argumentów i długość pełnej ścieżki do skojarzonego pliku przekracza 2080. Komunikat o błędzie skojarzony z tym wyjątkiem może być jedną z następujących: "w obszarze danych przekazany do wywołania systemowego jest za mały." lub "Odmowa dostępu".</exception>
        <exception cref="T:System.ObjectDisposedException">Obiekt proces został już usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metoda nie jest obsługiwana w systemie Linux lub macOS (tylko .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwości do przekazania do <see cref="M:System.Diagnostics.Process.Start" /> metody <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> Reprezentujący dane za pomocą którego ma zostać uruchomiony proces. Te argumenty obejmują nazwę pliku wykonywalnego lub dokument użyty do uruchomienia procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> reprezentuje zestaw parametrów do użycia do uruchomienia procesu. Gdy <xref:System.Diagnostics.Process.Start%2A> jest wywoływana, <xref:System.Diagnostics.Process.StartInfo%2A> służy do określania do rozpoczęcia procesu. Tylko niezbędne <xref:System.Diagnostics.Process.StartInfo%2A> element członkowski, aby ustawić to <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. Uruchamianie procesu, określając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości jest podobny do wpisywania informacji w **Uruchom** okna dialogowego Windows **Start** menu. W związku z tym <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość nie jest konieczne reprezentują pliku wykonywalnego. Może być dowolnego typu pliku, dla którego rozszerzenie został skojarzony z aplikacją, który został zainstalowany w systemie. Na przykład <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> może mieć rozszerzenie .txt, jeśli mają skojarzone pliki tekstowe z edytora, takiego jak Notatnik, lub może mieć .doc, jeśli masz pliki associated.doc za pomocą narzędzia do edytora tekstów, takiego jak Microsoft Word. Podobnie, w taki sam sposób **Uruchom** okno dialogowe może zaakceptować, nazwa pliku wykonywalnego z lub bez rozszerzenia .exe, rozszerzenie .exe jest opcjonalne w <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> elementu członkowskiego. Na przykład można ustawić <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość "Notepad.exe" lub "Notatnik".  
  
 Można uruchomić aplikacji ClickOnce, ustawiając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości do lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację. Nie należy uruchamiać aplikacji ClickOnce, określając jej lokalizacja instalacji na dysku twardym.  
  
 Jeśli nazwa pliku obejmuje niewykonywalne pliku, na przykład plik doc może zawierać czasownik określający akcję do wykonania na pliku. Na przykład można ustawić <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> do "Print" w odniesieniu do pliku w rozszerzeniem doc. Nazwa pliku określona w <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość musi mieć rozszerzenie, jeśli ręcznie wprowadzić wartość <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> właściwości. Jednak jeśli używasz <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> dostępnych właściwości w celu określenia, jakie polecenia, musi zawierać rozszerzenie.  
  
 Można zmienić parametrów określonych w <xref:System.Diagnostics.Process.StartInfo%2A> właściwości do czasu, który można wywoływać <xref:System.Diagnostics.Process.Start%2A> metody w procesie. Po rozpoczęciu procesu zmiany <xref:System.Diagnostics.Process.StartInfo%2A> wartości nie wpływa na lub uruchom ponownie proces skojarzone. Jeśli wywołasz <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> metody z <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> zestaw właściwości, niezarządzaną `CreateProcessWithLogonW` funkcja jest wywoływana, który uruchamia proces w nowe okno nawet wtedy, gdy <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> wartość właściwości jest `true` lub <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> wartość właściwości jest <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Jeśli nie używasz <xref:System.Diagnostics.Process.Start%2A> metodę, aby uruchomić proces, <xref:System.Diagnostics.Process.StartInfo%2A> właściwość nie będzie odzwierciedlał parametry używane do uruchomienia procesu. Na przykład, jeśli używasz <xref:System.Diagnostics.Process.GetProcesses%2A> uzyskać tablicę procesów uruchomionych na komputerze, <xref:System.Diagnostics.Process.StartInfo%2A> właściwości każdego <xref:System.Diagnostics.Process> nie zawiera oryginalna nazwa pliku lub argumenty używane w celu uruchomienia procesu.  
  
 Rozpoczęcie procesu, nazwa pliku jest plik, który wypełnia (tylko do odczytu) <xref:System.Diagnostics.Process.MainModule%2A> właściwości. Jeśli chcesz pobrać plik wykonywalny, który jest skojarzony z procesem, po rozpoczęciu procesu, należy użyć <xref:System.Diagnostics.Process.MainModule%2A> właściwości. Jeśli chcesz ustawić plik wykonywalny <xref:System.Diagnostics.Process> wystąpienia, dla którego skojarzony proces nie została uruchomiona, należy użyć <xref:System.Diagnostics.Process.StartInfo%2A> właściwości <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> elementu członkowskiego. Ponieważ członkowie <xref:System.Diagnostics.Process.StartInfo%2A> właściwości są argumenty, które są przekazywane do <xref:System.Diagnostics.Process.Start%2A> metoda procesu zmiany <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> nie spowoduje to zresetowanie właściwości po rozpoczęciu procesu skojarzony <xref:System.Diagnostics.Process.MainModule%2A> właściwości. Te właściwości są używane tylko do zainicjowania skojarzonego procesu.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Diagnostics.Process.StartInfo%2A> z pliku do wykonania na nich wykonane działania i tego, czy należy wyświetla interfejs użytkownika. Dodatkowe przykłady można znaleźć na stronach właściwości <xref:System.Diagnostics.ProcessStartInfo> klasy.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość, która określa <see cref="P:System.Diagnostics.Process.StartInfo" /> jest <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas, który skojarzony proces został uruchomiony.</summary>
        <value>Obiekt, który wskazuje, kiedy rozpocząć proces. Wyjątek jest generowany, jeśli proces nie jest uruchomiona.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.StartTime" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.InvalidOperationException">Proces został zakończony.  
  
—lub— 
Proces nie został uruchomiony.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd w wywołaniu funkcji Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane w wyniku zdarzenia zakończenia procesu.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Używany do organizowania wywołań obsługi zdarzeń, które są wydawane na <see cref="E:System.Diagnostics.Process.Exited" /> zdarzeń procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> jest `null`, metody, które obsługują <xref:System.Diagnostics.Process.Exited> zdarzenie są wywoływane w wątku z puli wątków systemu. Aby uzyskać więcej informacji na temat pul wątków systemu zobacz <xref:System.Threading.ThreadPool>.  
  
 Gdy <xref:System.Diagnostics.Process.Exited> zdarzenie jest obsługiwane przez visual składnika Windows Forms, takie jak <xref:System.Windows.Forms.Button>, dostęp do składnika za pośrednictwem puli wątków systemu mogą nie działać, lub może spowodować wyjątek. Tego uniknąć, ustawiając <xref:System.Diagnostics.Process.SynchronizingObject%2A> do składnika Windows Forms, co powoduje, że metody obsługi <xref:System.Diagnostics.Process.Exited> zdarzenie ma być wywołane na tym samym wątku, na którym została utworzona składnika.  
  
 Jeśli <xref:System.Diagnostics.Process> jest używana wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w Projektancie Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> jest automatycznie ustawiana na formant, który zawiera <xref:System.Diagnostics.Process>. Na przykład jeśli umieścisz <xref:System.Diagnostics.Process> w Projektancie dla `Form1` (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.Process.SynchronizingObject%2A> właściwość <xref:System.Diagnostics.Process> jest ustawiona na wystąpienie `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Zazwyczaj ta właściwość jest ustawiona gdy składnik jest umieszczony wewnątrz formantu lub formularzu, ponieważ te składniki są powiązane z określonym wątku.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw wątków, które są uruchomione w skojarzonego procesu.</summary>
        <value>Tablica typu <see cref="T:System.Diagnostics.ProcessThread" /> reprezentująca systemu operacyjnego wątki uruchomione w procesie skojarzone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek wykonuje kod w procesie. Każdy proces zostanie uruchomiony przy użyciu jednego wątku, a jego wątku głównego. Jednym z wątków można utworzyć dodatkowe wątki. Wątki w ramach procesu udostępniania przestrzeni adresowej procesu.  
  
 Użyj <xref:System.Diagnostics.ProcessThread> pobranie wszystkich wątków, które są skojarzone z bieżącym procesie. Wątek główny nie jest w indeksie zero w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Ten proces nie ma <see cref="P:System.Diagnostics.Process.Id" />, lub jest skojarzony żaden proces <see cref="T:System.Diagnostics.Process" /> wystąpienia.  
  
—lub— 
Skojarzony proces został zakończony.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Jest to platforma Windows 98 lub Windows Millennium Edition (Windows Me); Ustaw <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do <see langword="false" /> na dostęp do tej właściwości w systemach Windows 98 i Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formatuje nazwy procesu jako ciąg, w połączeniu z typu składnika nadrzędnego, jeśli ma to zastosowanie.</summary>
        <returns>
          <see cref="P:System.Diagnostics.Process.ProcessName" />, Połączone za pomocą podstawowego składnika <see cref="M:System.Object.ToString" /> zwracają wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> nie jest obsługiwana na Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitego czasu procesora dla tego procesu.</summary>
        <value>A <see cref="T:System.TimeSpan" /> oznacza ilość czasu przez skojarzony proces ma wykorzystanie procesora CPU. Ta wartość jest sumą <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> i <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas użytkownika procesora dla tego procesu.</summary>
        <value>A <see cref="T:System.TimeSpan" /> który wskazuje czas spędzony skojarzony proces uruchomiony kod wewnątrz aplikacji część procesu (poza core systemu operacyjnego).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Próbujesz uzyskać dostęp <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> właściwość dla procesu, który jest uruchomiony na komputerze zdalnym. Ta właściwość jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar pamięci wirtualnej procesu w bajtach.</summary>
        <value>Ilość pamięci wirtualnej, w bajtach, które zażądał skojarzonego procesu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci wirtualnej, w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci wirtualnej, w bajtach, przydzielany skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje bieżący rozmiar pamięci wirtualnej używane w procesie, w bajtach. System operacyjny mapuje wirtualnej przestrzeni adresowej dla każdego procesu załadowane do strony w pamięci fizycznej lub do stron, przechowywane w pliku stronicowania pamięci wirtualnej na dysku.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **Bajty wirtualne** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia okres czasu oczekiwania skojarzony proces zakończenia i bloki bieżącego wątku wykonywania, dopóki nie upłynie czas lub proces został zakończony. Aby uniknąć blokuje bieżący wątek, należy użyć <see cref="E:System.Diagnostics.Process.Exited" /> zdarzeń.  
  
Aby uzyskać przykłady kodu, zobacz <see cref="P:System.Diagnostics.Process.StandardError" /> i <see cref="P:System.Diagnostics.Process.ExitCode" /> strony odwołanie do właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnik, aby czekać w nieskończoność na zakończenie skojarzonego procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> sprawia, że bieżący wątek, poczekaj, aż do zakończenia skojarzonego procesu.  Powinna być wywoływana po wszystkie inne metody są wywoływane na temat procesu. Aby uniknąć blokuje bieżący wątek, należy użyć <xref:System.Diagnostics.Process.Exited> zdarzeń.  
  
 Ta metoda powoduje, że <xref:System.Diagnostics.Process> składnika oczekiwania nieskończoną ilość czasu obsługi procesów i zdarzeń zakończyć pracę. Może to spowodować, że aplikacja przestanie odpowiadać. Na przykład, jeśli wywołasz <xref:System.Diagnostics.Process.CloseMainWindow%2A> dla procesu, który ma interfejs użytkownika, żądanie systemowi operacyjnemu przerwać skojarzonego procesu może nie zostać obsłużone, jeśli proces jest zapisywany nigdy nie wprowadzają jego pętli komunikatów.  
  
> [!NOTE]
>  W [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] i wcześniejszymi wersjami, <xref:System.Diagnostics.Process.WaitForExit> przeciążenia czas potrzebny na <xref:System.Int32.MaxValue> milisekund (około 24 dni), nie na czas nieokreślony. Ponadto poprzednie wersje bez czekania na procedury obsługi zdarzeń zakończyć pracę, jeśli cały <xref:System.Int32.MaxValue> czas został osiągnięty.  
  
 Tego przeciążenia gwarantuje, że wszystkie przetwarzanie zostało ukończone, w tym obsługi zdarzeń asynchronicznych dla przekierowanego wyjścia standardowego. Należy używać tego przeciążenia po wywołaniu <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> przeciążać, gdy standardowe dane wyjściowe został przekierowany do procedury obsługi zdarzeń asynchronicznych.  
  
 Gdy skojarzony proces kończy działanie (to znaczy, gdy jej zostanie zamknięta przez system operacyjny za pośrednictwem zakończenie normalnego lub nietypowych), system przechowuje informacje administracyjne dotyczące procesu i zwraca do składnika, która była wywoływana <xref:System.Diagnostics.Process.WaitForExit>. <xref:System.Diagnostics.Process> Składnika mogą uzyskiwać dostęp do informacji, która zawiera <xref:System.Diagnostics.Process.ExitTime%2A>, za pomocą <xref:System.Diagnostics.Process.Handle%2A> do zakończenia procesu.  
  
 Ponieważ skojarzony proces został zakończony, <xref:System.Diagnostics.Process.Handle%2A> właściwość składnika nie jest już odwołuje się do istniejącego zasobu procesu. Zamiast tego uchwytu może służyć tylko dostęp do systemu operacyjnego informacji o zasobie procesu. System jest świadomy dojścia do zakończenia procesów, które nie zostały zwolnione przez <xref:System.Diagnostics.Process> składników, dzięki czemu zapewnia <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci, dopóki <xref:System.Diagnostics.Process> składnika specjalnie zwalnia zasoby. Z tego powodu każdym wywołaniu <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia, wywołaj <xref:System.Diagnostics.Process.Close%2A> podczas skojarzony proces został zakończony i nie potrzebujesz już wszelkie informacje administracyjne na jego temat. <xref:System.Diagnostics.Process.Close%2A> zwalnia pamięć przydzielona do zakończenia procesu.  
  
   
  
## Examples  
 Zobacz sekcję Uwagi <xref:System.Diagnostics.Process.StandardError%2A> strona odwołanie do właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można uzyskać dostępu do ustawienia oczekiwania.</exception>
        <exception cref="T:System.SystemException">Żaden proces <see cref="P:System.Diagnostics.Process.Id" /> została ustawiona, a <see cref="P:System.Diagnostics.Process.Handle" /> z którego <see cref="P:System.Diagnostics.Process.Id" /> można określić właściwości nie istnieje.  
  
—lub— 
Nie ma żadnych procesów skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.  
  
—lub— 
Próba wywołania <see cref="M:System.Diagnostics.Process.WaitForExit" /> dla procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Ilość czasu (w milisekundach) oczekiwania na zakończenie skojarzonego procesu. Wartość maksymalna to największa możliwa wartość liczby całkowitej 32-bitowy, który reprezentuje nieskończoności do systemu operacyjnego.</param>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika oczekiwania określoną liczbę milisekund skojarzonego procesu zakończyć pracę.</summary>
        <returns>
          <see langword="true" /> Jeśli skojarzony proces został zakończony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sprawia, że bieżący wątek, poczekaj, aż do zakończenia skojarzonego procesu. Powinna być wywoływana po wszystkie inne metody są wywoływane na temat procesu. Aby uniknąć blokuje bieżący wątek, należy użyć <xref:System.Diagnostics.Process.Exited> zdarzeń.  
  
 Ta metoda powoduje, że <xref:System.Diagnostics.Process> składnika oczekiwania ograniczoną ilość czasu na zakończenie procesu. Jeśli skojarzony proces nie istnieje na koniec interwału, ponieważ nastąpiła odmowa żądania, aby zakończyć, `false` są zwracane do procedury wywołującej. Można określić <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> dla `milliseconds`, i <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> będą zachowywać się taka sama jak <xref:System.Diagnostics.Process.WaitForExit> przeciążenia. Jeśli przekażesz 0 (zero) do metody, zwraca `true` tylko wtedy, gdy proces został już zakończony; w przeciwnym razie natychmiast zwraca `false`.  
  
> [!NOTE]
>  W [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] i wcześniejszymi wersjami, jeśli `milliseconds` został -1, <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> przeciążenia czas potrzebny na <xref:System.Int32.MaxValue> milisekund (około 24 dni), nie na czas nieokreślony.  
  
 Standardowe dane wyjściowe został przekierowany do procedury obsługi zdarzeń asynchronicznych, jest to możliwe, że przetwarzanie danych wyjściowych nie będzie zostały ukończone, gdy metoda zwróci wartość. Aby upewnić się, że obsługi zdarzeń asynchronicznych zostało ukończone, należy wywołać <xref:System.Diagnostics.Process.WaitForExit> przeciążenia, które przyjmuje żadnego parametru od momentu odebrania `true` z tego przeciążenia. Aby ułatwić, upewnij się, że <xref:System.Diagnostics.Process.Exited> zdarzeń odbywa się poprawnie w aplikacjach Windows Forms, ustaw <xref:System.Diagnostics.Process.SynchronizingObject%2A> właściwości.  
  
 Gdy zamyka skojarzony proces (zostanie zamknięty przez system operacyjny za pośrednictwem zakończenie normalnego lub nietypowych), system przechowuje informacje administracyjne dotyczące procesu i zwraca do składnika, która była wywoływana <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. <xref:System.Diagnostics.Process> Składnika mogą uzyskiwać dostęp do informacji, która zawiera <xref:System.Diagnostics.Process.ExitTime%2A>, za pomocą <xref:System.Diagnostics.Process.Handle%2A> do zakończenia procesu.  
  
 Ponieważ skojarzony proces został zakończony, <xref:System.Diagnostics.Process.Handle%2A> właściwość składnika nie jest już odwołuje się do istniejącego zasobu procesu. Zamiast tego uchwytu może służyć tylko dostęp do systemu operacyjnego informacji o zasobie procesu. System jest świadomy dojścia do zakończenia procesów, które nie zostały zwolnione przez <xref:System.Diagnostics.Process> składników, dzięki czemu zapewnia <xref:System.Diagnostics.Process.ExitTime%2A> i <xref:System.Diagnostics.Process.Handle%2A> informacje w pamięci, dopóki <xref:System.Diagnostics.Process> składnika specjalnie zwalnia zasoby. Z tego powodu każdym wywołaniu <xref:System.Diagnostics.Process.Start%2A> dla <xref:System.Diagnostics.Process> wystąpienia, wywołaj <xref:System.Diagnostics.Process.Close%2A> podczas skojarzony proces został zakończony i nie potrzebujesz już wszelkie informacje administracyjne na jego temat. <xref:System.Diagnostics.Process.Close%2A> zwalnia pamięć przydzielona do zakończenia procesu.  
  
   
  
## Examples  
 Zobacz przykład kodu dla <xref:System.Diagnostics.Process.ExitCode%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można uzyskać dostępu do ustawienia oczekiwania.</exception>
        <exception cref="T:System.SystemException">Żaden proces <see cref="P:System.Diagnostics.Process.Id" /> została ustawiona, a <see cref="P:System.Diagnostics.Process.Handle" /> z którego <see cref="P:System.Diagnostics.Process.Id" /> można określić właściwości nie istnieje.  
  
—lub— 
Nie ma żadnych procesów skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.  
  
—lub— 
Próba wywołania <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> dla procesu, który jest uruchomiony na komputerze zdalnym. Ta metoda jest dostępna tylko dla procesów uruchomionych na komputerze lokalnym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika oczekiwania skojarzonego procesu na przejściu w stan bezczynności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika czekanie w nieskończoność skojarzonego procesu na przejściu w stan bezczynności. To przeciążenie dotyczy tylko procesy przy użyciu interfejsu użytkownika, a więc pętli komunikatów.</summary>
        <returns>
          <see langword="true" /> Jeśli skojarzony proces osiągnął stan bezczynności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.WaitForInputIdle> wymuszenie przetwarzania aplikacji, aby poczekać, aż przywrócone pętli komunikatów do stanu bezczynności. Podczas wykonywania jest procesem, za pomocą interfejsu użytkownika, jego komunikat pętla jest wykonywana za każdym razem, gdy komunikat Windows jest wysyłany do procesu przez system operacyjny. Proces powraca do pętli komunikatów. Proces jest nazywany jest w stanie bezczynności, gdy trwa oczekiwanie komunikaty wewnątrz pętli komunikatów. Ten stan jest przydatne na przykład, gdy Twoja aplikacja musi czekać do uruchamiania procesu zakończyć tworzenie wyświetleniem głównego okna, zanim aplikacja komunikuje się z tego okna.  
  
 Jeśli proces nie ma pętlę komunikatów <xref:System.Diagnostics.Process.WaitForInputIdle> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> Powoduje, że przeciążenia <xref:System.Diagnostics.Process> składnik, aby czekać w nieskończoność na proces przejdzie w stan bezczynności w pętli komunikatów. Ta instrukcja może spowodować aplikacja przestanie odpowiadać. Na przykład, jeśli proces są zawsze zapisywane zakończyć jego pętli komunikatów natychmiast, tak jak fragmentu kodu `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten proces nie ma interfejsu graficznego.  
  
—lub— 
Wystąpił nieznany błąd. Nie można wprowadzić w stan bezczynności.  
  
—lub— 
Proces został już zakończony.  
  
—lub— 
Żaden proces nie jest skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Wartość 1, aby <see cref="F:System.Int32.MaxValue" /> który określa ilość czasu (w milisekundach) oczekiwania na proces skojarzone przejdzie w stan bezczynności. Wartość 0 określa bezpośredniego zwrotu, a wartość -1 oznacza nieskończone oczekiwanie.</param>
        <summary>Powoduje, że <see cref="T:System.Diagnostics.Process" /> składnika oczekiwania określoną liczbę milisekund skojarzonego procesu na przejściu w stan bezczynności. To przeciążenie dotyczy tylko procesy przy użyciu interfejsu użytkownika, a więc pętli komunikatów.</summary>
        <returns>
          <see langword="true" /> Jeśli skojarzony proces osiągnął stanu bezczynności; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> wymuszenie przetwarzania aplikacji, aby poczekać, aż przywrócone pętli komunikatów do stanu bezczynności. Podczas wykonywania jest procesem, za pomocą interfejsu użytkownika, jego komunikat pętla jest wykonywana za każdym razem, gdy komunikat Windows jest wysyłany do procesu przez system operacyjny. Proces powraca do pętli komunikatów. Proces jest nazywany jest w stanie bezczynności, gdy trwa oczekiwanie komunikaty wewnątrz pętli komunikatów. Ten stan jest przydatne na przykład, gdy Twoja aplikacja musi czekać do uruchamiania procesu zakończyć tworzenie wyświetleniem głównego okna, zanim aplikacja komunikuje się z tego okna.  
  
 Jeśli proces nie ma pętlę komunikatów <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Powoduje, że przeciążenia <xref:System.Diagnostics.Process> składnika oczekiwania skończony czas procesu przejdzie w stan bezczynności w pętli komunikatów. Jeśli skojarzony proces ma nie przejdzie w stan bezczynności przed zakończeniem interwał ponieważ pętli nadal przetwarza wiadomości, `false` są zwracane do procedury wywołującej.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten proces nie ma interfejsu graficznego.  
  
—lub— 
Wystąpił nieznany błąd. Nie można wprowadzić w stan bezczynności.  
  
—lub— 
Proces został już zakończony.  
  
—lub— 
Żaden proces nie jest skojarzony z tym <see cref="T:System.Diagnostics.Process" /> obiektu.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera skojarzonego procesu wykorzystania pamięci fizycznej w bajtach.</summary>
        <value>Całkowita ilość pamięci fizycznej skojarzone używanej przez proces, w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje pracę zestawu użycie pamięci przez proces, w bajtach bieżący rozmiar. Zestaw roboczy procesu to zbiór stron pamięci jest obecnie widoczna dla procesu w pamięci fizycznej RAM. Strony te są rezydentne i dostępne do użycia bez powodowania błąd strony aplikacji.  
  
 Zestaw roboczy zawiera dane elementów udostępnionych, jak i prywatnych. Udostępnione dane obejmują stron, które zawierają instrukcje, które wykonuje proces, łącznie z modułami przetwarzania i bibliotek systemowych.  
  
   
  
## Examples  
 Poniższy przykład uruchamia wystąpienie Notatnika. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla kod zakończenia procesu.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość pamięci fizycznej w bajtach, przydzielany skojarzonego procesu.</summary>
        <value>Ilość pamięci fizycznej w bajtach, przydzielany skojarzonego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość reprezentuje pracę zestawu użycie pamięci przez proces, w bajtach bieżący rozmiar. Zestaw roboczy procesu to zbiór stron pamięci jest obecnie widoczna dla procesu w pamięci fizycznej RAM. Strony te są rezydentne i dostępne do użycia bez powodowania błąd strony aplikacji.  
  
 Zestaw roboczy zawiera dane elementów udostępnionych, jak i prywatnych. Udostępnione dane obejmują stron, które zawierają instrukcje, które wykonuje proces, łącznie z instrukcjami w modułach procesu i bibliotek systemowych.  
  
 Ta właściwość może służyć do monitorowania wykorzystania pamięci na komputerach wyposażonych w procesory 32-bitowy lub 64-bitowych procesorach. Wartość właściwości jest odpowiednikiem **rozmiar zestawu roboczego** licznika wydajności dla procesu.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia wystąpienie aplikacji Notatnik. Przykład następnie pobiera i wyświetla różne właściwości skojarzonego procesu. Przykład wykrywa, gdy proces się zakończy i wyświetla jego statystyki pamięci zakończenia, jak kod i ze szczytową.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Windows Me), który nie obsługuje tej właściwości.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
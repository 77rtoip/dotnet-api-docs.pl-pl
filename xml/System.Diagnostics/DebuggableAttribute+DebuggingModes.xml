<Type Name="DebuggableAttribute+DebuggingModes" FullName="System.Diagnostics.DebuggableAttribute+DebuggingModes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="01ec3e7703297298a552f50811143263bb757553" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56357670" /></Metadata><TypeSignature Language="C#" Value="public enum DebuggableAttribute.DebuggingModes" />
  <TypeSignature Language="ILAsm" Value=".class nested public auto ansi sealed DebuggableAttribute/DebuggingModes extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DebuggableAttribute.DebuggingModes" />
  <TypeSignature Language="VB.NET" Value="Public Enum DebuggableAttribute.DebuggingModes" />
  <TypeSignature Language="C++ CLI" Value="public: enum class DebuggableAttribute::DebuggingModes" />
  <TypeSignature Language="F#" Value="type DebuggableAttribute.DebuggingModes = " />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa tryb debugowania, kompilator just-in-time (JIT).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes> Wyliczenie Określa, jak środowisko uruchomieniowe do śledzenia informacji ważnych dla debugera, podczas generowania kodu. Informacje te pomagają debugera, zapewniają bogate środowisko debugowania. W przeciwieństwie do programu .NET Framework w wersji 1.1 wersji 2.0 lub nowszej nie pozwalają wyłączyć śledzenie przez kompilator just-in-time (JIT). Śledzenia JIT jest zawsze włączona w przypadku debugowania plików.  W wersji 2.0 lub nowszej wartości wyliczenia mają wpływ następujące.  
  
|Tryb debugowania|Wynik|  
|--------------------|------------|  
|Brak|Śledzenie na optymalizacje JIT włączone|  
|Domyślny|Śledzenie na optymalizacje JIT włączone|  
|DisableOptimizations|Śledzenie na optymalizacje JIT włączone|  
|Default &#124; DisableOptimizations|Śledzenie na optymalizacje JIT wyłączone|  
  
 Punkty sekwencji są używane w celu wskazania lokalizacji w kodzie języka intermediate language (MSIL) firmy Microsoft, który debuger będzie zgodne z oczekiwaniami użytkownika Aby można było odwoływać się do unikatowego, np. ustawienie punktu przerwania. Kompilator JIT gwarantuje, że nie można go skompilować MSIL w dwóch różnych sekwencji punktów w pojedynczej instrukcji natywnych. Domyślnie kompilator JIT sprawdza, czy Magazyn symboli w pliku bazy danych (PDB) program lista dodatkowych sekwencji punktów. Jednak podczas ładowania pliku PDB plik wymaga pliku dostępna i ma negatywny wpływ na wydajność. Począwszy od wersji 2.0, kompilatory może emitować "niejawnej sekwencji punktów" w strumienia kodu MSIL przy użyciu MSIL "`nop"` instrukcje. Kompilatory takie należy ustawić flagę IgnoreSymbolStoreSequencePoints, aby powiadomić środowiska uruchomieniowego języka wspólnego nie były ładowane pliku PDB.  
  
> [!NOTE]
>  To wyliczenie jest głównie używane przez deweloperów języka. Ją ogólnie nie jest używana podczas tworzenia aplikacji. Użyj środowiska deweloperskie <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints> na podstawie kompilatora parametrów takich jak **/debug** i **/ optimize**.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="Default" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Diagnostics.DebuggableAttribute/DebuggingModes Default = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.Default" />
      <MemberSignature Language="VB.NET" Value="Default" />
      <MemberSignature Language="C++ CLI" Value="Default" />
      <MemberSignature Language="F#" Value="Default = 1" Usage="System.Diagnostics.DebuggableAttribute.DebuggingModes.Default" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DebuggableAttribute+DebuggingModes</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Instruuje kompilator just-in-time (JIT), aby użyć swojego zachowania domyślnego i obejmuje włączenie optymalizacje, wyłączenie Edytuj i Kontynuuj pomocy technicznej i przy użyciu sekwencji magazynu symboli punktów, jeśli jest obecny. Począwszy od .NET Framework w wersji 2.0, informacji ze śledzenia kompilatora JIT języka Microsoft intermediate language (MSIL) na przesunięcie kodu natywnego w metodzie, był zawsze generowany.</summary>
      </Docs>
    </Member>
    <Member MemberName="DisableOptimizations">
      <MemberSignature Language="C#" Value="DisableOptimizations" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Diagnostics.DebuggableAttribute/DebuggingModes DisableOptimizations = int32(256)" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations" />
      <MemberSignature Language="VB.NET" Value="DisableOptimizations" />
      <MemberSignature Language="C++ CLI" Value="DisableOptimizations" />
      <MemberSignature Language="F#" Value="DisableOptimizations = 256" Usage="System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DebuggableAttribute+DebuggingModes</ReturnType>
      </ReturnValue>
      <MemberValue>256</MemberValue>
      <Docs>
        <summary>Wyłącz optymalizacje wykonywane przez kompilator, aby plik wyjściowy był mniejszy, szybszy i bardziej wydajne. Optymalizacje doprowadzić do modyfikacji kodu w pliku danych wyjściowych, który może utrudnić debugowanie. Zazwyczaj optymalizacji powinno być wyłączone podczas debugowania. W wersji 2.0 lub nowszej, należy połączyć tę wartość przy użyciu domyślnego (domyślne | DisableOptimizations) umożliwiające śledzenie i wyłączone optymalizacje JIT.</summary>
      </Docs>
    </Member>
    <Member MemberName="EnableEditAndContinue">
      <MemberSignature Language="C#" Value="EnableEditAndContinue" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Diagnostics.DebuggableAttribute/DebuggingModes EnableEditAndContinue = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.EnableEditAndContinue" />
      <MemberSignature Language="VB.NET" Value="EnableEditAndContinue" />
      <MemberSignature Language="C++ CLI" Value="EnableEditAndContinue" />
      <MemberSignature Language="F#" Value="EnableEditAndContinue = 4" Usage="System.Diagnostics.DebuggableAttribute.DebuggingModes.EnableEditAndContinue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DebuggableAttribute+DebuggingModes</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Włącz edycję i kontynuować. Edytuj i Kontynuuj umożliwia do wprowadzania zmian w kodzie źródłowym, gdy program działa w trybie przerwania. Edytuj i Kontynuuj jest kompilatora zależnych.</summary>
      </Docs>
    </Member>
    <Member MemberName="IgnoreSymbolStoreSequencePoints">
      <MemberSignature Language="C#" Value="IgnoreSymbolStoreSequencePoints" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Diagnostics.DebuggableAttribute/DebuggingModes IgnoreSymbolStoreSequencePoints = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints" />
      <MemberSignature Language="VB.NET" Value="IgnoreSymbolStoreSequencePoints" />
      <MemberSignature Language="C++ CLI" Value="IgnoreSymbolStoreSequencePoints" />
      <MemberSignature Language="F#" Value="IgnoreSymbolStoreSequencePoints = 2" Usage="System.Diagnostics.DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DebuggableAttribute+DebuggingModes</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Użyj niejawnego punktów sekwencji MSIL, nie punktów sekwencji bazy danych (PDB) programu. Informacje symboliczne zwykle zawiera co najmniej jeden przesunięcia języka pośredniego (MSIL) firmy Microsoft dla poszczególnych wierszach źródła. Gdy kompilator just-in-time (JIT) ma compile — metoda, prosi usługi profilowania, aby uzyskać listę przesunięć MSIL, które mają zostać zachowane. Przesunięcia MSIL są nazywane punktów sekwencji.</summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Diagnostics.DebuggableAttribute/DebuggingModes None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.None" />
      <MemberSignature Language="VB.NET" Value="None" />
      <MemberSignature Language="C++ CLI" Value="None" />
      <MemberSignature Language="F#" Value="None = 0" Usage="System.Diagnostics.DebuggableAttribute.DebuggingModes.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DebuggableAttribute+DebuggingModes</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Począwszy od .NET Framework w wersji 2.0, informacje ze śledzenia kompilatora JIT był zawsze generowany, a ta flaga ma taki sam skutek jak <see cref="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.Default" />, z tą różnicą, że ustawia <see cref="P:System.Diagnostics.DebuggableAttribute.IsJITTrackingEnabled" /> właściwość <see langword="false" />. Ponieważ śledzenia JIT jest zawsze włączone, wartość właściwości jest ignorowane w wersji 2.0 lub nowszej.  
  
Należy zauważyć, że w przeciwieństwie do <see cref="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations" /> flagi <see cref="F:System.Diagnostics.DebuggableAttribute.DebuggingModes.None" /> nie można użyć flagi, aby wyłączyć optymalizacje JIT.</summary>
      </Docs>
    </Member>
  </Members>
</Type>
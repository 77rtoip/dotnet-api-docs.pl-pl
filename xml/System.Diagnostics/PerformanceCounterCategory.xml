<Type Name="PerformanceCounterCategory" FullName="System.Diagnostics.PerformanceCounterCategory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9a342238a6e395ebbd15934beaa074d05afb683e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69075976" /></Metadata><TypeSignature Language="C#" Value="public sealed class PerformanceCounterCategory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounterCategory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounterCategory" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounterCategory" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounterCategory sealed" />
  <TypeSignature Language="F#" Value="type PerformanceCounterCategory = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje obiekt wydajności, który definiuje kategorię liczników wydajności.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Tworzenie lub usuwanie licznika wydajności wymaga synchronizacji kodu bazowego przy użyciu nazwanego obiektu mutex. Jeśli aplikacja o wysokim poziomie uprawnień blokuje nazwany obiekt mutex, próby utworzenia lub usunięcia licznika wydajności powodują, że aplikacja przestanie odpowiadać do momentu zwolnienia blokady. Aby uniknąć tego problemu, nigdy nie Udziel <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnień do niezaufanego kodu. Ponadto <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnienie potencjalnie pozwala na obejście innych uprawnień i powinno być przyznawane tylko do wysoce zaufanego kodu.  
  
 Właściwość<xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A>wystąpieniajest wyświetlana w polu Obiekt wydajności w oknie dialogowym Dodaj licznik aplikacji Podgląd wydajności. <xref:System.Diagnostics.PerformanceCounterCategory>  
  
 <xref:System.Diagnostics.PerformanceCounterCategory> Klasa zawiera kilka metod współpracy z licznikami i kategoriami na komputerze. <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> Metody umożliwiają definiowanie kategorii niestandardowych. <xref:System.Diagnostics.PerformanceCounterCategory.Delete%2A> Metoda umożliwia usuwanie kategorii z komputera. Metoda umożliwia wyświetlenie listy kategorii, podczas gdy <xref:System.Diagnostics.PerformanceCounterCategory.ReadCategory%2A> pobiera wszystkie dane licznika i wystąpienia skojarzone z pojedynczą kategorią. <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A>  
  
 Licznik wydajności publikuje dane dotyczące wydajności aplikacji. Kategorie obejmują składniki fizyczne (takie jak procesory, dyski i pamięć) oraz obiekty systemowe (na przykład procesy i wątki). Liczniki systemowe, które są powiązane z tym samym obiektem wydajności, są pogrupowane w kategorię, która wskazuje ich typowy fokus. Gdy tworzysz wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy, najpierw wskaż kategorię, z którą będzie korzystać składnik, a następnie wybierz licznik z tej kategorii.  
  
 Na przykład jedna kategoria licznika systemu Windows jest kategorią pamięci. Liczniki systemowe w tej kategorii śledzą dane pamięci, takie jak liczba dostępnych bajtów i liczba buforowanych bajtów. Jeśli chcesz korzystać z bajtów w pamięci podręcznej w aplikacji, Utwórz wystąpienie <xref:System.Diagnostics.PerformanceCounter> składnika, połącz je z kategorią pamięci, a następnie wybierz odpowiedni licznik (w tym przypadku bajty w pamięci podręcznej) z tej kategorii.  
  
 Mimo że system udostępnia wiele większej liczby kategorii liczników, kategorie, z którymi najprawdopodobniej będzie najczęściej korzystać, to pamięć podręczna, pamięć, obiekty, DyskFizyczny, procesy, procesory, serwery, systemy i wątki.  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> Metoda<xref:System.Diagnostics.PerformanceCounter> w klasie zwolni licznik i, jeśli wybrano opcję ponownego użycia dla tej kategorii, wystąpienie licznika zostanie ponownie użyte. Może to spowodować sytuację wyścigu, jeśli inny proces lub nawet inna część kodu próbuje zapisać w wystąpieniu licznika.  
  
> [!NOTE]
>  Zdecydowanie zaleca się utworzenie nowych kategorii licznika wydajności podczas instalacji aplikacji, a nie w trakcie wykonywania aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych kategorii liczników wydajności przez system operacyjny. Jeśli lista nie została odświeżona, próba użycia kategorii zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Kategorie licznika wydajności zainstalowane z [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] użyciem oddzielnej udostępnionej pamięci, z każdą kategorią licznika wydajności mającą własną pamięć. Można określić rozmiar oddzielnej pamięci współdzielonej przez utworzenie typu DWORD o nazwie FileMappingSize w kluczu rejestru\\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services*\<Category Name >* \Performance. Wartość FileMappingSize jest ustawiona na rozmiar pamięci współdzielonej kategorii. Domyślny rozmiar to 131072 dziesiętny. Jeśli FileMappingSize wartość nie istnieje, `fileMappingSize` zostanie użyta wartość atrybutu dla elementu określonego w pliku Machine. config, co spowoduje dodatkowe obciążenie związane z `performanceCounters` przetwarzaniem plików konfiguracyjnych. Zwiększenie wydajności uruchamiania aplikacji można zrealizować przez ustawienie rozmiaru mapowania plików w rejestrze. Aby uzyskać więcej informacji o rozmiarze mapowania plików, zobacz [ &lt;liczniki wydajności&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa, czy <xref:System.Diagnostics.PerformanceCounter> <xref:System.Diagnostics.PerformanceCounterCategory> i istnieje na komputerze lokalnym, czy na innym komputerze. Jeśli te obiekty nie istnieją na komputerze lokalnym, Przykładowo można je utworzyć. Używa metody, <xref:System.Diagnostics.PerformanceCounterCategory.Exists%2A> aby określić, <xref:System.Diagnostics.PerformanceCounterCategory> czy istnieje.  <xref:System.Diagnostics.PerformanceCounterCategory> Jeśli nie istnieje i nie określono nazwy licznika lub jeśli komputer jest maszyną zdalną, przykład kończy się.  
  
 W przypadku podanej <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%2A> nazwy, przykład używa metody i wyświetla wynik dla użytkownika. <xref:System.Diagnostics.PerformanceCounter> Jeśli nie istnieje, użytkownik może je usunąć i <xref:System.Diagnostics.PerformanceCounterCategory> utworzyć ponownie z nowym <xref:System.Diagnostics.PerformanceCounter>. <xref:System.Diagnostics.PerformanceCounter> Jeśli użytkownik robi to, kategoria zostanie usunięta przy użyciu <xref:System.Diagnostics.PerformanceCounterCategory.Delete%2A> metody.  
  
 Jeśli zażądano, w przykładzie tworzony jest <xref:System.Diagnostics.PerformanceCounterCategory> nowy <xref:System.Diagnostics.PerformanceCounter> i przy <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> użyciu metody. Jeśli nazwa wystąpienia jest określona, przykład używa <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> metody i wyświetla wynik.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.Class/CS/perfcountercatcreateexist.cs#27)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.Class/VB/perfcountercatcreateexist.vb#27)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounter" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounterCategory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounterCategory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy, <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> pozostawia Właściwość <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> pustą i ustawia właściwość na komputer lokalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi być ustawiona przed skojarzeniem tego <xref:System.Diagnostics.PerformanceCounterCategory> wystąpienia z obiektem wydajności na serwerze. <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> W przeciwnym razie jest zgłaszany wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu akceptuje <xref:System.Diagnostics.PerformanceCounterCategory> nazwę i nazwę komputera z wiersza polecenia.  Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> on przy użyciu przeciążenia konstruktora odpowiednie dla liczby podanych parametrów, a następnie wyświetla właściwości.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatctor.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatctor.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounterCategory (string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounterCategory(System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounterCategory : string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="new System.Diagnostics.PerformanceCounterCategory categoryName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności lub obiektu wydajności, z którym ma zostać skojarzone to <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy, <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> ustawia właściwość na określoną <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> wartość i ustawia właściwość na komputer lokalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu akceptuje <xref:System.Diagnostics.PerformanceCounterCategory> nazwę i nazwę komputera z wiersza polecenia. Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> on przy użyciu przeciążenia konstruktora, które jest odpowiednie dla liczby podanych parametrów, a następnie wyświetla właściwości.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatctor.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatctor.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> Ma<see langword="null" />wartość.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania informacji o kategorii, takich jak nazwa kategorii. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounterCategory (string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounterCategory(System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounterCategory : string * string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="new System.Diagnostics.PerformanceCounterCategory (categoryName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności lub obiektu wydajności, z którym ma zostać skojarzone to <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienie.</param>
        <param name="machineName">Komputer, na którym istnieje kategoria licznika wydajności i skojarzone z nią liczniki.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy i <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> ustawia właściwości i <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> do określonych wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu akceptuje <xref:System.Diagnostics.PerformanceCounterCategory> nazwę i nazwę komputera z wiersza polecenia. Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> on przy użyciu przeciążenia konstruktora, które jest odpowiednie dla liczby podanych parametrów, a następnie wyświetla właściwości.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatctor.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatctor.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Składnia jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> Ma<see langword="null" />wartość.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania informacji o kategorii, takich jak nazwa komputera i kategorii. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CategoryHelp">
      <MemberSignature Language="C#" Value="public string CategoryHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.CategoryHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CategoryHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CategoryHelp : string" Usage="System.Diagnostics.PerformanceCounterCategory.CategoryHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tekst pomocy kategorii.</summary>
        <value>Opis obiektu wydajności, którego dotyczy ta kategoria.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor>przy użyciu. Zostanie wyświetlony komunikat z prośbą <xref:System.Diagnostics.PerformanceCounterCategory> o nazwę komputera i, a następnie <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> ustawia <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> właściwości i z wprowadzonych wartości. Następnie wyświetla wartości <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A>właściwości, <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A>i <xref:System.Diagnostics.PerformanceCounterCategory.CategoryHelp%2A> <xref:System.Diagnostics.PerformanceCounterCategory> lub wyświetla komunikat o błędzie, jeśli nie można uzyskać do niego dostępu.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatProps.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatprops.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość jest<see langword="null" />. Przed uzyskaniem pomocy dotyczącej kategorii należy ustawić nazwę kategorii.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounterCategory.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę obiektu wydajności, który definiuje tę kategorię.</summary>
        <value>Nazwa kategorii licznika wydajności lub obiektu wydajności, z którym ma zostać skojarzone to <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor>przy użyciu. Zostanie wyświetlony komunikat z prośbą <xref:System.Diagnostics.PerformanceCounterCategory> o nazwę komputera i, a następnie <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> ustawia <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> właściwości i z wprowadzonych wartości. Następnie wyświetla wartości <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A>właściwości, <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A>i <xref:System.Diagnostics.PerformanceCounterCategory.CategoryHelp%2A> <xref:System.Diagnostics.PerformanceCounterCategory> lub wyświetla komunikat o błędzie, jeśli nie można uzyskać do niego dostępu.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatProps.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatprops.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Ma<see langword="null" />wartość.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CategoryType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterCategoryType CategoryType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterCategoryType CategoryType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.CategoryType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CategoryType As PerformanceCounterCategoryType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterCategoryType CategoryType { System::Diagnostics::PerformanceCounterCategoryType get(); };" />
      <MemberSignature Language="F#" Value="member this.CategoryType : System.Diagnostics.PerformanceCounterCategoryType" Usage="System.Diagnostics.PerformanceCounterCategory.CategoryType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategoryType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ kategorii licznika wydajności.</summary>
        <value>Jedna z <see cref="T:System.Diagnostics.PerformanceCounterCategoryType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość wskazuje, <xref:System.Diagnostics.PerformanceCounterCategory> czy obiekt może mieć wiele wystąpień. <xref:System.Diagnostics.PerformanceCounterCategory.CategoryType%2A> Możliwe wartości to <xref:System.Diagnostics.PerformanceCounterCategoryType.MultiInstance>, <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>, lub <xref:System.Diagnostics.PerformanceCounterCategoryType.Unknown>.  
  
 Istnieją dwa typy kategorii liczników wydajności: pojedyncze wystąpienie i wiele wystąpień. Domyślnie kategoria ma pojedyncze wystąpienie, gdy jest tworzona, i zostaje wiele wystąpień, gdy dodawane jest inne wystąpienie. Kategorie są tworzone podczas konfigurowania aplikacji, a wystąpienia są dodawane w czasie wykonywania. W .NET Framework wersje 1,0 i 1,1 nie trzeba wiedzieć, czy kategoria licznika wydajności ma wiele wystąpień lub pojedyncze wystąpienie. W, Wyliczenie służy <xref:System.Diagnostics.PerformanceCounterCategoryType> do wskazywania, czy licznik wydajności może mieć wiele wystąpień. [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CounterExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy określony licznik jest zarejestrowany w określonej kategorii.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CounterExists">
      <MemberSignature Language="C#" Value="public bool CounterExists (string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CounterExists(string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CounterExists (counterName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CounterExists(System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="member this.CounterExists : string -&gt; bool" Usage="performanceCounterCategory.CounterExists counterName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterName">Nazwa licznika wydajności, który ma zostać wyszukany.</param>
        <summary>Określa, czy określony licznik jest zarejestrowany w tej kategorii, który jest wskazywany przez <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> właściwości <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> i.</summary>
        <returns><see langword="true" />Jeśli licznik jest zarejestrowany w kategorii, która jest określona przez <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> właściwości i <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> ; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem tej <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> metody należy ustawić właściwość. W przeciwnym razie jest zgłaszany wyjątek.  
  
 Jeśli <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> właściwość nie została ustawiona, ta metoda używa komputera lokalnego (".").  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Diagnostics.PerformanceCounter> czy istnieje. Nazwa kategorii, Nazwa licznika i nazwa komputera są pobierane z wiersza polecenia, jeśli są podane. Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> Obiekt przy użyciu odpowiednich <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor%2A>. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%28System.String%29> metody, aby określić, czy określony <xref:System.Diagnostics.PerformanceCounter> istnieje, i informuje użytkownika.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatobjexists.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatobjcountexists.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="counterName" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość nie została ustawiona.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CounterExists">
      <MemberSignature Language="C#" Value="public static bool CounterExists (string counterName, string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CounterExists(string counterName, string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CounterExists (counterName As String, categoryName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CounterExists(System::String ^ counterName, System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member CounterExists : string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.CounterExists (counterName, categoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterName">Nazwa licznika wydajności, który ma zostać wyszukany.</param>
        <param name="categoryName">Nazwa kategorii licznika wydajności lub obiektu wydajności, z którym jest skojarzony określony licznik wydajności.</param>
        <summary>Określa, czy określony licznik jest zarejestrowany w określonej kategorii na komputerze lokalnym.</summary>
        <returns><see langword="true" />, jeśli licznik jest zarejestrowany w określonej kategorii na komputerze lokalnym; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Diagnostics.PerformanceCounter> czy istnieje. Nazwa kategorii, Nazwa licznika i nazwa komputera są pobierane z wiersza polecenia, jeśli są podane. Używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%2A> metody, aby określić, czy określona <xref:System.Diagnostics.PerformanceCounter> nazwa istnieje w <xref:System.Diagnostics.PerformanceCounterCategory>. Przeciążenie jest wybierane na podstawie tego, czy podano nazwę komputera.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatcounterexists.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatcountexists.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> Ma<see langword="null" />wartość.  
  
—lub— 
<paramref name="counterName" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Jest pustym ciągiem ("").</exception>
        <exception cref="T:System.InvalidOperationException">Nazwa kategorii nie istnieje.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CounterExists">
      <MemberSignature Language="C#" Value="public static bool CounterExists (string counterName, string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CounterExists(string counterName, string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CounterExists (counterName As String, categoryName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CounterExists(System::String ^ counterName, System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CounterExists : string * string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.CounterExists (counterName, categoryName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterName">Nazwa licznika wydajności, który ma zostać wyszukany.</param>
        <param name="categoryName">Nazwa kategorii licznika wydajności lub obiektu wydajności, z którym jest skojarzony określony licznik wydajności.</param>
        <param name="machineName">Nazwa komputera, na którym istnieje kategoria licznika wydajności i skojarzone z nią liczniki.</param>
        <summary>Określa, czy określony licznik jest zarejestrowany w określonej kategorii na komputerze zdalnym.</summary>
        <returns><see langword="true" />, jeśli licznik jest zarejestrowany w określonej kategorii na określonym komputerze; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Diagnostics.PerformanceCounter> czy istnieje. Nazwa kategorii, Nazwa licznika i nazwa komputera są pobierane z wiersza polecenia, jeśli są podane. Używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%2A> metody, aby określić, czy określona <xref:System.Diagnostics.PerformanceCounter> nazwa istnieje w <xref:System.Diagnostics.PerformanceCounterCategory>. Przeciążenie jest wybierane na podstawie tego, czy podano nazwę komputera.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatcounterexists.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatcountexists.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> Ma<see langword="null" />wartość.  
  
—lub— 
<paramref name="counterName" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nazwa kategorii nie istnieje.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje niestandardową kategorię licznika wydajności oraz co najmniej jeden licznik w systemie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, System.Diagnostics.CounterCreationDataCollection counterData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, class System.Diagnostics.CounterCreationDataCollection counterData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.CounterCreationDataCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, counterData As CounterCreationDataCollection) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::Diagnostics::CounterCreationDataCollection ^ counterData);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * System.Diagnostics.CounterCreationDataCollection -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, counterData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use another overload that uses PerformanceCounterCategoryType instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="categoryHelp" Type="System.String" />
        <Parameter Name="counterData" Type="System.Diagnostics.CounterCreationDataCollection" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii niestandardowego licznika wydajności do tworzenia i rejestrowania w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="counterData">A <see cref="T:System.Diagnostics.CounterCreationDataCollection" /> , który określa liczniki do utworzenia jako część nowej kategorii.</param>
        <summary>Rejestruje kategorię niestandardowego licznika wydajności zawierającej określone liczniki na komputerze lokalnym.</summary>
        <returns>, <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> Który jest skojarzony z nową kategorią niestandardową lub obiektem wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Diagnostics.PerformanceCounterCategory> czy obiekt o nazwie "Orders" (zamówienia) istnieje. W przeciwnym razie tworzy <xref:System.Diagnostics.PerformanceCounterCategory> Obiekt przy <xref:System.Diagnostics.CounterCreationDataCollection> użyciu obiektu, który zawiera dwa liczniki wydajności.  
  
 [!code-cpp[PerfCounter_ccd#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter_ccd/CPP/ccd.cpp#1)]
 [!code-csharp[PerfCounter_ccd#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter_ccd/CS/ccd.cs#1)]
 [!code-vb[PerfCounter_ccd#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter_ccd/VB/ccd.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa licznika określona w <paramref name="counterData" /> kolekcji jest lub jest <see langword="null" /> pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony w <paramref name="counterData" /> kolekcji, już istnieje.  
  
—lub— 
<paramref name="counterName" /> Parametr ma nieprawidłową składnię. Może zawierać znaki ukośnika odwrotnego (\\"") lub mieć długość większą niż 80 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="categoryName" /></exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.  
  
—lub— 
Układ <paramref name="counterData" /> kolekcji jest niepoprawny dla liczników podstawowych. <see langword="AverageCount64" />Licznik typu, ,<see langword="CounterMultiTimer100Ns" /> ,,<see langword="SampleCounter" /> ,, lubmusibyćbezpośredniopojednymzpodstawowychtypówlicznika(<see langword="SampleFraction" /> <see langword="CounterMultiTimer" /> <see langword="AverageTimer32" /> <see langword="CounterMultiTimerInverse" /> <see langword="CounterMultiTimer100NsInverse" /> <see langword="RawFraction" /><see langword="AverageBase" /> ,<see langword="MultiBase" /> ,<see langword="RawBase" />lub )<see langword="SampleBase" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych dotyczących kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, System.Diagnostics.PerformanceCounterCategoryType categoryType, System.Diagnostics.CounterCreationDataCollection counterData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, valuetype System.Diagnostics.PerformanceCounterCategoryType categoryType, class System.Diagnostics.CounterCreationDataCollection counterData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.PerformanceCounterCategoryType,System.Diagnostics.CounterCreationDataCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, categoryType As PerformanceCounterCategoryType, counterData As CounterCreationDataCollection) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::Diagnostics::PerformanceCounterCategoryType categoryType, System::Diagnostics::CounterCreationDataCollection ^ counterData);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * System.Diagnostics.PerformanceCounterCategoryType * System.Diagnostics.CounterCreationDataCollection -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, categoryType, counterData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="categoryHelp" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="categoryType" Type="System.Diagnostics.PerformanceCounterCategoryType" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="counterData" Type="System.Diagnostics.CounterCreationDataCollection" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii niestandardowego licznika wydajności do tworzenia i rejestrowania w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="categoryType">Jedna z <see cref="T:System.Diagnostics.PerformanceCounterCategoryType" /> wartości.</param>
        <param name="counterData">A <see cref="T:System.Diagnostics.CounterCreationDataCollection" /> , który określa liczniki do utworzenia jako część nowej kategorii.</param>
        <summary>Rejestruje kategorię niestandardowego licznika wydajności zawierającej określone liczniki na komputerze lokalnym.</summary>
        <returns>, <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> Który jest skojarzony z nową kategorią niestandardową lub obiektem wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `categoryType` Parametr określa, czy kategoria licznika wydajności jest pojedynczym wystąpieniem, czy z obsługą wiele wystąpień. Domyślnie kategoria ma pojedyncze wystąpienie, gdy jest tworzona, i zostaje wiele wystąpień, gdy dodawane jest inne wystąpienie. Kategorie są tworzone podczas konfigurowania aplikacji, a wystąpienia są dodawane w czasie wykonywania. W .NET Framework wersje 1,0 i 1,1 nie trzeba wiedzieć, czy kategoria licznika wydajności ma wiele wystąpień lub pojedyncze wystąpienie. W, Wyliczenie służy <xref:System.Diagnostics.PerformanceCounterCategoryType> do wskazywania, czy licznik wydajności może mieć wiele wystąpień. [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]  
  
 Kategorie licznika wydajności zainstalowane z [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] użyciem oddzielnej udostępnionej pamięci, z każdą kategorią licznika wydajności mającą własną pamięć.  Można określić rozmiar oddzielnej pamięci współdzielonej przez utworzenie typu DWORD o nazwie FileMappingSize w kluczu rejestru\\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services*\<Category Name >* \Performance. Wartość FileMappingSize jest ustawiona na rozmiar pamięci współdzielonej kategorii. Domyślny rozmiar to 131072 dziesiętny. Jeśli FileMappingSize wartość nie istnieje, `fileMappingSize` zostanie użyta wartość atrybutu dla elementu określonego w pliku Machine. config, co spowoduje dodatkowe obciążenie związane z `performanceCounters` przetwarzaniem plików konfiguracyjnych. Zwiększenie wydajności uruchamiania aplikacji można zrealizować przez ustawienie rozmiaru mapowania plików w rejestrze.  
  
> [!NOTE]
>  Zdecydowanie zaleca się utworzenie nowych kategorii licznika wydajności podczas instalacji aplikacji, a nie w trakcie wykonywania aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych kategorii liczników wydajności przez system operacyjny. Jeśli lista nie została odświeżona, próba użycia kategorii zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> metody. W przykładzie pokazano, jak utworzyć niestandardową, Wieloetapową kategorię licznika wydajności dla liczby zamówień na sekundę.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategoryType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/CS/program.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategoryType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa licznika określona w <paramref name="counterData" /> kolekcji jest lub jest <see langword="null" /> pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony w <paramref name="counterData" /> kolekcji, już istnieje.  
  
—lub— 
 <paramref name="counterName" />ma nieprawidłową składnię. Może zawierać znaki ukośnika odwrotnego (\\"") lub mieć długość większą niż 80 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="counterData" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="categoryType" />wartość znajduje się poza zakresem następujących wartości: <see langword="MultiInstance" />, <see langword="SingleInstance" />, lub <see langword="Unknown" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.  
  
—lub— 
Układ <paramref name="counterData" /> kolekcji jest niepoprawny dla liczników podstawowych. <see langword="AverageCount64" />Licznik typu, ,<see langword="CounterMultiTimer100Ns" /> ,,<see langword="SampleCounter" /> ,,,, lub musi być bezpośrednio po jednym z podstawowych typów licznika ( <see langword="CounterMultiTimer" /> <see langword="AverageTimer32" /> <see langword="CounterMultiTimerInverse" /> <see langword="CounterMultiTimer100NsInverse" /> <see langword="RawFraction" /> <see langword="SampleFraction" /><see langword="AverageBase" /> ,<see langword="MultiBase" /> ,<see langword="RawBase" />lub )<see langword="SampleBase" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych dotyczących kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, string counterName, string counterHelp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, counterName As String, counterHelp As String) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::String ^ counterName, System::String ^ counterHelp);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * string * string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, counterName, counterHelp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use another overload that uses PerformanceCounterCategoryType instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="categoryHelp" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="counterHelp" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii niestandardowego licznika wydajności do tworzenia i rejestrowania w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="counterName">Nazwa nowego licznika typu <see langword="NumberOfItems32" />, który ma zostać utworzony jako część nowej kategorii.</param>
        <param name="counterHelp">Opis licznika, który jest skojarzony z nową kategorią niestandardową.</param>
        <summary>Rejestruje niestandardową kategorię licznika wydajności zawierającą pojedynczy licznik typu <see langword="NumberOfItems32" /> na komputerze lokalnym.</summary>
        <returns>, <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> Który jest skojarzony z nową kategorią systemu lub obiektem wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> i jeden <xref:System.Diagnostics.PerformanceCounter> z tekstem pomocy <xref:System.Diagnostics.PerformanceCounterCategory.Create%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> dla każdej z nich przy użyciu metody.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatcreate.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatcreate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="counterName" />jest <see langword="null" /> lub jest pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony przez <paramref name="counterName" /> już istnieje.  
  
—lub— 
 <paramref name="counterName" />ma nieprawidłową składnię. Może zawierać znaki ukośnika odwrotnego (\\"") lub mieć długość większą niż 80 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="counterHelp" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych dotyczących kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, System.Diagnostics.PerformanceCounterCategoryType categoryType, string counterName, string counterHelp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, valuetype System.Diagnostics.PerformanceCounterCategoryType categoryType, string counterName, string counterHelp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.PerformanceCounterCategoryType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, categoryType As PerformanceCounterCategoryType, counterName As String, counterHelp As String) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::Diagnostics::PerformanceCounterCategoryType categoryType, System::String ^ counterName, System::String ^ counterHelp);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * System.Diagnostics.PerformanceCounterCategoryType * string * string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, categoryType, counterName, counterHelp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="categoryHelp" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="categoryType" Type="System.Diagnostics.PerformanceCounterCategoryType" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="counterName" Type="System.String" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="counterHelp" Type="System.String" Index="4" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii niestandardowego licznika wydajności do tworzenia i rejestrowania w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="categoryType">Jedna z <see cref="T:System.Diagnostics.PerformanceCounterCategoryType" /> wartości określająca, czy kategoria jest <see cref="F:System.Diagnostics.PerformanceCounterCategoryType.MultiInstance" />, <see cref="F:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance" />, czy <see cref="F:System.Diagnostics.PerformanceCounterCategoryType.Unknown" />.</param>
        <param name="counterName">Nazwa nowego licznika, który ma zostać utworzony jako część nowej kategorii.</param>
        <param name="counterHelp">Opis licznika, który jest skojarzony z nową kategorią niestandardową.</param>
        <summary>Rejestruje kategorię niestandardowego licznika wydajności zawierającą pojedynczy licznik typu <see cref="F:System.Diagnostics.PerformanceCounterType.NumberOfItems32" /> na komputerze lokalnym.</summary>
        <returns>, <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> Który jest skojarzony z nową kategorią systemu lub obiektem wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `categoryType` Parametr określa, czy kategoria licznika wydajności jest pojedynczym wystąpieniem, czy z obsługą wiele wystąpień. Domyślnie kategoria ma pojedyncze wystąpienie, gdy jest tworzona, i zostaje wiele wystąpień, gdy dodawane jest inne wystąpienie. Kategorie są tworzone podczas konfigurowania aplikacji, a wystąpienia są dodawane w czasie wykonywania. W .NET Framework wersje 1,0 i 1,1 nie trzeba wiedzieć, czy kategoria licznika wydajności ma wiele wystąpień lub pojedyncze wystąpienie. W, Wyliczenie służy <xref:System.Diagnostics.PerformanceCounterCategoryType> do wskazywania, czy licznik wydajności może mieć wiele wystąpień. [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]  
  
 Kategorie licznika wydajności zainstalowane z [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] użyciem oddzielnej udostępnionej pamięci, z każdą kategorią licznika wydajności mającą własną pamięć. Można określić rozmiar oddzielnej pamięci współdzielonej przez utworzenie typu DWORD o nazwie FileMappingSize w kluczu rejestru\\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services*\<Category Name >* \Performance. Wartość FileMappingSize jest ustawiona na rozmiar pamięci współdzielonej kategorii. Domyślny rozmiar to 131072 dziesiętny. Jeśli FileMappingSize wartość nie istnieje, `fileMappingSize` zostanie użyta wartość atrybutu dla elementu określonego w pliku Machine. config, co spowoduje dodatkowe obciążenie związane z `performanceCounters` przetwarzaniem plików konfiguracyjnych. Zwiększenie wydajności uruchamiania aplikacji można zrealizować przez ustawienie rozmiaru mapowania plików w rejestrze.  
  
> [!NOTE]
>  Zdecydowanie zaleca się utworzenie nowych kategorii licznika wydajności podczas instalacji aplikacji, a nie w trakcie wykonywania aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych kategorii liczników wydajności przez system operacyjny. Jeśli lista nie została odświeżona, próba użycia kategorii zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> metody. W przykładzie przedstawiono sposób tworzenia niestandardowej kategorii licznika wydajności pojedynczego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategoryType#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/CS/program.cs#3)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategoryType#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/VB/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="counterName" />jest <see langword="null" /> lub jest pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony przez <paramref name="counterName" /> już istnieje.  
  
—lub— 
 <paramref name="counterName" />ma nieprawidłową składnię. Może zawierać znaki ukośnika odwrotnego (\\"") lub mieć długość większą niż 80 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="counterHelp" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych dotyczących kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (categoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.PerformanceCounterCategory.Delete categoryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii niestandardowego licznika wydajności do usunięcia.</param>
        <summary>Usuwa kategorię i skojarzone z nią liczniki z komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z systemu można usuwać tylko niestandardowe kategorie liczników wydajności. Nie można usunąć licznika z kategorii. Aby to zrobić, Usuń kategorię i Utwórz ponownie kategorię z licznikami, które chcesz zachować. Aby uniknąć wyjątku, upewnij się, że Kategoria istnieje przed podjęciem próby jego usunięcia.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Diagnostics.PerformanceCounterCategory.Delete%2A> metody do <xref:System.Diagnostics.PerformanceCounterCategory> usuwania i <xref:System.Diagnostics.PerformanceCounter> obiektów, które zawiera.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatDelete.cs#6)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatdelete.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="categoryName" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Parametr ma nieprawidłową składnię. Może zawierać znaki ukośnika odwrotnego (\\"") lub mieć długość większą niż 80 znaków.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można usunąć kategorii, ponieważ nie jest ona kategorią niestandardową.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.CounterCreationDataCollection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy kategoria jest zarejestrowana w systemie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (categoryName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.Exists categoryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności do wyszukania.</param>
        <summary>Określa, czy kategoria jest zarejestrowana na komputerze lokalnym.</summary>
        <returns><see langword="true" />Jeśli kategoria jest zarejestrowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterCategory.Exists%2A> Użycie metody może spowodować zauważalną spadek wydajności, podczas gdy wszystkie liczniki wydajności na komputerze są sprawdzane pod kątem dostępności. Jeśli zapisujesz tylko na liczniku wydajności, możesz uniknąć wyszukiwania globalnego liczników wydajności przez utworzenie licznika wydajności, gdy aplikacja jest zainstalowana i przy założeniu, że Kategoria istnieje podczas uzyskiwania dostępu do licznika. Nie ma możliwości uniknięcia przeszukiwania licznika wydajności podczas odczytywania z liczników wydajności.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Diagnostics.PerformanceCounterCategory> czy obiekt o nazwie "Orders" (zamówienia) istnieje. W przeciwnym razie tworzy <xref:System.Diagnostics.PerformanceCounterCategory> Obiekt przy <xref:System.Diagnostics.CounterCreationDataCollection> użyciu obiektu, który zawiera dwa liczniki wydajności.  
  
 [!code-cpp[PerfCounter_ccd#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter_ccd/CPP/ccd.cpp#1)]
 [!code-csharp[PerfCounter_ccd#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter_ccd/CS/ccd.cs#1)]
 [!code-vb[PerfCounter_ccd#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter_ccd/VB/ccd.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="categoryName" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (categoryName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.Exists (categoryName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności do wyszukania.</param>
        <param name="machineName">Nazwa komputera do sprawdzenia dla kategorii.</param>
        <summary>Określa, czy kategoria jest zarejestrowana na określonym komputerze.</summary>
        <returns><see langword="true" />Jeśli kategoria jest zarejestrowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterCategory.Exists%2A> Użycie metody może spowodować zauważalną spadek wydajności, podczas gdy wszystkie liczniki wydajności na komputerze są sprawdzane pod kątem dostępności. Jeśli zapisujesz tylko na liczniku wydajności, możesz uniknąć wyszukiwania globalnego liczników wydajności przez utworzenie licznika wydajności, gdy aplikacja jest zainstalowana i przy założeniu, że Kategoria istnieje podczas uzyskiwania dostępu do licznika. Nie ma możliwości uniknięcia przeszukiwania licznika wydajności podczas odczytywania z liczników wydajności.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład określa, czy <xref:System.Diagnostics.PerformanceCounterCategory> obiekt o nazwie `Orders` istnieje. Jeśli nie istnieje, przykład tworzy <xref:System.Diagnostics.PerformanceCounterCategory> Obiekt przy <xref:System.Diagnostics.CounterCreationDataCollection> użyciu obiektu, który zawiera dwa liczniki wydajności.  
  
 [!code-cpp[PerfCounter_ccd#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter_ccd/CPP/ccd.cpp#1)]
 [!code-csharp[PerfCounter_ccd#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter_ccd/CS/ccd.cs#1)]
 [!code-vb[PerfCounter_ccd#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter_ccd/VB/ccd.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="categoryName" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.IO.IOException">Nie można odnaleźć ścieżki sieciowej.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCategories">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera listę kategorii licznika wydajności, które są zarejestrowane na komputerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCategories">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory[] GetCategories ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory[] GetCategories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCategories" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCategories () As PerformanceCounterCategory()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::PerformanceCounterCategory ^&gt; ^ GetCategories();" />
      <MemberSignature Language="F#" Value="static member GetCategories : unit -&gt; System.Diagnostics.PerformanceCounterCategory[]" Usage="System.Diagnostics.PerformanceCounterCategory.GetCategories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę kategorii licznika wydajności, które są zarejestrowane na komputerze lokalnym.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> obiektów wskazująca kategorie, które są zarejestrowane na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> aby zwrócić <xref:System.Diagnostics.PerformanceCounterCategory> tablicę obiektów z komputera lokalnego lub określonego komputera. Konwertuje <xref:System.Diagnostics.PerformanceCounterCategory> tablicę na tablicę nazw kategorii, które są sortowane i wyświetlane dla użytkownika. Przeciążenie <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> jest wybierane na podstawie tego, czy określono nazwę komputera.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountergetcat.cpp#2)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountergetcat.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcat.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="GetCategories">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory[] GetCategories (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory[] GetCategories(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCategories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCategories (machineName As String) As PerformanceCounterCategory()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::PerformanceCounterCategory ^&gt; ^ GetCategories(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetCategories : string -&gt; System.Diagnostics.PerformanceCounterCategory[]" Usage="System.Diagnostics.PerformanceCounterCategory.GetCategories machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, na którym ma zostać przeszukany.</param>
        <summary>Pobiera listę kategorii licznika wydajności, które są zarejestrowane na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> obiektów wskazująca kategorie, które są zarejestrowane na określonym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pobrać kategorie na komputerze lokalnym, użyj innego przeciążenia lub Przekaż "." jako `machineName` parametr.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> aby zwrócić <xref:System.Diagnostics.PerformanceCounterCategory> tablicę obiektów z komputera lokalnego lub określonego komputera. Konwertuje <xref:System.Diagnostics.PerformanceCounterCategory> tablicę na tablicę nazw kategorii, które są sortowane i wyświetlane dla użytkownika. Przeciążenie <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> jest wybierane na podstawie tego, czy określono nazwę komputera.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountergetcat.cpp#2)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountergetcat.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcat.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCounters">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera listę liczników z tej kategorii licznika wydajności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCounters">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounter[] GetCounters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.PerformanceCounter[] GetCounters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCounters" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCounters () As PerformanceCounter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Diagnostics::PerformanceCounter ^&gt; ^ GetCounters();" />
      <MemberSignature Language="F#" Value="member this.GetCounters : unit -&gt; System.Diagnostics.PerformanceCounter[]" Usage="performanceCounterCategory.GetCounters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę liczników w kategorii licznika wydajności, która zawiera dokładnie jedno wystąpienie.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounter" /> obiektów wskazująca liczniki, które są skojarzone z tą kategorią licznika wydajności z jednym wystąpieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o wystąpieniach obiektów wydajności, <xref:System.Diagnostics.PerformanceCounter> Zobacz Omówienie klasy.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listę <xref:System.Diagnostics.PerformanceCounter> obiektów <xref:System.Diagnostics.PerformanceCounterCategory>w. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> za pomocą odpowiedniego konstruktora, w zależności od tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> metody do zwrócenia <xref:System.Diagnostics.PerformanceCounter> tablicy obiektów, wybierając Przeciążenie w zależności od tego <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> , czy nazwa wystąpienia została określona.  
  
 To <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters> Przeciążenie nie powiedzie się, chyba że jest używane z kategorią o pojedynczym wystąpieniu.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountercatgetcount.cpp#4)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountercatgetcount.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcount.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kategoria nie jest pojedynczym wystąpieniem.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria nie ma skojarzonego wystąpienia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="GetCounters">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounter[] GetCounters (string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.PerformanceCounter[] GetCounters(string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCounters(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCounters (instanceName As String) As PerformanceCounter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Diagnostics::PerformanceCounter ^&gt; ^ GetCounters(System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="member this.GetCounters : string -&gt; System.Diagnostics.PerformanceCounter[]" Usage="performanceCounterCategory.GetCounters instanceName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounter[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności, dla którego ma zostać pobrana lista skojarzonych liczników.</param>
        <summary>Pobiera listę liczników w kategorii licznika wydajności, która zawiera co najmniej jedno wystąpienie.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounter" /> obiektów wskazująca liczniki, które są skojarzone z określonym wystąpieniem obiektu tej kategorii licznika wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby przedstawić kategorię o pojedynczym wystąpieniu, należy przekazać pusty ciąg ("") dla `instanceName` parametru.  
  
 Aby uzyskać więcej informacji o wystąpieniach obiektów wydajności, <xref:System.Diagnostics.PerformanceCounter> Zobacz Omówienie klasy.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listę <xref:System.Diagnostics.PerformanceCounter> obiektów <xref:System.Diagnostics.PerformanceCounterCategory>w. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> za pomocą odpowiedniego konstruktora, w zależności od tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> metody do zwrócenia <xref:System.Diagnostics.PerformanceCounter> tablicy obiektów, wybierając Przeciążenie w zależności od tego <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> , czy nazwa wystąpienia została określona.  
  
 To <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%28System.String%29> Przeciążenie nie powiedzie się, chyba że jest używane z kategorią zawierającą wystąpienia.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountercatgetcount.cpp#4)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountercatgetcount.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcount.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="instanceName" /></exception>
        <exception cref="T:System.InvalidOperationException">Właściwość dla tego <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienia nie została ustawiona. <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />  
  
—lub— 
Kategoria nie zawiera wystąpienia określonego przez <paramref name="instanceName" /> parametr.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="GetInstanceNames">
      <MemberSignature Language="C#" Value="public string[] GetInstanceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetInstanceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetInstanceNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInstanceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetInstanceNames();" />
      <MemberSignature Language="F#" Value="member this.GetInstanceNames : unit -&gt; string[]" Usage="performanceCounterCategory.GetInstanceNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę wystąpień obiektów wydajności skojarzonych z tą kategorią.</summary>
        <returns>Tablica ciągów reprezentujących nazwy wystąpień obiektów wydajności, które są skojarzone z tą kategorią lub, jeśli kategoria zawiera tylko jedno wystąpienie obiektu wydajności, tablica o pojedynczej pozycji, która zawiera pusty ciąg ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera listę <xref:System.Diagnostics.PerformanceCounter> obiektów <xref:System.Diagnostics.PerformanceCounterCategory>w. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> obiekt, przy użyciu odpowiedniego konstruktora w zależności od tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.GetInstanceNames%2A> do zwracania nazw wystąpień jako <xref:System.String>tablicy, która sortuje i wyświetla.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountercatgetinst.cpp#6)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountercatgetinst.cs#6)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetinst.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość jest<see langword="null" />. Właściwość mogła nie zostać ustawiona.  
  
—lub— 
Kategoria nie ma skojarzonego wystąpienia.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InstanceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy kategoria zawiera określone wystąpienie obiektu wydajności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InstanceExists">
      <MemberSignature Language="C#" Value="public bool InstanceExists (string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InstanceExists(string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InstanceExists (instanceName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InstanceExists(System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="member this.InstanceExists : string -&gt; bool" Usage="performanceCounterCategory.InstanceExists instanceName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności w tej kategorii licznika wydajności do wyszukania.</param>
        <summary>Określa, czy określone wystąpienie obiektu wydajności istnieje w kategorii, która jest identyfikowana przez <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość tego obiektu.</summary>
        <returns><see langword="true" />Jeśli kategoria zawiera określone wystąpienie obiektu wydajności; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> nie `static`jest. Wymaga to utworzenia <xref:System.Diagnostics.PerformanceCounterCategory> obiektu i <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> ustawienia właściwości.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, <xref:System.Diagnostics.PerformanceCounter> <xref:System.Diagnostics.PerformanceCounterCategory>czy wystąpienie istnieje w. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> obiekt, przy użyciu odpowiedniego konstruktora w zależności od tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%28System.String%29> do określenia, czy określone wystąpienie istnieje, a następnie informuje użytkownika. Jeśli nazwa wystąpienia nie zostanie określona, w przykładzie zostanie użyta nazwa domyślna jednego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcounterobjinstexists.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatobjinstexists.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość jest<see langword="null" />. Właściwość mogła nie zostać ustawiona.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="instanceName" /></exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="InstanceExists">
      <MemberSignature Language="C#" Value="public static bool InstanceExists (string instanceName, string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool InstanceExists(string instanceName, string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InstanceExists (instanceName As String, categoryName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool InstanceExists(System::String ^ instanceName, System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member InstanceExists : string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.InstanceExists (instanceName, categoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności, które ma zostać wyszukane.</param>
        <param name="categoryName">Kategoria licznika wydajności do wyszukania.</param>
        <summary>Określa, czy określona Kategoria na komputerze lokalnym zawiera określone wystąpienie obiektu wydajności.</summary>
        <returns><see langword="true" />Jeśli kategoria zawiera określone wystąpienie obiektu wydajności; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można określić, czy wystąpienie obiektu wydajności istnieje na komputerze, bez określania określonej kategorii, która ma być wyszukiwana.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> , aby określić, czy dany <xref:System.Diagnostics.PerformanceCounter> wystąpienie istnieje w. <xref:System.Diagnostics.PerformanceCounterCategory> Przeciążenie jest wybierane na podstawie tego, czy określono nazwę komputera. Jeśli nazwa wystąpienia nie zostanie określona, w przykładzie zostanie użyta nazwa domyślna jednego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatinstexists.cs#10)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatinstexists.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="instanceName" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="categoryName" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="InstanceExists">
      <MemberSignature Language="C#" Value="public static bool InstanceExists (string instanceName, string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool InstanceExists(string instanceName, string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InstanceExists (instanceName As String, categoryName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool InstanceExists(System::String ^ instanceName, System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member InstanceExists : string * string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.InstanceExists (instanceName, categoryName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności, które ma zostać wyszukane.</param>
        <param name="categoryName">Kategoria licznika wydajności do wyszukania.</param>
        <param name="machineName">Nazwa komputera, na którym ma zostać wyszukana para wystąpień kategorii.</param>
        <summary>Określa, czy określona Kategoria na określonym komputerze zawiera określone wystąpienie obiektu wydajności.</summary>
        <returns><see langword="true" />Jeśli kategoria zawiera określone wystąpienie obiektu wydajności; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można określić, czy wystąpienie obiektu wydajności istnieje na komputerze, bez określania określonej kategorii, która ma być wyszukiwana.  
  
 Aby określić komputer lokalny, można użyć ".".  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> , aby określić, czy dany <xref:System.Diagnostics.PerformanceCounter> wystąpienie istnieje w. <xref:System.Diagnostics.PerformanceCounterCategory> Przeciążenie jest wybierane na podstawie tego, czy określono nazwę komputera. Jeśli nazwa wystąpienia nie zostanie określona, w przykładzie zostanie użyta nazwa domyślna jednego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatinstexists.cs#10)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatinstexists.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="instanceName" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="categoryName" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="categoryName" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounterCategory.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym istnieje ta kategoria.</summary>
        <value>Nazwa komputera, na którym istnieje kategoria licznika wydajności i skojarzone z nią liczniki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor> z konstruktorem. Zostanie wyświetlony komunikat z prośbą <xref:System.Diagnostics.PerformanceCounterCategory> o nazwę i nazwa komputera, a następnie <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> ustawia <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> właściwości i z wprowadzonych wartości. Następnie wyświetla wartości <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A>właściwości, <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A>i <xref:System.Diagnostics.PerformanceCounterCategory.CategoryHelp%2A> <xref:System.Diagnostics.PerformanceCounterCategory> lub wyświetla komunikat o błędzie, jeśli nie można uzyskać do niego dostępu.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatProps.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatprops.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> Składnia jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania kategorii licznika wydajności. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="ReadCategory">
      <MemberSignature Language="C#" Value="public System.Diagnostics.InstanceDataCollectionCollection ReadCategory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.InstanceDataCollectionCollection ReadCategory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.ReadCategory" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadCategory () As InstanceDataCollectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::InstanceDataCollectionCollection ^ ReadCategory();" />
      <MemberSignature Language="F#" Value="member this.ReadCategory : unit -&gt; System.Diagnostics.InstanceDataCollectionCollection" Usage="performanceCounterCategory.ReadCategory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.InstanceDataCollectionCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie dane wystąpienia licznika i wydajności, które są skojarzone z tą kategorią licznika wydajności.</summary>
        <returns><see cref="T:System.Diagnostics.InstanceDataCollectionCollection" /> Zawierający dane licznika i wystąpienia obiektu wydajności dla kategorii.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem <xref:System.Diagnostics.PerformanceCounterCategory.ReadCategory%2A>należy <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> ustawić właściwość.  
  
 Jednoczesne odczytywanie całej kategorii może być tak wydajne jak odczytywanie pojedynczego licznika ze względu na sposób, w jaki system udostępnia dane.  
  
> [!NOTE]
>  Aby odczytać liczniki wydajności w systemie Windows Vista lub nowszym, Windows XP Professional x64 Edition lub Windows Server 2003, trzeba być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administracyjne.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień dostępu do liczników wydajności w systemie Windows Vista i nowszych, należy dodać siebie do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> dla określonej <xref:System.Diagnostics.PerformanceCounterCategory> nazwy. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.ReadCategory%2A> do zwrócenia elementu <xref:System.Diagnostics.InstanceDataCollectionCollection> zawierającego dane wystąpienia dla <xref:System.Diagnostics.PerformanceCounter> wszystkich wystąpień obiektów w ramach <xref:System.Diagnostics.PerformanceCounterCategory>.  
  
 [!code-csharp[System.Diagnostics.InstanceData.CopyTo#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.InstanceData.CopyTo/CS/instdatacopyto.cs#6)]
 [!code-vb[System.Diagnostics.InstanceData.CopyTo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.InstanceData.CopyTo/VB/instdatacopyto.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość jest<see langword="null" />. Właściwość mogła nie zostać ustawiona.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod wykonywany bez uprawnień administracyjnych próbował odczytać licznik wydajności.</exception>
        <altmember cref="T:System.Diagnostics.InstanceDataCollectionCollection" />
        <altmember cref="T:System.Diagnostics.InstanceDataCollection" />
        <altmember cref="T:System.Diagnostics.InstanceData" />
      </Docs>
    </Member>
  </Members>
</Type>

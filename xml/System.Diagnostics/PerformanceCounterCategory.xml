<Type Name="PerformanceCounterCategory" FullName="System.Diagnostics.PerformanceCounterCategory">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3eb16e589584c77f60777b3776c63ca5b196533d" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49147634" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PerformanceCounterCategory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounterCategory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounterCategory" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounterCategory" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounterCategory sealed" />
  <TypeSignature Language="F#" Value="type PerformanceCounterCategory = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje obiekt wydajności, który definiuje kategorii liczników wydajności.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Tworzenie lub usuwanie licznika wydajności, który wymaga synchronizacji podstawowy kod przy użyciu nazwanego obiektu mutex. W przypadku aplikacji o wysokim poziomie uprawnień blokady o nazwie obiektu mutex, próbuje utworzyć lub usunąć licznika wydajności, który powoduje, że aplikacja przestanie odpowiadać, dopóki blokada jest zwalniana. Aby uniknąć tego problemu, nigdy nie przyznać <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnienia do niezaufanego kodu. Ponadto <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnień potencjalnie umożliwia innych uprawnień, aby pominąć i może być przyznany wyłącznie do wysoce zaufanym kodem.  
  
 <xref:System.Diagnostics.PerformanceCounterCategory> Wystąpienia <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> właściwości jest wyświetlana w polu Obiekt wydajności, okno dialogowe Dodawanie licznika aplikacji przeglądarki wydajności.  
  
 <xref:System.Diagnostics.PerformanceCounterCategory> Klasa udostępnia kilka metod do interakcji z liczników i kategorii na komputerze. <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> Metody umożliwiają definiowanie niestandardowych kategorii. <xref:System.Diagnostics.PerformanceCounterCategory.Delete%2A> Metoda zapewnia sposób usuwania kategorii z komputera. <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> Metoda umożliwia wyświetlenie listy kategorii, natomiast <xref:System.Diagnostics.PerformanceCounterCategory.ReadCategory%2A> pobiera wszystkie dane licznik i wystąpienie skojarzonych z jednej kategorii.  
  
 Licznik wydajności publikuje dane wydajności dotyczące aplikacji. Kategorie obejmują składniki fizyczne (takie jak procesory, dyski i pamięci) i obiektów systemowych (takich jak procesy i wątki). Liczniki systemu, które są powiązane z tego samego obiektu wydajności są zgrupowane w kategorii, która wskazuje skoncentruje wspólnej. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter> klasy, należy najpierw wskazują kategorii za pomocą którego należy ten składnik będzie interaktywnie korzystać, a następnie wybierz licznik z tej kategorii.  
  
 Na przykład jedną kategorię licznika Windows jest kategoria pamięci. Liczniki systemu w ramach tej kategorii śledzić dane pamięci, takie jak liczba dostępnych bajtów i liczby bajtów pamięci podręcznej. Jeśli chcesz pracować z bajtów pamięci podręcznej w aplikacji, należy utworzyć wystąpienie <xref:System.Diagnostics.PerformanceCounter> składnik, połącz go z kategorii pamięci, a następnie wybierz odpowiedniego licznika (w tym przypadku buforowanych bajtów) z tej kategorii.  
  
 Mimo że system udostępnia wiele więcej kategorii licznika, kategorie, które będą prawdopodobnie interakcji z najczęściej są kategorie pamięci podręcznej, pamięci, obiekty, dysk fizyczny, proces, procesora, Server, systemu i wątku.  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> Method in Class metoda <xref:System.Diagnostics.PerformanceCounter> klasy zwolni licznika i, jeśli wybrano opcję ponownego użycia dla tej kategorii, zostanie ono użyte ponownie wystąpienia licznika. Może to spowodować wyścigu, jeśli inny proces lub nawet inny część kodu jest próby zapisu wystąpienia licznika.  
  
> [!NOTE]
>  Zdecydowanie zaleca się, że nowe kategorie liczników wydajności utworzona podczas instalacji aplikacji, a nie w czasie wykonywania aplikacji. Dzięki temu czas na odświeżenie listy kategorii licznika wydajności zarejestrowanych systemu operacyjnego. Lista nie została odświeżona, można użyć kategorii zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Zainstalowane z kategorii licznika wydajności [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] oddzielne pamięci współużytkowanej, za pomocą każdej kategorii licznika wydajności własnej pamięci posiadające. Można określić rozmiar pamięci współużytkowanej oddzielne, tworząc DWORD o nazwie FileMappingSize w kluczu rejestru HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<nazwa kategorii >* \ Wydajność. Ustawiono wartość FileMappingSize rozmiar pamięci współużytkowanej kategorii. Domyślny rozmiar to 131072 dziesiętną. Jeśli nie jest obecny, wartość FileMappingSize `fileMappingSize` wartość dla atrybutu `performanceCounters` określone w pliku Machine.config jest używana, powoduje dodatkowe obciążenie przetwarzania pliku konfiguracji. Zwiększenie wydajności podczas uruchamiania aplikacji możesz uzyskać przez ustawienie rozmiaru mapowania pliku w rejestrze. Aby uzyskać więcej informacji na temat rozmiaru mapowania pliku zobacz [ &lt;liczniki wydajności&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md).  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Diagnostics.PerformanceCounter> i jego <xref:System.Diagnostics.PerformanceCounterCategory> istnieje na komputerze lokalnym lub na innym komputerze. Jeśli te obiekty nie istnieją na komputerze lokalnym, ten przykład opcjonalnie tworzy je. Używa ona <xref:System.Diagnostics.PerformanceCounterCategory.Exists%2A> metodę pozwala ustalić czy <xref:System.Diagnostics.PerformanceCounterCategory> istnieje.  Jeśli <xref:System.Diagnostics.PerformanceCounterCategory> nie istnieje i nazwa licznika nie zostanie określona, lub jeśli komputer jest komputera zdalnego, przykładu zamyka.  
  
 Jeśli <xref:System.Diagnostics.PerformanceCounter> nazwa zostanie podana, w przykładzie użyto <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%2A> metody i wyświetla wynik do użytkownika. Jeśli <xref:System.Diagnostics.PerformanceCounter> nie istnieje, użytkownik może usunąć i ponownie utwórz <xref:System.Diagnostics.PerformanceCounterCategory> przy użyciu nowego <xref:System.Diagnostics.PerformanceCounter>. Jeśli użytkownik ma tak, kategoria jest usuwana za pomocą <xref:System.Diagnostics.PerformanceCounterCategory.Delete%2A> metody.  
  
 Jeśli jest to wymagane, przykład utworzy teraz nową <xref:System.Diagnostics.PerformanceCounterCategory> i <xref:System.Diagnostics.PerformanceCounter> przy użyciu <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> metody. Jeśli określono nazwę wystąpienia, w przykładzie użyto <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> metody i wyświetla wynik.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.Class/CS/perfcountercatcreateexist.cs#27)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.Class/VB/perfcountercatcreateexist.vb#27)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounter" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounterCategory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounterCategory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy pozostawia <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> właściwość jest pusta i zestawy <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> właściwości na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> Musi być ustawiona właściwość przed skojarzeniem to <xref:System.Diagnostics.PerformanceCounterCategory> wystąpienia obiektu wydajności na serwerze. W przeciwnym razie jest zgłaszany wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu akceptuje <xref:System.Diagnostics.PerformanceCounterCategory> nazwę i nazwę komputera, z poziomu wiersza polecenia.  Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> następnie za pomocą przeciążenia konstruktora odpowiedniego dla liczby dostarczonych parametrów zostaną wyświetlone jej właściwości.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatctor.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatctor.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounterCategory (string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounterCategory(System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounterCategory : string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="new System.Diagnostics.PerformanceCounterCategory categoryName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności, lub obiekt wydajności, którą chcesz skojarzyć ten <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy zestawy <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> na określoną wartość i ustawia <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> właściwości na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu akceptuje <xref:System.Diagnostics.PerformanceCounterCategory> nazwę i nazwę komputera, z poziomu wiersza polecenia. Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> następnie za pomocą przeciążenia konstruktora, który jest odpowiedni dla liczby dostarczonych parametrów zostaną wyświetlone jej właściwości.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatctor.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatctor.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie informacji o kategorii, takich jak nazwa kategorii. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounterCategory (string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounterCategory(System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounterCategory : string * string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="new System.Diagnostics.PerformanceCounterCategory (categoryName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności, lub obiekt wydajności, którą chcesz skojarzyć ten <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienia.</param>
        <param name="machineName">Komputer, na którym istnieją kategorii licznika wydajności i jego skojarzone liczniki.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> klasy i zestawy <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> i <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> właściwości do określonej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu akceptuje <xref:System.Diagnostics.PerformanceCounterCategory> nazwę i nazwę komputera, z poziomu wiersza polecenia. Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> następnie za pomocą przeciążenia konstruktora, który jest odpowiedni dla liczby dostarczonych parametrów zostaną wyświetlone jej właściwości.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatctor.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatctor.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Składnia jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie informacji o kategorii, takie jak nazwa komputera i kategorii. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CategoryHelp">
      <MemberSignature Language="C#" Value="public string CategoryHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.CategoryHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CategoryHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CategoryHelp : string" Usage="System.Diagnostics.PerformanceCounterCategory.CategoryHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tekst pomocy dla tej kategorii.</summary>
        <value>Opis obiektu wydajności, który mierzy tej kategorii.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> z <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor>. Jednak monituje użytkownika o <xref:System.Diagnostics.PerformanceCounterCategory> i nazwy komputera, następnie ustawia <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> z wprowadzone wartości właściwości. Następnie wyświetla wartości <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A>, i <xref:System.Diagnostics.PerformanceCounterCategory.CategoryHelp%2A> właściwości lub jest on wyświetla komunikat o błędzie, jeśli <xref:System.Diagnostics.PerformanceCounterCategory> nie są dostępne.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatProps.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatprops.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość <see langword="null" />. Przed uzyskaniem pomocy na temat kategorii, należy ustawić nazwę kategorii.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounterCategory.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę obiektu wydajności, który definiuje tę kategorię.</summary>
        <value>Nazwa kategorii licznika wydajności, lub obiekt wydajności, którą chcesz skojarzyć ten <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> z <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor>. Jednak monituje użytkownika o <xref:System.Diagnostics.PerformanceCounterCategory> i nazwy komputera, następnie ustawia <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> z wprowadzone wartości właściwości. Następnie wyświetla wartości <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A>, i <xref:System.Diagnostics.PerformanceCounterCategory.CategoryHelp%2A> właściwości lub jest on wyświetla komunikat o błędzie, jeśli <xref:System.Diagnostics.PerformanceCounterCategory> nie są dostępne.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatProps.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatprops.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CategoryType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterCategoryType CategoryType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterCategoryType CategoryType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.CategoryType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CategoryType As PerformanceCounterCategoryType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterCategoryType CategoryType { System::Diagnostics::PerformanceCounterCategoryType get(); };" />
      <MemberSignature Language="F#" Value="member this.CategoryType : System.Diagnostics.PerformanceCounterCategoryType" Usage="System.Diagnostics.PerformanceCounterCategory.CategoryType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategoryType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ kategorii licznika wydajności.</summary>
        <value>Jedną z <see cref="T:System.Diagnostics.PerformanceCounterCategoryType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterCategory.CategoryType%2A> Właściwość wskazuje, czy <xref:System.Diagnostics.PerformanceCounterCategory> obiekt może mieć wielu wystąpień. Możliwe wartości to <xref:System.Diagnostics.PerformanceCounterCategoryType.MultiInstance>, <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>, lub <xref:System.Diagnostics.PerformanceCounterCategoryType.Unknown>.  
  
 Istnieją dwa typy kategorii licznika wydajności: jednym wystąpieniu i obejmujące wiele wystąpień. Domyślnie kategoria jest jednym wystąpieniu, gdy jest tworzony i staje się wiele wystąpień, po dodaniu innego wystąpienia. Kategorie są tworzone, gdy aplikacja jest skonfigurowana i dodaniu wystąpień w czasie wykonywania. W wersjach programu .NET Framework 1.0 i 1.1 nie jest konieczne wiedzieć, czy kategorii licznika wydajności jest wiele wystąpień lub jednego wystąpienia. W [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], <xref:System.Diagnostics.PerformanceCounterCategoryType> wyliczenia jest używany do wskazania, czy licznik wydajności może mieć wiele wystąpień.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CounterExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy określony licznik jest zarejestrowany do określonej kategorii.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CounterExists">
      <MemberSignature Language="C#" Value="public bool CounterExists (string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CounterExists(string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CounterExists (counterName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CounterExists(System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="member this.CounterExists : string -&gt; bool" Usage="performanceCounterCategory.CounterExists counterName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterName">Nazwa licznika wydajności do wyszukania.</param>
        <summary>Określa, czy określonego licznika jest zarejestrowany do tej kategorii, która jest wskazywany przez <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> i <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość licznika jest zarejestrowany do kategorii, który jest określony przez <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> i <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> właściwości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> właściwości przed wywołaniem tej metody. W przeciwnym razie jest zgłaszany wyjątek.  
  
 Jeśli nie ustawisz <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> właściwości, ta metoda korzysta z komputera lokalnego (".").  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Diagnostics.PerformanceCounter> istnieje. Otrzymuje nazwę kategorii, nazwa licznika i nazwę komputera z wiersza polecenia, jeśli podana jest. Tworzy <xref:System.Diagnostics.PerformanceCounterCategory> przy użyciu odpowiedniego <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor%2A>. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%28System.String%29> metodę, aby określić, czy określony <xref:System.Diagnostics.PerformanceCounter> istnieje i informuje użytkownika.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatobjexists.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatobjcountexists.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="counterName" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Nie ustawiono właściwości.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CounterExists">
      <MemberSignature Language="C#" Value="public static bool CounterExists (string counterName, string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CounterExists(string counterName, string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CounterExists (counterName As String, categoryName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CounterExists(System::String ^ counterName, System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member CounterExists : string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.CounterExists (counterName, categoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterName">Nazwa licznika wydajności do wyszukania.</param>
        <param name="categoryName">Nazwa kategorii licznika wydajności lub obiekt wydajności, z którym jest skojarzona określony licznik wydajności.</param>
        <summary>Określa, czy określonego licznika jest zarejestrowany do określonej kategorii na komputerze lokalnym.</summary>
        <returns>
          <see langword="true" />, jeśli licznik jest zarejestrowany w określonej kategorii na komputerze lokalnym. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Diagnostics.PerformanceCounter> istnieje. Otrzymuje nazwę kategorii, nazwa licznika i nazwę komputera z wiersza polecenia, jeśli podana jest. Używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%2A> metodę, aby określić, czy określony <xref:System.Diagnostics.PerformanceCounter> istnieje w <xref:System.Diagnostics.PerformanceCounterCategory>. Przeciążenie jest zaznaczone, oparte na tego, czy podano nazwę komputera.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatcounterexists.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatcountexists.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="counterName" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Jest pustym ciągiem ("").</exception>
        <exception cref="T:System.InvalidOperationException">Nazwa kategorii nie istnieje.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="CounterExists">
      <MemberSignature Language="C#" Value="public static bool CounterExists (string counterName, string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CounterExists(string counterName, string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CounterExists (counterName As String, categoryName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CounterExists(System::String ^ counterName, System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CounterExists : string * string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.CounterExists (counterName, categoryName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterName">Nazwa licznika wydajności do wyszukania.</param>
        <param name="categoryName">Nazwa kategorii licznika wydajności lub obiekt wydajności, z którym jest skojarzona określony licznik wydajności.</param>
        <param name="machineName">Nazwa komputera, na którym istnieją kategorii licznika wydajności i jego skojarzone liczniki.</param>
        <summary>Określa, czy określonego licznika jest zarejestrowany do określonej kategorii na komputerze zdalnym.</summary>
        <returns>
          <see langword="true" />, jeśli licznik jest zarejestrowany w określonej kategorii na określonym komputerze. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Diagnostics.PerformanceCounter> istnieje. Otrzymuje nazwę kategorii, nazwa licznika i nazwę komputera z wiersza polecenia, jeśli podana jest. Używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.CounterExists%2A> metodę, aby określić, czy określony <xref:System.Diagnostics.PerformanceCounter> istnieje w <xref:System.Diagnostics.PerformanceCounterCategory>. Przeciążenie jest zaznaczone, oparte na tego, czy podano nazwę komputera.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatcounterexists.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatcountexists.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="counterName" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Nazwa kategorii nie istnieje.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rejestruje kategorię licznika wydajności niestandardowych i co najmniej jeden licznik w systemie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, System.Diagnostics.CounterCreationDataCollection counterData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, class System.Diagnostics.CounterCreationDataCollection counterData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.CounterCreationDataCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, counterData As CounterCreationDataCollection) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::Diagnostics::CounterCreationDataCollection ^ counterData);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * System.Diagnostics.CounterCreationDataCollection -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, counterData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use another overload that uses PerformanceCounterCategoryType instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="categoryHelp" Type="System.String" />
        <Parameter Name="counterData" Type="System.Diagnostics.CounterCreationDataCollection" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności niestandardowe, aby utworzyć i zarejestrować się w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="counterData">Element <see cref="T:System.Diagnostics.CounterCreationDataCollection" /> , który określa liczniki, które można utworzyć w ramach nowej kategorii.</param>
        <summary>Rejestruje niestandardowych kategorii licznika wydajności zawierający określony liczniki na komputerze lokalnym.</summary>
        <returns>A <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> skojarzonego z nową kategorię niestandardową lub obiektu wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Diagnostics.PerformanceCounterCategory> istnieje obiekt o nazwie "orders". Jeśli nie, tworzy <xref:System.Diagnostics.PerformanceCounterCategory> obiektu za pomocą <xref:System.Diagnostics.CounterCreationDataCollection> obiekt, który zawiera dwa liczniki wydajności.  
  
 [!code-cpp[PerfCounter_ccd#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter_ccd/CPP/ccd.cpp#1)]
 [!code-csharp[PerfCounter_ccd#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter_ccd/CS/ccd.cs#1)]
 [!code-vb[PerfCounter_ccd#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter_ccd/VB/ccd.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa licznika, która jest określona w ramach <paramref name="counterData" /> kolekcja jest <see langword="null" /> ani być pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony w ramach <paramref name="counterData" /> Kolekcja już istnieje.  
  
—lub— 
<paramref name="counterName" /> Parametr ma nieprawidłową składnię. Może on zawierać odwróconej kreski ułamkowej ("\\") lub ma długość większą niż 80 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.  
  
—lub— 
Układ <paramref name="counterData" /> kolekcji jest niepoprawny dla liczników podstawowego. Licznik typu <see langword="AverageCount64" />, <see langword="AverageTimer32" />, <see langword="CounterMultiTimer" />, <see langword="CounterMultiTimerInverse" />, <see langword="CounterMultiTimer100Ns" />, <see langword="CounterMultiTimer100NsInverse" />, <see langword="RawFraction" />, <see langword="SampleFraction" /> lub <see langword="SampleCounter" /> musi być bezpośrednio następuje jeden z typów licznik podstawowy (<see langword="AverageBase" />, <see langword="MultiBase" />, <see langword="RawBase" />, lub <see langword="SampleBase" />).</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych na kategorie liczników wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, System.Diagnostics.PerformanceCounterCategoryType categoryType, System.Diagnostics.CounterCreationDataCollection counterData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, valuetype System.Diagnostics.PerformanceCounterCategoryType categoryType, class System.Diagnostics.CounterCreationDataCollection counterData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.PerformanceCounterCategoryType,System.Diagnostics.CounterCreationDataCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, categoryType As PerformanceCounterCategoryType, counterData As CounterCreationDataCollection) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::Diagnostics::PerformanceCounterCategoryType categoryType, System::Diagnostics::CounterCreationDataCollection ^ counterData);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * System.Diagnostics.PerformanceCounterCategoryType * System.Diagnostics.CounterCreationDataCollection -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, categoryType, counterData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="categoryHelp" Type="System.String" />
        <Parameter Name="categoryType" Type="System.Diagnostics.PerformanceCounterCategoryType" />
        <Parameter Name="counterData" Type="System.Diagnostics.CounterCreationDataCollection" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności niestandardowe, aby utworzyć i zarejestrować się w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="categoryType">Jedną z <see cref="T:System.Diagnostics.PerformanceCounterCategoryType" /> wartości.</param>
        <param name="counterData">Element <see cref="T:System.Diagnostics.CounterCreationDataCollection" /> , który określa liczniki, które można utworzyć w ramach nowej kategorii.</param>
        <summary>Rejestruje niestandardowych kategorii licznika wydajności zawierający określony liczniki na komputerze lokalnym.</summary>
        <returns>A <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> skojarzonego z nową kategorię niestandardową lub obiektu wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `categoryType` Parametr określa, czy kategoria licznika wydajności jest jednego wystąpienia lub wielu wystąpień. Domyślnie kategoria jest jednym wystąpieniu, gdy jest tworzony i staje się wiele wystąpień, po dodaniu innego wystąpienia. Kategorie są tworzone, gdy aplikacja jest skonfigurowana i dodaniu wystąpień w czasie wykonywania. W wersjach programu .NET Framework 1.0 i 1.1 nie jest konieczne wiedzieć, czy kategorii licznika wydajności jest wiele wystąpień lub jednego wystąpienia. W [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], <xref:System.Diagnostics.PerformanceCounterCategoryType> wyliczenia jest używany do wskazania, czy licznik wydajności może mieć wiele wystąpień.  
  
 Zainstalowane z kategorii licznika wydajności [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] oddzielne pamięci współużytkowanej, za pomocą każdej kategorii licznika wydajności własnej pamięci posiadające.  Można określić rozmiar pamięci współużytkowanej oddzielne, tworząc DWORD o nazwie FileMappingSize w kluczu rejestru HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<nazwa kategorii >* \ Wydajność. Ustawiono wartość FileMappingSize rozmiar pamięci współużytkowanej kategorii. Domyślny rozmiar to 131072 dziesiętną. Jeśli nie jest obecny, wartość FileMappingSize `fileMappingSize` wartość dla atrybutu `performanceCounters` określone w pliku Machine.config jest używana, powoduje dodatkowe obciążenie przetwarzania pliku konfiguracji. Zwiększenie wydajności podczas uruchamiania aplikacji możesz uzyskać przez ustawienie rozmiaru mapowania pliku w rejestrze.  
  
> [!NOTE]
>  Zdecydowanie zaleca się, że nowe kategorie liczników wydajności utworzona podczas instalacji aplikacji, a nie w czasie wykonywania aplikacji. Dzięki temu czas na odświeżenie listy kategorii licznika wydajności zarejestrowanych systemu operacyjnego. Lista nie została odświeżona, można użyć kategorii zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> metody. W przykładzie pokazano sposób tworzenia niestandardowego, obejmujące wiele wystąpień kategorii licznika wydajności dla liczby zamówienia na sekundę.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategoryType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/CS/program.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategoryType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa licznika, która jest określona w ramach <paramref name="counterData" /> kolekcja jest <see langword="null" /> ani być pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony w ramach <paramref name="counterData" /> Kolekcja już istnieje.  
  
—lub— 
 <paramref name="counterName" /> ma nieprawidłową składnię. Może on zawierać odwróconej kreski ułamkowej ("\\") lub ma długość większą niż 80 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="counterData" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="categoryType" /> wartość jest poza zakresem z następujących wartości: <see langword="MultiInstance" />, <see langword="SingleInstance" />, lub <see langword="Unknown" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.  
  
—lub— 
Układ <paramref name="counterData" /> kolekcji jest niepoprawny dla liczników podstawowego. Licznik typu <see langword="AverageCount64" />, <see langword="AverageTimer32" />, <see langword="CounterMultiTimer" />, <see langword="CounterMultiTimerInverse" />, <see langword="CounterMultiTimer100Ns" />, <see langword="CounterMultiTimer100NsInverse" />, <see langword="RawFraction" />, <see langword="SampleFraction" />, lub <see langword="SampleCounter" /> musi bezpośrednio poprzedzać jeden z typów licznik podstawowy (<see langword="AverageBase" />, <see langword="MultiBase" />, <see langword="RawBase" />, lub <see langword="SampleBase" />).</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych na kategorie liczników wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, string counterName, string counterHelp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, counterName As String, counterHelp As String) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::String ^ counterName, System::String ^ counterHelp);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * string * string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, counterName, counterHelp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use another overload that uses PerformanceCounterCategoryType instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="categoryHelp" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="counterHelp" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności niestandardowe, aby utworzyć i zarejestrować się w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="counterName">Nazwa nowego licznika, typu <see langword="NumberOfItems32" />, aby utworzyć w ramach nowej kategorii.</param>
        <param name="counterHelp">Opis licznika, który jest skojarzony z nową kategorię niestandardową.</param>
        <summary>Rejestruje kategorię licznika wydajności niestandardowych, zawierających jeden licznik typu <see langword="NumberOfItems32" /> na komputerze lokalnym.</summary>
        <returns>A <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> skojarzonego z nową kategorię systemu lub obiektu wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> i jednym <xref:System.Diagnostics.PerformanceCounter> tekstem pomocy dla każdego z nich, przy użyciu <xref:System.Diagnostics.PerformanceCounterCategory.Create%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> metody.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfcountercatcreate.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatcreate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="counterName" /> jest <see langword="null" /> lub jest pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony przez <paramref name="counterName" /> już istnieje.  
  
—lub— 
 <paramref name="counterName" /> ma nieprawidłową składnię. Może on zawierać odwróconej kreski ułamkowej ("\\") lub ma długość większą niż 80 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="counterHelp" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych na kategorie liczników wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory Create (string categoryName, string categoryHelp, System.Diagnostics.PerformanceCounterCategoryType categoryType, string counterName, string counterHelp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory Create(string categoryName, string categoryHelp, valuetype System.Diagnostics.PerformanceCounterCategoryType categoryType, string counterName, string counterHelp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.PerformanceCounterCategoryType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (categoryName As String, categoryHelp As String, categoryType As PerformanceCounterCategoryType, counterName As String, counterHelp As String) As PerformanceCounterCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::PerformanceCounterCategory ^ Create(System::String ^ categoryName, System::String ^ categoryHelp, System::Diagnostics::PerformanceCounterCategoryType categoryType, System::String ^ counterName, System::String ^ counterHelp);" />
      <MemberSignature Language="F#" Value="static member Create : string * string * System.Diagnostics.PerformanceCounterCategoryType * string * string -&gt; System.Diagnostics.PerformanceCounterCategory" Usage="System.Diagnostics.PerformanceCounterCategory.Create (categoryName, categoryHelp, categoryType, counterName, counterHelp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="categoryHelp" Type="System.String" />
        <Parameter Name="categoryType" Type="System.Diagnostics.PerformanceCounterCategoryType" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="counterHelp" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności niestandardowe, aby utworzyć i zarejestrować się w systemie.</param>
        <param name="categoryHelp">Opis kategorii niestandardowej.</param>
        <param name="categoryType">Jedną z <see cref="T:System.Diagnostics.PerformanceCounterCategoryType" /> wartości określających, czy kategoria jest <see cref="F:System.Diagnostics.PerformanceCounterCategoryType.MultiInstance" />, <see cref="F:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance" />, lub <see cref="F:System.Diagnostics.PerformanceCounterCategoryType.Unknown" />.</param>
        <param name="counterName">Nazwa nowego licznika, który ma być utworzony jako część nowej kategorii.</param>
        <param name="counterHelp">Opis licznika, który jest skojarzony z nową kategorię niestandardową.</param>
        <summary>Rejestruje niestandardowych kategorii licznika wydajności zawierające jeden licznik typu <see cref="F:System.Diagnostics.PerformanceCounterType.NumberOfItems32" /> na komputerze lokalnym.</summary>
        <returns>A <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> skojarzonego z nową kategorię systemu lub obiektu wydajności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `categoryType` Parametr określa, czy kategoria licznika wydajności jest jednego wystąpienia lub wielu wystąpień. Domyślnie kategoria jest jednym wystąpieniu, gdy jest tworzony i staje się wiele wystąpień, po dodaniu innego wystąpienia. Kategorie są tworzone, gdy aplikacja jest skonfigurowana i dodaniu wystąpień w czasie wykonywania. W wersjach programu .NET Framework 1.0 i 1.1 nie jest konieczne wiedzieć, czy kategorii licznika wydajności jest wiele wystąpień lub jednego wystąpienia. W [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], <xref:System.Diagnostics.PerformanceCounterCategoryType> wyliczenia jest używany do wskazania, czy licznik wydajności może mieć wiele wystąpień.  
  
 Zainstalowane z kategorii licznika wydajności [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] oddzielne pamięci współużytkowanej, za pomocą każdej kategorii licznika wydajności własnej pamięci posiadające. Można określić rozmiar pamięci współużytkowanej oddzielne, tworząc DWORD o nazwie FileMappingSize w kluczu rejestru HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<nazwa kategorii >* \ Wydajność. Ustawiono wartość FileMappingSize rozmiar pamięci współużytkowanej kategorii. Domyślny rozmiar to 131072 dziesiętną. Jeśli nie jest obecny, wartość FileMappingSize `fileMappingSize` wartość dla atrybutu `performanceCounters` określone w pliku Machine.config jest używana, powoduje dodatkowe obciążenie przetwarzania pliku konfiguracji. Zwiększenie wydajności podczas uruchamiania aplikacji możesz uzyskać przez ustawienie rozmiaru mapowania pliku w rejestrze.  
  
> [!NOTE]
>  Zdecydowanie zaleca się, że nowe kategorie liczników wydajności utworzona podczas instalacji aplikacji, a nie w czasie wykonywania aplikacji. Dzięki temu czas na odświeżenie listy kategorii licznika wydajności zarejestrowanych systemu operacyjnego. Lista nie została odświeżona, można użyć kategorii zakończy się niepowodzeniem.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A> metody. W przykładzie pokazano sposób tworzenia niestandardowych, pojedyncze wystąpienie kategorii licznika wydajności.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategoryType#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/CS/program.cs#3)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategoryType#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategoryType/VB/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="counterName" /> jest <see langword="null" /> lub jest pustym ciągiem ("").  
  
—lub— 
Licznik, który jest określony przez <paramref name="counterName" /> już istnieje.  
  
—lub— 
 <paramref name="counterName" /> ma nieprawidłową składnię. Może on zawierać odwróconej kreski ułamkowej ("\\") lub ma długość większą niż 80 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria już istnieje na komputerze lokalnym.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="counterHelp" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do wykonywania zadań administracyjnych na kategorie liczników wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
        <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (categoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.PerformanceCounterCategory.Delete categoryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności niestandardowych do usunięcia.</param>
        <summary>Usuwa kategorii i jego skojarzone liczniki z komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz usunąć tylko kategorii licznika wydajności niestandardowe z systemu. Licznik nie można usunąć z kategorii. Aby to zrobić, należy usunąć kategorię i ponownie utworzyć kategorii liczników, które chcesz zachować. Aby uniknąć wyjątek, upewnij się, że kategorii istnieje przed podjęciem próby usunięcia go.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Diagnostics.PerformanceCounterCategory.Delete%2A> metodę, aby usunąć <xref:System.Diagnostics.PerformanceCounterCategory> i <xref:System.Diagnostics.PerformanceCounter> obiektów, które zawiera.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatDelete.cs#6)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatdelete.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Parametr ma nieprawidłową składnię. Może on zawierać odwróconej kreski ułamkowej ("\\") lub ma długość większą niż 80 znaków.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można usunąć kategorii, ponieważ nie jest kategorię niestandardową.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Administer" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Create(System.String,System.String,System.Diagnostics.CounterCreationDataCollection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy kategoria jest zarejestrowany w systemie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (categoryName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.Exists categoryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności do wyszukania.</param>
        <summary>Określa, czy kategoria jest zarejestrowany na komputerze lokalnym.</summary>
        <returns>
          <see langword="true" /> Jeśli kategoria jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z <xref:System.Diagnostics.PerformanceCounterCategory.Exists%2A> metody może spowodować zmniejszyć wydajność, gdy dostępność sprawdzane są wszystkie liczniki wydajności na maszynie. Jeśli piszesz tylko do liczników wydajności, można uniknąć wyszukiwania globalnego dla liczników wydajności, tworząc licznika wydajności, gdy aplikacja jest zainstalowana i kategorii zakładając, że istnieje podczas uzyskiwania dostępu do liczników. Nie ma możliwości w celu uniknięcia przeszukiwania licznika wydajności podczas odczytywania z liczników wydajności.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Diagnostics.PerformanceCounterCategory> istnieje obiekt o nazwie "orders". Jeśli nie, tworzy <xref:System.Diagnostics.PerformanceCounterCategory> obiektu za pomocą <xref:System.Diagnostics.CounterCreationDataCollection> obiekt, który zawiera dwa liczniki wydajności.  
  
 [!code-cpp[PerfCounter_ccd#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter_ccd/CPP/ccd.cpp#1)]
 [!code-csharp[PerfCounter_ccd#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter_ccd/CS/ccd.cs#1)]
 [!code-vb[PerfCounter_ccd#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter_ccd/VB/ccd.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (categoryName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.Exists (categoryName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności do wyszukania.</param>
        <param name="machineName">Nazwa komputera w celu zbadania dla kategorii.</param>
        <summary>Określa, czy kategoria jest zarejestrowany na określonym komputerze.</summary>
        <returns>
          <see langword="true" /> Jeśli kategoria jest zarejestrowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z <xref:System.Diagnostics.PerformanceCounterCategory.Exists%2A> metody może spowodować zmniejszyć wydajność, gdy dostępność sprawdzane są wszystkie liczniki wydajności na maszynie. Jeśli piszesz tylko do liczników wydajności, można uniknąć wyszukiwania globalnego dla liczników wydajności, tworząc licznika wydajności, gdy aplikacja jest zainstalowana i kategorii zakładając, że istnieje podczas uzyskiwania dostępu do liczników. Nie ma możliwości w celu uniknięcia przeszukiwania licznika wydajności podczas odczytywania z liczników wydajności.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład określa czy <xref:System.Diagnostics.PerformanceCounterCategory> obiektu o nazwie `Orders` istnieje. Jeśli nie istnieje, w przykładzie jest tworzony <xref:System.Diagnostics.PerformanceCounterCategory> obiektu za pomocą <xref:System.Diagnostics.CounterCreationDataCollection> obiekt, który zawiera dwa liczniki wydajności.  
  
 [!code-cpp[PerfCounter_ccd#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter_ccd/CPP/ccd.cpp#1)]
 [!code-csharp[PerfCounter_ccd#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter_ccd/CS/ccd.cs#1)]
 [!code-vb[PerfCounter_ccd#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter_ccd/VB/ccd.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.IO.IOException">Nie można odnaleźć ścieżki sieciowej.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCategories">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera listę kategorii licznika wydajności, które są zarejestrowane na komputerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCategories">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory[] GetCategories ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory[] GetCategories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCategories" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCategories () As PerformanceCounterCategory()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::PerformanceCounterCategory ^&gt; ^ GetCategories();" />
      <MemberSignature Language="F#" Value="static member GetCategories : unit -&gt; System.Diagnostics.PerformanceCounterCategory[]" Usage="System.Diagnostics.PerformanceCounterCategory.GetCategories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę kategorii licznika wydajności, które są zarejestrowane na komputerze lokalnym.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> obiektów wskazujący kategorie, które są rejestrowane na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> metodę, aby zwrócić tablicę <xref:System.Diagnostics.PerformanceCounterCategory> obiektów z na komputerze lokalnym lub na określonym komputerze. Konwertuje <xref:System.Diagnostics.PerformanceCounterCategory> tablicy na tablicę nazw kategorii, które go sortuje i wyświetla dla użytkownika. <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> Przeciążenie jest zaznaczone, oparte na tego, czy określono nazwę komputera.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountergetcat.cpp#2)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountergetcat.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcat.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="GetCategories">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.PerformanceCounterCategory[] GetCategories (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.PerformanceCounterCategory[] GetCategories(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCategories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCategories (machineName As String) As PerformanceCounterCategory()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::PerformanceCounterCategory ^&gt; ^ GetCategories(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetCategories : string -&gt; System.Diagnostics.PerformanceCounterCategory[]" Usage="System.Diagnostics.PerformanceCounterCategory.GetCategories machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterCategory[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, aby wyglądały na.</param>
        <summary>Pobiera listę kategorii licznika wydajności, które są zarejestrowane na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> obiektów wskazujący kategorie, które są zarejestrowane na określonym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do pobrania kategorii na komputerze lokalnym, należy użyć innego przeciążenia metody lub przekazać "." jako `machineName` parametru.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> metodę, aby zwrócić tablicę <xref:System.Diagnostics.PerformanceCounterCategory> obiektów z na komputerze lokalnym lub na określonym komputerze. Konwertuje <xref:System.Diagnostics.PerformanceCounterCategory> tablicy na tablicę nazw kategorii, które go sortuje i wyświetla dla użytkownika. <xref:System.Diagnostics.PerformanceCounterCategory.GetCategories%2A> Przeciążenie jest zaznaczone, oparte na tego, czy określono nazwę komputera.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountergetcat.cpp#2)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountergetcat.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcat.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCounters">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera listę liczników w tej kategorii licznika wydajności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCounters">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounter[] GetCounters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.PerformanceCounter[] GetCounters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCounters" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCounters () As PerformanceCounter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Diagnostics::PerformanceCounter ^&gt; ^ GetCounters();" />
      <MemberSignature Language="F#" Value="member this.GetCounters : unit -&gt; System.Diagnostics.PerformanceCounter[]" Usage="performanceCounterCategory.GetCounters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę liczników w kategorii licznika wydajności, który zawiera dokładnie jedno wystąpienie.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounter" /> obiektów wskazujący liczniki, które są skojarzone z tej kategorii licznika wydajności pojedynczych wystąpień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat wystąpienia obiektu wydajności Zobacz <xref:System.Diagnostics.PerformanceCounter> klasa — Przegląd.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę <xref:System.Diagnostics.PerformanceCounter> obiekty w <xref:System.Diagnostics.PerformanceCounterCategory>. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> za pomocą odpowiedniego konstruktora, na podstawie tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> metodę, aby zwrócić tablicę <xref:System.Diagnostics.PerformanceCounter> obiektów, wybierając <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> przeciążenie oparte na tego, czy określono nazwę wystąpienia.  
  
 To <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters> przeciążenia kończy się niepowodzeniem, chyba że jest używany z kategorią jednego wystąpienia.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountercatgetcount.cpp#4)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountercatgetcount.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcount.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kategoria nie jest pojedynczym wystąpieniem.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.InvalidOperationException">Kategoria nie ma skojarzonego wystąpienia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="GetCounters">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounter[] GetCounters (string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.PerformanceCounter[] GetCounters(string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetCounters(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCounters (instanceName As String) As PerformanceCounter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Diagnostics::PerformanceCounter ^&gt; ^ GetCounters(System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="member this.GetCounters : string -&gt; System.Diagnostics.PerformanceCounter[]" Usage="performanceCounterCategory.GetCounters instanceName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounter[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności dla którego można pobrać listy skojarzone liczniki.</param>
        <summary>Pobiera listę liczników w kategorii licznika wydajności, który zawiera co najmniej jedno wystąpienie.</summary>
        <returns>Tablica <see cref="T:System.Diagnostics.PerformanceCounter" /> liczników, które są skojarzone z określonego obiektu wystąpienia kategorii licznika wydajności przedstawiających obiekty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do reprezentowania kategorii jednego wystąpienia, należy przekazać pusty ciąg ("") dla `instanceName` parametru.  
  
 Aby uzyskać więcej informacji na temat wystąpienia obiektu wydajności Zobacz <xref:System.Diagnostics.PerformanceCounter> klasa — Przegląd.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę <xref:System.Diagnostics.PerformanceCounter> obiekty w <xref:System.Diagnostics.PerformanceCounterCategory>. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> za pomocą odpowiedniego konstruktora, na podstawie tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> metodę, aby zwrócić tablicę <xref:System.Diagnostics.PerformanceCounter> obiektów, wybierając <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%2A> przeciążenie oparte na tego, czy określono nazwę wystąpienia.  
  
 To <xref:System.Diagnostics.PerformanceCounterCategory.GetCounters%28System.String%29> przeciążenia kończy się niepowodzeniem, chyba że jest używana z kategorii, która zawiera wystąpienia.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountercatgetcount.cpp#4)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountercatgetcount.cs#4)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetcount.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwości dla tego <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> wystąpienia nie została ustawiona.  
  
—lub— 
Kategoria nie zawiera wystąpienia, który jest określony przez <paramref name="instanceName" /> parametru.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="GetInstanceNames">
      <MemberSignature Language="C#" Value="public string[] GetInstanceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetInstanceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.GetInstanceNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInstanceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetInstanceNames();" />
      <MemberSignature Language="F#" Value="member this.GetInstanceNames : unit -&gt; string[]" Usage="performanceCounterCategory.GetInstanceNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę wystąpień obiektów wydajności, które są skojarzone z tej kategorii.</summary>
        <returns>Tablica ciągów reprezentujących nazwy wystąpienia obiektów wydajności, które są skojarzone z tej kategorii lub, jeśli kategoria zawiera tylko jedno wystąpienie obiektu wydajności, pojedynczy wpis tablica zawiera pusty ciąg ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę <xref:System.Diagnostics.PerformanceCounter> obiekty w <xref:System.Diagnostics.PerformanceCounterCategory>. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> obiektu przy użyciu odpowiedniego konstruktora, które są oparte na tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.GetInstanceNames%2A> zwrócić nazwy wystąpienia jako tablicę <xref:System.String>, która sortuje i wyświetla.  
  
 [!code-cpp[System.Diagnostics.PerformanceCounterCategory.GetMembers#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/cpp/perfcountercatgetinst.cpp#6)]
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.GetMembers#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/CS/perfcountercatgetinst.cs#6)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.GetMembers#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.GetMembers/VB/perfcountercatgetinst.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość <see langword="null" />. Właściwość może nie została ustawiona.  
  
—lub— 
Kategoria nie ma skojarzonego wystąpienia.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InstanceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy kategoria zawiera wystąpienie obiektu określonego działania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InstanceExists">
      <MemberSignature Language="C#" Value="public bool InstanceExists (string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InstanceExists(string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InstanceExists (instanceName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InstanceExists(System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="member this.InstanceExists : string -&gt; bool" Usage="performanceCounterCategory.InstanceExists instanceName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności w tej kategorii licznika wydajności do wyszukania.</param>
        <summary>Określa, czy wystąpienie obiektu określonego działania istnieje w kategorii, która jest identyfikowana przez to <see cref="T:System.Diagnostics.PerformanceCounterCategory" /> obiektu <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli kategoria zawiera wystąpienie obiektu określonego działania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> nie `static`. Wymaga utworzenia <xref:System.Diagnostics.PerformanceCounterCategory> obiektu i ustawienie <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> właściwości.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy <xref:System.Diagnostics.PerformanceCounter> istnieje wystąpienie w ramach <xref:System.Diagnostics.PerformanceCounterCategory>. Najpierw tworzy <xref:System.Diagnostics.PerformanceCounterCategory> obiektu przy użyciu odpowiedniego konstruktora, które są oparte na tego, czy określono nazwę komputera. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%28System.String%29> ustalenie, czy określone wystąpienie istnieje, a następnie informuje użytkownika. Jeśli nazwa wystąpienia nie jest określony, w przykładzie użyto domyślna nazwa pojedynczego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcounterobjinstexists.cs#2)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatobjinstexists.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość <see langword="null" />. Właściwość może nie została ustawiona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="InstanceExists">
      <MemberSignature Language="C#" Value="public static bool InstanceExists (string instanceName, string categoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool InstanceExists(string instanceName, string categoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InstanceExists (instanceName As String, categoryName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool InstanceExists(System::String ^ instanceName, System::String ^ categoryName);" />
      <MemberSignature Language="F#" Value="static member InstanceExists : string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.InstanceExists (instanceName, categoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności do wyszukania.</param>
        <param name="categoryName">Kategoria licznika wydajności do wyszukania.</param>
        <summary>Określa, czy określonej kategorii na komputerze lokalnym zawiera wystąpienie obiektu określonego działania.</summary>
        <returns>
          <see langword="true" /> Jeśli kategoria zawiera wystąpienie obiektu określonego działania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest możliwe ustalenie, czy wystąpienie obiektu wydajności istnieje na komputerze bez określania określonej kategorii do przeszukania.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> ustalenie, czy dany <xref:System.Diagnostics.PerformanceCounter> wystąpienie istnieje w <xref:System.Diagnostics.PerformanceCounterCategory>. Przeciążenie jest zaznaczone, oparte na tego, czy nazwa komputera jest określony. Jeśli nazwa wystąpienia nie jest określony, w przykładzie użyto domyślna nazwa pojedynczego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatinstexists.cs#10)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatinstexists.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceName" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="categoryName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="InstanceExists">
      <MemberSignature Language="C#" Value="public static bool InstanceExists (string instanceName, string categoryName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool InstanceExists(string instanceName, string categoryName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.InstanceExists(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InstanceExists (instanceName As String, categoryName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool InstanceExists(System::String ^ instanceName, System::String ^ categoryName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member InstanceExists : string * string * string -&gt; bool" Usage="System.Diagnostics.PerformanceCounterCategory.InstanceExists (instanceName, categoryName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Wystąpienie obiektu wydajności do wyszukania.</param>
        <param name="categoryName">Kategoria licznika wydajności do wyszukania.</param>
        <param name="machineName">Nazwa komputera, na którym należy szukać pary wystąpienie kategorii.</param>
        <summary>Określa, czy określonej kategorii na określonym komputerze zawiera wystąpienie obiektu określonego działania.</summary>
        <returns>
          <see langword="true" /> Jeśli kategoria zawiera wystąpienie obiektu określonego działania; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest możliwe ustalenie, czy wystąpienie obiektu wydajności istnieje na komputerze bez określania określonej kategorii do przeszukania.  
  
 Można użyć ".", aby określić komputer lokalny.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu używa statycznych przeciążeń <xref:System.Diagnostics.PerformanceCounterCategory.InstanceExists%2A> ustalenie, czy dany <xref:System.Diagnostics.PerformanceCounter> wystąpienie istnieje w <xref:System.Diagnostics.PerformanceCounterCategory>. Przeciążenie jest zaznaczone, oparte na tego, czy nazwa komputera jest określony. Jeśli nazwa wystąpienia nie jest określony, w przykładzie użyto domyślna nazwa pojedynczego wystąpienia.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/CS/perfcountercatstatinstexists.cs#10)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.ExistMembers#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.ExistMembers/VB/perfcountercatstatinstexists.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceName" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="categoryName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="categoryName" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
<paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.CounterExists(System.String)" />
        <altmember cref="M:System.Diagnostics.PerformanceCounterCategory.Exists(System.String)" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounterCategory.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounterCategory.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym znajduje się tej kategorii.</summary>
        <value>Nazwa komputera, na którym istnieją kategorii licznika wydajności i jego skojarzone liczniki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> z <xref:System.Diagnostics.PerformanceCounterCategory.%23ctor> konstruktora. Jednak monituje użytkownika o <xref:System.Diagnostics.PerformanceCounterCategory> i nazwy komputera, następnie ustawia <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A> z wprowadzone wartości właściwości. Następnie wyświetla wartości <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounterCategory.MachineName%2A>, i <xref:System.Diagnostics.PerformanceCounterCategory.CategoryHelp%2A> właściwości lub jest on wyświetla komunikat o błędzie, jeśli <xref:System.Diagnostics.PerformanceCounterCategory> nie są dostępne.  
  
 [!code-csharp[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/CS/perfCounterCatProps.cs#8)]
 [!code-vb[System.Diagnostics.PerformanceCounterCategory.OtherMembers#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.PerformanceCounterCategory.OtherMembers/VB/perfcountercatprops.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.MachineName" /> Składnia jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do odczytywania wydajności kategorie liczników. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" />
        <altmember cref="T:System.Diagnostics.PerformanceCounter" />
      </Docs>
    </Member>
    <Member MemberName="ReadCategory">
      <MemberSignature Language="C#" Value="public System.Diagnostics.InstanceDataCollectionCollection ReadCategory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.InstanceDataCollectionCollection ReadCategory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounterCategory.ReadCategory" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadCategory () As InstanceDataCollectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::InstanceDataCollectionCollection ^ ReadCategory();" />
      <MemberSignature Language="F#" Value="member this.ReadCategory : unit -&gt; System.Diagnostics.InstanceDataCollectionCollection" Usage="performanceCounterCategory.ReadCategory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.InstanceDataCollectionCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie licznika i wydajność wystąpienia dane obiektów, które jest skojarzone z tej kategorii licznika wydajności.</summary>
        <returns>
          <see cref="T:System.Diagnostics.InstanceDataCollectionCollection" /> Zawierający dane wystąpienia obiektu licznika i wydajności dla tej kategorii.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.Diagnostics.PerformanceCounterCategory.CategoryName%2A> właściwości przed wywołaniem <xref:System.Diagnostics.PerformanceCounterCategory.ReadCategory%2A>.  
  
 Odczytywanie całej kategorii jednocześnie może być wydajne niż jeden licznik do czytania ze względu na sposób, że system zawiera dane.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w Windows Vista lub nowszy, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista i nowszych wersjach, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterCategory> do określonego <xref:System.Diagnostics.PerformanceCounterCategory> nazwy. Następnie używa <xref:System.Diagnostics.PerformanceCounterCategory.ReadCategory%2A> do zwrócenia <xref:System.Diagnostics.InstanceDataCollectionCollection> zawierający dane wystąpienia dla wszystkich wystąpień <xref:System.Diagnostics.PerformanceCounter> obiektów w ramach <xref:System.Diagnostics.PerformanceCounterCategory>.  
  
 [!code-csharp[System.Diagnostics.InstanceData.CopyTo#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.InstanceData.CopyTo/CS/instdatacopyto.cs#6)]
 [!code-vb[System.Diagnostics.InstanceData.CopyTo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.InstanceData.CopyTo/VB/instdatacopyto.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounterCategory.CategoryName" /> Właściwość <see langword="null" />. Właściwość może nie została ustawiona.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wywołanie w celu podstawowego interfejsu API systemu nie powiodło się.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <altmember cref="T:System.Diagnostics.InstanceDataCollectionCollection" />
        <altmember cref="T:System.Diagnostics.InstanceDataCollection" />
        <altmember cref="T:System.Diagnostics.InstanceData" />
      </Docs>
    </Member>
  </Members>
</Type>
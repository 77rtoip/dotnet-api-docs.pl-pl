<Type Name="ProcessStartInfo" FullName="System.Diagnostics.ProcessStartInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="57b90f5410d83f27ef62009855cc5e70be040006" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36343335" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ProcessStartInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ProcessStartInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessStartInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ProcessStartInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessStartInfo sealed" />
  <TypeSignature Language="F#" Value="type ProcessStartInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa zbiór wartości, które są używane podczas uruchamiania procesu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo> jest używany razem z <xref:System.Diagnostics.Process> składnika. Po rozpoczęciu procesu przy użyciu <xref:System.Diagnostics.Process> klasy, musisz mieć dostęp do przetworzenia informacje oprócz są dostępne, kiedy dołączanie do uruchomionego procesu.  
  
 Można użyć <xref:System.Diagnostics.ProcessStartInfo> klasy dla lepszej kontroli nad procesem uruchamiania. Należy skonfigurować co najmniej <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości, albo ręcznie lub za pomocą konstruktora. Nazwa pliku jest dowolną aplikację lub dokument. W tym miejscu dokument jest zdefiniowany dowolny typ pliku, który został otwarty lub domyślna akcja skojarzona z nim. Dla komputera można wyświetlić zarejestrowane typy plików i ich skojarzonych aplikacji przy użyciu **Opcje folderów** okno dialogowe, która jest dostępna w systemach operacyjnych. **Zaawansowane** przycisk prowadzi do okna dialogowego pokazuje, czy jest otwarty akcję skojarzoną z określonym zarejestrowany typ pliku.  
  
 Ponadto można ustawić inne właściwości, które definiują akcjami wykonywanymi z tego pliku. Można określić wartość specyficznych dla typu <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwość <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> właściwości. Na przykład można określić "print" dla typu dokumentu. Ponadto można określić <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> wartości właściwości jako argumenty wiersza polecenia do przekazania do procedury otwierania pliku. Na przykład określ aplikację Edytor tekstu w <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości, można użyć <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> właściwości w celu określenia pliku tekstowego, który ma zostać otwarty w edytorze.  
  
 Standardowe dane wejściowe jest zwykle klawiatury, i wyjście standardowe i błąd standardowy są zwykle ekranu. Można jednak użyć <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, i <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> właściwości, aby spowodować, że proces pobrać dane wejściowe z ani zwracać dane wyjściowe do pliku lub innego urządzenia. Jeśli używasz <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, lub <xref:System.Diagnostics.Process.StandardError%2A> właściwości <xref:System.Diagnostics.Process> składnika, należy najpierw ustawić wartość odpowiadająca na <xref:System.Diagnostics.ProcessStartInfo> właściwości. W przeciwnym razie system zgłasza wyjątek podczas odczytu lub zapisu do strumienia.  
  
 Ustaw <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwości w celu określenia, czy można uruchomić proces, za pomocą powłoki systemu operacyjnego. Jeśli <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ustawiono `false`, nowy proces dziedziczy standardowe dane wejściowe, danych wyjściowych standard i przetwarzania strumieni standardowy błąd wywołania metody, chyba że <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, lub <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> właściwości, są odpowiednio ustawione na `true`. 
  
 Można zmienić wartość dowolnych <xref:System.Diagnostics.ProcessStartInfo> właściwości do czasu, która rozpoczyna się proces. Po rozpoczęciu procesu zmiana tych wartości nie ma znaczenia.  
  
> [!NOTE]
>  Ta klasa zawiera żądanie łącza na poziomie klasy, która ma zastosowanie do wszystkich elementów członkowskich. A <xref:System.Security.SecurityException> jest generowany, gdy bezpośredniego obiektu wywołującego nie ma uprawnienia pełnego zaufania. Aby uzyskać szczegółowe informacje dotyczące żądania kontroli zabezpieczeń, zobacz [Linkdemand](~/docs/framework/misc/link-demands.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Diagnostics.ProcessStartInfo> klasę, aby uruchomić program Internet Explorer, zapewniając docelowego adresu URL jako <xref:System.Diagnostics.ProcessStartInfo> argumentów.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">dla członków wywoływania <see cref="T:System.Diagnostics.ProcessStartInfo" />. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; [NIB: nazwane zestawy uprawnień] (http://msdn.microsoft.com/library/08250d67-c99d-4ab0-8d2b-b0e12019f6e3): <see langword="FullTrust" />.</permission>
    <altmember cref="T:System.Diagnostics.Process" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.ProcessStartInfo" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.ProcessStartInfo" /> klasy bez określania nazwy pliku uruchamiania procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy skonfigurować co najmniej <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości przed rozpoczęciem procesu. Nazwa pliku jest dowolną aplikację lub dokument. W takim przypadku dokumentu jest zdefiniowana na dowolny typ pliku, który został otwarty lub domyślna akcja skojarzona z nim. Dla komputera można wyświetlić zarejestrowane typy plików i ich skojarzonych aplikacji przy użyciu **Opcje folderów** okno dialogowe, która jest dostępna w systemach operacyjnych. **Zaawansowane** przycisk prowadzi do okna dialogowego pokazuje, czy jest otwarty akcję skojarzoną z określonym zarejestrowany typ pliku.  
  
 Opcjonalnie można również ustawić inne właściwości przed rozpoczęciem procesu. <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Właściwości dostarcza akcje, takie jak "print" z plikiem wskazanych w <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Właściwość udostępnia sposób przekazywania argumenty wiersza polecenia do pliku, gdy system go otwiera.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Aplikacja lub dokument, z którym do uruchomienia procesu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.ProcessStartInfo" /> , określa nazwę pliku, np. aplikację lub dokument, z którym można uruchomić procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa pliku jest dowolną aplikację lub dokument. W takim przypadku dokumentu jest zdefiniowana na dowolny typ pliku, który został otwarty lub domyślna akcja skojarzona z nim. Dla komputera można wyświetlić zarejestrowane typy plików i ich skojarzonych aplikacji przy użyciu **Opcje folderów** okno dialogowe, która jest dostępna w systemach operacyjnych. **Zaawansowane** przycisk prowadzi do okna dialogowego pokazuje, czy jest otwarty akcję skojarzoną z określonym zarejestrowany typ pliku.  
  
 Możesz zmienić <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości po wywołaniu tego konstruktora do czasu, która rozpoczyna się proces. Po rozpoczęciu procesu zmiana tych wartości nie ma znaczenia.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, arguments As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string * string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo (fileName, arguments)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Aplikacji, w której do uruchomienia procesu.</param>
        <param name="arguments">Argumenty wiersza polecenia do przekazania do aplikacji podczas uruchamiania procesu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.ProcessStartInfo" /> klasy, określa nazwę pliku aplikacji, z którym można uruchomić procesu i określa zestaw argumentów wiersza polecenia do przekazania aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa pliku jest dowolną aplikację lub dokument. W takim przypadku dokumentu jest zdefiniowana na dowolny typ pliku, który został otwarty lub domyślna akcja skojarzona z nim. Dla komputera można wyświetlić zarejestrowane typy plików i ich skojarzonych aplikacji przy użyciu **Opcje folderów** okno dialogowe, która jest dostępna w systemach operacyjnych. **Zaawansowane** przycisk prowadzi do okna dialogowego pokazuje, czy jest otwarty akcję skojarzoną z określonym zarejestrowany typ pliku.  
  
 Możesz zmienić <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> lub <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> właściwości po wywołaniu tego konstruktora do czasu, która rozpoczyna się proces. Po rozpoczęciu procesu zmiana tych wartości nie ma znaczenia.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="ArgumentList">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; ArgumentList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; ArgumentList" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArgumentList As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ ArgumentList { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ArgumentList : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arguments">
      <MemberSignature Language="C#" Value="public string Arguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Arguments" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberSignature Language="VB.NET" Value="Public Property Arguments As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Arguments { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Arguments : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Command line arguments that will be passed to the application specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zbiór argumenty wiersza polecenia do użycia podczas uruchamiania aplikacji.</summary>
        <value>Jeden ciąg zawierający argumenty do przekazania do aplikacji docelowej, określone w <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> właściwości. Wartością domyślną jest ciąg pusty (""). W systemach Windows Vista i wcześniejszych wersjach systemu operacyjnego Windows długość argumenty dodane do długość pełnej ścieżki do procesu musi być mniejsza niż 2080. W systemie Windows 7 i nowszych wersjach długość musi być mniejsza niż 32699.  Argumenty są analizowane i interpretowane przez aplikacji docelowej, dlatego muszą być wyrównane z oczekiwań tej aplikacji. For.NET aplikacji, co pokazano w poniższych przykładach spacje są interpretowane jako separatora między wiele argumentów. Jeden argument, który zawiera spacje muszą być ujęte w cudzysłów, ale te znaki cudzysłowu nie odbywa się za pośrednictwem do aplikacji docelowej. W zawierają znaki cudzysłowu w końcowym przeanalizować argumentu, ucieczki triple każdego znaku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pierwszy tworzy aplikację małe (argsecho.exe) tego tłumiące echo argumenty do konsoli. Drugi przykład tworzy aplikację, która wywołuje argsecho.exe aby zademonstrować różnych zmian właściwości argumentów.  
  
 [!code-cpp[Process.Start_static#3](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#3)]
 [!code-csharp[Process.Start_static#3](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#3)]
 [!code-vb[Process.Start_static#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#3)]  
  
 [!code-cpp[Process.Start_static#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#2)]
 [!code-csharp[Process.Start_static#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#2)]
 [!code-vb[Process.Start_static#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNoWindow">
      <MemberSignature Language="C#" Value="public bool CreateNoWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CreateNoWindow" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property CreateNoWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CreateNoWindow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CreateNoWindow : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to start the process without creating a new window to contain it.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy można uruchomić procesu w nowym oknie.</summary>
        <value>
          <see langword="true" /> Jeśli mają być uruchamiane przez proces bez tworzenia nowego okna, które zawierałoby proces; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwość jest `true` lub <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A> właściwości nie są `null`, <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> wartość właściwości jest ignorowany i zostanie utworzone nowe okno.  

 Oprogramowanie .NET core nie obsługuje tworzenia systemu windows bezpośrednio na platformach podobnymi do systemu Unix, w tym system macOS i Linux. Ta właściwość jest ignorowana na tych platformach.
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która identyfikuje domeny do użycia podczas uruchamiania procesu. Jeśli ta wartość jest <see langword="null" />, <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> musi być określona właściwość w formacie nazwy UPN.</summary>
        <value>Domena usługi Active Directory do użycia podczas uruchamiania procesu. Jeśli ta wartość jest <see langword="null" />, <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> musi być określona właściwość w formacie nazwy UPN.</value>
        <remarks>Ta właściwość jest przede wszystkim użytkownikom w środowiskach przedsiębiorstw, które używają usługi Active Directory.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Environment">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; Environment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; Environment" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Environment As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ Environment { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Environment : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zmienne środowiskowe, które mają zastosowanie do tego procesu i jego procesy podrzędne.</summary>
        <value>Ogólny słownik zawierający zmienne środowiskowe, które mają zastosowanie do tego procesu i jego procesy podrzędne. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmienne środowiskowe zawiera ścieżki wyszukiwania plików, katalogów, plików tymczasowych, opcje specyficzne dla aplikacji i inne podobne informacje. Mimo że nie można bezpośrednio ustawić <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> właściwości, można zmodyfikować słownika ogólnego zwrócony przez właściwość. Na przykład następujący kod dodaje zmienną środowiskową TempPath: `myProcess.StartInfo.Environment.Add("TempPath", "C:\\Temp")`.  Należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwości `false` do rozpoczęcia procesu po zmianie <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> właściwości. Jeśli <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`, <xref:System.InvalidOperationException> jest generowany, gdy <xref:System.Diagnostics.Process.Start%2A> metoda jest wywoływana.  
  
 W przypadku aplikacji .NET Framework, przy użyciu <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> właściwości jest taka sama jak przy użyciu <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="EnvironmentVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.StringDictionary EnvironmentVariables" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvironmentVariables As StringDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::StringDictionary ^ EnvironmentVariables { System::Collections::Specialized::StringDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvironmentVariables : System.Collections.Specialized.StringDictionary" Usage="System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StringDictionaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Set of environment variables that apply to this process and child processes.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.StringDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyszukiwanie ścieżki do plików, katalogów, plików tymczasowych, opcje specyficzne dla aplikacji i inne podobne informacje.</summary>
        <value>Słownik ciąg, który zawiera zmiennych środowiskowych, które mają zastosowanie do tego procesu i procesów podrzędnych. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie można ustawić <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> właściwości, można zmodyfikować <xref:System.Collections.Specialized.StringDictionary> zwrócony przez właściwość. Na przykład następujący kod dodaje zmienną środowiskową TempPath: `myProcess.StartInfo.EnvironmentVariables.Add("TempPath", "C:\\Temp")`.  Należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwości `false` do rozpoczęcia procesu po zmianie <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> właściwości. Jeśli <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`, <xref:System.InvalidOperationException> jest generowany, gdy <xref:System.Diagnostics.Process.Start%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialog">
      <MemberSignature Language="C#" Value="public bool ErrorDialog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ErrorDialog" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ErrorDialog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialog : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to show an error dialog to the user if there is an error.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy użytkownikowi zostanie wyświetlone okno dialogowe błędu, jeśli nie można uruchomić procesu.</summary>
        <value>
          <see langword="true" /> Jeśli okno dialogowe błędu powinien być wyświetlany na ekranie, jeśli nie można uruchomić procesu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> musi być `true` Jeśli chcesz ustawić <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> do `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialogParentHandle">
      <MemberSignature Language="C#" Value="public IntPtr ErrorDialogParentHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ErrorDialogParentHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialogParentHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ErrorDialogParentHandle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialogParentHandle : nativeint with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia uchwytu okna do użycia, gdy okno dialogowe błędu jest wyświetlana dla procesu, który nie może zostać uruchomiona.</summary>
        <value>Wskaźnik do uchwytu okna dialogowego błędu, że wyniki z procesem rozpocząć awarii.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> jest `true`, <xref:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle%2A> właściwość określa okno nadrzędne dla okna dialogowego, który jest widoczny. Należy określić element nadrzędny, aby zachować okno dialogowe przed aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileName">
      <MemberSignature Language="C#" Value="public string FileName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberSignature Language="VB.NET" Value="Public Property FileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FileName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StartFileNameEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the application, document or URL to start.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia aplikację lub dokument, aby rozpocząć.</summary>
        <value>Nazwa aplikacji, aby uruchomić lub nazwę dokumentu, typu pliku skojarzone z aplikacją i który ma wartość domyślną, otwórz dostępnych akcji. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy skonfigurować co najmniej <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości przed rozpoczęciem procesu. Nazwa pliku jest dowolną aplikację lub dokument. Dokument jest zdefiniowany dowolny typ pliku, który został otwarty lub domyślna akcja skojarzona z nim. Dla komputera można wyświetlić zarejestrowane typy plików i ich skojarzonych aplikacji przy użyciu **Opcje folderów** okno dialogowe, która jest dostępna w systemach operacyjnych. **Zaawansowane** przycisk prowadzi do okna dialogowego pokazuje, czy jest otwarty akcję skojarzoną z określonym zarejestrowany typ pliku.  
  
 Zestaw typów plików, które są dostępne w części zależy wartość <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwości. Jeśli <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`, można uruchomić każdy dokument i wykonywania operacji na pliku, na przykład drukowania z <xref:System.Diagnostics.Process> składnika. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `false`, można uruchomić tylko pliki wykonywalne z <xref:System.Diagnostics.Process> składnika.  
  
 Można uruchomić aplikacji ClickOnce, ustawiając <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości do lokalizacji (na przykład adres sieci Web), w którym zainstalowano aplikację. Nie należy uruchamiać aplikacji ClickOnce, określając jego zainstalowanej lokalizacji na dysku twardym.  
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUserProfile">
      <MemberSignature Language="C#" Value="public bool LoadUserProfile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadUserProfile" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadUserProfile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadUserProfile { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadUserProfile : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy profil użytkownika systemu Windows ma być załadowany z rejestru.</summary>
        <value>
          <see langword="true" /> Jeśli profil użytkownika systemu Windows powinna być ładowana; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wywoływany, jeśli proces jest uruchamiana za pomocą nazwy użytkownika, hasło i domenę.  
  
 Jeśli wartość jest `true`, profil użytkownika w `HKEY_USERS` klucz rejestru został załadowany. Ładowanie profil może być czasochłonne. W związku z tym warto korzystać z tej wartości tylko wtedy, gdy muszą uzyskać dostęp do informacji w `HKEY_CURRENT_USER` klucza rejestru.  
  
 W systemie Windows Server 2003 i Windows 2000 profil jest usunięty z pamięci po nowy proces został zakończony, niezależnie od tego, czy Proces został utworzony podrzędnych procesów.  
  
 W systemie Windows XP profil jest usunięty z pamięci po nowy proces i wszystkie procesy podrzędne, które zostały utworzone zostały zakończone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Password">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Password { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.SecureString Password" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Password" />
      <MemberSignature Language="VB.NET" Value="Public Property Password As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::SecureString ^ Password { System::Security::SecureString ^ get(); void set(System::Security::SecureString ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Password : System.Security.SecureString with get, set" Usage="System.Diagnostics.ProcessStartInfo.Password" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bezpieczny ciąg, który zawiera hasło użytkownika używana podczas uruchamiania procesu.</summary>
        <value>Hasło użytkownika używana podczas uruchamiania procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Musi być ustawiona właściwość, jeśli <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A> są udostępniane. Jeśli nie ustawiono właściwości, domyślny katalog roboczy jest % SYSTEMROOT%\system32.  
  
> [!NOTE]
>  Ustawienie <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>i <xref:System.Diagnostics.ProcessStartInfo.Password%2A> właściwości w <xref:System.Diagnostics.ProcessStartInfo> obiekt jest zalecana praktyka dla uruchamiania procesu z poświadczeniami użytkownika.  
  
 A <xref:System.Security.SecureString> obiektu przypomina <xref:System.String> obiektów w tym ma wartość tekstową. Jednak wartość <xref:System.Security.SecureString> obiektu są szyfrowane automatycznie, można modyfikować, dopóki aplikacja oznacza je jako tylko do odczytu i może zostać usunięta z pamięci komputera przez aplikację lub moduł zbierający elementy bezużyteczne .NET Framework.  
  
 Aby uzyskać więcej informacji na temat bezpiecznego ciągów i przykładem uzyskać hasło, aby ustawić tę właściwość, zobacz <xref:System.Security.SecureString> klasy.  
  
> [!NOTE]
>  Jeśli musisz podać wartość dla <xref:System.Diagnostics.ProcessStartInfo.Password%2A> właściwość <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwość musi być `false`, lub <xref:System.InvalidOperationException> będzie zostać zgłoszony, gdy <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PasswordInClearText">
      <MemberSignature Language="C#" Value="public string PasswordInClearText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PasswordInClearText" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordInClearText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PasswordInClearText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordInClearText : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia hasło użytkownika w postaci zwykłego tekstu do użycia podczas uruchamiania procesu.</summary>
        <value>Hasło użytkownika w postaci zwykłego tekstu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardError">
      <MemberSignature Language="C#" Value="public bool RedirectStandardError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardError : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process's error output is written to the Process instance's StandardError member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dane wyjściowe błędów aplikacji jest zapisywane <see cref="P:System.Diagnostics.Process.StandardError" /> strumienia.</summary>
        <value>
          <see langword="true" /> Jeśli mają być zapisywane dane wyjściowe błędów <see cref="P:System.Diagnostics.Process.StandardError" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.Process> zapisuje tekst jego Standardowy strumień błędów, że tekst jest zwykle wyświetlany w konsoli. Dzięki przekierowaniu <xref:System.Diagnostics.Process.StandardError%2A> strumienia, można manipulować i pomijania błędów wyjścia procesu. Na przykład możesz filtrować tekst, sformatuj go w inny sposób i zapisać dane wyjściowe do konsoli i pliku dziennika wyznaczonych.  
  
> [!NOTE]
>  Należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> do `false` Jeśli chcesz ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> do `true`. W przeciwnym razie odczytu z <xref:System.Diagnostics.Process.StandardError%2A> strumienia zgłasza wyjątek.  
  
 Przekierowane <xref:System.Diagnostics.Process.StandardError%2A> synchronicznie lub asynchronicznie można odczytać strumienia. Metody, takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A> i <xref:System.IO.StreamReader.ReadToEnd%2A> przeprowadzić synchronicznej operacji odczytu na błąd strumień wyjściowy procesu. Te synchroniczne do odczytu do skojarzonego nie są wykonywane operacje <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardError%2A> strumienia lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardError%2A> strumienia. Ta metoda umożliwia obsługi zdarzeń w wyznaczonych dla strumieni wyjściowych i natychmiast zwraca obiekt wywołujący, które można wykonywać inne zadania, gdy strumień wyjściowy jest kierowany do obsługi zdarzeń.  
  
> [!NOTE]
>  Aplikacja, która jest przetwarzania asynchronicznego dane wyjściowe powinny wywoływać <xref:System.Diagnostics.Process.WaitForExit%2A> metody, aby upewnić się, że zostały opróżnione buforu wyjściowego.  
  
 Synchroniczne odczytu operacji wprowadzenie zależności między wywołującego odczytu z <xref:System.Diagnostics.Process.StandardError%2A> strumienia i podrzędnego procesu zapisywanie w strumieniu. Te zależności może spowodować warunki zakleszczenia. Gdy obiekt wywołujący odczytuje z przekierowanego strumienia procesu podrzędnego, jest on zależny od elementu podrzędnego. Obiekt wywołujący oczekuje dla operacji odczytu, aż podrzędne zapisuje do strumienia lub zamyka strumienia. Podczas procesu podrzędnego zapisuje wystarczającej ilości danych w celu wypełnienia jej przekierowanego strumienia, jest on zależny od obiektu nadrzędnego. Procesu podrzędnego oczekuje dla następnej operacji zapisu, aż nadrzędnego odczytuje strumienia pełnego lub zamyka strumienia. Wyniki warunku zakleszczenie podczas wywołującego i procesu podrzędnego oczekiwania dla pozostałych do zakończenia operacji i nie można kontynuować. Można uniknąć zakleszczenie wyniku obliczenia zależności między wywołującego i procesu podrzędnego.  
  
 Na przykład następujący kod C# pokazano, jak można czytać ze strumienia przekierowane i poczekaj na zakończenie procesu podrzędnego.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 Przykładowy kod pozwala uniknąć zakleszczenie, wywołując `p.StandardError.ReadToEnd` przed `p.WaitForExit`. Zakleszczenie może powodować, jeśli element nadrzędny przetwarzania wywołania `p.WaitForExit` przed `p.StandardError.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst, aby wypełnić przekierowanego strumienia. Proces nadrzędny będzie czekać w nieskończoność na zakończenie procesu podrzędnego. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Brak podobne problem podczas odczytu cały tekst z wyjście standardowe i błąd standardowy strumieni. Na przykład następujący kod C# wykonuje operację odczytu na obu strumieni.  
  
```csharp  
// Do not perform a synchronous read to the end of both  
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Przykład kodu pozwala uniknąć zakleszczenia, wykonując asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Zakleszczenie wyniki, jeśli element nadrzędny przetwarzania wywołania `p.StandardOutput.ReadToEnd` następuje `p.StandardError.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst w celu wypełnienia jej strumień błędów. Proces nadrzędny będzie czekać w nieskończoność procesu podrzędnego zamknąć jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Aby uniknąć tych zależności i ich potencjalne zakleszczenia, można użyć asynchronicznych operacji odczytu. Alternatywnie można uniknąć zakleszczenia przez utworzenie dwóch wątków i odczytywania dane wyjściowe każdego strumienia w oddzielnym wątku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `net use` polecenia wraz z argumentem dostarczone przez użytkownika do mapowania zasobu sieciowego. Następnie Standardowy strumień błędów polecenia net odczytuje i zapisuje go do konsoli.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardInput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardInput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process command input is read from the Process instance's StandardInput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dane wejściowe dla aplikacji są odczytywane z <see cref="P:System.Diagnostics.Process.StandardInput" /> strumienia.</summary>
        <value>
          <see langword="true" /> Jeśli dane wejściowe są odczytywane z <see cref="P:System.Diagnostics.Process.StandardInput" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Diagnostics.Process> można odczytać tekstu wejściowego z jego Standardowy strumień wejściowy zwykle klawiatury. Dzięki przekierowaniu <xref:System.Diagnostics.Process.StandardInput%2A> strumienia, można programowo określić wejścia procesu. Na przykład zamiast przy użyciu klawiatury, musisz podać tekst z zawartości wybrany plik lub wyjście z innej aplikacji.  
  
> [!NOTE]
>  Należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> do `false` Jeśli chcesz ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> do `true`. W przeciwnym razie zapisywania <xref:System.Diagnostics.Process.StandardInput%2A> strumienia zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przekierowania <xref:System.Diagnostics.Process.StandardInput%2A> strumienia procesu. `sort` Polecenie jest aplikacja konsolowa, która odczytuje i sortuje wprowadzania tekstu.  
  
 W przykładzie uruchomiono `sort` polecenia przy użyciu przekierowanych danych wejściowych. Następnie monituje użytkownika o tekstu i przekazuje tekst, który `sort` procesu za pomocą przekierowanego <xref:System.Diagnostics.Process.StandardInput%2A> strumienia. `sort` Wyniki są wyświetlane użytkownikowi na konsoli.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardOutput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardOutput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process output is written to the Process instance's StandardOutput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zapisywane są dane wyjściowe tekstową aplikacji <see cref="P:System.Diagnostics.Process.StandardOutput" /> strumienia.</summary>
        <value>
          <see langword="true" /> Jeśli mają być zapisywane dane wyjściowe <see cref="P:System.Diagnostics.Process.StandardOutput" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.Process> zapisuje tekst jego Standardowy strumień, że tekst jest zwykle wyświetlany w konsoli. Przez ustawienie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> do `true` przekierować <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia, można manipulować lub pominąć wyjścia procesu. Na przykład możesz filtrować tekst, sformatuj go w inny sposób i zapisać dane wyjściowe do konsoli i pliku dziennika wyznaczonych.  
  
> [!NOTE]
>  Należy ustawić <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> do `false` Jeśli chcesz ustawić <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> do `true`. W przeciwnym razie odczytu z <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia zgłasza wyjątek.  
  
 Przekierowane <xref:System.Diagnostics.Process.StandardOutput%2A> synchronicznie lub asynchronicznie można odczytać strumienia. Metody, takie jak <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, i <xref:System.IO.StreamReader.ReadToEnd%2A> przeprowadzić synchronicznej operacji odczytu na strumień wyjściowy procesu. Te synchroniczne do odczytu do skojarzonego nie są wykonywane operacje <xref:System.Diagnostics.Process> zapisuje jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia lub zamyka strumienia.  
  
 Z kolei <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> uruchamia asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Ta metoda umożliwia obsługę programu obsługi zdarzeń w wyznaczonych (zobacz <xref:System.Diagnostics.Process.OutputDataReceived>) dla strumieni wyjściowych i natychmiast zwraca do obiektu wywołującego, który wykonywać inne zadania w podczas strumieni wyjściowych jest kierowany do obsługi zdarzeń.  
  
> [!NOTE]
>  Aplikacja, która jest przetwarzania asynchronicznego dane wyjściowe powinny wywoływać <xref:System.Diagnostics.Process.WaitForExit%2A> metody, aby upewnić się, że zostały opróżnione buforu wyjściowego.  
  
 Synchroniczne odczytu operacji wprowadzenie zależności między wywołującego odczytu z <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia i podrzędnego procesu zapisywanie w strumieniu. Te zależności może spowodować warunki zakleszczenia. Gdy obiekt wywołujący odczytuje z przekierowanego strumienia procesu podrzędnego, jest on zależny od elementu podrzędnego. Obiekt wywołujący oczekuje dla operacji odczytu, aż podrzędne zapisuje do strumienia lub zamyka strumienia. Podczas procesu podrzędnego zapisuje wystarczającej ilości danych w celu wypełnienia jej przekierowanego strumienia, jest on zależny od obiektu nadrzędnego. Procesu podrzędnego oczekuje dla następnej operacji zapisu, aż nadrzędnego odczytuje strumienia pełnego lub zamyka strumienia. Wyniki warunku zakleszczenie podczas wywołującego i procesu podrzędnego oczekiwania dla pozostałych do zakończenia operacji i nie można kontynuować. Można uniknąć zakleszczenie wyniku obliczenia zależności między wywołującego i procesu podrzędnego.  
  
 Na przykład następujący kod C# pokazano, jak można czytać ze strumienia przekierowane i poczekaj na zakończenie procesu podrzędnego.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 Przykładowy kod pozwala uniknąć zakleszczenie, wywołując `p.StandardOutput.ReadToEnd` przed `p.WaitForExit`. Zakleszczenie może powodować, jeśli element nadrzędny przetwarzania wywołania `p.WaitForExit` przed `p.StandardOutput.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst, aby wypełnić przekierowanego strumienia. Proces nadrzędny będzie czekać w nieskończoność na zakończenie procesu podrzędnego. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia.  
  
 Brak podobne problem podczas odczytu cały tekst z wyjście standardowe i błąd standardowy strumieni. Na przykład następujący kod C# wykonuje operację odczytu na obu strumieni.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Przykład kodu pozwala uniknąć zakleszczenia, wykonując asynchronicznych operacji odczytu na <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Zakleszczenie wyniki, jeśli element nadrzędny przetwarzania wywołania `p.StandardOutput.ReadToEnd` następuje `p.StandardError.ReadToEnd` i procesu podrzędnego zapisuje za mało tekst w celu wypełnienia jej strumień błędów. Proces nadrzędny będzie czekać w nieskończoność procesu podrzędnego zamknąć jego <xref:System.Diagnostics.Process.StandardOutput%2A> strumienia. Proces podrzędny będzie czekać w nieskończoność nadrzędnego do odczytu z w pełni <xref:System.Diagnostics.Process.StandardError%2A> strumienia.  
  
 Aby uniknąć tych zależności i ich potencjalne zakleszczenia, można użyć asynchronicznych operacji odczytu. Alternatywnie można uniknąć zakleszczenia przez utworzenie dwóch wątków i odczytywania dane wyjściowe każdego strumienia w oddzielnym wątku.  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
      </Docs>
    </Member>
    <Member MemberName="StandardErrorEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardErrorEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardErrorEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardErrorEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardErrorEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardErrorEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia preferowany kodowania danych wyjściowych błędu.</summary>
        <value>Obiekt, który reprezentuje preferowane kodowanie dla danych wyjściowych błędu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> właściwość jest `null`, proces korzysta z domyślnym kodowaniem błędów dla błędów wyjścia. <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> Właściwość musi być ustawiona przed uruchomieniem procesu. Ustawienie tej właściwości nie gwarantuje to, że proces będzie używał określonego kodowania; tylko kodowania, które obsługuje będzie używany przez proces. Aplikacja powinna być przetestowane w celu ustalenia, kodowania, które są obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardInputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardInputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardInputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardInputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardInputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardInputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardOutputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardOutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardOutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardOutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardOutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia preferowanego kodowania dla wyjścia standardowego.</summary>
        <value>Obiekt, który reprezentuje preferowane kodowanie do wyjścia standardowego. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> właściwość jest `null`, proces korzysta z domyślnym kodowaniem wyjścia standardowego dla wyjścia standardowego. <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> Właściwość musi być ustawiona przed uruchomieniem procesu. Ustawienie tej właściwości nie gwarantuje to, że proces będzie używał określonego kodowania. Aplikacji powinny być testowane w celu określenia kodowania, które obsługuje procesu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public string UserName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę użytkownika używane podczas uruchamiania procesu. Jeśli używasz formatu nazwy UPN <paramref name="user" /> @ <paramref name="DNS_domain_name" />, <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> właściwość musi być <see langword="null" />.</summary>
        <value>Nazwa użytkownika używana podczas uruchamiania procesu. Jeśli używasz formatu nazwy UPN <paramref name="user" /> @ <paramref name="DNS_domain_name" />, <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> właściwość musi być <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Musi być ustawiona właściwość, jeśli <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A> są udostępniane. Jeśli nie ustawiono właściwości, domyślny katalog roboczy jest % SYSTEMROOT%\system32.  
  
 Jeśli <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> właściwość nie jest `null` lub ciąg pusty <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwość musi być `false`, lub <xref:System.InvalidOperationException> będzie zostać zgłoszony, gdy <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseShellExecute">
      <MemberSignature Language="C#" Value="public bool UseShellExecute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseShellExecute" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberSignature Language="VB.NET" Value="Public Property UseShellExecute As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseShellExecute { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseShellExecute : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to use the operating system shell to start the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy używać powłoki systemu operacyjnego do uruchomienia procesu.</summary>
        <value>
          <see langword="true" /> Jeśli powłoki powinno być używane podczas uruchamiania procesu; <see langword="false" /> Jeśli proces powinien zostać utworzony bezpośrednio z pliku wykonywalnego. Wartość domyślna to <see langword="true" /> w aplikacjach .NET Framework i <see langword="false" /> w aplikacjach .NET Core.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości na `false` umożliwia przekierowanie strumieni danych wejściowych, wyjściowych i błędów.  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> musi być `false` Jeśli <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> właściwość nie jest `null` lub ciąg pusty lub <xref:System.InvalidOperationException> będzie zostać zgłoszony, gdy <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> metoda jest wywoływana.  
  
 Korzystając z powłoki systemu operacyjnego do uruchamiania procesów, możesz rozpocząć dokumentu (czyli dowolnego typu plików skojarzonych z pliku wykonywalnego, który ma domyślne działanie Otwórz), a wykonywanie operacji na pliku, takich jak drukowanie, za pomocą <xref:System.Diagnostics.Process> obiekt. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `false`, można uruchomić tylko pliki wykonywalne za pomocą <xref:System.Diagnostics.Process> obiektu.  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> musi być `true` Jeśli ustawisz <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> właściwości `true`.  
  
 <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Właściwości zachowuje się inaczej w zależności od wartości <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> właściwości. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> właściwość określa lokalizację pliku wykonywalnego. Jeśli <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> jest pustym ciągiem, zakłada się, że bieżący katalog zawiera pliku wykonywalnego.  
  
 Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> właściwość nie jest używana do znajdowania pliku wykonywalnego. Zamiast tego jest używany tylko przez proces, która została uruchomiona i ma znaczenie tylko w kontekście nowego procesu. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `false`, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości może być w pełni kwalifikowana ścieżka do pliku wykonywalnego lub proste nazwy pliku wykonywalnego, który system będzie podejmować próby znalezienia w folderach określonej przez zmienną środowiskową ścieżki.  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Podjęto próbę ustawienia wartości <see langword="true" /> na aplikacje systemu Windows platformy Uniwersalnej występuje.</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="Verb">
      <MemberSignature Language="C#" Value="public string Verb { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Verb" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberSignature Language="VB.NET" Value="Public Property Verb As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Verb { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Verb : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.VerbConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The verb to apply to the document specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zlecenie do używania podczas otwierania aplikacji lub dokumencie określonym przez <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> właściwości.</summary>
        <value>Działanie podejmowane w pliku otwartym w procesie. Wartość domyślna to ciąg pusty (""), która oznacza, że żadna akcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każde rozszerzenie nazwy pliku ma swój własny zestaw poleceń, które można uzyskać za pomocą <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> właściwości. Na przykład "`print`" zlecenie będzie drukować dokument określony za pomocą <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Zlecenie domyślne można określić przy użyciu pustego ciągu (""). Przykłady poleceń są "Edytuj", "Open", "OpenAsReadOnly", "Print" i "Printto". Należy używać wyłącznie zlecenia, które pojawiają się w zestawie zleceń zwróconej przez <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> właściwości.  
  
 Jeśli używasz <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> właściwość, należy uwzględnić rozszerzenie nazwy pliku podczas ustaw wartość <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. Nazwa pliku musi mieć rozszerzenie, jeśli ręcznie wprowadzić wartość <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykładowy kod uruchamia nowy proces, korzystając z określone zlecenie i nazwę pliku. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> właściwości.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#4](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#4)]
 [!code-vb[ProcessVerbs_Diagnostics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      </Docs>
    </Member>
    <Member MemberName="Verbs">
      <MemberSignature Language="C#" Value="public string[] Verbs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Verbs" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Verbs As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Verbs { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Verbs : string[]" Usage="System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw poleceń skojarzone z typem pliku określonego przez <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> właściwości.</summary>
        <value>Akcje, które system można zastosować do pliku wskazywanym przez <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Właściwość umożliwia określenie zlecenia, które mogą być używane z pliku określonego przez <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. Można ustawić <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> właściwości do wartości wszystkie zlecenie w zestawie. Przykłady poleceń są "Edytuj", "Open", "OpenAsReadOnly", "Print" i "Printto".  
  
 Jeśli używasz <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> właściwość, należy uwzględnić rozszerzenie nazwy pliku podczas ustaw wartość <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> właściwości. Rozszerzenie nazwy pliku Określa zestaw możliwych zleceń.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia określonych zleceń dla nazwy wybranego pliku. Jeśli użytkownik wybierze jeden z określonych zleceń, przykładzie uruchamia nowy proces, za pomocą wybranego zlecenia i nazwa pliku wejściowego.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#3](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#3)]
 [!code-vb[ProcessVerbs_Diagnostics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verb" />
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessWindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As ProcessWindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessWindowStyle WindowStyle { System::Diagnostics::ProcessWindowStyle get(); void set(System::Diagnostics::ProcessWindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Diagnostics.ProcessWindowStyle with get, set" Usage="System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("How the main window should be created when the process starts.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessWindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia stan okna do użycia podczas uruchamiania procesu.</summary>
        <value>Jedną z wartości wyliczenia, które wskazuje, czy proces jest uruchamiana w oknie, które jest zmaksymalizowane zminimalizowane normalny (ani zmaksymalizowane zminimalizowane), lub nie jest widoczny. Wartość domyślna to <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Styl okna nie jest jednym z <see cref="T:System.Diagnostics.ProcessWindowStyle" /> elementy członkowskie wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkingDirectory">
      <MemberSignature Language="C#" Value="public string WorkingDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkingDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkingDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkingDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WorkingDirectory : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The initial working directory for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwość jest <see langword="false" />, pobiera lub ustawia katalog roboczy dla procesu, który ma zostać uruchomiony. Gdy <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> jest <see langword="true" />, pobiera lub ustawia katalog, który zawiera proces, który ma zostać uruchomiony.</summary>
        <value>Gdy <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> jest <see langword="true" />, w pełni kwalifikowana nazwa katalog, który zawiera proces, który ma zostać uruchomiony. Gdy <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> właściwość jest <see langword="false" />, katalog roboczy dla procesu, który ma zostać uruchomiony. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Musi być ustawiona właściwość, jeśli <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> i <xref:System.Diagnostics.ProcessStartInfo.Password%2A> są udostępniane. Jeśli nie ustawiono właściwości, domyślny katalog roboczy jest % SYSTEMROOT%\system32.  
  
 Katalog jest już częścią systemu zmiennej path, nie trzeba powtórzyć lokalizację katalogu, w tej właściwości.  
  
 <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Właściwości zachowuje się inaczej po <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true` niż <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `false`. Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> właściwość określa lokalizację pliku wykonywalnego. Jeśli <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> to ciąg pusty zrozumieniu bieżący katalog zawierający plik wykonywalny.  
  
> [!NOTE]
>  Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `true`, katalog roboczy aplikacji, która rozpoczyna się plik wykonywalny jest także katalog roboczy pliku wykonywalnego.  
  
 Gdy <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> jest `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> właściwość nie jest używana do znajdowania pliku wykonywalnego. Zamiast tego wartość dotyczy proces, który jest uruchomiony i tylko ma znaczenie w kontekście nowego procesu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
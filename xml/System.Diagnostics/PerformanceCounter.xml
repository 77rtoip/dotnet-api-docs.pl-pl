<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d47684b994c25f668409bc728450e90e28479cfa" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52913484" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type PerformanceCounter = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje składnik licznika wydajności systemu Windows NT.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter> Składnika może służyć do odczytu istniejących, wstępnie zdefiniowanych lub liczników niestandardowych i publikowania wydajności (zapisywanie) dane liczników niestandardowych.  
  
 Istnieje wiele wstępnie zdefiniowanych liczniki na liście w Monitorze wydajności Windows [okno dialogowe Dodawanie liczników](https://go.microsoft.com/fwlink/p/?LinkId=257854). Aby uzyskać informacje dotyczące liczników wydajności w .NET Framework, zobacz [liczniki wydajności](~/docs/framework/debug-trace-profile/performance-counters.md).  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
> [!IMPORTANT]
>  W wersjach 1.0 i 1.1 programu .NET Framework ta klasa wymaga natychmiastowej wywołujących jest w pełni zaufany. Począwszy od programu .NET Framework w wersji 2.0, wymaga tej klasy <xref:System.Diagnostics.PerformanceCounterPermission> dla określonych akcji. Zdecydowanie zalecane jest, <xref:System.Diagnostics.PerformanceCounterPermission> nie udziela się częściowo zaufanego kodu.  Możliwość odczytu i zapisu liczniki wydajności umożliwia kodu do wykonania akcji, takich jak wyliczanie procesów wykonywania i uzyskiwanie informacji o nich.  
>   
>  Ponadto, przekazując <xref:System.Diagnostics.PerformanceCounter> obiektu na niższym poziomie zaufania kod można utworzyć problem z zabezpieczeniami. Nigdy nie przekazać wydajności licznik obiektów, takich jak <xref:System.Diagnostics.PerformanceCounterCategory> lub <xref:System.Diagnostics.PerformanceCounter>na mniejsze zaufanego kodu.  
  
 Aby zapoznać się z licznika wydajności, Utwórz wystąpienie obiektu <xref:System.Diagnostics.PerformanceCounter> klasy, należy ustawić <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>i, opcjonalnie, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> lub <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości, a następnie wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metody wydajności Odczytywanie liczników.  
  
 Aby opublikować dane licznika wydajności, należy utworzyć co najmniej jeden liczników niestandardowych za pomocą <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> metody, Utwórz wystąpienie obiektu <xref:System.Diagnostics.PerformanceCounter> klasy, należy ustawić <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> i, opcjonalnie, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> lub <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości a następnie wywołać <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, lub <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody lub zestawu <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwości, aby zmienić wartość Twojej liczników niestandardowych.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartość licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie potrzebujesz dokładności, który blokowanej operacji podane, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy lepszą wydajność.  Jednak w scenariusze wielowątkowe, niektóre aktualizacje, aby wartość licznika może być ignorowany, skutkuje niedokładne dane.  
  
 Licznik jest mechanizm według wydajności, które są zbierane dane. Rejestr przechowuje nazwy liczników, każdy z nich jest powiązany z określonego obszaru funkcji systemu. Przykłady obejmują czas zajętości procesora, wykorzystanie pamięci lub liczba bajtów odebranych za pośrednictwem połączenia sieciowego.  
  
 Każdego licznika jest unikatowo identyfikowane za pomocą nazwy i lokalizacji. W ten sam sposób, że ścieżka pliku zawiera dysk, katalogu, co najmniej jeden podkatalogów i nazwy pliku, informacje o liczniku składa się z czterech elementów: komputer, kategorii, wystąpienie kategorii i nazwę licznika.  
  
 Informacje o liczniku musi zawierać, kategorii lub obiekt wydajności, która mierzy danych. Kategorie komputera obejmują składniki fizyczne, takie jak procesory, dyski i pamięci. Dostępne są także system kategorii, takich jak procesy i wątki. Każda kategoria jest powiązana z element funkcjonalny na komputerze i ma przypisane zestaw standardowych liczników. Te obiekty są wyszczególnione na liście rozwijanej obiektu wydajności okna dialogowego Dodawanie liczników w ramach monitorowania systemu Windows 2000, i musi zawierać je w ścieżce liczników. Dane dotyczące wydajności są grupowane według kategorii, do którego jest powiązane.  
  
 W niektórych przypadkach może istnieć wiele kopii tej samej kategorii. Na przykład kilka procesy i wątki uruchomione jednocześnie, a niektóre komputery zawiera więcej niż jednego procesora. Kopie kategorii są nazywane wystąpienia kategorii, a każde wystąpienie ma zestaw liczników standardowy do niej przypisany. Jeśli kategorii może mieć więcej niż jedno wystąpienie, specyfikacja wystąpienia musi zawierać informacje o liczniku.  
  
 Aby uzyskać dane wydajności dla liczników, które są wymagane wartości początkowej lub poprzedniego do wykonywania obliczeń konieczne, należy wywołać <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metodę dwa razy i informacje zwracane jako aplikacja wymaga użycia.  
  
> [!NOTE]
>  Zainstalowane z kategorii licznika wydajności [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] oddzielne pamięci współużytkowanej, za pomocą każdej kategorii licznika wydajności własnej pamięci posiadające. Można określić rozmiar pamięci współużytkowanej oddzielne, tworząc DWORD o nazwie FileMappingSize w kluczu rejestru HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<nazwa kategorii >* \ Wydajność. Ustawiono wartość FileMappingSize rozmiar pamięci współużytkowanej kategorii. Domyślny rozmiar to 131072 dziesiętną. Jeśli nie jest obecny, wartość FileMappingSize `fileMappingSize` wartość dla atrybutu `performanceCounters` określone w pliku Machine.config jest używana, powoduje dodatkowe obciążenie przetwarzania pliku konfiguracji. Zwiększenie wydajności podczas uruchamiania aplikacji możesz uzyskać przez ustawienie rozmiaru mapowania pliku w rejestrze. Aby uzyskać więcej informacji na temat rozmiaru mapowania pliku zobacz [ &lt;liczniki wydajności&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Diagnostics.PerformanceCounter> klasa do tworzenia i używania <xref:System.Diagnostics.PerformanceCounterType.AverageCount64> licznik typu. Przykład tworzy kategorie, konfiguruje liczników, zbiera dane z liczników i wywołania <xref:System.Diagnostics.CounterSampleCalculator> klasy do interpretacji danych licznika wydajności. Wyniki pośrednie i końcowe są wyświetlane w oknie konsoli. Dodatkowe przykłady innych typów liczników wydajności, zobacz <xref:System.Diagnostics.PerformanceCounterType> wyliczenia.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy bez skojarzenia z wystąpieniem z dowolnego systemu lub licznika wydajności niestandardowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie zestawy Konstruktor <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości puste ciągi ("") i ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym (".").  
  
 Ten konstruktor nie zainicjować licznika wydajności, aby nie kojarzyć wystąpienia przy użyciu istniejącego licznika, na komputerze lokalnym. Wskaż licznika wydajności konkretnego zestawu <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>i, opcjonalnie, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> i <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości przed odczytem inne właściwości lub próby odczytu z licznika. Aby zapisać licznika wydajności, należy ustawić <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> właściwość `false`.  
  
> [!NOTE]
>  <xref:System.Security.Permissions.HostProtectionAttribute> Zastosowany do tego elementu członkowskiego ma <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A> wartość właściwości: <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState>. Atrybut <xref:System.Security.Permissions.HostProtectionAttribute> nie ma wpływu na aplikacje pulpitu (które typowo są uruchamiane przez dwukrotne kliknięcie ikony, wpisanie polecenia albo wprowadzenie adresu URL w przeglądarce). Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.HostProtectionAttribute> klasy lub [programowania programu SQL Server i atrybuty ochrony hosta](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy domyślne wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> wartości właściwości są zestawu i wyniki wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metody są wyświetlane.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub licznika wydajności niestandardowe na komputerze lokalnym. Ten konstruktor musi mieć czy kategoria pojedynczego wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametr nie jest rozróżniana wielkość liter.  
  
 To przeciążenie umożliwia dostęp do liczników na komputerze lokalnym, który należy do kategorii zawierającą wystąpienia kategorii licznika wydajności pojedynczej. Jeśli spróbujesz użyć tego konstruktora, aby wskazać to <xref:System.Diagnostics.PerformanceCounter> wystąpienia do kategorii, która zawiera wiele wystąpień, Konstruktor zgłaszającej wyjątek. Tego przeciążenia można uzyskać dostęp wszystkie tylko do odczytu lub odczytu i zapisu licznika, ale tak nie jest w trybie tylko do odczytu. A <xref:System.Diagnostics.PerformanceCounter> wystąpienia utworzone za pomocą tego przeciążenia nie można zapisać do licznika, nawet w przypadku licznika odczytu/zapisu.  
  
 To przeciążenie zestawy Konstruktor <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwości do wartości należy przekazać, ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym "." i ustawia <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości na ciąg pusty ("").  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie przy użyciu istniejącego licznika (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które są przekazywane w dla <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwości musi się odnosić do istniejącego licznika wydajności na komputerze lokalnym.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="counterName" /> jest pustym ciągiem ("").  
  
—lub— 
Nie ma określonej kategorii.  
  
—lub— 
Określonej kategorii jest oznaczony jako obejmujące wiele wystąpień i wymaga licznika wydajności do utworzenia z nazwą wystąpienia.  
  
—lub— 
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="readOnly">
          <see langword="true" /> do dostępu do liczników w trybie tylko do odczytu (chociaż licznika może być odczytu/zapisu); <see langword="false" /> dostępu licznika w trybie odczytu i zapisu do.</param>
        <summary>Inicjuje nowy, tylko do odczytu lub odczytu/zapisu wystąpienia <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub licznika wydajności niestandardowe na komputerze lokalnym. Ten konstruktor wymaga, że kategoria zawiera jedno wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametr nie jest rozróżniana wielkość liter.  
  
 To przeciążenie umożliwia dostęp tylko do odczytu lub odczytu i zapisu licznik na komputerze lokalnym, który należy do kategorii zawierającą wystąpienia kategorii licznika wydajności pojedynczej. Jeśli spróbujesz użyć tego konstruktora, aby wskazać to <xref:System.Diagnostics.PerformanceCounter> wystąpienia do kategorii, która zawiera wiele wystąpień, Konstruktor zgłaszającej wyjątek.  
  
 To przeciążenie zestawy Konstruktor <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> właściwości do wartości należy przekazać, ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym "." i ustawia <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości na ciąg pusty ("").  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie przy użyciu istniejącego licznika (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które są przekazywane w dla <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwości musi się odnosić do istniejącego licznika wydajności na komputerze lokalnym. Jeśli wystąpienie licznika wydajności, wskazujące na nie jest prawidłowy, wywołanie konstruktora, zgłasza wyjątek.  
  
> [!NOTE]
>  Tego przeciążenia można używać, połączyć się z liczników systemu, ale nie można zapisać liczników systemu. W związku z tym, ustawienie `readOnly` do `false` podczas nawiązywania połączenia z liczników systemu powoduje, że konstruktora, aby zgłosić wyjątek.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy. Przykład przekazuje nazwy kategorii, nazwy licznika i wartość flagi wskazującą, że licznik nie jest tylko do odczytu. Ten przykład kodu jest częścią większego przykładu dla <xref:System.Diagnostics.PerformanceCounter> klasy.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> Jest pustym ciągiem ("").  
  
—lub— 
<paramref name="counterName" /> Jest pustym ciągiem ("").  
  
—lub— 
Nie ma określonej kategorii. (Jeśli <paramref name="readOnly" /> jest <see langword="true" />).  
  
—lub— 
Określonej kategorii nie jest kategorię niestandardową w programie .NET Framework (Jeśli <paramref name="readOnly" /> jest <see langword="false" />).  
  
—lub— 
Określonej kategorii jest oznaczony jako obejmujące wiele wystąpień i wymaga licznika wydajności do utworzenia z nazwą wystąpienia.  
  
—lub— 
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="instanceName">Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli kategoria zawiera jedno wystąpienie.</param>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub wystąpienia licznika i kategorii wydajności niestandardowe na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametr nie jest rozróżniana wielkość liter.  
  
 To przeciążenie zestawy Konstruktor <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości do wartości możesz przekazać i ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym ".".  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie przy użyciu istniejącego licznika (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które są przekazywane w dla <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości musi się odnosić do istniejącego licznika wydajności na komputerze lokalnym. Jeśli wystąpienie licznika wydajności, które wskażesz nie jest prawidłowy, wywołanie konstruktora, zgłasza wyjątek.  
  
 Tego przeciążenia można uzyskać dostęp wszystkie tylko do odczytu lub odczytu i zapisu licznika, ale tak nie jest w trybie tylko do odczytu. A <xref:System.Diagnostics.PerformanceCounter> wystąpienia utworzone za pomocą tego przeciążenia nie można zapisać do licznika, nawet w przypadku licznika odczytu/zapisu.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="counterName" /> jest pustym ciągiem ("").  
  
—lub— 
Określonej kategorii jest nieprawidłowa.  
  
—lub— 
Określonej kategorii jest oznaczony jako obejmujące wiele wystąpień i wymaga licznika wydajności do utworzenia z nazwą wystąpienia.  
  
—lub— 
 <paramref name="instanceName" /> jest dłuższa niż 127 znaków.  
  
—lub— 
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="instanceName">Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli kategoria zawiera jedno wystąpienie.</param>
        <param name="readOnly">
          <see langword="true" /> Aby dostęp do liczników w trybie tylko do odczytu; <see langword="false" /> dostępu licznika w trybie odczytu/zapisu do.</param>
        <summary>Inicjuje nowy, tylko do odczytu lub odczytu/zapisu wystąpienia <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub wystąpienia licznika i kategorii wydajności niestandardowe na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametr nie jest rozróżniana wielkość liter.  
  
 To przeciążenie umożliwia dostęp licznika wydajności w jednym tylko do odczytu lub w trybie odczytu/zapisu.  
  
 To przeciążenie zestawy Konstruktor <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości do wartości są przekazywane w go i zestawy <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym ".".  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie przy użyciu istniejącego licznika (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które są przekazywane w dla <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości musi się odnosić do istniejącego licznika wydajności na komputerze lokalnym. Jeśli wystąpienie licznika wydajności, wskazujące na nie jest prawidłowy, wywołanie konstruktora, zgłasza wyjątek.  
  
> [!NOTE]
>  Tego przeciążenia można używać, połączyć się z liczników systemu, ale nie można zapisać liczników systemu. W związku z tym, ustawienie `readOnly` do `false` podczas nawiązywania połączenia z liczników systemu powoduje, że konstruktora, aby zgłosić wyjątek.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="counterName" /> jest pustym ciągiem ("").  
  
—lub— 
Ustawienia żądane uprawnienia odczytu/zapisu jest nieprawidłowy dla tego licznika.  
  
—lub— 
Nie ma określonej kategorii (Jeśli <paramref name="readOnly" /> jest <see langword="true" />).  
  
—lub— 
Określonej kategorii nie jest kategorię niestandardową w programie .NET Framework (Jeśli <paramref name="readOnly" /> jest <see langword="false" />).  
  
—lub— 
Określonej kategorii jest oznaczony jako obejmujące wiele wystąpień i wymaga licznika wydajności do utworzenia z nazwą wystąpienia.  
  
—lub— 
 <paramref name="instanceName" /> jest dłuższa niż 127 znaków.  
  
—lub— 
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="instanceName">Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli kategoria zawiera jedno wystąpienie.</param>
        <param name="machineName">Komputer, na którym istnieją licznika wydajności i jego skojarzonej kategorii.</param>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub wydajność — niestandardowy licznika i Kategoria wystąpienia na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametr nie jest rozróżniana wielkość liter.  
  
 To przeciążenie zestawy Konstruktor <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, i <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości do wartości przekazanej.  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie przy użyciu istniejącego licznika (system lub liczników niestandardowych), na określonym komputerze. Wartości, które są przekazywane w dla <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> i <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości musi się odnosić do istniejącego licznika wydajności. Jeśli wystąpienie licznika wydajności, które wskażesz nie jest prawidłowy, wywołanie konstruktora, zgłasza wyjątek. Tego przeciążenia można uzyskać dostęp wszystkie tylko do odczytu lub odczytu i zapisu licznika, ale tak nie jest w trybie tylko do odczytu. A <xref:System.Diagnostics.PerformanceCounter> wystąpienia utworzone za pomocą tego przeciążenia nie można zapisać do licznika, nawet w przypadku licznika odczytu/zapisu.  
  
> [!NOTE]
>  Nie można zapisać liczniki wydajności zdalnego. Istnieje żadne przeciążenie, która pozwala na określenie wystąpienia odczytu/zapisu w programu <xref:System.Diagnostics.PerformanceCounter> klasy, który nawiązuje połączenie z komputerem zdalnym.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
> [!NOTE]
>  Windows Vista gdy komputer zdalny jest członkiem grupy roboczej, konieczne może być wyłączenie funkcji Kontrola konta użytkownika, aby konto użytkownika lokalnego nie jest filtrowany i może być z podwyższonym poziomem uprawnień do konta administratora. Ze względów bezpieczeństwa wyłączenie funkcji Kontrola konta użytkownika powinny być tylko w ostateczności. Aby uzyskać informacji na temat wyłączania kontroli konta użytkownika, zobacz [Kontrola konta użytkownika i WMI](https://go.microsoft.com/fwlink/?LinkId=91617).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="counterName" /> jest pustym ciągiem ("").  
  
—lub— 
Ustawienia żądane uprawnienia odczytu/zapisu jest nieprawidłowy dla tego licznika.  
  
—lub— 
Ten licznik nie istnieje na określonym komputerze.  
  
—lub— 
Określonej kategorii jest oznaczony jako obejmujące wiele wystąpień i wymaga licznika wydajności do utworzenia z nazwą wystąpienia.  
  
—lub— 
 <paramref name="instanceName" /> jest dłuższa niż 127 znaków.  
  
—lub— 
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="performanceCounter.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się inicjowanie <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienie używane w formularzu lub przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> Metoda kończy się inicjowanie. Za pomocą <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> i <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem składnika.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę kategorii licznika wydajności dla tego licznika wydajności.</summary>
        <value>Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Jest wyświetlany w `Performance Object` pole przystawki programu MMC Menedżer licznika wydajności w firmy `Add Counter` okno dialogowe.  
  
 Licznik wydajności monitoruje zachowanie kategorii lub obiekt wydajności na komputerze. Kategorie obejmują składniki fizyczne (takie jak procesory, dyski i pamięci) i obiektów systemowych (takich jak procesy i wątki). Liczniki systemu, które są powiązane z tego samego obiektu wydajności są zgrupowane w kategorii, która wskazuje skoncentruje wspólnej. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter> klasy, należy najpierw wskazują kategorii za pomocą którego należy ten składnik będzie interaktywnie korzystać, a następnie wybierz licznik z tej kategorii.  
  
 Na przykład jedną kategorię licznika Windows jest kategoria pamięci. Liczniki systemu w ramach tej kategorii śledzić dane pamięci, takie jak liczba dostępnych bajtów i liczby bajtów pamięci podręcznej. Jeśli chcesz pracować z bajtów pamięci podręcznej w aplikacji, należy utworzyć wystąpienie <xref:System.Diagnostics.PerformanceCounter> składnik, połącz go z kategorii pamięci, a następnie wybierz odpowiedniego licznika (w tym przypadku buforowanych bajtów) z tej kategorii.  
  
 Mimo że system udostępnia wiele więcej kategorii licznika, kategorie, które będą prawdopodobnie interakcji z najczęściej są kategorie pamięci podręcznej, pamięci, obiekty, dysk fizyczny, proces, procesora, Server, systemu i wątku.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy domyślne wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> wartości właściwości są zestawu i wyniki wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metody są wyświetlane.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="performanceCounter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka licznik wydajności i zwalnia wszystkie zasoby przydzielone przez to wystąpienie licznika wydajności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po skojarzeniu to <xref:System.Diagnostics.PerformanceCounter> wystąpienia licznika wydajności, która znajduje się na serwerze systemu inicjuje wystąpienie i przydziela pamięć zawiera informacje o liczniku próbki. <xref:System.Diagnostics.PerformanceCounter.Close%2A> Metoda zwalnia zasoby przydzielone przez obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberSignature Language="F#" Value="static member CloseSharedResources : unit -&gt; unit" Usage="System.Diagnostics.PerformanceCounter.CloseSharedResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia przydzielonej przez liczniki stanie Biblioteka udostępniona licznika wydajności.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterHelp : string" Usage="System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterHelp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opis dla tego licznika wydajności.</summary>
        <value>Opis elementu lub liczba, która mierzy ten licznik wydajności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno dialogowe Dodawanie liczników z przystawki MMC Menedżer licznika wydajności w wyświetlaniu <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> tekstu, gdy użytkownik wybiera licznik z listy liczników, a następnie klika przycisk wyjaśnienia.  
  
 Gdy tworzysz nowy licznik, użyj <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> tekst opisujący licznik monitoruje zrobić użytkownika można określić, czy można dodać licznika do ekranu Monitora systemu.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.PerformanceCounter" /> Wystąpienia nie jest skojarzony z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CounterName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę licznika wydajności, który jest skojarzony z tym <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienia.</summary>
        <value>Nazwa licznika, który opisano ilość podwójnemu. Ta nazwa będzie wyświetlana na liście liczników MMC Menedżer licznika wydajności przystawkę przez okno dialogowe Dodawanie liczników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz uzyskać listę dostępnych liczników istniejące z Windows wydajności Menedżera [okno dialogowe Dodawanie liczników](https://go.microsoft.com/fwlink/p/?LinkId=257854).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawić <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwość na nazwę typowych liczników.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterType : System.Diagnostics.PerformanceCounterType" Usage="System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ licznika licznika wydajności skojarzonego.</summary>
        <value>Element <see cref="T:System.Diagnostics.PerformanceCounterType" /> , który opisuje zarówno jak licznik współdziała z monitorowania aplikacji i charakteru wartości które zawiera (na przykład, obliczona lub nieobliczone).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterType> Wyliczenia zawiera typy, liczników wydajności, współpracujące z usługą. Niektóre typy licznika reprezentują obliczone wartości, takich jak average pomiarów licznika, który podjął systemu. Inne typy reprezentują nieprzetworzoną lub nieobliczoną wartości. W poniższej tabeli przedstawiono typy liczników, które będziesz korzystać z najczęściej.  
  
|Odpowiedzialność licznika|Wartość PerformanceCounterType|Przykład|  
|------------------------------|----------------------------------|-------------|  
|Obsługa proste liczba elementów lub operacji.|`NumberOfItems32`|Śledzenie liczbę zamówień odebrana jako 32-bitową liczbę całkowitą.|  
|Obsługa liczbą proste lepszą wydajność.|`NumberOfItems64`|Śledzenie liczby zamówień dla lokacji, z bardzo dużą, przechowywane jako 64-bitową liczbę całkowitą.|  
|Śledź liczbę elementów lub operacje na sekundę.|`RateOfCountsPerSecond32`|Śledzenie zamówień, odebranych na sekundę w lokacji.|  
|Śledź większej pojemności liczba elementów lub operacje na sekundę.|`RateOfCountsPerSecond64`|Śledzenie zamówień odebranych na sekundę w witrynie za pomocą bardzo dużych ilościach.|  
|Obliczenia średniego czasu wykonania procesu lub przetworzyć elementu|`AverageTimer32`|Obliczenia średniego czasu, jaką zamówienie do przetworzenia.|  
  
 Podczas tworzenia licznika, którego typ wymaga użycia odpowiedniego licznik podstawowy musi deklarować licznik i base w <xref:System.Diagnostics.CounterCreationDataCollection> przekazać do <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberSignature Language="F#" Value="member this.Decrement : unit -&gt; int64" Usage="performanceCounter.Decrement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dekrementuje licznika wydajności skojarzonego jeden przez skuteczną niepodzielną operację.</summary>
        <returns>Zmniejszona wartość licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz zapisywać tylko liczników niestandardowych. Wszystkie liczniki systemu są przeznaczone tylko do odczytu.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartość licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie potrzebujesz dokładności, który blokowanej operacji podane, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy lepszą wydajność.  Jednak w scenariusze wielowątkowe, niektóre aktualizacje, aby wartość licznika może być ignorowany, skutkuje niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Licznik jest tylko do odczytu, dzięki czemu aplikacja nie może zmniejszyć go.  
  
—lub— 
Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Ta metoda nie jest metodą o bezpiecznych wątkach.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultFileMappingSize : int" Usage="System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa rozmiar w bajtach pamięci globalnej współużytkowane przez liczniki wydajności. Domyślny rozmiar to 524,288 bajtów.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="performanceCounter.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienia, który jest używany w formularzu lub przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> Metoda uruchamia inicjowania. Za pomocą <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> i <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem składnika.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberSignature Language="F#" Value="member this.Increment : unit -&gt; int64" Usage="performanceCounter.Increment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwiększa wartość licznika wydajności skojarzonego jeden przez skuteczną niepodzielną operację.</summary>
        <returns>Zwiększona wartość licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz zapisywać tylko liczników niestandardowych. Wszystkie liczniki systemu są przeznaczone tylko do odczytu.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartość licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie potrzebujesz dokładności, który blokowanej operacji podane, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy lepszą wydajność.  Jednak w scenariusze wielowątkowe, niektóre aktualizacje, aby wartość licznika może być ignorowany, skutkuje niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Licznik jest tylko do odczytu, dzięki czemu aplikacja nie może zwiększyć go.  
  
—lub— 
Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Ta metoda nie jest metodą o bezpiecznych wątkach.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int64 -&gt; int64" Usage="performanceCounter.IncrementBy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zwiększenia. (Ujemnych wartości zmniejsza wartość licznika.)</param>
        <summary>Zwiększa lub zmniejsza wartość licznika wydajności skojarzonego przez określoną ilość poprzez skuteczną niepodzielną operację.</summary>
        <returns>Nowa wartość licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz zapisywać tylko liczników niestandardowych. Wszystkie liczniki systemu są przeznaczone tylko do odczytu.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartość licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie potrzebujesz dokładności, który blokowanej operacji podane, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy lepszą wydajność.  Jednak w scenariusze wielowątkowe, niektóre aktualizacje, aby wartość licznika może być ignorowany, skutkuje niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> metody w celu dodania zwiększa się licznika. Ten przykład kodu jest częścią większego przykładu dla <xref:System.Diagnostics.PerformanceCounter> klasy.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Licznik jest tylko do odczytu, dzięki czemu aplikacja nie może zwiększyć go.  
  
—lub— 
Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> właściwość <see langword="false" />. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Ta metoda nie jest metodą o bezpiecznych wątkach.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceLifetime : System.Diagnostics.PerformanceCounterInstanceLifetime with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okres istnienia procesu.</summary>
        <value>Jedną z <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> wartości. Wartość domyślna to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kategorii licznika wydajności jest tworzona przy użyciu .NET Framework w wersji 1.0 i 1.1, używa globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.CounterType%2A> właściwość <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>, <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> wartość licznika wydajności musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość nie jest członkiem <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> wyliczenia.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> jest ustawiany po <see cref="T:System.Diagnostics.PerformanceCounter" /> został zainicjowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę instancji dla tego licznika wydajności.</summary>
        <value>Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli licznik jest licznikiem jednego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nazwy wystąpień musi zawierać mniej niż 128 znaków.  
  
 W niektórych sytuacjach kategorie są podzielone na wystąpień, które śledzą dane dotyczące wielu wystąpień obiektu, który dotyczy kategorii. Wystąpienia mają zastosowanie do kategorii jako całości, a nie do poszczególnych liczników. Każdy liczników w ramach kategorii ma każde wystąpienie zdefiniowane dla tej kategorii. Na przykład kategoria procesu zawiera wystąpienia o nazwie bezczynne i systemu. Co licznika w kategorii procesu związku z tym zawiera dane dla każdego wystąpienia, przedstawiający informacje na temat bezczynne procesy lub procesy systemowe.  
  
 Wiele kategorii nie zawierają wiele wystąpień, dzięki czemu tę właściwość można pozostawić puste, aby wskazać, że żadne wystąpienie jest skojarzony z kategorii.  
  
 Jeśli ten <xref:System.Diagnostics.PerformanceCounter> wystąpienia punktów z kategorią standardowych mogą wybierać tylko istniejących wystąpień kategorii. Nowe wystąpienia kategorii można utworzyć tylko w kategorii niestandardowych, dzięki czemu można zdefiniować jako wiele liczników i kategoria wystąpień, ilu potrzebujesz.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Nie używaj znaków "(",")", "#", "\\", lub "/" w nazwie wystąpienia. Jeśli używane są dowolne spośród tych znaków, wydajność konsoli (zobacz [profilowanie środowiska uruchomieniowego](~/docs/framework/debug-trace-profile/runtime-profiling.md)) wartości wystąpienia nie może być poprawnie wyświetlany.  
  
 Jeśli nazwa wystąpienia jest generowany automatycznie i może zawierać znaków "(",")", "#", "\\", lub "/", użyj mapowanie znaków w poniższej tabeli.  
  
|Znak|Zamapowane znaków|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|\_|  
|\|_|  
|/|\_|  
  
 <xref:System.AppDomain.FriendlyName%2A> Właściwość <xref:System.AppDomain> uzyskanego z <xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType> właściwość jest wspólne źródło nazwy wystąpienia, które może zawierać nieprawidłowych znaków.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy domyślne wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> wartości właściwości są zestawu i wyniki wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metody są wyświetlane.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera dla tego licznika wydajności</summary>
        <value>Serwer, na którym znajdują się liczników wydajności i jego skojarzonej kategorii.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz zapisywać wartości tylko liczniki, które znajdują się na komputerze lokalnym. Można jednak odczytać wartości liczników za pomocą dowolnego komputera w przedsiębiorstwie, dla której masz uprawnienia dostępu.  
  
 Po ustawieniu <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości, aby wskazywała na komputerze zdalnym <xref:System.Diagnostics.PerformanceCounter> wystąpienia próbuje otworzyć licznik na tym komputerze. Jeśli licznik nie istnieje, ustawienie tej właściwości zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.PerformanceCounter.MachineName" /> Format jest nieprawidłowy.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberSignature Language="F#" Value="member this.NextSample : unit -&gt; System.Diagnostics.CounterSample" Usage="performanceCounter.NextSample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje próbkę licznika oraz zwraca nieprzetworzoną lub nieobliczoną wartość.</summary>
        <returns>A <see cref="T:System.Diagnostics.CounterSample" /> reprezentujący następną nieprzetworzoną wartość system uzyskuje dla tego licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana dla liczników, które zawierają wartości nieobliczone.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> metodę, aby uzyskać dalej nieobliczone wartość licznika. Ten przykład kodu jest częścią większego przykładu dla <xref:System.Diagnostics.PerformanceCounter> klasy.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberSignature Language="F#" Value="member this.NextValue : unit -&gt; single" Usage="performanceCounter.NextValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje próbkę licznika oraz zwraca obliczoną wartość.</summary>
        <returns>Dalej obliczona wartość uzyskujący systemu dla tego licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli obliczona wartość licznika zależy od dwa odczyty licznik, w pierwszej operacji odczytu zwraca wartość 0,0. Resetowanie właściwości licznika wydajności, aby określić inny licznik jest odpowiednikiem tworzenie nowy licznik wydajności i pierwszej operacji odczytu przy użyciu nowych właściwości zwraca wartość 0,0. Czas opóźnienia zalecany między wywołaniami <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metodą jest jedna sekunda, umożliwia licznika do wykonania w następnym odczytem przyrostowe.  
  
> [!NOTE]
>  Aby uzyskać liczniki wydajności, musi mieć uprawnienia administracyjne. W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterType.ElapsedTime> licznika i używa <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metodę, aby wyświetlić wartości liczników w przedziale czasu.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.RawValue : int64 with get, set" Usage="System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_RawValue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nieprzetworzoną lub nieobliczoną wartość tego licznika.</summary>
        <value>Nieprzetworzona wartość licznika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz ustawić tę właściwość na wartość, która jest zbyt duży, aby dopasować typ licznika jest rozmiar 32-bitowych, właściwość obcina wartość do 32 bitów. Podczas odczytywania liczników niestandardowych na komputerze lokalnym, za pomocą <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwości, a nie obliczonej wartości może spowodować znacznie lepszą wydajność w scenariuszach, gdzie wartość Nieprzetworzona jest wystarczająca.  
  
 Jeśli licznik, który podczas odczytu jest tylko do odczytu, wprowadzenie <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość próbek licznika w czasie, który nosi nazwę właściwości. Ta akcja jest odpowiednikiem początkowego wywołania do <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> metody. Jeśli potem zostanie wywołana <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>, można przeprowadzić obliczenia na podstawie wartości, które zwróciły obu tych wywołań.  
  
 Ponieważ liczniki systemu są tylko do odczytu, możesz uzyskać, ale nieustawiona ich wartości w wierszach.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartość licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie potrzebujesz dokładności, który blokowanej operacji podane, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy lepszą wydajność.  Jednak w scenariusze wielowątkowe, niektóre aktualizacje, aby wartość licznika może być ignorowany, skutkuje niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Do odczytu liczników wydajności w Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub uprawnień administracyjnych.  
>   
>  Aby uniknąć konieczności podwyższenie swoje uprawnienia do dostępu do liczników wydajności w Windows Vista, Dołącz do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Diagnostics.CounterSample> klasy, aby wyświetlić wartość <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwości dla licznika.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbujesz ustawić wartość Nieprzetworzona wartość licznika, ale ten licznik jest tylko do odczytu.  
  
—lub— 
Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu z licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_ReadOnly")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy to <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienie jest w trybie tylko do odczytu.</summary>
        <value>
          <see langword="true" />, jeśli <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienie jest w trybie tylko do odczytu (nawet jeśli licznika jest niestandardowych liczników .NET Framework); <see langword="false" /> jeśli znajduje się w trybie odczytu i zapisu. Wartość domyślna to wartość ustawioną przy użyciu konstruktora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla licznika system <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> powinni zawsze `true`. Nie można zapisać liczników systemu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberSignature Language="F#" Value="member this.RemoveInstance : unit -&gt; unit" Usage="performanceCounter.RemoveInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wystąpienie kategorii określone przez <see cref="T:System.Diagnostics.PerformanceCounter" /> obiektu <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można usunąć wystąpienia tylko w przypadku liczników niestandardowych. Wszystkie liczniki systemu są tylko do odczytu, więc próby usunięcia jednego z nich zgłasza wyjątek.  
  
> [!NOTE]
>  Aby uniknąć sytuacji wyścigu możliwe po zwolnieniu pamięci udostępnione licznika wydajności, zalecane jest, <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> można wywołać metody z <xref:System.AppDomain.DomainUnload> programu obsługi zdarzeń.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności został utworzony za pomocą .NET Framework w wersji 1.0 i 1.1, <xref:System.InvalidOperationException> zgłaszany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach, globalnej pamięci współdzielonej, a wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategorii nie jest używany przez aplikacje działające w wersjach 1.0 i 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten licznik jest tylko do odczytu, więc nie można usunąć dowolne wystąpienie, który jest skojarzony z tej kategorii.  
  
—lub— 
Wystąpienie nie jest prawidłowo skojarzone z licznika wydajności.  
  
—lub— 
<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> po użyciu globalnego pamięć współużytkowaną.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma jest Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do zapisywania kategorii licznika wydajności. Powiązane wyliczenie: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ab683a58bdb6ba8eb978fb164cb7aa4c138637c7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30449691" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Oznacza składnik licznika wydajności systemu Windows NT.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter> Składnika może służyć do odczytywanie istniejących, wstępnie zdefiniowanych lub liczników niestandardowych i publikowania wydajności (zapis) danych w licznikach niestandardowych.  
  
 Istnieją wiele wstępnie zdefiniowanych liczniki Monitora wydajności systemu Windows na liście [okno dialogowe Dodawanie liczników](http://go.microsoft.com/fwlink/p/?LinkId=257854). Aby uzyskać informacje dotyczące liczników wydajności .NET Framework, zobacz [liczniki wydajności](~/docs/framework/debug-trace-profile/performance-counters.md).  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
> [!IMPORTANT]
>  W wersjach 1.0 i 1.1 programu .NET Framework ta klasa wymaga natychmiastowego wywołującym być w pełni zaufany. Ta klasa w programie .NET Framework w wersji 2.0, wymaga <xref:System.Diagnostics.PerformanceCounterPermission> dla określonych akcji. Zdecydowanie zalecane jest <xref:System.Diagnostics.PerformanceCounterPermission> nie udziela się częściowo zaufanego kodu.  Odczyt i zapis liczniki wydajności możliwości kod, aby wykonać akcje, takie jak wyliczania wykonywane procesy i uzyskiwanie informacji o nich.  
>   
>  Ponadto przekazywanie <xref:System.Diagnostics.PerformanceCounter> obiekt na niższym poziomie zaufania kod może utworzyć problem z zabezpieczeniami. Nigdy nie takich jak przekazać wydajności obiektów licznika <xref:System.Diagnostics.PerformanceCounterCategory> lub <xref:System.Diagnostics.PerformanceCounter>, do mniej zaufanego kodu.  
  
 Aby odczytać z licznika wydajności, Utwórz wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy, ustaw <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>i, opcjonalnie, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> lub <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości, a następnie wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metodę wydajności Odczytywanie liczników.  
  
 Do publikowania danych licznika wydajności, należy utworzyć jeden lub więcej liczników niestandardowych za pomocą <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> metody, Utwórz wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy, ustaw <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> i, opcjonalnie, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> lub <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości a następnie wywołać <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, lub <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody lub zestawu <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwości, aby zmienić wartość z liczników niestandardowych.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartości licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie ma potrzeby dokładności blokowanej operacji Podaj, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy zwiększenie wydajności.  Jednak w scenariuszach wielowątkowe niektóre aktualizacje, aby wartość licznika może być ignorowane, niedokładne dane.  
  
 Licznik jest mechanizm przez wydajności, które są zbierane dane. Rejestr przechowuje nazwy wszystkich liczników, z których każdy jest powiązany z określonego obszaru funkcji systemu. Przykładami czasu zajętości procesora, wykorzystanie pamięci lub liczbę bajtów odebranych za pośrednictwem połączenia sieciowego.  
  
 Każdy licznik jest unikatowo identyfikowana przy użyciu nazwy i lokalizacji. W ten sam sposób, że ścieżka pliku zawiera dysk, katalogu, co najmniej jeden podkatalogi i nazwę pliku, informacje o liczniku składa się z czterech elementów: komputer, kategoria, wystąpienie kategorii i nazwę licznika.  
  
 Informacje o liczniku musi zawierać kategorii lub obiektu wydajności, które mierzy danych. Kategorie komputera obejmują składniki fizyczne, takie jak procesory, dyski i pamięci. Istnieją również system kategorii, procesów i wątków. Każda kategoria powiązany jest element funkcjonalny na komputerze i ma przypisany zestaw standardowych liczników. Te obiekty są wyszczególnione na liście rozwijanej wydajności obiektu okna dialogowego Dodawanie liczników w ramach monitorowania systemu Windows 2000 i należy je uwzględnić w ścieżki licznika. Dane dotyczące wydajności są grupowane według kategorii, z którym jest powiązane.  
  
 W niektórych przypadkach może istnieć wiele kopii tej samej kategorii. Na przykład wiele procesów i wątków działać jednocześnie, a niektóre komputery zawiera więcej niż jeden procesor. Kopie kategorii są nazywane wystąpień kategorii, a każde wystąpienie ma zestaw liczników standardowe przypisane do niej. Jeśli kategorii może mieć więcej niż jedno wystąpienie, specyfikacja wystąpienie musi być uwzględniona w informacjach dotyczących licznika.  
  
 Aby uzyskać dane o wydajności dla liczników, które są wymagane do wykonania niezbędnych obliczeń początkowej lub poprzedniej wartości, należy wywołać <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> dwukrotnie metody i informacje zwracane jako aplikacja wymaga użycia.  
  
> [!NOTE]
>  Kategorii licznika wydajności z zainstalowanym [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] oddzielne pamięci współużytkowanej, za pomocą każdej kategorii licznika wydajności posiadanie własnej pamięci. Można określić rozmiar pamięci współużytkowanej oddzielne tworząc DWORD o nazwie FileMappingSize w kluczu rejestru HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<nazwa kategorii >* \ Wydajność. Wartość FileMappingSize jest ustawiona na rozmiar pamięci współużytkowanej kategorii. Rozmiar domyślny to 131072 dziesiętną. Jeśli wartość FileMappingSize nie jest obecny, `fileMappingSize` wartość dla atrybutu `performanceCounters` element określony w pliku Machine.config jest używana, powoduje dodatkowe obciążenie przetwarzania pliku konfiguracji. Można zrealizować poprawy wydajności w przypadku uruchamiania aplikacji przez ustawienie rozmiaru mapowania pliku w rejestrze. Aby uzyskać więcej informacji na temat rozmiaru mapowania pliku, zobacz [ &lt;liczniki wydajności&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Diagnostics.PerformanceCounter> klasa do tworzenia i używania <xref:System.Diagnostics.PerformanceCounterType.AverageCount64> licznika typu. Przykład tworzy kategorii konfiguruje liczników, zbiera dane z liczników i wywołania <xref:System.Diagnostics.CounterSampleCalculator> klasy interpretować dane licznika wydajności. W oknie konsoli są wyświetlane wyniki pośrednie i końcowe. Dodatkowe przykłady inne typy liczników wydajności można znaleźć <xref:System.Diagnostics.PerformanceCounterType> wyliczenia.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy bez kojarzenia wystąpienie z systemu lub licznika wydajności niestandardowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie ustawia konstruktora <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości, które mają puste ciągi ("") i ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym (".").  
  
 Ten konstruktor nie zainicjować licznika wydajności, aby nie kojarzyć wystąpienie licznika istniejących na komputerze lokalnym. Aby wskazywała licznika wydajności zależnych, ustaw <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>i, opcjonalnie, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> i <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości przed przeczytaniem inne właściwości lub odczytywania licznika. Aby zapisać w liczniku wydajności, należy ustawić <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> właściwości `false`.  
  
> [!NOTE]
>  <xref:System.Security.Permissions.HostProtectionAttribute> Atrybut zastosowany do tego elementu członkowskiego zawiera następujące <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A> wartość właściwości: <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState>. Atrybut <xref:System.Security.Permissions.HostProtectionAttribute> nie ma wpływu na aplikacje pulpitu (które typowo są uruchamiane przez dwukrotne kliknięcie ikony, wpisanie polecenia albo wprowadzenie adresu URL w przeglądarce). Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.HostProtectionAttribute> klasy lub [atrybuty ochrony hosta i programowanie programu SQL Server](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie domyślne <xref:System.Diagnostics.PerformanceCounter> klasy. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> wartości właściwości są zestawu i wyniki wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metody są wyświetlane.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub licznika wydajności niestandardowe na komputerze lokalnym. Ten konstruktor musi mieć kategorię pojedynczego wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametru nie jest rozróżniana.  
  
 To przeciążenie umożliwia dostęp do licznika, na komputerze lokalnym, który należy do kategorii zawierające wystąpienie kategorii licznika wydajności pojedynczego. Jeśli spróbujesz użyć tego konstruktora do tego punktu <xref:System.Diagnostics.PerformanceCounter> wystąpienia kategorię, która zawiera wiele wystąpień, Konstruktor zwraca wyjątek. To przeciążenie można uzyskać dostępu do żadnych tylko do odczytu lub odczytu/zapisu licznika, ale w trybie tylko do odczytu. A <xref:System.Diagnostics.PerformanceCounter> wystąpienia utworzone za pomocą tego przeciążenia nie można zapisać do licznika, nawet jeśli licznika jest odczytu/zapisu.  
  
 To przeciążenie ustawia konstruktora <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwości do wartości należy przekazać, ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym, "." i ustawia <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości na ciąg pusty ("").  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie licznika istniejących (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które przekazujesz do <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwości musi wskazywać istniejący licznika wydajności na komputerze lokalnym.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="counterName" /> to ciąg pusty ("").  
  
 —lub—  
  
 Określona kategoria nie istnieje.  
  
 —lub—  
  
 Określonej kategorii jest oznaczona jako występująca i wymaga licznika wydajności są tworzone z użyciem nazwy wystąpienia.  
  
 —lub—  
  
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="readOnly">
          <see langword="true" /> do liczników w trybie tylko do odczytu (mimo że licznika może być odczytu/zapisu); <see langword="false" /> dostępu licznika w trybie odczytu i zapisu do.</param>
        <summary>Inicjuje nowy, tylko do odczytu lub odczytu/zapisu wystąpienie <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub licznika wydajności niestandardowe na komputerze lokalnym. Ten konstruktor wymaga, aby kategoria zawiera pojedyncze wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametru nie jest rozróżniana.  
  
 To przeciążenie umożliwia dostęp tylko do odczytu lub odczytu/zapisu licznika, na komputerze lokalnym, który należy do kategorii zawierające wystąpienie kategorii licznika wydajności pojedynczego. Jeśli spróbujesz użyć tego konstruktora do tego punktu <xref:System.Diagnostics.PerformanceCounter> wystąpienia kategorię, która zawiera wiele wystąpień, Konstruktor zwraca wyjątek.  
  
 To przeciążenie ustawia konstruktora <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> właściwości do wartości należy przekazać, ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym, "." i ustawia <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości na ciąg pusty ("").  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie licznika istniejących (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które przekazujesz do <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> i <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwości musi wskazywać istniejący licznika wydajności na komputerze lokalnym. Jeśli wystąpienie licznika wydajności, które wskazują na nie jest prawidłowy, wywoływania konstruktora zgłasza wyjątek.  
  
> [!NOTE]
>  To przeciążenie można użyć do nawiązania połączenia liczników systemu, ale nie można zapisać liczników systemu. W związku z tym ustawienie `readOnly` do `false` podczas nawiązywania połączenia z liczników systemu powoduje konstruktora, aby zgłosić wyjątek.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie <xref:System.Diagnostics.PerformanceCounter> klasy. Przykład przekazuje w nazwy kategorii, licznika oraz wartość flagi wskazującą, że licznik nie jest tylko do odczytu. Ten przykładowy kod jest częścią większego przykładu dla <xref:System.Diagnostics.PerformanceCounter> klasy.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> To ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="counterName" /> To ciąg pusty ("").  
  
 —lub—  
  
 Określona kategoria nie istnieje. (Jeśli <paramref name="readOnly" /> jest <see langword="true" />).  
  
 —lub—  
  
 Określona kategoria nie jest kategorią niestandardowych .NET Framework (Jeśli <paramref name="readOnly" /> jest <see langword="false" />).  
  
 —lub—  
  
 Określonej kategorii jest oznaczona jako występująca i wymaga licznika wydajności są tworzone z użyciem nazwy wystąpienia.  
  
 —lub—  
  
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="instanceName">Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli kategoria zawiera jedno wystąpienie.</param>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub wystąpienie kategorii i licznika wydajności niestandardowe na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametru nie jest rozróżniana.  
  
 To przeciążenie ustawia konstruktora <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości do wartości należy przekazać w i ustawia <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym, ".".  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie licznika istniejących (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które przekazujesz do <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości musi wskazywać istniejący licznika wydajności na komputerze lokalnym. Jeśli wystąpienie licznika wydajności, które wskazaniu nie jest prawidłowy, wywoływania konstruktora zgłasza wyjątek.  
  
 To przeciążenie można uzyskać dostępu do żadnych tylko do odczytu lub odczytu/zapisu licznika, ale w trybie tylko do odczytu. A <xref:System.Diagnostics.PerformanceCounter> wystąpienia utworzone za pomocą tego przeciążenia nie można zapisać do licznika, nawet jeśli licznika jest odczytu/zapisu.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="counterName" /> to ciąg pusty ("").  
  
 —lub—  
  
 Określonej kategorii jest nieprawidłowy.  
  
 —lub—  
  
 Określonej kategorii jest oznaczona jako występująca i wymaga licznika wydajności są tworzone z użyciem nazwy wystąpienia.  
  
 —lub—  
  
 <paramref name="instanceName" /> jest dłuższa niż 127 znaków.  
  
 —lub—  
  
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="instanceName">Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli kategoria zawiera jedno wystąpienie.</param>
        <param name="readOnly">
          <see langword="true" /> Aby dostęp do liczników w trybie tylko do odczytu; <see langword="false" /> dostępu licznika w trybie odczytu i zapisu do.</param>
        <summary>Inicjuje nowy, tylko do odczytu lub odczytu/zapisu wystąpienie <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub wystąpienie kategorii i licznika wydajności niestandardowe na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametru nie jest rozróżniana.  
  
 To przeciążenie umożliwia dostęp licznika wydajności w jednym tylko do odczytu lub w trybie odczytu i zapisu.  
  
 To przeciążenie ustawia konstruktora <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości do wartości przekazywane w go i zestawy <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości na komputerze lokalnym, ".".  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie licznika istniejących (system lub liczników niestandardowych), na komputerze lokalnym. Wartości, które przekazujesz do <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> właściwości musi wskazywać istniejący licznika wydajności na komputerze lokalnym. Jeśli wystąpienie licznika wydajności, które wskazują na nie jest prawidłowy, wywoływania konstruktora zgłasza wyjątek.  
  
> [!NOTE]
>  To przeciążenie można użyć do nawiązania połączenia liczników systemu, ale nie można zapisać liczników systemu. W związku z tym ustawienie `readOnly` do `false` podczas nawiązywania połączenia z liczników systemu powoduje konstruktora, aby zgłosić wyjątek.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="counterName" /> to ciąg pusty ("").  
  
 —lub—  
  
 Ustawienia żądane uprawnienia odczytu/zapisu jest nieprawidłowy dla tego licznika.  
  
 —lub—  
  
 Określona kategoria nie istnieje (Jeśli <paramref name="readOnly" /> jest <see langword="true" />).  
  
 —lub—  
  
 Określona kategoria nie jest kategorią niestandardowych .NET Framework (Jeśli <paramref name="readOnly" /> jest <see langword="false" />).  
  
 —lub—  
  
 Określonej kategorii jest oznaczona jako występująca i wymaga licznika wydajności są tworzone z użyciem nazwy wystąpienia.  
  
 —lub—  
  
 <paramref name="instanceName" /> jest dłuższa niż 127 znaków.  
  
 —lub—  
  
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</param>
        <param name="counterName">Nazwa licznika wydajności.</param>
        <param name="instanceName">Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli kategoria zawiera jedno wystąpienie.</param>
        <param name="machineName">Komputer, na którym licznik wydajności i jego skojarzony kategorii.</param>
        <summary>Inicjuje wystąpienie nowego, tylko do odczytu <see cref="T:System.Diagnostics.PerformanceCounter" /> klasy i kojarzy ją z określonego systemu lub wydajność — niestandardowy kategorii i licznik wystąpienia, na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciągi parametru nie jest rozróżniana.  
  
 To przeciążenie ustawia konstruktora <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, i <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości do wartości przekazywane w.  
  
 Ten konstruktor inicjuje licznika wydajności i kojarzy wystąpienie licznika istniejących (system lub liczników niestandardowych), na określonym komputerze. Wartości, które przekazujesz do <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> i <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości musi wskazywać istniejący licznika wydajności. Jeśli wystąpienie licznika wydajności, które wskazaniu nie jest prawidłowy, wywoływania konstruktora zgłasza wyjątek. To przeciążenie można uzyskać dostępu do żadnych tylko do odczytu lub odczytu/zapisu licznika, ale w trybie tylko do odczytu. A <xref:System.Diagnostics.PerformanceCounter> wystąpienia utworzone za pomocą tego przeciążenia nie można zapisać do licznika, nawet jeśli licznika jest odczytu/zapisu.  
  
> [!NOTE]
>  Nie można zapisać liczniki wydajności zdalnego. Nie istnieje żadne przeciążenie, który pozwala na określenie odczyt/zapis wystąpienia <xref:System.Diagnostics.PerformanceCounter> klasy, która łączy się z komputerem zdalnym.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
> [!NOTE]
>  W systemie Windows Vista gdy komputer zdalny jest członkiem grupy roboczej, konieczne może być wyłączony funkcji Kontrola konta użytkownika, tak aby konta użytkownika lokalnego nie jest filtrowany i może być z podwyższonym poziomem uprawnień do konta administratora. Ze względów bezpieczeństwa wyłączenie kontroli konta użytkownika należy ostateczność. Informacje dotyczące wyłączania funkcji Kontrola konta użytkownika, zobacz [Kontrola konta użytkownika i WMI](http://go.microsoft.com/fwlink/?LinkId=91617).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="counterName" /> to ciąg pusty ("").  
  
 —lub—  
  
 Ustawienia żądane uprawnienia odczytu/zapisu jest nieprawidłowy dla tego licznika.  
  
 —lub—  
  
 Licznik nie istnieje na określonym komputerze.  
  
 —lub—  
  
 Określonej kategorii jest oznaczona jako występująca i wymaga licznika wydajności są tworzone z użyciem nazwy wystąpienia.  
  
 —lub—  
  
 <paramref name="instanceName" /> jest dłuższa niż 127 znaków.  
  
 —lub—  
  
 <paramref name="categoryName" /> i <paramref name="counterName" /> zostały zlokalizowane w różnych językach.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> lub <paramref name="counterName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjowanie <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienie używane w formularzu lub przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> Metoda kończy się inicjowania. Przy użyciu <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> i <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem składnika.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę kategorii licznika wydajności dla tego licznika wydajności.</summary>
        <value>Nazwa kategorii licznika wydajności (obiekt wydajności), z którym skojarzony jest ten licznik wydajności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Jest wyświetlany w `Performance Object` pole przystawki programu MMC Menedżer licznika wydajności w jego `Add Counter` okno dialogowe.  
  
 Licznik wydajności monitoruje zachowanie kategorii lub obiekt wydajności na komputerze. Kategorie obejmują składniki fizyczne (takich jak procesory, dyski i pamięci) i obiektów systemowych (na przykład procesów i wątków). Liczniki systemu, które są powiązane z tym samym obiektem wydajności są zgrupowane w kategorię, która wskazuje ich wspólnej fokus. Podczas tworzenia wystąpienia <xref:System.Diagnostics.PerformanceCounter> klasy, należy najpierw wskazać kategorii, z którym będzie współpracować składnik, a następnie wybierz licznik z tej kategorii.  
  
 Na przykład kategoria pamięci jest jedną kategorię licznika systemu Windows. Liczniki systemu w tej kategorii śledzenia pamięci dane, takie jak liczba dostępnych bajtów i liczby bajtów w pamięci podręcznej. Jeśli chcesz pracować z bajtów pamięci podręcznej w aplikacji, należy utworzyć wystąpienie <xref:System.Diagnostics.PerformanceCounter> składnika, połącz go z kategorii pamięci, a następnie wybierz odpowiedniego licznika (w tym przypadku buforowanych bajtów) z tej kategorii.  
  
 Chociaż system udostępnia wiele więcej kategorii licznika, kategorie, które będą prawdopodobnie w interakcję z najczęściej są kategorie pamięci podręcznej, pamięci, obiekty, dysk fizyczny, proces, procesora, serwera, systemu i wątku.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie domyślne <xref:System.Diagnostics.PerformanceCounter> klasy. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> wartości właściwości są zestawu i wyniki wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metody są wyświetlane.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka licznik wydajności i zwalnia wszystkie zasoby przydzielone przez to wystąpienie licznika wydajności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po skojarzeniu to <xref:System.Diagnostics.PerformanceCounter> wystąpienia licznika wydajności, która znajduje się na serwerze systemu inicjuje wystąpienie i przydziela pamięć zawierają informacji próbka licznika. <xref:System.Diagnostics.PerformanceCounter.Close%2A> Metoda zwalnia zasoby przydzielone przez obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia przydzielone przez liczniki stan biblioteki udostępnione licznika wydajności.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opis dla tego licznika wydajności.</summary>
        <value>Opis elementu lub ilość środków ten licznik wydajności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Okno dialogowe Dodawanie liczników z przystawki MMC Menedżer licznika wydajności w Wyświetla <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> tekstu, gdy użytkownik wybiera licznik z listy liczników i kliknie przycisk wyjaśnienia.  
  
 Tworząc nowy licznik, użyj <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> tekst opisujący licznik monitoruje zrobić użytkownika można określić, czy można dodać licznika do ekranu Monitora systemu.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.PerformanceCounter" /> Wystąpienia nie jest skojarzony z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę licznika wydajności, który jest skojarzony z tym <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienia.</summary>
        <value>Nazwa licznika, który opisano ilość inwentaryzacji. Ta nazwa będzie wyświetlana na liście liczników wydajności licznik programu MMC przystawkę przez okno dialogowe Dodawanie liczników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zostanie wyświetlona lista dostępnych liczników istniejące z systemu Windows wydajności Menedżera [okno dialogowe Dodawanie liczników](http://go.microsoft.com/fwlink/p/?LinkId=257854).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób ustawiania <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> właściwość na nazwę licznika typowych.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ licznika licznika wydajności skojarzonego.</summary>
        <value>A <see cref="T:System.Diagnostics.PerformanceCounterType" /> opisujący zarówno jak licznik współdziała z monitorowania aplikacji i rodzaj zawiera wartości (na przykład obliczona lub nieobliczone).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterType> Wyliczenie zawiera typy liczniki wydajności, które użytkownik może interakcyjnie przeprowadzić. Niektóre typy licznika reprezentują obliczone wartości, takie jak Średnia pomiarów licznika, który trwało systemu. Inne typy reprezentują nieprzetworzoną lub nieobliczoną wartości. W poniższej tabeli przedstawiono typy licznika współpracujące z najczęściej.  
  
|Odpowiedzialność licznika|Wartość PerformanceCounterType|Przykład|  
|------------------------------|----------------------------------|-------------|  
|Obsługa prostego liczba elementów lub operacji.|`NumberOfItems32`|Śledzenie numer zamówienia jako liczba całkowita 32-bitowych.|  
|Obsługa liczbą proste większej pojemności.|`NumberOfItems64`|Śledzenie numer zamówienia witryny z bardzo dużych obciążeń, przechowywane jako 64-bitową liczbę całkowitą.|  
|Śledź liczbę elementów lub operacji na sekundę.|`RateOfCountsPerSecond32`|Śledzenia zleceń odebranych na sekundę w lokacji.|  
|Śledzenie większej pojemności liczba elementów lub operacji na sekundę.|`RateOfCountsPerSecond64`|Śledzenie zamówień odebranych na sekundę w lokacji z bardzo dużych obciążeń.|  
|Oblicz średni czas do wykonania procesu lub w celu przetworzenia elementu|`AverageTimer32`|Oblicz średni czas, jaki zajmuje kolejności przetwarzania.|  
  
 Po utworzeniu licznika, którego typ wymaga użycia odpowiedniego podstawowy licznik musi deklarować licznik i base w <xref:System.Diagnostics.CounterCreationDataCollection> przekazywane do <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza licznika wydajności skojarzonego o jeden przez skuteczną niepodzielną operację.</summary>
        <returns>Zmniejszona wartość licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zapisywać tylko w licznikach niestandardowych. Wszystkie liczniki systemu są tylko do odczytu.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartości licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie ma potrzeby dokładności blokowanej operacji Podaj, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy zwiększenie wydajności.  Jednak w scenariuszach wielowątkowe niektóre aktualizacje, aby wartość licznika może być ignorowane, niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Licznik jest tylko do odczytu, więc aplikacja nie można jej zmniejszyć.  
  
 —lub—  
  
 Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Ta metoda nie jest metodą o bezpiecznych wątkach.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa rozmiar w bajtach pamięci globalnej współużytkowane przez liczniki wydajności. Rozmiar domyślny to 524,288 bajtów.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienie, które jest używane w formularzu lub przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> Metoda uruchamia inicjowania. Przy użyciu <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> i <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem składnika.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwiększa licznik wydajności skojarzona jeden przez skuteczną niepodzielną operację.</summary>
        <returns>Zwiększona wartość licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zapisywać tylko w licznikach niestandardowych. Wszystkie liczniki systemu są tylko do odczytu.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartości licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie ma potrzeby dokładności blokowanej operacji Podaj, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy zwiększenie wydajności.  Jednak w scenariuszach wielowątkowe niektóre aktualizacje, aby wartość licznika może być ignorowane, niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Licznik jest tylko do odczytu, więc aplikacja nie może zwiększyć go.  
  
 —lub—  
  
 Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Ta metoda nie jest metodą o bezpiecznych wątkach.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zwiększenia. (Ujemnych wartości zmniejsza licznika.)</param>
        <summary>Zwiększa lub zmniejsza wartość licznika wydajności skojarzonego przez określoną ilość poprzez skuteczną niepodzielną operację.</summary>
        <returns>Nowa wartość licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zapisywać tylko w licznikach niestandardowych. Wszystkie liczniki systemu są tylko do odczytu.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartości licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie ma potrzeby dokładności blokowanej operacji Podaj, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy zwiększenie wydajności.  Jednak w scenariuszach wielowątkowe niektóre aktualizacje, aby wartość licznika może być ignorowane, niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> metody, aby dodać zwiększa licznik. Ten przykładowy kod jest częścią większego przykładu dla <xref:System.Diagnostics.PerformanceCounter> klasy.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Licznik jest tylko do odczytu, więc aplikacja nie może zwiększyć go.  
  
 —lub—  
  
 Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności, jeśli <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> jest właściwość <see langword="false" />. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Ta metoda nie jest metodą o bezpiecznych wątkach.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okres istnienia procesu.</summary>
        <value>Jeden z <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> wartości. Wartość domyślna to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kategoria licznika wydajności jest utworzony w programie .NET Framework w wersji 1.0 lub 1.1, używa globalnej pamięci współdzielonej i wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.CounterType%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>, <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> wartość licznika wydajności musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana wartość nie jest elementem członkowskim <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> wyliczenia.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> jest ustawiany po <see cref="T:System.Diagnostics.PerformanceCounter" /> został zainicjowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wystąpienia dla tego licznika wydajności.</summary>
        <value>Nazwa wystąpienia kategorii licznika wydajności lub ciąg pusty (""), jeśli licznik jest pojedynczym wystąpieniem licznika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nazwy wystąpień musi być krótszy niż 128 znaków.  
  
 W niektórych sytuacjach kategorie są podzielone na wystąpienia, które śledzą dane dotyczące wielu wystąpień kategorii odnosi się do obiektu. Wystąpienia mają zastosowanie do kategorii jako całość, a nie do poszczególnych liczników. Każdy licznik w ramach kategorii ma każde wystąpienie zdefiniowane dla kategorii. Na przykład kategorii procesu zawiera wystąpienia o nazwie bezczynny i systemu. Każdy licznik w kategorii procesu w związku z tym zawiera dane dla każdego wystąpienia, wyświetlanie informacji o bezczynności procesów lub procesów systemowych.  
  
 Wiele kategorii nie zawierają wiele wystąpień, więc można pozostaw puste, aby wskazać, że wystąpienie nie jest skojarzony z kategorią tej właściwości.  
  
 Jeśli ta <xref:System.Diagnostics.PerformanceCounter> wystąpienie punktów do standardowych kategorii, można wybrać tylko istniejącego wystąpienia kategorii. Możesz utworzyć nowe wystąpienia kategorii tylko w niestandardowe kategorie, które umożliwiają definiowanie jako wiele liczników i kategorii wystąpień zgodnie z potrzebami.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Nie używaj znaków "(",")", "#", "\\", lub "/" w nazwie wystąpienia. Jeśli którykolwiek z tych znaków są używane, wydajność konsoli (zobacz [profilowanie środowiska uruchomieniowego](~/docs/framework/debug-trace-profile/runtime-profiling.md)) mogą nie wyświetlać poprawnie wartości wystąpienia.  
  
 Jeśli nazwa wystąpienia jest generowany automatycznie i może zawierać znaków "(",")", "#", "\\", lub "/", użyj mapowania znaków w poniższej tabeli.  
  
|Znak|Zmapowane znaków|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 <xref:System.AppDomain.FriendlyName%2A> Właściwość <xref:System.AppDomain> uzyskanego z <xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType> właściwość jest wspólne źródło nazw wystąpień, które mogą zawierać nieprawidłowych znaków.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie domyślne <xref:System.Diagnostics.PerformanceCounter> klasy. Po utworzeniu wystąpienia <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, i <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> wartości właściwości są zestawu i wyniki wywołania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metody są wyświetlane.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera dla tego licznika wydajności</summary>
        <value>Serwer, na którym znajdują się liczników wydajności i jego skojarzonej kategorii.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik może zapisać wartości tylko liczniki, które znajdują się na komputerze lokalnym. Można jednak odczytać wartości liczników za pomocą dowolnego komputera w przedsiębiorstwie, dla którego masz uprawnienia dostępu.  
  
 Podczas ustawiania <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> właściwości do punktu z komputerem zdalnym <xref:System.Diagnostics.PerformanceCounter> wystąpienia próbuje otworzyć licznik na tym komputerze. Jeśli licznik nie istnieje, ustawienie dla tej właściwości zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.PerformanceCounter.MachineName" /> Format jest nieprawidłowy.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje próbkę licznika oraz zwraca nieprzetworzoną lub nieobliczoną wartość.</summary>
        <returns>A <see cref="T:System.Diagnostics.CounterSample" /> reprezentujący następną nieprzetworzoną wartość uzyskaną przez system dla tego licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana dla liczników, które zawierają nieobliczone wartości.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> metodę, aby uzyskać dalej nieobliczone wartości licznika. Ten przykładowy kod jest częścią większego przykładu dla <xref:System.Diagnostics.PerformanceCounter> klasy.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje próbkę licznika oraz zwraca obliczoną wartość.</summary>
        <returns>Obliczona wartość następnego uzyskaną przez system dla tego licznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli obliczona wartość licznika zależy od dwa odczyty licznika, pierwszy operacja odczytu zwraca wartość 0,0. Resetowanie właściwości licznika wydajności, aby określić inny licznik jest odpowiednikiem tworzenie nowy licznik wydajności i pierwszej operacji odczytu przy użyciu nowych właściwości zwraca wartość 0,0. Zalecane opóźnienia między wywołań <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metoda jest 1 sekundę, umożliwia licznik do wykonania następnego odczytu przyrostowe.  
  
> [!NOTE]
>  Aby uzyskać liczniki wydajności, musi mieć uprawnienia administracyjne. W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Diagnostics.PerformanceCounterType.ElapsedTime> licznika oraz zastosowania <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> metodę, aby wyświetlić wartości liczników w czasie.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">Odczytywanie kategorii licznika wydajności. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nieprzetworzoną lub nieobliczoną wartość tego licznika.</summary>
        <value>Nieprzetworzona wartość licznika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ licznika ma rozmiar 32-bitowy, próba ustawienia tej właściwości wartość, która jest za duży dla właściwości obcina wartość do 32-bitowy. Podczas odczytywania liczników niestandardowych na komputerze lokalnym, przy użyciu <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> zamiast obliczonej wartości właściwości może spowodować znacznie większą wydajność w zastosowaniach nieprzetworzonej wartości wystarczające.  
  
 Jeśli licznik odczytywania jest tylko do odczytu, uzyskiwanie <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwości próbek licznika w czasie nosi nazwę właściwości. Ta akcja jest odpowiednikiem początkowej wywołania do <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> metody. Jeśli następnie wywołaj <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>, można wykonać obliczeń na wartości, które zwracane zarówno wywołania.  
  
 Liczniki systemu znajdują się tylko do odczytu, można uzyskać, ale nie ustawienia ich wartości pierwotnych.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, I <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> metody Użyj rygle, aby zaktualizować wartości licznika. Dzięki temu wartość licznika dokładne w scenariuszach wielowątkowe lub wielu procesów, ale także powoduje spadek wydajności. Jeśli nie ma potrzeby dokładności blokowanej operacji Podaj, można zaktualizować <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwość bezpośrednio dla maksymalnie 5 razy zwiększenie wydajności.  Jednak w scenariuszach wielowątkowe niektóre aktualizacje, aby wartość licznika może być ignorowane, niedokładne dane.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
> [!NOTE]
>  Aby odczytywanie liczników wydajności w systemie Windows Vista, Windows XP Professional x64 Edition lub Windows Server 2003, musisz być członkiem grupy Użytkownicy monitora wydajności lub mieć uprawnienia administratora.  
>   
>  Aby uniknąć konieczności podniesienia uprawnień Twoje uprawnienia do dostępu do liczników wydajności w systemie Windows Vista, należy dodać użytkownika do grupy Użytkownicy monitora wydajności.  
>   
>  W systemie Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Diagnostics.CounterSample> klasę, aby wyświetlić wartość <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> właściwości dla licznika.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Próbujesz ustawić nieprzetworzonej wartości licznika, ale ten licznik jest tylko do odczytu.  
  
 —lub—  
  
 Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Kod, który jest wykonywany bez uprawnień administracyjnych podjęto próbę odczytu licznika wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy to <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienie jest w trybie tylko do odczytu.</summary>
        <value>
          <see langword="true" />, jeśli <see cref="T:System.Diagnostics.PerformanceCounter" /> wystąpienie jest w trybie tylko do odczytu (nawet jeśli licznika jest licznikiem niestandardowym .NET Framework); <see langword="false" /> , jeśli jest w trybie odczytu i zapisu. Wartość domyślna to wartość ustawioną przez konstruktora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla licznika system <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> powinien zawsze `true`. Nie można zapisać liczników systemu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wystąpienie kategorii określone przez <see cref="T:System.Diagnostics.PerformanceCounter" /> obiektu <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można usunąć wystąpienia tylko w przypadku liczników niestandardowych. Wszystkie liczniki systemu są tylko do odczytu, więc próby usunięcia jednego z nich zgłasza wyjątek.  
  
> [!NOTE]
>  Aby uniknąć sytuacji wyścigu możliwe po zwolnieniu pamięci udostępnionych licznika wydajności, zalecane jest <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> można wywołać metody z <xref:System.AppDomain.DomainUnload> obsługi zdarzeń.  
  
 Aby utworzyć wystąpienie kategorii wydajności, należy określić `instanceName` na <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> konstruktora. Jeśli wystąpienie kategorii określone przez `instanceName` już istnieje nowy obiekt będzie odwoływać się do istniejącego wystąpienia kategorii.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> właściwość jest <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> i kategorii licznika wydajności została utworzona z .NET Framework w wersji 1.0 lub 1.1, <xref:System.InvalidOperationException> jest generowany. Użyj kategorii licznika wydajności utworzonych w starszych wersjach globalnej pamięci współdzielonej, a następnie jego wartość <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> musi być <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Jeśli kategoria nie jest używany przez aplikacje działające na wersji 1.0 lub 1.1 programu .NET Framework, Usuń i ponownie utworzyć kategorii.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ten licznik jest tylko do odczytu, więc nie można usunąć dowolne wystąpienie, który jest skojarzony z kategorią.  
  
 —lub—  
  
 Wystąpienie nie jest poprawnie skojarzone z licznika wydajności.  
  
 —lub—  
  
 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> Właściwość jest ustawiona na <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> gdy za pomocą globalnej pamięci współdzielonej.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Wystąpił błąd podczas uzyskiwania dostępu do interfejsu API systemu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition (Me), który nie obsługuje liczników wydajności.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">do pisania kategorii licznika wydajności. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
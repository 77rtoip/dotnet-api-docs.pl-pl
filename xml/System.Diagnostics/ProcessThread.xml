<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="088e26e27317339e278a3b3dfe749a6eba53bb72" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36742081" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ProcessThread = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje wątku procesu systemu operacyjnego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.ProcessThread> do uzyskiwania informacji o wątku, który jest obecnie uruchomiony w systemie. Umożliwi to można na przykład monitorować charakterystyki wydajności wątku.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 Wątek jest ścieżką wykonywania za pośrednictwem programu. Jest to najmniejsza jednostka wykonanie, które planuje Win32. Składa się z stosu, stan rejestrów Procesora i wpis na liście wykonywania Harmonogram systemu.  
  
 Proces składa się z co najmniej jeden wątek i kod, danych i innych zasobów programu w pamięci. Zasoby typowego programu są otwarte pliki, semaforów i dynamicznej alokacji pamięci. Każdy zasób procesu jest współużytkowana przez wszystkie te wątków procesu.  
  
 Program wykonuje się, gdy Harmonogram systemu zapewnia kontrolę wykonywania na jeden z wątków programu. Określa harmonogram wątków, które powinno być ono uruchomione i kiedy. Wątek o niższym priorytecie może wymusić Zaczekaj, aż wątki wyższy priorytet zadania. Na komputerach wieloprocesorowych harmonogram można przenieść poszczególne wątki różnych procesorów, w związku z tym Równoważenie obciążenia Procesora.  
  
 Rozpoczyna każdy proces z jednym wątkiem, znany jako podstawowy wątku. Którymkolwiek wątku można utworzyć dodatkowe wątki. Wszystkie wątki w ramach procesu udostępniania przestrzeni adresowej procesu.  
  
 Podstawowy wątek nie jest zawsze znajduje się w pierwszym indeksem w kolekcji.  
  
> [!NOTE]
>  W programie .NET Framework w wersji 2.0, możliwość odwołania dane liczników wydajności na innych komputerach został wyeliminowany dla wielu właściwości i metod .NET Framework. Ta zmiana została wprowadzona w celu zwiększenia wydajności i umożliwić niż administratorzy mogą używać <xref:System.Diagnostics.ProcessThread> klasy. W związku z tym niektóre aplikacje, które nie pobrały wyjątków we wcześniejszych wersjach programu .NET Framework może teraz zostać <xref:System.NotSupportedException>. Zbyt duża, aby wyświetlić w tym miejscu są metody i właściwości, których to dotyczy, ale informacje o wyjątku został dodany do tematów dotyczy elementu członkowskiego.  
  
 Wątki tego procesu wykonaj indywidualnie i są zna sobie wzajemnie, chyba że zostanie stały się widoczne ze sobą. Za pomocą semaforów lub innej metody komunikacji międzyprocesowej wątków, które Udostępnianie wspólnych zasobów, jednak musi koordynować pracę.  
  
 Można pobrać kolekcji wszystkich <xref:System.Diagnostics.ProcessThread> uzyskać obiekty skojarzone z bieżącym procesie <xref:System.Diagnostics.Process.Threads%2A> właściwość <xref:System.Diagnostics.Process> wystąpienia.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera priorytet podstawowy wątku.</summary>
        <value>Priorytet podstawowy wątku, który oblicza systemu operacyjnego, łącząc klasy priorytetu procesu z poziom priorytetu wątku skojarzone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.BasePriority%2A> Jest początkowy priorytet wątku procesu. Można przeglądać informacje o priorytet podstawowy licznik priorytet podstawowy Monitor systemu.  
  
 System operacyjny oblicza priorytet podstawowy wątku, łącząc zakres poziom priorytetu wątku z klasy priorytetu procesu. Można ustawić procesu <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> właściwości do jednej z wartości w <xref:System.Diagnostics.ProcessPriorityClass> wyliczenia, które są <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, lub <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Można ustawić wątku <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> właściwości zakresu wartości zakresem priorytet podstawowy wątku. Win32 używa czterech klasy priorytetów z siedmiu poziomów podstawowy priorytet dla klasy.  
  
 Bieżący priorytet wątku mogą różni się od priorytet podstawowy. Na przykład można zmienić system operacyjny <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> właściwości na podstawie czasu, jaki upłynął lub innych zwiększenie, gdy proces musi znajdować się przed innymi dostępu do procesora. Ponadto można ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> właściwość, aby spowodować, że system tymczasowo zwiększania priorytetu wątku zawsze, gdy proces jest zajęty ze stanu oczekiwania. Priorytet jest resetowany, gdy proces powróci do stanu oczekiwania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPriority : int" Usage="System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący priorytet wątku.</summary>
        <value>Bieżący priorytet wątku, który może różnić się od priorytet podstawowy oparty na sposób planowania wątku jest system operacyjny. Priorytet może tymczasowo boosted dla aktywnego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący priorytet wątku mogą różni się od priorytet podstawowy. Na przykład można zmienić system operacyjny <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> właściwości na podstawie czasu, jaki upłynął, lub inne zwiększenie, gdy proces musi znajdować się przed innymi dostępu do procesora. Ponadto można ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> właściwość, aby spowodować, że system tymczasowo zwiększania priorytetu wątku zawsze, gdy proces jest zajęty ze stanu oczekiwania. Priorytet jest resetowany, gdy proces powróci do stanu oczekiwania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator wątku.</summary>
        <value>Unikatowy identyfikator skojarzony z konkretnym wątkiem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny ponownie używa numery identyfikacyjne wątku, który zidentyfikować wątków tylko podczas ich życia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IdealProcessor : int" Usage="System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia preferowany procesora dla tego wątku do uruchamiania na.</summary>
        <value>Preferowany procesora dla wątku używany, gdy system planuje wątków, aby określić, który procesor do uruchomienia na wątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> Wartość jest liczony od zera.  Innymi słowy koligacji wątków dla pierwszego procesora, ustawia właściwość na wartość zero.  
  
 System planuje wątków na ich preferowanego procesorów, jeśli to możliwe.  
  
 Wątek procesu można migrować z procesora do procesora, za pomocą każdej migracji ponownego ładowania pamięci podręcznej procesora. Określanie procesora dla wątku umożliwiają poprawę wydajności pod obciążeniem duże systemu dzięki zmniejszeniu liczby powtórzeń załadowaniu pamięci podręcznej procesora.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> właściwości dla wystąpienia programu Notatnik do pierwszego procesora.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">System nie może ustawić wątku do uruchomienia w określonym procesorem.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy system operacyjny tymczasowo powinien zwiększania priorytetu wątku skojarzone zawsze, gdy fokus głównego okna procesu wątku.</summary>
        <value>
          <see langword="true" /> do zwiększania priorytetu wątku, gdy użytkownik wchodzi w interakcję z procesem przez interfejs; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> jest `true`, gdy jego skojarzony proces jest zajęty ze stanu oczekiwania system tymczasowo zwiększa priorytet wątku. Ta akcja uniemożliwia inne procesy przerywania przetwarzania bieżącego wątku. <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> Ustawienie ma wpływ na wszystkie wątki istniejących, a także wszystkie wątki następnie utworzone przez proces. Aby przywrócić normalne działanie, należy ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> właściwości `false`.  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> ma wpływ tylko wtedy, gdy wątek jest uruchomiony w ramach procesu, który ma <xref:System.Diagnostics.Process.PriorityClass%2A> ustawić jedną z wartości wyliczenia priorytet dynamiczny (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, lub <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).  
  
> [!NOTE]
>  Zwiększanie wyniku zbyt wysoki priorytet może opróżnienia zasobów z podstawowych systemu operacyjnego i funkcji sieciowych. Może to spowodować problemy z innych zadań systemu operacyjnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać informacji o priorytecie zwiększanie wyniku.  - lub - nie można ustawić priorytet informacji zwiększanie wyniku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityLevel : System.Diagnostics.ThreadPriorityLevel with get, set" Usage="System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poziom priorytetu wątku.</summary>
        <value>Jeden z <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> wartości określenie zakresu, który zakresem priorytetu wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom priorytetu nie jest pojedynczą wartość, ale raczej zakresu wartości. System operacyjny oblicza priorytet podstawowy wątku przy użyciu procesu <xref:System.Diagnostics.Process.PriorityClass%2A> wybrać wartość z zakresu określonego w <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać informacji o poziom priorytetu wątku.  - lub - nie można ustawić poziom priorytetu wątku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas spędzony wątek kodu wewnątrz rdzenia systemu operacyjnego.</summary>
        <value>A <see cref="T:System.TimeSpan" /> wskazująca czas spędzony wątek kodu wewnątrz rdzenia systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System Windows używa kilku różne mechanizmy ochrony i w katalogu głównym wszystkich jest różnica między tryb użytkownika i w trybie uprzywilejowanym. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> odpowiada ilość czasu spędzony aplikacji działających w trybie uprzywilejowanym wewnątrz rdzenia systemu operacyjnego. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> Właściwość wskazuje czas spędzony aplikacji kodu w trybie użytkownika, poza rdzeniem systemu.  
  
 Tryb użytkownika ogranicza aplikację na dwa sposoby ważne. Najpierw aplikacji nie może bezpośrednio uzyskać dostępu do urządzenia peryferyjne, ale zamiast tego należy wywołać rdzeniem systemu operacyjnego można pobrać lub ustawić peryferyjne danych. System operacyjny w związku z tym zapewnia jedną aplikację zniszczy peryferyjne danych, który jest wymagany przez inny. Po drugie aplikacja nie może odczytać lub zmień dane, które przechowuje sam system operacyjny. To ograniczenie uniemożliwia aplikacji przypadkowo lub celowo uszkodzenia podstawowego. Jeśli aplikacja wymaga systemu operacyjnego, można wykonać operacji, wywołuje jedną z procedur systemu. Wiele z tych przejścia w trybie uprzywilejowanym wykonania tej operacji, a sprawnie wrócisz do trybu użytkownika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać czasu wątku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint" Usage="System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia procesory, na których można uruchomić wątku skojarzone.</summary>
        <value>
          <see cref="T:System.IntPtr" /> Zestawu usługi bits, z których każdy reprezentuje procesor, które można uruchomić wątku, na który wskazuje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Koligacja procesorów wątku jest zestaw procesorów, które ma ona relację. Innymi słowy te, które mogą być planowane na.  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> reprezentuje jako nieco każdego procesora. Bit 0 oznacza procesora, co, bit 1 oznacza procesora dwa i tak dalej. W poniższej tabeli przedstawiono podzbiór możliwe <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> systemu czterech procesorów.  
  
|Wartość właściwości (w formacie szesnastkowym)|Nieprawidłowa procesorów|  
|---------------------------------------|----------------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 lub 2|  
|0x0004|3|  
|0x0005|1 lub 3|  
|0x0007|1, 2 lub 3|  
|0x000F|1, 2, 3 lub 4|  
  
 Można również określić pojedynczy, preferowane procesor do wątku przez ustawienie <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> właściwości. Wątek procesu można migrować z procesora do procesora, za pomocą każdej migracji ponownego ładowania pamięci podręcznej procesora. Określanie procesora dla wątku umożliwiają poprawę wydajności pod obciążeniem duże systemu dzięki zmniejszeniu liczby powtórzeń załadowaniu pamięci podręcznej procesora.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawiania <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> właściwości dla wystąpienia programu Notatnik do pierwszego procesora.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można ustawić koligacji procesora.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberSignature Language="F#" Value="member this.ResetIdealProcessor : unit -&gt; unit" Usage="processThread.ResetIdealProcessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje idealne procesora dla tego wątku do wskazywania nie pojedynczy procesor idealne. Innymi słowy, aby doskonale dowolnego procesora.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można zresetować idealne procesora.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.StartAddress : nativeint" Usage="System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres pamięci funkcji, która wywołuje systemu operacyjnego i rozpoczęcia tego wątku.</summary>
        <value>Wątku początkowy adres, który wskazuje wykonujący wątku funkcji zdefiniowanych przez aplikację.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozpoczyna każdy proces z jednym wątkiem, znany jako podstawowy wątku. Którymkolwiek wątku można utworzyć dodatkowe wątki.  
  
 Proces ma wirtualnej przestrzeni adresowej, kodu wykonywalnego, danych, uchwytami, zmienne środowiskowe, priorytet podstawowy i minimalna i maksymalny rozmiar zestawu roboczego. Wszystkie wątki tego procesu udostępniania zasobów systemu i miejsca jego wirtualnego adresu. Ponadto każdy wątek zapewnia obsługę wyjątków, priorytetu planowania i zestaw struktur, w których system zapisuje kontekst wątku, gdy wątek oczekuje do zaplanowania. Kontekst wątku zawiera zestaw wątku rejestrów maszyny, stosu jądra blok środowiska wątku i stosu użytkownika w przestrzeni adresowej procesu wątku.  
  
 Każdy wątek Windows faktycznie rozpoczyna wykonanie w funkcji dostarczanych przez system, nie funkcja dostarczone przez aplikację. Początkowy adres podstawowy wątku jest, w związku z tym takie same (ponieważ reprezentuje on adresu funkcji dostarczanych przez system) dla każdego procesu systemu Windows w systemie. Jednak <xref:System.Diagnostics.ProcessThread.StartAddress%2A> właściwości umożliwia uzyskiwanie początkowy adres funkcja, która jest specyficzna dla aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas uruchomienia wątku systemu operacyjnego.</summary>
        <value>A <see cref="T:System.DateTime" /> reprezentującą godzinę, który był w systemie, gdy system operacyjny uruchomiony wątek.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać czasu wątku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Diagnostics.ThreadState" Usage="System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący stan tego wątku.</summary>
        <value>A <see cref="T:System.Diagnostics.ThreadState" /> wskazujące wykonanie wątku, na przykład uruchomiony Oczekiwanie lub został zakończony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Wartość właściwości jest prawidłowe tylko w przypadku <xref:System.Diagnostics.ProcessThread.ThreadState%2A> wartość jest <xref:System.Diagnostics.ThreadState.Wait>. Sprawdź, w związku z tym <xref:System.Diagnostics.ProcessThread.ThreadState%2A> wartości, zanim będzie można pobrać <xref:System.Diagnostics.ProcessThread.WaitReason%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą ilość czasu spędzony tego wątku przy użyciu procesora.</summary>
        <value>A <see cref="T:System.TimeSpan" /> wskazująca czas były wątek kontroli procesora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> Właściwość wskazuje łączny czas trwania, że system ma podjąć ze stanu oczekiwania wątku i priorytet go na dowolnego procesora. W wielu systemach procesora ta wartość obejmuje czas spędzony na każdy procesor wątek użycie więcej niż jeden procesor.  
  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> Właściwości to suma <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> i <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać czasu wątku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas spędzony skojarzone wątku kodu wewnątrz aplikacji.</summary>
        <value>A <see cref="T:System.TimeSpan" /> wskazująca czas spędzony wątek uruchamianie kodu w aplikacji, w przeciwieństwie do wewnątrz rdzenia systemu operacyjnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT używa kilku różne mechanizmy ochrony i w katalogu głównym wszystkich jest różnica między tryb użytkownika i w trybie uprzywilejowanym. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> odpowiada ilość czasu spędzony aplikacji działających w trybie użytkownika, poza rdzeniem systemu operacyjnego. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> Odpowiada czas spędzony aplikacji uruchamianie kodu w trybie uprzywilejowanym wewnątrz rdzenia systemu.  
  
 Tryb użytkownika ogranicza aplikację na dwa sposoby ważne. Najpierw aplikacji nie może bezpośrednio uzyskać dostępu do urządzenia peryferyjne, ale zamiast tego należy wywołać rdzeniem systemu operacyjnego można pobrać lub ustawić peryferyjne danych. System operacyjny w związku z tym zapewnia jedną aplikację zniszczy peryferyjne danych, który jest wymagany przez inny. Po drugie aplikacja nie może odczytać lub zmień dane, które przechowuje sam system operacyjny. To ograniczenie uniemożliwia aplikacji przypadkowo lub celowo uszkodzenia podstawowego. Jeśli aplikacja wymaga systemu operacyjnego, można wykonać operacji, wywołuje jedną z procedur systemu. Wiele z tych przejścia w trybie uprzywilejowanym wykonania tej operacji, a sprawnie wrócisz do trybu użytkownika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Nie można pobrać czasu wątku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitReason : System.Diagnostics.ThreadWaitReason" Usage="System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Przyczyna oczekiwania wątku.</summary>
        <value>A <see cref="T:System.Diagnostics.ThreadWaitReason" /> reprezentujący powód wątek znajduje się w stanie oczekiwania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Właściwość jest prawidłowe tylko w przypadku <xref:System.Diagnostics.ProcessThread.ThreadState%2A> jest <xref:System.Diagnostics.ThreadState.Wait>. Sprawdź, w związku z tym <xref:System.Diagnostics.ProcessThread.ThreadState%2A> wartości, zanim będzie można pobrać <xref:System.Diagnostics.ProcessThread.WaitReason%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wątek nie jest w stanie oczekiwania.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Platforma to Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">Proces odbywa się na komputerze zdalnym.</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2145a11bbb9faa94763035b22147eede6d4adee" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30449718" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia interakcję z dziennikami zdarzeń systemu Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> Umożliwia dostęp do lub dostosować dzienniki zdarzeń systemu Windows, które rejestrowania informacji o ważnych zdarzeniach oprogramowania lub sprzętu. Przy użyciu <xref:System.Diagnostics.EventLog>, można odczytać z istniejących dzienników, zapisywanie wpisów dzienników, tworzenie lub usuwanie źródeł zdarzeń, Usuń dzienniki i odpowiadanie na pozycje dziennika. Można również utworzyć nowe dzienniki podczas tworzenia źródła zdarzenia.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 Oprócz zapewnienia dostępu do poszczególnych dzienniki zdarzeń i ich wpisy <xref:System.Diagnostics.EventLog> klasy pozwala uzyskiwać dostęp do kolekcji wszystkie dzienniki zdarzeń. Można użyć `static` członkami <xref:System.Diagnostics.EventLog> można usunąć dzienniki, Pobierz listy dziennika, utworzyć lub usunąć źródła lub ustal, czy komputer zawiera już określonego źródła.  
  
 Istnieją trzy dzienniki zdarzeń domyślne: aplikacji, System i zabezpieczenia. Dziennika zabezpieczeń jest tylko do odczytu. Inne aplikacje i usługi, które będą instalowane, takich jak usługi Active Directory, może być dodatkowe dzienniki zdarzeń.  
  
 Istnieją zagadnienia dotyczące zabezpieczeń przy użyciu <xref:System.Diagnostics.EventLog> klasy. <xref:System.Diagnostics.EventLog> wymaga <xref:System.Diagnostics.EventLogPermission> uprawnienia dla określonych akcji w programie .NET Framework 2.0 i nowszych wersjach lub pełnego zaufania w .NET Framework 1.0 i 1.1. Zalecamy, aby <xref:System.Diagnostics.EventLogPermission> nie udziela się częściowo zaufany kod.  Nigdy nie należy przekazać dowolnego obiektu dziennika zdarzeń, w tym <xref:System.Diagnostics.EventLogEntryCollection> i <xref:System.Diagnostics.EventLogEntry> obiektów do mniej zaufanego kodu. Na przykład tworzenie <xref:System.Diagnostics.EventLog> obiektu, zapisywania wpisu, a następnie przekazywanie <xref:System.Diagnostics.EventLog> obiekt częściowo zaufanego kodu można utworzyć problem z zabezpieczeniami, ponieważ kod, aby wykonać akcje, takie jak wystawianie umożliwia możliwości odczytu i zapisu do dziennika zdarzeń komunikaty dziennika zdarzeń w nazwach inną aplikację.  
  
 Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) Określa poświadczenia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do uruchomienia kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musi najpierw podwyższenie poświadczeń z użytkownika standardowego, do administratora. Można to zrobić, podczas uruchamiania aplikacji przez otwarcie menu skrótów dla aplikacji (Jeśli używasz myszy, kliknij prawym przyciskiem myszy ikonę aplikacji) i wskazujący, że chcesz uruchomić jako administrator.  
  
 Można użyć <xref:System.Diagnostics.EventLog> do tworzenia niestandardowych dzienniki zdarzeń, które można wyświetlić za pomocą serwera do podglądu zdarzeń. Użyj <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> metodę w celu wyświetlenia zlokalizowana nazwa dziennika zdarzeń w Podglądzie zdarzeń. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> metodę, aby skonfigurować działanie dziennika zdarzeń, po osiągnięciu jej maksymalny rozmiar dziennika.  
  
 Aby odczytać z dziennika zdarzeń, określ nazwę dziennika (<xref:System.Diagnostics.EventLog.Log%2A> właściwości) i nazwy serwera (<xref:System.Diagnostics.EventLog.MachineName%2A> właściwości dziennika zdarzeń. Jeśli nie zostanie określony z nazwą komputera serwera, komputer lokalny, ".", zakłada, że. Nie jest konieczne określić źródło zdarzenia (<xref:System.Diagnostics.EventLog.Source%2A> właściwości), ponieważ jest wymagana tylko w przypadku zapisywania dzienników źródło. <xref:System.Diagnostics.EventLog.Entries%2A> Właściwość jest automatycznie wypełniane przy użyciu listy wpisów dziennika zdarzeń.  
  
 Można zapisać do dziennika zdarzeń, określ lub Utwórz źródło zdarzenia (<xref:System.Diagnostics.EventLog.Source%2A> właściwości). Musi mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń. Źródło zdarzenia rejestruje aplikację z dziennika zdarzeń jako prawidłowe źródło wpisów. Źródło zdarzenia służy do zapisu do dziennika tylko jeden naraz. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość może być dowolnym ciągiem losowych, ale nazwa musi się różnić od innych źródeł na tym komputerze. Źródło zdarzenia jest zwykle nazwa aplikacji lub inny ciąg identyfikacyjny. W trakcie tworzenia duplikat <xref:System.Diagnostics.EventLog.Source%2A> wartość zgłasza wyjątek. Jednak pojedynczy dziennik zdarzeń może być skojarzony z wieloma źródłami.  
  
 Jeśli źródło zdarzenia w dzienniku zdarzeń skojarzonych z <xref:System.Diagnostics.EventLog> wystąpienie nie istnieje, utworzone nowe źródło zdarzeń. Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, należy mieć poświadczenia administracyjne.  
  
 To wymaganie dotyczy, ponieważ wszystkie dzienniki zdarzeń, w tym dzienniki zabezpieczeń musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> jest generowany.  
  
> [!IMPORTANT]
>  Tworzenie lub usuwanie źródła zdarzenia wymaga synchronizacji z kodu źródłowego przy użyciu nazwanego obiektu mutex. Jeśli aplikacja wysoko uprzywilejowane blokuje nazwanego obiektu mutex, w trakcie tworzenia lub usuwania źródłem zdarzenia powoduje, że aplikacja przestanie odpowiadać, dopóki nie zostanie zwolniony blokady. Aby uniknąć tego problemu, nigdy nie udzielić <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnienia do niezaufanych kodu. Ponadto <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnienia potencjalnie umożliwia inne uprawnienia do obejścia i tylko powinny być przyznane wysokiej zaufanego kodu.  
  
 Aplikacje i usługi, należy zapisać do dziennika aplikacji lub dziennik niestandardowy. Sterowniki urządzeń, należy zapisać w dzienniku systemu. Jeśli nie zostanie jawnie ustawiona <xref:System.Diagnostics.EventLog.Log%2A> właściwości, domyślnie dziennik zdarzeń w dzienniku aplikacji.  
  
> [!NOTE]
>  Nie ma nic do ochrony aplikacji przed Zapisywanie jako wszelkie zarejestrowane źródło.  Jeśli aplikacja ma przyznane uprawnienia <xref:System.Diagnostics.EventLogPermissionAccess.Write> uprawnienia, może on zapisywać zdarzeń dla dowolnego prawidłowego źródła zarejestrowana na komputerze.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> metody się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia się zapisać zdarzeń; należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżenia listy źródeł zdarzeń i próbie zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować za pomocą <xref:System.Diagnostics.EventLogInstaller> obiektu lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Każde źródło może zapisywać do dziennika zdarzeń tylko jeden jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników zdarzeń. Na przykład aplikacja może wymagać wielu źródeł skonfigurowane dla różnych dzienników zdarzeń lub innego zasobu plików. Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Użycie innych aplikacji lub składników istniejącego źródła, Utwórz nowe źródło z zaktualizowaną konfiguracją zamiast usuwania istniejącego źródła.  
  
 Źródło zdarzenia można zarejestrować z zlokalizowanych zasobów dla zdarzeń ciągów Kategoria i komunikatu. Aplikację można pisać wpisy w dzienniku zdarzeń przy użyciu identyfikatorów zasobów zamiast określania wartości rzeczywistych ciągu. Zapoznaj się <xref:System.Diagnostics.EventLogInstaller> i <xref:System.Diagnostics.EventSourceCreationData> klasy, aby uzyskać więcej informacji o konfigurowaniu źródła z plikami zasobów.  
  
 Aplikacja zapisuje wartości ciągu bezpośrednio do dziennika zdarzeń, nie trzeba ustawić zasobu właściwości pliku źródłowego. Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Podczas zapisywania zdarzeń, użytkownik musi określać co najmniej ciąg komunikatu lub identyfikator zasobu ciąg komunikatu. Inne właściwości zdarzenia są opcjonalne. Następujące przykłady ustawienia opcjonalne zdarzeń:  
  
-   Można ustawić <xref:System.Diagnostics.EventLogEntryType> określić ikonę, która podglądu zdarzeń wyświetlane wpisu.  
  
-   Można określić identyfikatora kategorii dla zdarzeń, jeśli aplikacja używa kategorii do filtrowania zdarzeń.  
  
-   Jeśli chcesz skojarzyć dodatkowe informacje z jednego z określonych zdarzeń, możesz dołączyć dane binarne do wpisu zdarzeń.  
  
> [!IMPORTANT]
>  Rejestrowanie zdarzeń zużywa miejsca na dysku, czas procesora i innych zasobów. Należy rejestrować tylko istotne informacje. Zaleca się, że wywołania dziennika zdarzeń w ścieżce błąd, a nie w ścieżce kodu głównego, dlatego ich nie negatywnie wpłynąć na wydajność.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>, zobacz <xref:System.Diagnostics.EventLog.%23ctor%2A> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło zdarzenia `MySource` Jeśli go jeszcze nie istnieje, a dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
> [!NOTE]
>  Począwszy od systemu Windows Vista, należy uruchomić tę aplikację jako administrator.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Wiąże wystąpienie z dowolnego dziennika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A> właściwość <xref:System.Diagnostics.EventLog> wystąpienia. Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A> z dziennika, można również określić tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Komputer lokalny (".").|  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` Jeśli jeszcze nie istnieje, a dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na komputerze lokalnym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennika na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A> właściwości `logName` parametru. Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A> właściwość <xref:System.Diagnostics.EventLog> wystąpienia. Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A> z dziennika, można również określić tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że. Określa tego przeciążenia konstruktora <xref:System.Diagnostics.EventLog.Log%2A> właściwości, ale można go zmienić przed przeczytaniem <xref:System.Diagnostics.EventLog.Entries%2A> właściwości.  
  
 Źródło, w przypadku określenia w <xref:System.Diagnostics.EventLog.Source%2A> właściwości jest unikatowa z innych źródeł na komputerze, kolejne wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> tworzy dziennik o określonej nazwie, jeśli jeszcze nie istnieje.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametru.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Komputer lokalny (".").|  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "myNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na określonym komputerze.</param>
        <param name="machineName">Komputer, na którym znajduje się dziennik.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennika na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A> właściwości `logName` parametru i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości `machineName` parametru. Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A> właściwość <xref:System.Diagnostics.EventLog>. Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A> z dziennika, można również określić tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości.  
  
> [!NOTE]
>  Określa tego przeciążenia konstruktora <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości, ale można zmienić przed odczytu <xref:System.Diagnostics.EventLog.Entries%2A> właściwości.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametru.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` Parametru.|  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "myNewLog" na komputerze "MójSerwer".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.  
  
 —lub—  
  
 Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na określonym komputerze</param>
        <param name="machineName">Komputer, na którym znajduje się dziennik.</param>
        <param name="source">Źródło wpisy w dzienniku zdarzeń.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennika na określonym komputerze i tworzy lub przypisuje z określonego źródła <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawia tego konstruktora <xref:System.Diagnostics.EventLog.Log%2A> właściwości `logName` parametru <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości `machineName` parametru i <xref:System.Diagnostics.EventLog.Source%2A> właściwości `source` parametru. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość jest wymagana podczas zapisywania dziennika zdarzeń. Jednak jeśli jest tylko do odczytu z dziennika zdarzeń, tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości są wymagane (o ile dziennik zdarzeń na serwerze ma już skojarzony z nim źródła). Jeśli jest tylko do odczytu z dziennika zdarzeń, może być wystarczające innego przeciążenia metody konstruktora.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` Parametru.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametru.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` Parametru.|  
  
   
  
## Examples  
 Poniższy przykład dokona wpisu dziennika zdarzeń, "MyNewLog" na komputerze lokalnym, przy użyciu źródła "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.  
  
 —lub—  
  
 Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjowanie <see cref="T:System.Diagnostics.EventLog" /> używane w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.EndInit%2A> Metoda kończy się inicjowania. Przy użyciu <xref:System.Diagnostics.EventLog.BeginInit%2A> i <xref:System.Diagnostics.EventLog.EndInit%2A> metody uniemożliwić formantu przed jest w pełni zainicjowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> jest już zainicjowany.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie wpisy z dziennika zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzienniki zdarzeń są ustawiane o maksymalnym rozmiarze, który określa liczbę wpisów, które zawierają. Po zapełnieniu dziennika zdarzeń zatrzymuje rejestrowanie nowych zdarzeń informacji lub rozpoczyna się w celu zastąpienia starszych wpisów. Jeśli zatrzymuje rejestrowanie zdarzeń, służy ta metoda aby wyczyścić dziennik istniejące wpisy i umożliwić mu ponownie uruchomić rejestrowanie zdarzeń. Musi mieć uprawnienia administratora na komputerze, na którym znajduje się dziennika, aby wyczyścić wpisy w dzienniku zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> powoduje zamknięcie dziennika zdarzeń, zwalnia uchwytów zdarzeń pobiera nowe odczytu i zapisu dojść i ponownie otwiera dziennik zdarzeń. Zdarzenia po wywołaniu metody nie zostaną wyczyszczone, wraz z istniejących zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład powoduje wyczyszczenie dziennika zdarzeń.  
  
> [!CAUTION]
>  Ponieważ aplikacji, System, zabezpieczenia, a inne dzienniki niestandardowych nie mogą zawierać ważnych informacji; należy określić dziennik niestandardowy przed wykonaniem tego przykładowego kodu. W tym przykładzie usuwa dziennik niestandardowy `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Dziennik zdarzeń nie został wyczyszczony pomyślnie.  
  
 —lub—  
  
 Nie można otworzyć dziennika. Kod błędu systemu Windows nie jest dostępna.</exception>
        <exception cref="T:System.ArgumentException">Nie określono wartości dla <see cref="P:System.Diagnostics.EventLog.Log" /> właściwości. Upewnij się, że nazwa dziennika nie jest ciągiem pustym.</exception>
        <exception cref="T:System.InvalidOperationException">Dziennik nie istnieje.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka dziennik zdarzeń i zwalnia odczytu i zapisu uchwytów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A> Metoda jest wywoływana przez chronionej <xref:System.ComponentModel.Component.Dispose%2A> metody. Nie trzeba wywołać <xref:System.Diagnostics.EventLog.Close%2A> przed wywołaniem <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Dziennik zdarzeń uchwyt odczytu lub zapisu nie został zwolniony pomyślnie.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia aplikacji jako możliwość zapisywania dziennika zdarzeń informacji w systemie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Właściwości konfiguracji dla źródła zdarzenia i jego dziennikiem zdarzeń docelowego.</param>
        <summary>Określa źródło zdarzeń prawidłowe zapiszą zdarzenie zlokalizowanych komunikaty, przy użyciu określonej konfiguracji właściwości źródło zdarzeń i odpowiedniego dziennika zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia skonfigurowanie nowego źródła dla zapisywania wpisów dziennika zdarzeń na komputerze lokalnym lub zdalnym. Nie jest konieczne do używania tej metody można odczytać z dziennika zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> — Metoda korzysta z danych wejściowych `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> i <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> właściwości w celu utworzenia wartości rejestru na komputerze docelowym nowe źródło i jego skojarzony dziennika zdarzeń. Nowa nazwa źródła nie może dopasować istniejącej nazwy źródła lub istniejącej nazwy dziennika zdarzeń na komputerze docelowym. Jeśli <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> właściwość nie jest ustawiona, źródło jest zarejestrowane w dzienniku zdarzeń aplikacji. Jeśli <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> nie jest ustawione źródło jest zarejestrowana na komputerze lokalnym.  
  
> [!NOTE]
>  Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyny tego wymagania jest, że wszystkie dzienniki zdarzeń, zabezpieczeń, w tym musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> jest generowany.  
>   
>  Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia się zapisać zdarzeń; należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennik jest tworzone dopiero po pierwszej pozycji są zapisywane do niego.  
  
 System operacyjny zapisuje dzienniki zdarzeń jako plików. Jeśli używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Aby utworzyć nowy dziennik zdarzeń, skojarzony plik znajduje się w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona przez dodanie pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Każdego źródła tylko może zapisywać do dziennika zdarzeń tylko jeden jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników zdarzeń. Na przykład aplikacja może wymagać wielu źródeł skonfigurowane dla różnych dzienników zdarzeń lub innego zasobu plików.  
  
 Źródło zdarzenia można zarejestrować z plików zlokalizowanych zasobów dla zdarzeń ciągów Kategoria i komunikatu. Aplikację można napisać przy użyciu identyfikatorów zasobów, a nie rzeczywiste ciąg określający wpisy w dzienniku zdarzeń. Podgląd zdarzeń używa identyfikatora zasobu można znaleźć i wyświetlić odpowiedni ciąg z pliku zasobów zlokalizowanych oparte na bieżących ustawieniach języka. Możesz zarejestrować osobny plik dla kategorii zdarzeń, wiadomości i ciągi wstawiania parametru lub można zarejestrować tego samego pliku zasobów dla wszystkich trzech typów ciągów. Użyj <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, i <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> właściwości, aby skonfigurować źródła na zapisywanie wpisów zlokalizowanego w dzienniku zdarzeń. Jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń, ustaw te właściwości nie jest konieczne.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Użycie innych aplikacji lub składników istniejącego źródła, Utwórz nowe źródło o zaktualizowanej konfiguracji od usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli źródłem jest skonfigurowany do dziennika zdarzeń i skonfigurujesz innego dziennika zdarzeń, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład określa, czy źródło zdarzenia o nazwie `SampleApplicationSource` jest zarejestrowana na komputerze lokalnym. Jeśli źródło zdarzenia nie istnieje, w przykładzie ustawia pliku zasobów komunikatów dla źródła i tworzy nowe źródło zdarzeń. Ponadto w przykładzie nazwę wyświetlaną zlokalizowanego w dzienniku zdarzeń przy użyciu wartości identyfikatora zasobu w `DisplayNameMsgId` i ścieżka pliku zasobu w `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 W przykładzie użyto następującego pliku tekst wiadomości wbudowanych w bibliotece EventLogMsgs.dll zasobów. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatorów zasobów i tekst dla kategorii, komunikatu o zdarzeniu i ciągi wstawiania parametru. W szczególności identyfikator zasobu 5001 jest zdefiniowany dla zlokalizowana nazwa dziennika zdarzeń.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa komputera określona w <paramref name="sourceData" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Podana nazwa źródła w <paramref name="sourceData" /> jest <see langword="null" />.  
  
 \- lub -  
  
 Nazwa dziennika określona w <paramref name="sourceData" /> jest nieprawidłowy. Nazwy dzienników zdarzeń muszą składać się ze znaków drukowalnych i nie może zawierać znaków ' * ','?', lub "\\".  
  
 \- lub -  
  
 Nazwa dziennika określona w <paramref name="sourceData" /> jest nieprawidłowa dla utworzenia dziennika użytkownika. Nazwy dzienników zdarzeń AppEvent, SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
 \- lub -  
  
 Nazwa dziennika odpowiada istniejącej nazwy źródła zdarzenia.  
  
 \- lub -  
  
 Podana nazwa źródła w <paramref name="sourceData" /> powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.  
  
 \- lub -  
  
 Pierwsze 8 znaków nazwy dziennika określonej w <paramref name="sourceData" /> nie są unikatowe.  
  
 \- lub -  
  
 Podana nazwa źródła w <paramref name="sourceData" /> jest już zarejestrowany.  
  
 \- lub -  
  
 Podana nazwa źródła w <paramref name="sourceData" /> odpowiada istniejącej nazwy dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła, według której aplikacja jest zarejestrowana na komputerze lokalnym.</param>
        <param name="logName">Nazwa dziennika źródła wpisy są zapisywane. Możliwe wartości to aplikacja, System lub niestandardowych dziennika zdarzeń.</param>
        <summary>Określa nazwę określonego źródła jako źródło zdarzeń prawidłowe zapisywania wpisów dziennika na komputerze lokalnym. Tej metody można też utworzyć nowy dziennik niestandardowy na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można utworzyć dziennika niestandardowego lub można utworzyć ani zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> do istniejącego dziennika na komputerze lokalnym.  
  
 Jeśli `logName` jest `null` lub ciąg pusty ("") podczas wywoływania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, domyślnie przyjmowana jest dziennika w dzienniku aplikacji. Jeśli dziennika nie istnieje na komputerze lokalnym, system tworzy dziennik niestandardowy i rejestruje aplikację jako <xref:System.Diagnostics.EventLog.Source%2A> dla tego dziennika.  
  
> [!NOTE]
>  Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyny tego wymagania jest, że wszystkie dzienniki zdarzeń, zabezpieczeń, w tym musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> jest generowany.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Należy utworzyć źródło zdarzeń podczas pisania w dzienniku zdarzeń. Przed zapisaniem wpis w dzienniku zdarzeń, należy zarejestrować źródło zdarzenia z dziennika zdarzeń jako prawidłowe źródło zdarzeń. Podczas zapisu dziennika system używa <xref:System.Diagnostics.EventLog.Source%2A> można znaleźć do odpowiedniego dziennika, w którym można umieścić wpis. Jeśli odczytujesz dziennika zdarzeń, można określić <xref:System.Diagnostics.EventLog.Source%2A>, lub <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Nie należy określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się z dziennikiem na komputerze lokalnym. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> podczas czytania z dziennika, na komputerze lokalnym (".") zakłada, że.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia się zapisać zdarzeń; należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennik jest tworzone dopiero po pierwszej pozycji są zapisywane do niego.  
  
 System operacyjny zapisuje dzienniki zdarzeń jako plików. Jeśli używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Aby utworzyć nowy dziennik zdarzeń, skojarzony plik znajduje się w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona przez dodanie pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Źródło musi być unikatowa na komputerze lokalnym; Nowa nazwa źródła nie może dopasować istniejącej nazwy źródła lub nazwa istniejącego dziennika zdarzeń. Każde źródło może zapisywać do dziennika zdarzeń tylko jeden jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników zdarzeń. Na przykład aplikacja może wymagać wielu źródeł skonfigurowane dla różnych dzienników zdarzeń lub innego zasobu plików.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Użycie innych aplikacji lub składników istniejącego źródła, Utwórz nowe źródło o zaktualizowanej konfiguracji od usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` Jeśli jeszcze nie istnieje, a dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> to ciąg pusty ("") lub <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="logName" /> nie jest nazwą prawidłową dziennika zdarzeń. Nazwy dzienników zdarzeń muszą składać się ze znaków drukowalnych i nie może zawierać znaków ' * ','?', lub "\\".  
  
 \- lub -  
  
 <paramref name="logName" /> jest nieprawidłowa dla utworzenia dziennika użytkownika. Nazwy dzienników zdarzeń AppEvent, SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
 \- lub -  
  
 Nazwa dziennika odpowiada istniejącej nazwy źródła zdarzenia.  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.  
  
 \- lub -  
  
 Pierwsze 8 znaków <paramref name="logName" /> dopasowania pierwsze 8 znaków istniejącej nazwy dziennika zdarzeń.  
  
 \- lub -  
  
 Nie można zarejestrować źródła, ponieważ już istnieje na komputerze lokalnym.  
  
 \- lub -  
  
 Nazwa źródła jest zgodna istniejącą nazwę dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze lokalnym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="logName">Nazwa dziennika źródła wpisy są zapisywane. Możliwe wartości to aplikacja, System lub niestandardowych dziennika zdarzeń. Jeśli nie określisz wartości, <c>Nazwa_dziennika</c> wartości domyślnych do aplikacji.</param>
        <param name="machineName">Nazwa komputera, aby zarejestrować źródłem tego zdarzenia, lub "." na komputerze lokalnym.</param>
        <summary>Określa nazwę określonego źródła jako źródło zdarzeń prawidłowe zapisywania wpisów dziennika na określonym komputerze. Tej metody można również utworzyć nowy dziennik niestandardowy na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można utworzyć dziennika niestandardowego lub można utworzyć ani zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> do istniejącego dziennika na określonym komputerze.  
  
 Jeśli `logName` jest `null` lub ciąg pusty ("") podczas wywoływania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, domyślnie przyjmowana jest dziennika w dzienniku aplikacji. Jeśli dziennika nie istnieje na określonym komputerze, system tworzy dziennik niestandardowy i rejestruje aplikację jako <xref:System.Diagnostics.EventLog.Source%2A> dla tego dziennika.  
  
 Należy utworzyć źródło zdarzeń podczas pisania w dzienniku zdarzeń. Przed zapisaniem wpis w dzienniku zdarzeń, należy zarejestrować źródło zdarzenia z dziennika zdarzeń jako prawidłowe źródło zdarzeń. Podczas zapisu dziennika system używa <xref:System.Diagnostics.EventLog.Source%2A> można znaleźć do odpowiedniego dziennika, w którym można umieścić wpis. Jeśli odczytujesz dziennika zdarzeń, można określić <xref:System.Diagnostics.EventLog.Source%2A>, lub <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyny tego wymagania jest, że wszystkie dzienniki zdarzeń, zabezpieczeń, w tym musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. W systemie Windows Vista lub nowszy użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> jest generowany.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia się zapisać zdarzeń; należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennik jest tworzone dopiero po pierwszej pozycji są zapisywane do niego.  
  
 System operacyjny zapisuje dzienniki zdarzeń jako plików. Jeśli używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Aby utworzyć nowy dziennik zdarzeń, skojarzony plik znajduje się w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona przez dodanie pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Źródło musi być unikatowa na komputerze lokalnym; Nowa nazwa źródła nie może dopasować istniejącej nazwy źródła lub nazwa istniejącego dziennika zdarzeń. Każde źródło może zapisywać do dziennika zdarzeń tylko jeden jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników zdarzeń. Na przykład aplikacja może wymagać wielu źródeł skonfigurowane dla różnych dzienników zdarzeń lub innego zasobu plików.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Użycie innych aplikacji lub składników istniejącego źródła, Utwórz nowe źródło o zaktualizowanej konfiguracji od usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` na komputerze `MyServer`i dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Nie jest prawidłową nazwą komputera.  
  
 \- lub -  
  
 <paramref name="source" /> to ciąg pusty ("") lub <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="logName" /> nie jest nazwą prawidłową dziennika zdarzeń. Nazwy dzienników zdarzeń muszą składać się ze znaków drukowalnych i nie może zawierać znaków ' * ','?', lub "\\".  
  
 \- lub -  
  
 <paramref name="logName" /> jest nieprawidłowa dla utworzenia dziennika użytkownika. Nazwy dzienników zdarzeń AppEvent, SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
 \- lub -  
  
 Nazwa dziennika odpowiada istniejącej nazwy źródła zdarzenia.  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.  
  
 \- lub -  
  
 Pierwsze 8 znaków <paramref name="logName" /> dopasowania nazwy pierwsze 8 znaków istniejący dziennik zdarzeń na określonym komputerze.  
  
 \- lub -  
  
 Nie można zarejestrować źródła, ponieważ już istnieje na określonym komputerze.  
  
 \- lub -  
  
 Nazwa źródła odpowiada istniejącej nazwy źródła zdarzenia.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na określonym komputerze.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa zasób dziennika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do usunięcia. Możliwe wartości: aplikacji, zabezpieczeń, systemu i wszelkie niestandardowe dzienniki zdarzeń na komputerze.</param>
        <summary>Usuwa dziennik zdarzeń z komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dziennik, który chcesz usunąć na komputerze lokalnym. Możesz usunąć wszelkie dziennika na komputerze, pod warunkiem, że odpowiednich uprawnień rejestru.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Usuwa dziennik określony przez `logName` z komputera lokalnego. Jeśli chcesz usunąć tylko źródła zarejestrowane w dzienniku, wywołaj <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, więc można wywołać w samej klasy. Nie jest konieczne do utworzenia nowego wystąpienia <xref:System.Diagnostics.EventLog> wywoływanie jednej z metod.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Metoda najpierw usuwa plik, w którym jest przechowywana zawartość dziennika. Następnie uzyskuje dostęp do rejestru i usuwa wszystkie źródła zdarzenia zarejestrowane dla tego dziennika. Czy można odtworzyć dziennik w późniejszym czasie, należy zarejestrować źródła zdarzeń ponownie, jeśli mają być ponownie używane. Jeśli nie zarejestrujesz źródła zdarzeń i inni użytkownicy zapisać źródła zdarzenia bez określania nazwy dziennika, zostanie utworzona źródło zdarzenia w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były możliwość zapisywania wpisów dziennika, należy usunąć i utworzyć ponownie zostaną zapisane w dzienniku aplikacji, ponieważ zawiera teraz źródło zdarzenia.  
  
> [!NOTE]
>  Ponowne tworzenie dziennika zdarzeń może być trudne procesu. Nie usuwaj żadnego z dzienników zdarzeń utworzonych przez system, takie jak dziennik aplikacji.  
  
 Usuwanie dziennika poprzez wywołanie <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających.  
  
   
  
## Examples  
 Poniższy przykład usuwa dziennik z komputera lokalnego. Przykład określa dziennika od źródła.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennik niestandardowy, upewnij się, brak innych źródeł zapisu do tego dziennika.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> to ciąg pusty ("") lub <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze lokalnym.  
  
 \- lub -  
  
 Dziennik nie istnieje na komputerze lokalnym.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Dziennik zdarzeń nie został wyczyszczony pomyślnie.  
  
 —lub—  
  
 Nie można otworzyć dziennika. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do usunięcia. Możliwe wartości: aplikacji, zabezpieczeń, systemu i wszelkie niestandardowe dzienniki zdarzeń na określonym komputerze.</param>
        <param name="machineName">Nazwa komputera, aby usunąć dziennika, lub "." na komputerze lokalnym.</param>
        <summary>Usuwa dziennik zdarzeń z określonego komputera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dziennik, który chcesz usunąć z komputera zdalnego. Możesz usunąć wszelkie dziennika na komputerze, pod warunkiem, że odpowiednich uprawnień rejestru.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Usuwa dziennik określony przez `logName` z komputera określoną przez `machineName`. Jeśli chcesz usunąć tylko źródła zarejestrowane w dzienniku, wywołaj <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, więc można wywołać w samej klasy. Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> wywoływanie jednej z metod.  
  
 Ta metoda usuwa najpierw plik, w którym jest przechowywana zawartość dziennika. Następnie uzyskuje dostęp do rejestru i usuwa wszystkie źródła zdarzenia zarejestrowane dla tego dziennika. Czy można odtworzyć dziennik w późniejszym czasie, należy zarejestrować źródła zdarzeń ponownie, jeśli mają być ponownie używane. Jeśli nie zarejestrujesz źródła zdarzeń i inni użytkownicy zapisać źródła zdarzenia bez określania nazwy dziennika, zostanie utworzona źródło zdarzenia w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były możliwość zapisywania wpisów dziennika, należy usunąć i utworzyć ponownie zostaną zapisane w dzienniku aplikacji, ponieważ zawiera teraz źródło zdarzenia.  
  
> [!NOTE]
>  Ponowne tworzenie dziennika zdarzeń może być trudne procesu. Nie usuwaj żadnego z dzienników zdarzeń utworzonych przez system, takie jak dziennik aplikacji.  
  
 Usuwanie dziennika poprzez wywołanie <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających.  
  
   
  
## Examples  
 Poniższy przykład usuwa dziennik z określonego komputera. Przykład określa dziennika od źródła.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennik niestandardowy, upewnij się, brak innych źródeł zapisu do tego dziennika.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> to ciąg pusty ("") lub <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="machineName" /> nie jest prawidłową nazwą komputera.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na określonym komputerze.  
  
 \- lub -  
  
 Dziennik nie istnieje na określonym komputerze.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Dziennik zdarzeń nie został wyczyszczony pomyślnie.  
  
 —lub—  
  
 Nie można otworzyć dziennika. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa rejestrację źródła zdarzeń aplikacji z dziennika zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa, za pomocą której aplikacja jest zarejestrowany w dzienniku zdarzeń systemu.</param>
        <summary>Usuwa rejestrację źródła zdarzenia z dziennika zdarzeń komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do usunięcia rejestracji <xref:System.Diagnostics.EventLog.Source%2A> z komputera lokalnego. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> uzyskuje dostęp do rejestru na komputerze lokalnym i usuwa rejestrację aplikacji jako prawidłowe źródło zdarzeń.  
  
 Jeśli nie jest już potrzebna na zapisywanie wpisów w tym dzienniku, należy usunąć składnika jako prawidłowe źródło zdarzeń. Na przykład zrobić to jeśli musisz zmienić składnika z jednego dziennika do innego. Ponieważ źródłem można zarejestrować tylko jeden dziennik w czasie, zmiana w dzienniku wymaga usunięcia bieżącego rejestracji.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Usuwa tylko źródło, które są zarejestrowane w dzienniku. Jeśli chcesz usunąć samego dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Delete%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, więc można wywołać w samej klasy. Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> wywoływanie jednej z metod.  
  
 Usuwanie dziennika poprzez wywołanie <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających.  
  
> [!NOTE]
>  Jeśli źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład powoduje usunięcie źródła z komputera lokalnego. Przykład określa dziennika od źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennik niestandardowy, upewnij się, brak innych źródeł zapisu do tego dziennika.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Parametr nie istnieje w rejestrze komputera lokalnego.  
  
 \- lub -  
  
 Nie masz dostępu do zapisu klucza rejestru dla dziennika zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa, za pomocą której aplikacja jest zarejestrowany w dzienniku zdarzeń systemu.</param>
        <param name="machineName">Nazwa komputera, aby usunąć rejestrację, lub "." na komputerze lokalnym.</param>
        <summary>Usuwa rejestrację źródła zdarzeń aplikacji z określonego komputera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby usunąć rejestrację, użyj tego przeciążenia <xref:System.Diagnostics.EventLog.Source%2A> z komputera zdalnego. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> uzyskuje dostęp do rejestru na komputerze określonym przez `machineName` i usuwa rejestrację aplikacji jako prawidłowe źródło zdarzeń.  
  
 Jeśli nie jest już potrzebna na zapisywanie wpisów w tym dzienniku, należy usunąć składnika jako prawidłowe źródło zdarzeń. Na przykład zrobić to jeśli musisz zmienić składnika z jednego dziennika do innego. Ponieważ źródłem można zarejestrować tylko jeden dziennik w czasie, zmiana w dzienniku wymaga usunięcia bieżącego rejestracji.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Usuwa tylko źródło, które są zarejestrowane w dzienniku. Jeśli chcesz usunąć samego dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Delete%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, więc można wywołać w samej klasy. Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> wywoływanie jednej z metod.  
  
 Usuwanie dziennika poprzez wywołanie <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających.  
  
> [!NOTE]
>  Jeśli źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład usuwa źródła z określonego komputera. Przykład określa dziennika od źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennik niestandardowy, upewnij się, brak innych źródeł zapisu do tego dziennika.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest nieprawidłowy.  
  
 \- lub -  
  
 <paramref name="source" /> Parametr nie istnieje w rejestrze określonego komputera.  
  
 \- lub -  
  
 Nie masz dostępu do zapisu klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> Nie można usunąć, ponieważ w rejestrze, klucz rejestru nadrzędnej <paramref name="source" /> nie zawiera podklucz o takiej samej nazwie.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Diagnostics.EventLog" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Diagnostics.EventLog> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.Diagnostics.EventLog" /> odbiera <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> powiadomienia o zdarzeniach.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Diagnostics.EventLog" /> otrzymuje powiadomienie, gdy wpis jest zapisywane w dzienniku, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Właściwość określa, czy <xref:System.Diagnostics.EventLog> informuje o zdarzeniach, gdy wpisy są zapisywane w dzienniku. Gdy ta właściwość jest `true`, składników, które odbierają <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenia będą otrzymywać powiadomienia kiedykolwiek wpis dziennika, który jest określony w <xref:System.Diagnostics.EventLog.Log%2A> właściwości. Jeśli <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> jest `false`, są zgłaszane żadne zdarzenia.  
  
> [!NOTE]
>  Można otrzymywać powiadomienia o zdarzeniach, tylko wtedy, gdy wpisy są zapisywane na komputerze lokalnym. Nie można otrzymywać powiadomienia w nich pozycje zapisane na komputerach zdalnych.  
  
   
  
## Examples  
 Następujący przykład uchwytów <xref:System.Diagnostics.EventLog.EntryWritten> zdarzeń.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dziennik zdarzeń znajduje się na komputerze zdalnym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Diagnostics.EventLog" /> używane w formularzu lub przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.BeginInit%2A> Metoda uruchamia inicjowania. Przy użyciu <xref:System.Diagnostics.EventLog.BeginInit%2A> i <xref:System.Diagnostics.EventLog.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawartość dziennika zdarzeń.</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLogEntryCollection" /> Zawierający wpisy w dzienniku zdarzeń. Każdy wpis jest skojarzony z wystąpieniem <see cref="T:System.Diagnostics.EventLogEntry" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.EventLog.Entries%2A> elementu członkowskiego podczas czytania z dziennika zdarzeń.  
  
 Ponieważ ta właściwość jest tylko do odczytu, nie można zmodyfikować wpisu lub zapisu do dziennika przy użyciu <xref:System.Diagnostics.EventLog.Entries%2A>. Zamiast tego określ <xref:System.Diagnostics.EventLog.Source%2A> i Wywołaj <xref:System.Diagnostics.EventLog.WriteEntry%2A> zapisać nowy wpis dziennika. Można użyć <xref:System.Diagnostics.EventLog.Entries%2A> liczbę wpisów w dzienniku zdarzeń i wyświetlić każdego <xref:System.Diagnostics.EventLogEntry> w kolekcji. Użyj indeksowanej <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> elementu członkowskiego można pobrać informacji na temat określonego wpisu, takich jak <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, lub <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Nie jest konieczne w celu określenia <xref:System.Diagnostics.EventLog.Source%2A> gdy tylko do odczytu z dziennika. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwy i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości (nazwa komputera serwera) <xref:System.Diagnostics.EventLog> wystąpienia. W obu przypadkach <xref:System.Diagnostics.EventLog.Entries%2A> elementu członkowskiego jest automatycznie wypełniane przy użyciu listy wpisów dziennika zdarzeń. Możesz wybrać odpowiedni indeks elementu na liście do odczytu poszczególne pozycje.  
  
 To ważna różnica między odczytywania i zapisywania wpisów dziennika jest, że nie jest konieczne jawnie wywołać metodę odczytu. Po <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> są określone, <xref:System.Diagnostics.EventLog.Entries%2A> właściwość zostanie wypełnione automatycznie. W przypadku zmiany wartości <xref:System.Diagnostics.EventLog.Log%2A> lub <xref:System.Diagnostics.EventLog.MachineName%2A> właściwość <xref:System.Diagnostics.EventLog.Entries%2A> właściwości jest zapełnienia przy następnym go odczytać.  
  
> [!NOTE]
>  Nie należy określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się z dziennikiem. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny, ".", zakłada, że.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń, "MyNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wpis dziennika zdarzeń na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać powiadomienia o zdarzeniach, należy ustawić <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> do `true`. Może odbierać powiadomienia o zdarzeniach, gdy wpisy są zapisywane na komputerze lokalnym. Nie można otrzymywać powiadomienia w nich pozycje zapisane na komputerach zdalnych.  
  
 Po utworzeniu <xref:System.Diagnostics.EventLog.EntryWritten> delegata, należy określić metodę, która obsłuży zdarzenie. Aby skojarzyć zdarzenie z obsługi zdarzenia, należy dodać wystąpienia delegata zdarzenia. Program obsługi zdarzeń jest wywoływana, gdy wystąpi zdarzenie, przed usunięciem obiektu delegowanego. Aby uzyskać więcej informacji na temat obsługi zdarzeń z delegatów zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 System odpowiada <xref:System.Diagnostics.EventLog.WriteEntry%2A> tylko wtedy, gdy ostatnie zdarzenie zapisu wystąpił co najmniej sześć sekund wcześniej. Oznacza to, zostanie wyświetlony tylko jeden <xref:System.Diagnostics.EventLog.EntryWritten> powiadamianie o zdarzeniach w ciągu sekundy sześciu, nawet jeśli zmiana w dzienniku więcej niż jedno zdarzenie występuje. Po wstawieniu interwał uśpienia wystarczająco długi (około 10 sekund) między wywołania <xref:System.Diagnostics.EventLog.WriteEntry%2A>, jest mniej prawdopodobne sygnałów zdarzenia. Jednak jeśli zdarzenia zapisu częściej, może nie odbierać powiadomienie o zdarzeniu do momentu następnym interwale czasowym. Zwykle powiadomienia o zdarzeniach brakujących są nie utracone, ale opóźnienie.  
  
   
  
## Examples  
 Poniższy przykład obsługuje wpis zapisywane zdarzenia.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy określony dziennik istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do wyszukania. Możliwe wartości: aplikacji, zabezpieczeń, System, inne dzienniki specyficzne dla aplikacji (takich jak powiązane z usługą Active Directory) lub dowolnego niestandardowego dziennika na komputerze.</param>
        <summary>Określa, czy dziennik istnieje na komputerze lokalnym.</summary>
        <returns>
          <see langword="true" /> Jeśli dziennik istnieje na komputerze lokalnym; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy dziennik istnieje na komputerze lokalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na komputerze lokalnym; w przeciwnym razie zwraca `false`.  
  
 Ponieważ nowego dziennika nie może zawierać nazwę istniejącego dziennika na tym samym komputerze, ta metoda przed utworzeniem nowego dziennika można określić, czy określony `logName` już istnieje na komputerze lokalnym. `logName` Parametr nie jest uwzględniana wielkość liter.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> jest `static` metody, więc może ona zostać wywołana w samej klasy. Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> do wywołania <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jest Nazwa_dziennika <see langword="null" /> lub wartość jest pusta.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Dziennik do wyszukania. Możliwe wartości: aplikacji, zabezpieczeń, System, inne dzienniki specyficzne dla aplikacji (takich jak powiązane z usługą Active Directory) lub dowolnego niestandardowego dziennika na komputerze.</param>
        <param name="machineName">Nazwa komputera, na których będą poszukiwane dziennika, lub "." na komputerze lokalnym.</param>
        <summary>Określa, czy dziennik istnieje na określonym komputerze.</summary>
        <returns>
          <see langword="true" /> Jeśli istnieje dziennika na określonym komputerze. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy dziennik istnieje na komputerze zdalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze zdalnym, użyj <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na określonym komputerze. w przeciwnym razie zwraca `false`.  
  
 Ponieważ nowego dziennika nie może zawierać nazwę istniejącego dziennika na tym samym komputerze, ta metoda przed utworzeniem nowego dziennika można określić, czy jest to jeden z określonym `logName` już istnieje na serwerze określonym przez `machineName` parametru. `logName` i `machineName` parametrów nie jest uwzględniana.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> jest `static` metody, więc może ona zostać wywołana w samej klasy. Nie jest konieczne do utworzenia nowego wystąpienia <xref:System.Diagnostics.EventLog> do wywołania <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr ma nieprawidłowy format. Upewnij się, że używasz poprawnej składni dla komputera, na którym wyszukujesz.  
  
 —lub—  
  
 <paramref name="logName" /> Jest <see langword="null" /> lub wartość jest pusta.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę w dziennikach zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przeszukuje wszystkie dzienniki zdarzeń na komputerze lokalnym i tworzy tablicę <see cref="T:System.Diagnostics.EventLog" /> obiektów, które zawierają listy.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.EventLog" /> reprezentujący dzienniki na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica <xref:System.Diagnostics.EventLog> obiektów jest migawką wszystkie dzienniki zdarzeń na komputerze lokalnym po wywołaniu <xref:System.Diagnostics.EventLog.GetEventLogs%2A> staje się. Nie jest kolekcją dynamicznych, więc nie odzwierciedla usunięcia lub tworzenia dzienników w czasie rzeczywistym. Należy sprawdzić, czy dziennika w tablicy istnieje przed odczytać lub zapisać go. Tablica zwykle zawiera co najmniej trzy dzienniki: aplikacji, System i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na komputerze lokalnym, pojawią się również do tablicy.  
  
 Aby pobrać listę dzienników zdarzeń, musi mieć odpowiednich uprawnień rejestru. Te uprawnienia są takie same jak wymagane do wywołania <xref:System.Diagnostics.EventLog.Exists%2A> i <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Nie masz dostępu do odczytu do rejestru.  
  
 —lub—  
  
 Nie ma żadnej usługi dziennika zdarzeń na komputerze.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, na których będą poszukiwane dzienników zdarzeń.</param>
        <summary>Przeszukuje wszystkie dzienniki zdarzeń na danym komputerze i tworzy tablicę <see cref="T:System.Diagnostics.EventLog" /> obiektów, które zawierają listy.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.EventLog" /> reprezentujący dzienniki na danym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica <xref:System.Diagnostics.EventLog> obiektów jest migawką wszystkie dzienniki zdarzeń na komputerze określonym przez `machineName` parametru po wywołaniu <xref:System.Diagnostics.EventLog.GetEventLogs%2A> staje się. Nie jest kolekcją dynamicznych, więc nie odzwierciedla usunięcia lub tworzenia dzienników w czasie rzeczywistym. Należy sprawdzić, czy dziennika w tablicy istnieje przed odczytać lub zapisać go. Tablica zwykle zawiera co najmniej trzy dzienniki: aplikacji, System i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na określonym komputerze pojawią się również do tablicy.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> jest `static` metody, więc może ona zostać wywołana na <xref:System.Diagnostics.EventLog> samej klasy. Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> obiekt do wywoływania metody.  
  
 Aby pobrać listę dzienników zdarzeń, musi mieć odpowiednich uprawnień rejestru. Te uprawnienia są takie same jak wymagane do wywołania <xref:System.Diagnostics.EventLog.Exists%2A> i <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Poniższy przykład pobiera listę dzienników na komputerze "MójSerwer". Następnie danych wyjściowych nazwę każdego dziennika.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest prawidłową nazwą komputera.</exception>
        <exception cref="T:System.InvalidOperationException">Nie masz dostępu do odczytu do rejestru.  
  
 —lub—  
  
 Nie ma żadnej usługi dziennika zdarzeń na komputerze.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę dziennika do odczytu lub zapisu.</summary>
        <value>Nazwa dziennika. Może to być aplikacji, System, zabezpieczenia lub niestandardowej nazwy dziennika. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie na serwerze istnieje trzech plików dziennika: aplikacji, System i zabezpieczenia. Aplikacje i usługi, należy użyć pliku dziennika aplikacji. Sterowniki urządzeń, użyj pliku dziennika systemowego. System generuje sukces i niepowodzenie zdarzeń inspekcji w dzienniku zabezpieczeń po włączeniu inspekcji. Jeśli masz inne aplikacje zainstalowane, jak usługa Active Directory w systemach Windows Server może być inne domyślnych plików dziennika. Ponadto można utworzyć plików dziennika niestandardowego na komputerze lokalnym lub zdalnym. Niestandardowe dzienniki zorganizowane wpisy w sposób bardziej szczegółowy, niż jest dozwolone, gdy składniki sieci zapisać zdarzeń do dziennika aplikacji domyślne.  
  
> [!NOTE]
>  Nazwy dzienników mogą zawierać maksymalnie osiem znaków. Wybranego systemu MyLogSample1 i MyLogSample2 są tego samego dziennika.  
  
 Podczas pisania do dziennika zdarzeń nie wystarcza do określenia <xref:System.Diagnostics.EventLog.Log%2A> właściwości. Musisz skojarzyć <xref:System.Diagnostics.EventLog.Source%2A> właściwości zasobem dziennika zdarzeń, aby połączyć go z dziennika. Nie jest konieczne w celu określenia <xref:System.Diagnostics.EventLog.Source%2A> po tylko do odczytu z dziennika, ale źródłem zdarzenia musi być skojarzony z zasobem dziennika zdarzeń w rejestrze serwera. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwy i <xref:System.Diagnostics.EventLog.MachineName%2A> (nazwa komputera serwera) można odczytać z niego.  
  
> [!NOTE]
>  Nie należy określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się z dziennikiem. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Source%2A> właściwość nie została określona, wywołanie <xref:System.Diagnostics.EventLog.Log%2A> zwraca pusty ciąg, jeśli <xref:System.Diagnostics.EventLog.Log%2A> nie została jawnie ustawiona (przez ustawienie <xref:System.Diagnostics.EventLog.Log%2A> właściwości, lub za pośrednictwem konstruktora). Jeśli <xref:System.Diagnostics.EventLog.Source%2A> został określony, <xref:System.Diagnostics.EventLog.Log%2A> zwraca nazwę dziennika, do którego zarejestrowano tego źródła.  
  
 Źródła można zarejestrować tylko jeden dziennik w czasie. Jeśli <xref:System.Diagnostics.EventLog.Source%2A> właściwość została ustawiona na wystąpienie <xref:System.Diagnostics.EventLog>, nie można zmienić <xref:System.Diagnostics.EventLog.Log%2A> właściwości w tym <xref:System.Diagnostics.EventLog> bez zmiany wartości <xref:System.Diagnostics.EventLog.Source%2A> lub wywoływania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> pierwszy. Jeśli zmienisz <xref:System.Diagnostics.EventLog.Log%2A> właściwości po <xref:System.Diagnostics.EventLog.Source%2A> właściwość została ustawiona, zapisywania wpisów dziennika zgłasza wyjątek.  
  
 System operacyjny zapisuje dzienniki zdarzeń jako plików. Jeśli używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Aby utworzyć nowy dziennik zdarzeń, skojarzony plik znajduje się w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona przez dodanie pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Nie można utworzyć nowego przy użyciu dziennika <xref:System.Diagnostics.EventLog.Log%2A> właściwości samego (bez określania źródła dziennika). Możesz wywołać <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, przekazując nazwę dziennika jako parametru, a następnie wywołać <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Jednak celem jest zwykle albo utwórz (i pozycje, aby zapisać) nowe dzienniki specyficzne dla aplikacji, lub do odczytu z istniejących dzienników.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Log%2A> zmiany wartości dziennika zdarzeń zostanie zamknięte, a wszystkie uchwytów zdarzeń są wydawane.  
  
> [!CAUTION]
>  Jeśli ustawisz <xref:System.Diagnostics.EventLog.Log%2A> właściwość na nazwę dziennika, który nie istnieje, system dołącza <xref:System.Diagnostics.EventLog> w dzienniku aplikacji, ale nie ostrzega użytkownika, że używa dziennika inną niż określona.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń, "NewEventLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przyjazną nazwę dziennika zdarzeń.</summary>
        <value>Nazwa, która reprezentuje dziennika zdarzeń w Podglądzie zdarzeń systemu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  W systemie Windows Vista lub nowszy użytkownicy nie masz uprawnień do dostępu do dziennika zabezpieczeń. Jeśli korzystasz z systemu Windows Vista lub nowszego jako użytkownik, zostanie wyświetlony <xref:System.Security.SecurityException> usiłujące uzyskać dostępu do nazwy wyświetlanej zdarzenia w dzienniku zabezpieczeń.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 W poniższym przykładzie wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla <xref:System.Diagnostics.EventLog.LogDisplayName%2A> dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony <see cref="P:System.Diagnostics.EventLog.Log" /> nie istnieje w rejestrze dla tego komputera.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Możliwość odczytu wskazanego klucza rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Możliwość dostępu do wskazanego klucza rejestru, jeśli jest to klucz zdalny. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia.</param>
        <param name="machineName">Nazwa komputera, na którym do przeszukania, lub "." na komputerze lokalnym.</param>
        <summary>Pobiera nazwę dziennika, do którego określone źródło jest zarejestrowany.</summary>
        <returns>Nazwa dziennika skojarzonych z określonego źródła w rejestrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródło zdarzenia wskazuje co rejestruje zdarzenie. Często jest nazwa aplikacji lub nazwy podskładnika aplikacji, jeśli aplikacja jest duży. Aplikacje i usługi, należy zapisać dziennik aplikacji lub dziennik niestandardowy. Sterowniki urządzeń, należy zapisać w dzienniku systemu.  
  
 Podczas tworzenia nowego źródła naraz tylko może zapisywać w jednym dzienniku, system rejestruje aplikację z dziennika zdarzeń jako prawidłowe źródło wpisów. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość może być dowolnym ciągiem, ale nazwa nie może być używane przez inne źródła na komputerze. Próba utworzenia zduplikowanych <xref:System.Diagnostics.EventLog.Source%2A> wartość zgłasza wyjątek. Jednak pojedynczy dziennik zdarzeń może mieć wiele różnych źródeł, zapisywania do niego.  
  
   
  
## Examples  
 Poniższy przykład powoduje usunięcie źródła z komputera lokalnego. Przykład określa dziennika od źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennik niestandardowy, upewnij się, brak innych źródeł zapisu do tego dziennika.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym ma być odczytywane lub zapisywane zdarzenia.</summary>
        <value>Nazwa serwera, na którym znajduje się w dzienniku zdarzeń. Wartość domyślna to komputer lokalny (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli piszesz do dziennika zdarzeń, należy skojarzyć <xref:System.Diagnostics.EventLog.Source%2A> z obiektem dziennika zdarzeń nawiązać dziennika. Nie jest konieczne w celu określenia <xref:System.Diagnostics.EventLog.Source%2A> właściwości, gdy tylko do odczytu z dziennika. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwy i <xref:System.Diagnostics.EventLog.MachineName%2A> (nazwa komputera serwera).  
  
> [!NOTE]
>  Nie trzeba określać <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się z dziennikiem. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 Źródła można zarejestrować tylko jeden dziennik w czasie. Jeśli <xref:System.Diagnostics.EventLog.Source%2A> właściwość została ustawiona na wystąpienie <xref:System.Diagnostics.EventLog>, nie można zmienić <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości w tym <xref:System.Diagnostics.EventLog> bez zmiany wartości <xref:System.Diagnostics.EventLog.Source%2A> lub wywoływania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> pierwszy. Jeśli zmienisz <xref:System.Diagnostics.EventLog.MachineName%2A> właściwość <xref:System.Diagnostics.EventLog> zamyka wszystkie dojścia i reattaches do log i source na nowym komputerze.  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> Wartość nie może być pustym ciągiem. Jeśli nie jest jawnie ustawiona domyślnie na komputerze lokalnym (".").  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń, "NewEventLog" na określonym komputerze.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar dziennika zdarzeń w kilobajtach.</summary>
        <value>Maksymalny rozmiar dziennika zdarzeń w kilobajtach. Wartość domyślna to 512 i wskazujący maksymalny rozmiar pliku 512 kilobajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Właściwość reprezentuje limit rozmiaru pliku dziennika zdarzeń. Gdy dziennik zdarzeń osiągnie limit rozmiaru skonfigurowanego <xref:System.Diagnostics.EventLog.OverflowAction%2A> wartość określa, czy nowe wpisy zostaną odrzucone lub czy nowe wpisy zastąpić starsze wpisy.  
  
> [!NOTE]
>  Ta właściwość reprezentuje ustawienia konfiguracji dziennika zdarzeń reprezentowanym przez to wystąpienie. Jeśli dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy zarejestrowane w dzienniku zdarzeń wszystkie źródła zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona wartość jest mniejsza niż 64, lub większa niż 4194240 lub nie jest wielokrotnością 64.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest nazwą prawidłowego dziennika.  
  
 \- lub -  
  
 Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze docelowym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę dni, aby zachować wpisy w dzienniku zdarzeń.</summary>
        <value>Liczba dni, które są przechowywane wpisy w dzienniku zdarzeń. Wartość domyślna to 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> właściwości, aby sprawdzić bieżące ustawienia dla dziennika zdarzeń. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Aby zmienić minimalną liczbę dni, które muszą zostać zachowane każdego wpisu w dzienniku zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wartość zależy od zachowania skonfigurowanych przepełnienia dziennika zdarzeń. Jeśli <xref:System.Diagnostics.OverflowAction> ma ustawioną wartość właściwości dziennika zdarzeń <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, a następnie <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość jest równa 0. Jeśli <xref:System.Diagnostics.OverflowAction> ma ustawioną wartość właściwości dziennika zdarzeń <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, a następnie <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość wynosi -1. Jeśli <xref:System.Diagnostics.OverflowAction> ma ustawioną wartość właściwości dziennika zdarzeń <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, a następnie <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość jest większa od zera i reprezentuje liczbę dni, aby zachować wpisy w dzienniku zdarzeń po zapełnieniu dziennika zdarzeń.  
  
 Zachowanie przepełnienie tylko występuje, gdy dziennik zdarzeń osiągnie limit rozmiaru. Gdy <xref:System.Diagnostics.EventLog> ma jego <xref:System.Diagnostics.EventLog.OverflowAction%2A> ustawioną <xref:System.Diagnostics.OverflowAction.OverwriteOlder>i dziennik zdarzeń osiągnie maksymalny rozmiar, a następnie nowe wpisy są zapisywane tylko jeśli ich zastąpić wpisów, którego okres ważności przekracza <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> okresu. Zachowywanie wpisy zdarzeń minimalny okres jest odpowiednie, gdy regularnie archiwizacji dziennik zdarzeń. W przeciwnym razie ryzyko utraty nowe wpisy, gdy dziennik zdarzeń osiągnie limit. Aby uniknąć utraty nowych informacji o zdarzeniu, należy ustawić co najmniej dni zdarzeń oparte na harmonogramie archiwum dla określonego dziennika zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Zachowanie przepełnienia dla zapisywania nowych wpisów w dzienniku zdarzeń.</param>
        <param name="retentionDays">Minimalna liczba dni, przez które każdy wpis dziennika zdarzeń jest przechowywane. Ten parametr jest używany tylko wtedy, gdy <c>akcji</c> ma ustawioną wartość <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Zmienia zachowanie skonfigurowanych dla zapisywania nowych wpisów po jego maksymalny rozmiar pliku dziennika zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie przepełnienia dziennika zdarzeń określa, co się dzieje, gdy nowe wpisy są zapisywane do dziennika, który osiągnął maksymalny rozmiar.  
  
> [!NOTE]
>  Zachowanie przepełnienie obowiązuje tylko wtedy, gdy dziennik zdarzeń osiągnie maksymalny rozmiar. Zachowanie przepełnienie nie ma wpływu na zapisywanie nowego wpisu w dzienniku, która może obsłużyć wpisy w dzienniku zdarzeń dodatkowe.  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Metody konfiguruje działanie przepełnienia dziennika zdarzeń. <xref:System.Diagnostics.EventLog> wystąpienie. Po wywołaniu tej metody dla dziennika zdarzeń określony przez <xref:System.Diagnostics.EventLog.Log%2A> właściwość <xref:System.Diagnostics.EventLog.OverflowAction%2A> i <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartości właściwości odzwierciedlają zachowanie nowo skonfigurowanego przepełnienia.  
  
> [!NOTE]
>  Ta właściwość reprezentuje ustawienia konfiguracji dziennika zdarzeń reprezentowanym przez to wystąpienie. Jeśli dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy zarejestrowane w dzienniku zdarzeń wszystkie źródła zdarzeń.  
  
 Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> aby wskazać, że nowy wpis zastępuje najstarszą wpis podczas <xref:System.Diagnostics.EventLog> osiągnie maksymalny rozmiar. Jeśli `action` ustawiono parametr <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, `retentionDays` wartość parametru jest ignorowana.  
  
 Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction.OverwriteOlder> aby wskazać, że każdy nowy wpis zastępuje starsze wpisy podczas <xref:System.Diagnostics.EventLog> osiągnie maksymalny rozmiar. Określ liczbę dni, które muszą zostać zachowane zdarzenia w dzienniku przy użyciu `retentionDays` parametru. Zapisywane zakresu przechowywania zdarzenia nie zostaną zastąpione przez nowe wpisy.  
  
 Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> odrzucić nowe zdarzenia po osiągnięciu maksymalnego rozmiaru dziennika. Jeśli `action` ustawiono parametr <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, `retentionDays` wartość parametru jest ignorowana.  
  
> [!CAUTION]
>  Ustawienie zasad przepełnienie <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> Określa, że nowe wpisy zostaną odrzucone po zapełnieniu dziennika zdarzeń. Jeśli używasz tego ustawienia upewnij się, regularnie zarchiwizowane i wyczyszczone, aby uniknąć osiągnięcia limit maksymalnego rozmiaru dziennika zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład przedstawia zasady skonfigurowane przepełnienia dla określonego dziennika zdarzeń i zezwala użytkownikowi na wybranie nowe ustawienie zasad przepełnienia dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> nie jest prawidłową <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> nie może być większa niż jeden, większy niż 365.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest nazwą prawidłowego dziennika.  
  
 \- lub -  
  
 Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze docelowym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zachowanie skonfigurowany do przechowywania nowych wpisów, gdy jego maksymalny rozmiar pliku dziennika osiągnie dziennika zdarzeń.</summary>
        <value>
          <see cref="T:System.Diagnostics.OverflowAction" /> Wartość, która określa zachowanie skonfigurowany do przechowywania nowych wpisów, gdy jego maksymalny rozmiar dziennika osiągnie dziennika zdarzeń. Wartość domyślna to <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzienniki zdarzeń zwiększa się rozmiar jako nowe zdarzenia są zapisywane do nich. Każdy dziennik zdarzeń ma limit maksymalnego skonfigurowanego rozmiaru; <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> właściwość określa maksymalną liczbę kilobajtów dozwolony rozmiar pliku dziennika zdarzeń.  
  
 Użyj <xref:System.Diagnostics.EventLog.OverflowAction%2A> wartości właściwości do sprawdzenia zachowania skonfigurowanych przepełnienia dziennika zdarzeń na maksymalnego rozmiaru. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> metodę, aby zmienić zachowanie przepełnienia dziennika zdarzeń.  
  
> [!NOTE]
>  Zachowanie przepełnienie obowiązuje tylko wtedy, gdy dziennik zdarzeń osiągnie maksymalny rozmiar. Zachowanie przepełnienie nie ma wpływu na zapisywanie nowego wpisu w dzienniku, która może obsłużyć wpisy w dzienniku zdarzeń dodatkowe.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Pełna ścieżka do pliku zlokalizowanych zasobów.</param>
        <param name="resourceId">Identyfikator zasobu indeksujący zlokalizowane ciągi w pliku zasobów.</param>
        <summary>Zlokalizowana nazwa dziennika zdarzeń, który jest wyświetlany w Podglądzie zdarzeń serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> do rejestracji i do zlokalizowanej nazwy wyświetlanej w Podglądzie zdarzeń niestandardowych dzienników zdarzeń.  
  
 Identyfikator określony zasób musi odpowiadać zlokalizowane ciągi zdefiniowane w pliku zasobów. Podgląd zdarzeń wyświetla nazwę dziennika zdarzeń niestandardowych przy użyciu zlokalizowany ciąg i bieżące ustawienia kultury. Na przykład można zdefiniować wiele nazw dziennika zdarzeń zlokalizowane dla innych kultur w pliku zasobów. Podgląd zdarzeń wyświetla zlokalizowany ciąg odpowiadający ustawienia kultury bieżącego użytkownika.  
  
 Jeśli podglądu zdarzeń nie może załadować zlokalizowanego ciągu z pliku zasobów lub jeśli nie nazwę wyświetlaną nie zostało zarejestrowano w dzienniku zdarzeń, następnie Podgląd zdarzeń wyświetla nazwę dziennika zdarzeń zdefiniowanych w <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Nie trzeba zarejestrować nazwę wyświetlaną dla wstępnie zdefiniowanego dzienników zdarzeń. System operacyjny rejestruje nazwy wyświetlane zlokalizowanych dzienniki zdarzeń aplikacji, System i zabezpieczenia.  
  
   
  
## Examples  
 Poniższy przykład określa, czy źródło zdarzenia o nazwie `SampleApplicationSource` jest zarejestrowana na komputerze lokalnym. Jeśli źródło zdarzenia nie istnieje, w przykładzie ustawia pliku zasobów komunikatów dla źródła i tworzy nowe źródło zdarzeń. Ponadto w przykładzie nazwę wyświetlaną zlokalizowanego w dzienniku zdarzeń przy użyciu wartości identyfikatora zasobu w `DisplayNameMsgId` i ścieżka pliku zasobu w `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 W przykładzie użyto następującego pliku tekst wiadomości wbudowanych w bibliotece EventLogMsgs.dll zasobów. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatorów zasobów i tekst dla kategorii, komunikatu o zdarzeniu i ciągi wstawiania parametru. W szczególności identyfikator zasobu 5001 jest zdefiniowany dla zlokalizowana nazwa dziennika zdarzeń.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest nazwą prawidłowego dziennika.  
  
 \- lub -  
  
 Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze docelowym.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę źródła do rejestracji i używana podczas zapisywania w dzienniku zdarzeń.</summary>
        <value>Nazwa zarejestrowany jako źródło wpisów dziennika zdarzeń. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródło zdarzenia wskazuje co rejestruje zdarzenie. Często jest nazwa aplikacji lub nazwy podskładnika aplikacji, jeśli aplikacja jest duży. Aplikacje i usługi, należy zapisać dziennik aplikacji lub dziennik niestandardowy. Sterowniki urządzeń, należy zapisać w dzienniku systemu.  
  
 Należy określić źródło zdarzenia będą zapisywane do dziennika zdarzeń. Przed zapisaniem wpis w dzienniku zdarzeń, należy zarejestrować źródło zdarzenia z dziennika zdarzeń jako prawidłowe źródło zdarzeń. Podczas zapisu dziennika system używa <xref:System.Diagnostics.EventLog.Source%2A> właściwości, aby znaleźć odpowiednie dziennika, w którym można umieścić wpis. Jeśli odczytujesz dziennika zdarzeń, można określić <xref:System.Diagnostics.EventLog.Source%2A>, lub <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Nie należy określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się z dziennikiem na komputerze lokalnym. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia się zapisać zdarzeń; należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennik jest tworzone dopiero po pierwszej pozycji są zapisywane do niego.  
  
 Źródło musi być unikatowa na komputerze lokalnym; Nowa nazwa źródła nie może dopasować istniejącej nazwy źródła lub nazwa istniejącego dziennika zdarzeń. Każde źródło może zapisywać do dziennika zdarzeń tylko jeden jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników zdarzeń. Na przykład aplikacja może wymagać wielu źródeł skonfigurowane dla różnych dzienników zdarzeń lub innego zasobu plików.  
  
 Jeśli zmienisz <xref:System.Diagnostics.EventLog.Source%2A> wartość <xref:System.Diagnostics.EventLog> do której został on zarejestrowany zostanie zamknięte, a wszystkie uchwytów zdarzeń są wydawane.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Użycie innych aplikacji lub składników istniejącego źródła, Utwórz nowe źródło o zaktualizowanej konfiguracji od usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` Jeśli jeszcze nie istnieje, a dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje w rejestrze komputera dla danego źródła zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia.</param>
        <summary>Określa, czy źródłem zdarzenia jest zarejestrowana na komputerze lokalnym.</summary>
        <returns>
          <see langword="true" /> Jeśli źródło zdarzenia jest zarejestrowana na komputerze lokalnym; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy źródło zdarzenia istnieje na komputerze lokalnym. Jeśli chcesz określić, czy dziennik istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na komputerze lokalnym; w przeciwnym razie <xref:System.Security.SecurityException> zostanie wygenerowany.  
  
> [!NOTE]
>  Aby wyszukiwać źródła zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyny tego wymagania jest, że wszystkie dzienniki zdarzeń, zabezpieczeń, w tym musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> jest generowany.  
>   
>  Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
> [!NOTE]
>  Usługa, która jest wykonywana w ramach <xref:System.ServiceProcess.ServiceAccount.LocalSystem> konto nie ma uprawnienia wymagane do wykonania tej metody. Rozwiązanie to sprawdź, czy źródło zdarzenia znajduje się w <xref:System.ServiceProcess.ServiceInstaller>, a jeśli on nie istnieje, można utworzyć źródła w Instalatorze.  
  
 Ponieważ nowe źródło nie może zawierać nazwę istniejącego źródła na tym samym komputerze, ta metoda umożliwia przed podjęciem próby wykonania wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do zapewnienia, że źródło z nazwą określoną przez `source` jeszcze nie istnieje na komputerze lokalnym. `source` Parametr nie jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` Jeśli jeszcze nie istnieje, a dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> Nie można odnaleźć, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia.</param>
        <param name="machineName">Nazwa komputera, na którym do przeszukania, lub "." na komputerze lokalnym.</param>
        <summary>Określa, czy źródłem zdarzenia jest zarejestrowany na określonym komputerze.</summary>
        <returns>
          <see langword="true" /> Jeśli źródło zdarzenia jest zarejestrowany na danym komputerze. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do określenia, czy źródło zdarzenia istnieje na komputerze określonym przez `machineName` parametru. Jeśli chcesz określić, czy dziennik istnieje na określonym komputerze, użyj <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na danym serwerze; w przeciwnym razie <xref:System.Security.SecurityException> zostanie wygenerowany.  
  
> [!NOTE]
>  Aby wyszukiwać źródła zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyny tego wymagania jest, że wszystkie dzienniki zdarzeń, zabezpieczeń, w tym musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> jest generowany.  
>   
>  Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
> [!NOTE]
>  Usługa, która jest wykonywana w ramach <xref:System.ServiceProcess.ServiceAccount.LocalSystem> konto nie ma uprawnienia wymagane do wykonania tej metody. Rozwiązanie to sprawdź, czy źródło zdarzenia znajduje się w <xref:System.ServiceProcess.ServiceInstaller>, a jeśli on nie istnieje, można utworzyć źródła w Instalatorze.  
  
 Ponieważ nowe źródło nie może zawierać nazwę istniejącego źródła na tym samym komputerze, ta metoda umożliwia przed podjęciem próby wykonania wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do zapewnienia, że źródło z nazwą określoną przez `source` jeszcze nie istnieje na komputerze. `source` i `machineName` parametrów nie jest uwzględniana.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> jest `static` metody, więc może ona zostać wywołana w samej klasy. Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> do wywołania <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` na komputerze `MyServer`i dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> jest prawidłową nazwą komputera.</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> Nie można odnaleźć, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane w <see cref="T:System.Diagnostics.EventLog" /> wpis zapisywane zdarzenia.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Używany do organizowania wywołań obsługi zdarzeń utworzony w <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> zdarzenia w dzienniku zdarzeń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> jest `null`, metod obsługi <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenia są wywołany w wątku z puli wątków systemu. Aby uzyskać więcej informacji na pule wątków systemu, zobacz <xref:System.Threading.ThreadPool>.  
  
 Gdy <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenie jest obsługiwane przez visual formularzy systemu Windows składnika, takiego jak przycisk, dostęp do składnika za pośrednictwem puli wątków systemu mogą nie działać lub może spowodować wyjątek. Tego uniknąć, ustawiając <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> składnika formularzy systemu Windows, co powoduje, że metody obsługi <xref:System.Diagnostics.EventLog.EntryWritten> zdarzeń ma być wywołane na tym samym wątku, w której utworzono składnika.  
  
 Jeśli <xref:System.Diagnostics.EventLog> jest używany wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w projektancie formularzy systemu Windows, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> jest automatycznie ustawiana zawierająca formant <xref:System.Diagnostics.EventLog>. Na przykład, jeśli zostanie <xref:System.Diagnostics.EventLog> na Projektant Form1 (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> właściwość <xref:System.Diagnostics.EventLog> ustawiono wystąpienie Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dokona wpisu w dzienniku zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <summary>Zapisuje wpisu typu informacji z tekstem danej wiadomości w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu w dzienniku zdarzeń skojarzonych z tym informacji <xref:System.Diagnostics.EventLog> wystąpienia. Jeśli chcesz określić inne <xref:System.Diagnostics.EventLogEntryType>, użyj innego przeciążenia <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwości na Twojej <xref:System.Diagnostics.EventLog> składnik, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwości tego <xref:System.Diagnostics.EventLog> wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> poprzez wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona na Twojej <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` Jeśli jeszcze nie istnieje, a dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
 —lub—  
  
 Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Źródło jest już zarejestrowany dla innego dziennika zdarzeń.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <summary>Zapisuje błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub wpis inspekcji awarii tekstem danej wiadomości w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu w określonej <xref:System.Diagnostics.EventLogEntryType> w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwości na Twojej <xref:System.Diagnostics.EventLog> składnik, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwości tego <xref:System.Diagnostics.EventLog> wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> poprzez wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona na Twojej <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis dziennika zdarzeń, "MyNewLog", na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
 —lub—  
  
 Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Źródło jest już zarejestrowany dla innego dziennika zdarzeń.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <summary>Zapisuje wpisu typu informacji o tekst danego komunikatu w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do zapisu w dzienniku zdarzeń przy użyciu źródła, która jest już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie informacje. Jeśli chcesz określić inne <xref:System.Diagnostics.EventLogEntryType>, użyj innego przeciążenia <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
>   
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` Jeśli jeszcze nie istnieje, a dokona wpisu w dzienniku zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
 \- lub -  
  
 <paramref name="source" /> Wartość jest <see langword="null" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <summary>Zapisuje wpis z tekstu podanym komunikatem i identyfikator zdefiniowanym przez aplikację zdarzeń w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu z określonym przez aplikację `eventID` w dzienniku zdarzeń. `eventID` Wraz z źródło identyfikują zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
 Oprócz identyfikator zdarzenia, możesz określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwości na Twojej <xref:System.Diagnostics.EventLog> składnik, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwości tego <xref:System.Diagnostics.EventLog> wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> poprzez wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona na Twojej <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
 —lub—  
  
 Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Źródło jest już zarejestrowany dla innego dziennika zdarzeń.  
  
 \- lub -  
  
 <paramref name="eventID" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <summary>Zapisuje błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub wpis inspekcji awarii tekstem danej wiadomości w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu w określonej <xref:System.Diagnostics.EventLogEntryType> w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis dziennika zdarzeń, "MyNewLog", na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
 \- lub -  
  
 <paramref name="source" /> Wartość jest <see langword="null" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <summary>Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowane aplikacji w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu z określonym przez aplikację `category` w dzienniku zdarzeń. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 jest wyświetlany jako 65,526, -1 jako 65 535.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą parametrów kategorii w pliku zasobów przy użyciu <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Oprócz kategorii można określić identyfikatora zdarzenia dla zdarzenia są zapisywane w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwości na Twojej <xref:System.Diagnostics.EventLog> składnik, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwości tego <xref:System.Diagnostics.EventLog> wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> poprzez wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona na Twojej <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
 —lub—  
  
 Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Źródło jest już zarejestrowany dla innego dziennika zdarzeń.  
  
 \- lub -  
  
 <paramref name="eventID" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <summary>Zapisuje wpis z tekstu podanym komunikatem i identyfikator zdefiniowanym przez aplikację zdarzeń w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu z określonym przez aplikację `eventID` w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. `eventID`, Wraz ze źródła, identyfikują zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzenia są wyświetlane te ciągi użytkownika pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
 Oprócz identyfikator zdarzenia to przeciążenia z <xref:System.Diagnostics.EventLog.WriteEntry%2A> umożliwia określenie <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
 \- lub -  
  
 <paramref name="source" /> Wartość jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="eventID" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <param name="rawData">Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem.</param>
        <summary>Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowanym przez aplikację do dziennika zdarzeń i dołącza dane binarne do wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia zapis zdefiniowanym przez aplikację dane specyficzne dla zdarzenia w dzienniku zdarzeń. Podgląd zdarzeń nie ma możliwości interpretowania tych danych; nieprzetworzone dane są wyświetlane tylko w formacie łączna liczba szesnastkowa i tekst. Użyj dane specyficzne dla zdarzenia oszczędnie, włączając go tylko wtedy, gdy upewnij się, że mogą być przydatne dla kogoś debugowanie problemu. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania pliku dziennika i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.  
  
 Oprócz danych binarnych można określić kategorię zdefiniowanym przez aplikację i identyfikator zdarzenia zdefiniowane przez aplikację. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 jest wyświetlany jako 65,526, -1 jako 65 535.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą parametrów kategorii w pliku zasobów przy użyciu <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwości na Twojej <xref:System.Diagnostics.EventLog> składnik, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwości tego <xref:System.Diagnostics.EventLog> wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> poprzez wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona na Twojej <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
 —lub—  
  
 Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Źródło jest już zarejestrowany dla innego dziennika zdarzeń.  
  
 \- lub -  
  
 <paramref name="eventID" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <summary>Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowane aplikacji w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła. <paramref name="category" /> Mogą być używane przez Podgląd zdarzeń, aby filtrować zdarzenia w dzienniku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu z określonym przez aplikację `category` w dzienniku zdarzeń przy użyciu źródła, które jest już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 jest wyświetlany jako 65,526, -1 jako 65 535.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą parametrów kategorii w pliku zasobów przy użyciu <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Oprócz kategorii można określić identyfikatora zdarzenia dla zdarzenia są zapisywane w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
>   
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
 \- lub -  
  
 <paramref name="source" /> Wartość jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="eventID" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jeden z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <param name="rawData">Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem.</param>
        <summary>Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowane aplikacji w dzienniku zdarzeń (przy użyciu źródła określonego zdarzenia zarejestrowane) i dołącza dane binarne do wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do zapisu w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie dane specyficzne dla zdarzenia zdefiniowane przez aplikację. Podgląd zdarzeń nie ma możliwości interpretowania tych danych; nieprzetworzone dane są wyświetlane tylko w formacie łączna liczba szesnastkowa i tekst. Użyj danych dotyczących zdarzeń oszczędnie; Dołącz ją tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania pliku dziennika i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.  
  
 Oprócz danych binarnych można określić kategorię zdefiniowanym przez aplikację i identyfikator zdarzenia zdefiniowane przez aplikację. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 będą wyświetlane jako 65,526, -1 jako 65 535.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą parametrów kategorii w pliku zasobów przy użyciu <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody można zapisać zdarzenia przy użyciu pliku zasobów zlokalizowanych wiadomości.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
>   
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
 \- lub -  
  
 <paramref name="source" /> Wartość jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="eventID" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 Ciąg komunikatu jest dłuższa niż 31,839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłową <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wejścia zlokalizowany zdarzenia w dzienniku zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje zlokalizowanych wpisu w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowanych zapisu w dzienniku zdarzeń. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.  
  
 Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń. Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwości na Twojej <xref:System.Diagnostics.EventLog> składnika przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli do komputera zdalnego, wartość zapisać wpis `message` ciąg może nie być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework. Ponadto `message` ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład zapisuje dwa wpisy w dzienniku zdarzeń inspekcji `myNewLog`. W przykładzie jest tworzony nowe źródło zdarzeń i utworzenie nowego dziennika zdarzeń, jeśli nie istnieją na komputerze lokalnym. Tekst komunikatu o zdarzeniu został określony przy użyciu identyfikatora zasobów w pliku zasobów.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 W przykładzie użyto następującego pliku tekst wiadomości wbudowanych w bibliotece EventLogMsgs.dll zasobów. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatorów zasobów i tekst dla kategorii, komunikatu o zdarzeniu i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
 —lub—  
  
 Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Źródło jest już zarejestrowany dla innego dziennika zdarzeń.  
  
 \- lub -  
  
 <paramref name="instance.InstanceId" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
 \- lub -  
  
 Jeden z <paramref name="values" /> elementów jest dłuższa niż maksymalnie 32 766 bajtów.  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane.</param>
        <param name="data">Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje wpis dziennika zdarzeń przy użyciu danych z określonych zdarzeń, ciągi zamienne wiadomości i skojarzone dane binarne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowanych zapisu o dodatkowe dane dotyczące zdarzeń w dzienniku zdarzeń. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.  
  
 Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń. Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.  
  
 Określ dane binarne do zdarzenia, gdy jest to niezbędne w celu dostarczenie dodatkowych szczegółów zdarzenia. Na przykład użyć `data` parametr, aby uwzględnić informacje na temat określonego błędu. Podgląd zdarzeń nie ma możliwości interpretowania danych skojarzone ze zdarzeniem; dane są wyświetlane w formacie łączna liczba szesnastkowa i tekst. Użyj danych dotyczących zdarzeń oszczędnie; Dołącz ją tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania dziennika zdarzeń i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwości na Twojej <xref:System.Diagnostics.EventLog> składnika przed składnik przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEvent%2A>, komputer lokalny (".") zakłada, że.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli do komputera zdalnego, wartość zapisać wpis `message` ciąg może nie być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework. Ponadto `message` ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład zapisuje dwa wpisy w dzienniku zdarzeń inspekcji `myNewLog`. W przykładzie jest tworzony nowe źródło zdarzeń i utworzenie nowego dziennika zdarzeń, jeśli nie istnieją na komputerze lokalnym. Tekst komunikatu o zdarzeniu został określony przy użyciu identyfikatora zasobów w pliku zasobów.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 W przykładzie użyto następującego pliku tekst wiadomości wbudowanych w bibliotece EventLogMsgs.dll zasobów. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatorów zasobów i tekst dla kategorii, komunikatu o zdarzeniu i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
 —lub—  
  
 Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
 \- lub -  
  
 Źródło jest już zarejestrowany dla innego dziennika zdarzeń.  
  
 \- lub -  
  
 <paramref name="instance.InstanceId" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
 \- lub -  
  
 Jeden z <paramref name="values" /> elementów jest dłuższa niż maksymalnie 32 766 bajtów.  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia zarejestrowane dla aplikacji na określonym komputerze.</param>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje danych i komunikatów ciągów zamiennych przy użyciu źródła określonego zdarzenia w zarejestrowany wpis dziennika zdarzeń z określonych zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowanych zapisu w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla tego źródła. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.  
  
 Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń. Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.  
  
 Określone źródło musi być zarejestrowana do dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpisu zdarzenia informacyjną i wpis zdarzeń ostrzeżenie istniejący dziennik zdarzeń. Tekst komunikatu o zdarzeniu został określony przy użyciu identyfikatora zasobów w pliku zasobów. Przykładzie przyjęto założenie, że odpowiedni plik zasobów został zarejestrowany dla tego źródła.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 W przykładzie użyto następującego pliku tekst wiadomości wbudowanych w bibliotece EventLogMsgs.dll zasobów. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatorów zasobów i tekst dla kategorii, komunikatu o zdarzeniu i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
 \- lub -  
  
 <paramref name="source" /> Wartość jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="instance.InstanceId" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
 \- lub -  
  
 Jeden z <paramref name="values" /> elementów jest dłuższa niż maksymalnie 32 766 bajtów.  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia zarejestrowane dla aplikacji na określonym komputerze.</param>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane.</param>
        <param name="data">Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje zdarzenie wpis dziennika przy użyciu danych z określonych zdarzeń ciągów zamiennych wiadomości i skojarzone dane binarne i przy użyciu określonego zarejestrowane źródło zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowanych zapisu o dodatkowe dane dotyczące zdarzeń w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla tego źródła. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.  
  
 Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń. Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.  
  
 Określ dane binarne do zdarzenia, gdy jest to niezbędne w celu dostarczenie dodatkowych szczegółów zdarzenia. Na przykład użyć `data` parametr, aby uwzględnić informacje na temat określonego błędu. Podgląd zdarzeń nie ma możliwości interpretowania danych skojarzone ze zdarzeniem; dane są wyświetlane w formacie łączna liczba szesnastkowa i tekst. Użyj danych dotyczących zdarzeń oszczędnie; Dołącz ją tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania dziennika zdarzeń i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.  
  
 Określone źródło musi być zarejestrowana do dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpisu zdarzenia informacyjną i wpis zdarzeń ostrzeżenie istniejący dziennik zdarzeń. Tekst komunikatu o zdarzeniu został określony przy użyciu identyfikatora zasobów w pliku zasobów. Przykładzie przyjęto założenie, że odpowiedni plik zasobów został zarejestrowany dla tego źródła.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 W przykładzie użyto następującego pliku tekst wiadomości wbudowanych w bibliotece EventLogMsgs.dll zasobów. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatorów zasobów i tekst dla kategorii, komunikatu o zdarzeniu i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
 \- lub -  
  
 <paramref name="source" /> Wartość jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="instance.InstanceId" /> jest mniejsza niż zero lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
 \- lub -  
  
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
 \- lub -  
  
 Jeden z <paramref name="values" /> elementów jest dłuższa niż maksymalnie 32 766 bajtów.  
  
 \- lub -  
  
 Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>
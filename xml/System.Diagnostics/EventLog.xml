<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0ff824b2a8e88519f623df8888db8a53b11a77e2" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69076436" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia interakcję z dziennikami zdarzeń systemu Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog>umożliwia dostęp lub dostosowanie dzienników zdarzeń systemu Windows, które rejestrują informacje dotyczące ważnych programów lub zdarzeń sprzętu. Korzystając <xref:System.Diagnostics.EventLog>z programu, można czytać z istniejących dzienników, zapisywać wpisy do dzienników, tworzyć lub usuwać źródła zdarzeń, usuwać dzienniki i odpowiadać na wpisy dziennika. Można również tworzyć nowe dzienniki podczas tworzenia źródła zdarzeń.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 Oprócz zapewniania dostępu do poszczególnych dzienników zdarzeń i ich wpisów, <xref:System.Diagnostics.EventLog> Klasa pozwala uzyskać dostęp do kolekcji wszystkich dzienników zdarzeń. `static` Członków programu<xref:System.Diagnostics.EventLog> można używać do usuwania dzienników, uzyskiwania list dzienników, tworzenia lub usuwania źródła lub określania, czy komputer zawiera już określone źródło.  
  
 Istnieją trzy domyślne dzienniki zdarzeń: Aplikacja, system i zabezpieczenia. Dziennik zabezpieczeń jest tylko do odczytu. Inne instalowane aplikacje i usługi, takie jak Active Directory, mogą mieć dodatkowe dzienniki zdarzeń.  
  
 W przypadku korzystania z klasy należy <xref:System.Diagnostics.EventLog> wziąć pod uwagę kwestie związane z bezpieczeństwem. <xref:System.Diagnostics.EventLog>wymaga <xref:System.Diagnostics.EventLogPermission> uprawnień do określonych akcji w .NET Framework 2,0 i nowszych wersjach albo w pełni zaufane w .NET Framework 1,0 i 1,1. Zaleca się, <xref:System.Diagnostics.EventLogPermission> aby nie przyznawać do częściowo zaufanego kodu.  Nigdy nie należy przekazywać żadnych obiektów dziennika zdarzeń, <xref:System.Diagnostics.EventLogEntryCollection> w <xref:System.Diagnostics.EventLogEntry> tym obiektów i, do mniej zaufanych kodów. Na przykład utworzenie <xref:System.Diagnostics.EventLog> obiektu, zapisanie wpisu, a następnie <xref:System.Diagnostics.EventLog> przekazanie obiektu do częściowo zaufanego kodu może stworzyć problem z zabezpieczeniami, ponieważ możliwość odczytywania i zapisywania w dzienniku zdarzeń pozwala na wykonywanie akcji, takich jak wydawanie komunikaty dziennika zdarzeń w nazwie innej aplikacji.  
  
 Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) określa poświadczenia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby uruchomić kod, który uzyskuje dostęp do dziennika zabezpieczeń, należy najpierw podnieść poziom poświadczeń użytkownika standardowego do administratora. Możesz to zrobić podczas uruchamiania aplikacji, otwierając menu skrótów dla aplikacji (Jeśli używasz myszy, kliknij prawym przyciskiem myszy ikonę aplikacji) i wskazując, że chcesz uruchomić program jako administrator.  
  
 Programu można użyć <xref:System.Diagnostics.EventLog> do tworzenia niestandardowych dzienników zdarzeń, które można wyświetlić za pomocą Podgląd zdarzeń serwera. Użyj metody <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> , aby wyświetlić zlokalizowaną nazwę dziennika zdarzeń w Podgląd zdarzeń. <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Użyj metody, aby skonfigurować zachowanie dziennika zdarzeń po osiągnięciu maksymalnego rozmiaru dziennika.  
  
 Aby odczytywać z dziennika zdarzeń, określ nazwę dziennika (<xref:System.Diagnostics.EventLog.Log%2A> Właściwość) i nazwę komputera serwera (<xref:System.Diagnostics.EventLog.MachineName%2A> Właściwość dziennika zdarzeń. Jeśli nie zostanie określona nazwa komputera serwera, zostanie przyjęty komputer lokalny ".". Nie trzeba określać źródła zdarzeń (<xref:System.Diagnostics.EventLog.Source%2A> Właściwość), ponieważ źródło jest wymagane tylko do zapisu w dziennikach. <xref:System.Diagnostics.EventLog.Entries%2A> Właściwość jest automatycznie wypełniana listą wpisów dziennika zdarzeń.  
  
 Aby zapisać w dzienniku zdarzeń, określ lub Utwórz źródło zdarzenia (<xref:System.Diagnostics.EventLog.Source%2A> Właściwość). Musisz mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń. Źródło zdarzenia rejestruje aplikację w dzienniku zdarzeń jako prawidłowe Źródło wpisów. Możesz użyć źródła zdarzeń do zapisu tylko do jednego dziennika naraz. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość może być dowolnym ciągiem losowym, ale nazwa musi być odrębna od innych źródeł na komputerze. Źródło zdarzenia jest zazwyczaj nazwą aplikacji lub innym ciągiem identyfikującym. Próba utworzenia zduplikowanej <xref:System.Diagnostics.EventLog.Source%2A> wartości powoduje wystąpienie wyjątku. Jednak pojedynczy dziennik zdarzeń może być skojarzony z wieloma źródłami.  
  
 Jeśli źródło zdarzeń dla dziennika zdarzeń skojarzonego z <xref:System.Diagnostics.EventLog> wystąpieniem nie istnieje, zostanie utworzone nowe źródło zdarzenia. Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć poświadczenia administracyjne.  
  
 To wymaganie wynika z faktu, że wszystkie dzienniki zdarzeń, w tym dzienniki zabezpieczeń, muszą być przeszukiwane w celu ustalenia, czy źródło zdarzenia jest unikatowe. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z <xref:System.Security.SecurityException> tym jest zgłaszany.  
  
> [!IMPORTANT]
>  Tworzenie lub usuwanie źródła zdarzenia wymaga synchronizacji kodu bazowego przy użyciu nazwanego obiektu mutex. Jeśli aplikacja o wysokim poziomie uprawnień blokuje nazwany obiekt mutex, próba utworzenia lub usunięcia źródła zdarzenia powoduje, że aplikacja przestanie odpowiadać do momentu zwolnienia blokady. Aby zapobiec temu problemowi, nigdy nie <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> Udziel uprawnień do niezaufanego kodu. Ponadto <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnienie potencjalnie pozwala na obejście innych uprawnień i powinno być przyznawane tylko do wysoce zaufanego kodu.  
  
 Aplikacje i usługi powinny zapisywać w dzienniku aplikacji lub w dzienniku niestandardowym. Sterowniki urządzeń powinny zapisywać dane w dzienniku systemu. Jeśli nie ustawisz jawnie <xref:System.Diagnostics.EventLog.Log%2A> właściwości, dziennik zdarzeń zostanie domyślnie ustawiony na dziennik aplikacji.  
  
> [!NOTE]
>  Nie ma nic do ochrony aplikacji przed zapisem jako dowolnego zarejestrowanego źródła.  Jeśli aplikacja otrzymuje <xref:System.Diagnostics.EventLogPermissionAccess.Write> uprawnienie, może zapisywać zdarzenia dla każdego prawidłowego źródła zarejestrowanego na komputerze.  
  
 Za pomocą metod <xref:System.Diagnostics.EventLog.WriteEntry%2A>iZapisz zdarzenia w dzienniku zdarzeń. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Należy określić źródło zdarzenia do zapisywania zdarzeń; przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył listy źródeł zdarzeń i spróbuje napisać zdarzenie z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller> obiektu <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub metody. Musisz mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Każde źródło może zapisywać tylko w jednym dzienniku zdarzeń naraz; Jednak aplikacja może zapisywać w wielu dziennikach zdarzeń przy użyciu wielu źródeł. Na przykład aplikacja może wymagać wielu źródeł skonfigurowanych dla różnych dzienników zdarzeń lub różnych plików zasobów. Aby zmienić szczegóły konfiguracji istniejącego źródła, należy usunąć źródło, a następnie utworzyć je przy użyciu nowej konfiguracji. Jeśli inne aplikacje lub składniki używają istniejącego źródła, należy utworzyć nowe źródło ze zaktualizowaną konfiguracją, a nie usunąć istniejące źródło.  
  
 Źródło zdarzeń można zarejestrować przy użyciu zlokalizowanych zasobów dla kategorii zdarzeń i ciągów komunikatów. Aplikacja może zapisywać wpisy dziennika zdarzeń przy użyciu identyfikatorów zasobów zamiast określać rzeczywiste wartości ciągu. Zapoznaj się <xref:System.Diagnostics.EventLogInstaller> z <xref:System.Diagnostics.EventSourceCreationData> klasami i, aby uzyskać więcej informacji na temat konfigurowania źródła przy użyciu plików zasobów.  
  
 Jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń, nie ma potrzeby ustawiania właściwości pliku zasobu dla źródła. Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Podczas pisania zdarzeń należy określić jako ciąg komunikatu lub identyfikator zasobu dla ciągu komunikatu. Inne właściwości zdarzenia są opcjonalne. Przykłady opcjonalnych ustawień zdarzeń są następujące:  
  
-   Można ustawić, <xref:System.Diagnostics.EventLogEntryType> aby określić ikonę, która Podgląd zdarzeń wyświetlana dla wpisu.  
  
-   Możesz określić identyfikator kategorii dla zdarzenia, jeśli aplikacja używa kategorii do filtrowania zdarzeń.  
  
-   Możesz dołączyć dane binarne do wpisu zdarzenia, jeśli chcesz skojarzyć dodatkowe informacje z danym zdarzeniem.  
  
> [!IMPORTANT]
>  Rejestrowanie zdarzeń wykorzystuje miejsce na dysku, czas procesora i inne zasoby systemowe. Ważne jest, aby rejestrować tylko istotne informacje. Zalecamy umieszczenie wywołań dzienników zdarzeń w ścieżce błędu, a nie w głównej ścieżce kodu, więc nie mają one negatywnego wpływu na wydajność.  
  
 Aby uzyskać listę początkowych wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>, <xref:System.Diagnostics.EventLog.%23ctor%2A> Zobacz Konstruktor.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` zdarzenia, jeśli jeszcze nie istnieje, i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
> [!NOTE]
>  Począwszy od systemu Windows Vista, należy uruchomić tę aplikację jako administrator.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Nie kojarzy wystąpienia z żadnym dziennikiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Source%2A> Określ właściwość <xref:System.Diagnostics.EventLog> wystąpienia. W przypadku odczytywania <xref:System.Diagnostics.EventLog.Entries%2A> tylko z dziennika można określić <xref:System.Diagnostics.EventLog.Log%2A> tylko właściwości i <xref:System.Diagnostics.EventLog.MachineName%2A> .  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, zostanie przyjęty komputer lokalny (".").  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Komputer lokalny (".").|  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` , jeśli jeszcze nie istnieje, i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na komputerze lokalnym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennikiem na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A> właściwość na wartość `logName` parametru. Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Source%2A> Określ właściwość <xref:System.Diagnostics.EventLog> wystąpienia. W przypadku odczytywania <xref:System.Diagnostics.EventLog.Entries%2A> tylko z dziennika można określić <xref:System.Diagnostics.EventLog.Log%2A> tylko właściwości i <xref:System.Diagnostics.EventLog.MachineName%2A> .  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, zostanie przyjęty komputer lokalny ("."). To przeciążenie konstruktora określa <xref:System.Diagnostics.EventLog.Log%2A> właściwość, ale można ją zmienić przed <xref:System.Diagnostics.EventLog.Entries%2A> przeczytaniem właściwości.  
  
 Jeśli źródło określone we <xref:System.Diagnostics.EventLog.Source%2A> właściwości jest unikatowe z innych źródeł na komputerze, kolejne wywołanie w celu <xref:System.Diagnostics.EventLog.WriteEntry%2A> utworzenia dziennika o określonej nazwie, jeśli jeszcze nie istnieje.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametr.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Komputer lokalny (".").|  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "myNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na określonym komputerze.</param>
        <param name="machineName">Komputer, na którym znajduje się dziennik.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennikiem na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A> Właściwość `logName` na parametr i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwość na wartość `machineName` parametru. Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>należy <xref:System.Diagnostics.EventLog.Source%2A> określić właściwość <xref:System.Diagnostics.EventLog>. W przypadku odczytywania <xref:System.Diagnostics.EventLog.Entries%2A> tylko z dziennika można określić <xref:System.Diagnostics.EventLog.Log%2A> tylko właściwości i <xref:System.Diagnostics.EventLog.MachineName%2A> .  
  
> [!NOTE]
>  To przeciążenie konstruktora określa <xref:System.Diagnostics.EventLog.Log%2A> właściwości i <xref:System.Diagnostics.EventLog.MachineName%2A> , ale można je <xref:System.Diagnostics.EventLog.Entries%2A> zmienić przed przeczytaniem właściwości.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametr.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` Parametr.|  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "myNewLog" na komputerze "" ".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.  
  
 —lub—  
  
 Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na określonym komputerze</param>
        <param name="machineName">Komputer, na którym znajduje się dziennik.</param>
        <param name="source">Źródło wpisów dziennika zdarzeń.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennikiem na określonym komputerze i tworzy lub przypisuje określone źródło do <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Log%2A> Ten konstruktor ustawia właściwość `logName` na parametr <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog.Source%2A> , właściwość `source` do `machineName` parametru oraz właściwość do parametru. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość jest wymagana podczas zapisywania w dzienniku zdarzeń. Jednak w przypadku odczytywania tylko z dziennika zdarzeń tylko <xref:System.Diagnostics.EventLog.Log%2A> właściwości i <xref:System.Diagnostics.EventLog.MachineName%2A> są wymagane (o ile do dziennika zdarzeń na serwerze jest już skojarzone Źródło). W przypadku odczytywania tylko z dziennika zdarzeń może być wystarczające inne przeciążenie konstruktora.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` Parametr.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametr.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` Parametr.|  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis w dzienniku zdarzeń "MyNewLog" na komputerze lokalnym przy użyciu źródła "Moje Źródło".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.  
  
 —lub—  
  
 Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjalizację <see cref="T:System.Diagnostics.EventLog" /> użytą w formularzu lub używaną przez inny składnik. Inicjalizacja odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] projektowe używa tej metody do uruchamiania inicjowania składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.EndInit%2A> Metoda przerywa inicjalizację. Użycie metod <xref:System.Diagnostics.EventLog.EndInit%2A> i uniemożliwia użycie formantu przed jego pełnym zainicjowaniem. <xref:System.Diagnostics.EventLog.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" />jest już zainicjowany.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie wpisy z dziennika zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia dzienników zdarzeń mają maksymalny rozmiar, który określa liczbę wpisów, które mogą zawierać. Gdy dziennik zdarzeń jest zapełniony, przestaje rejestrować nowe informacje o zdarzeniu lub rozpoczyna zastępowanie wcześniejszych wpisów. Jeśli rejestrowanie zdarzeń zostanie zatrzymane, można użyć tej metody, aby wyczyścić dziennik istniejących wpisów i umożliwić jej ponowne uruchomienie rejestrowania zdarzeń. Musisz mieć uprawnienia administratora na komputerze, na którym znajduje się dziennik, aby wyczyścić wpisy dziennika zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A>zamyka dziennik zdarzeń, zwalnia dojścia do zdarzeń, pobiera nowe dojścia do odczytu i zapisu, a następnie ponownie otwiera Dziennik zdarzeń. Zdarzenia otrzymane po wywołaniu metody nie są czyszczone wraz z istniejącymi zdarzeniami.  
  
   
  
## Examples  
 Poniższy przykład czyści dziennik zdarzeń.  
  
> [!CAUTION]
>  Ponieważ aplikacje, system, zabezpieczenia i inne nieniestandardowe dzienniki mogą zawierać kluczowe informacje; należy pamiętać o określeniu dziennika niestandardowego przed wykonaniem tego przykładowego kodu. Ten przykład umożliwia usunięcie dziennika `myNewLog`niestandardowego.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Dziennik zdarzeń nie został pomyślnie wyczyszczony.  
  
 —lub—  
  
 Nie można otworzyć dziennika. Kod błędu systemu Windows jest niedostępny.</exception>
        <exception cref="T:System.ArgumentException">Dla <see cref="P:System.Diagnostics.EventLog.Log" /> właściwości nie określono wartości. Upewnij się, że nazwa dziennika nie jest pustym ciągiem.</exception>
        <exception cref="T:System.InvalidOperationException">Dziennik nie istnieje.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka dziennik zdarzeń i zwalnia uchwyty odczytu i zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana przez metodę chronioną <xref:System.ComponentModel.Component.Dispose%2A>. <xref:System.Diagnostics.EventLog.Close%2A> Nie trzeba wywoływać <xref:System.Diagnostics.EventLog.Close%2A> przed wywołaniem metody <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Dojście do odczytu lub zapis dziennika zdarzeń nie zostało pomyślnie wydane.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia aplikację, która może zapisywać informacje o zdarzeniach w konkretnym dzienniku w systemie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">Właściwości konfiguracji źródła zdarzeń i jego docelowego dziennika zdarzeń.</param>
        <summary>Ustanawia prawidłowe źródło zdarzeń do zapisywania zlokalizowanych komunikatów zdarzeń przy użyciu określonych właściwości konfiguracji dla źródła zdarzeń i odpowiedniego dziennika zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby skonfigurować nowe źródło do zapisu wpisów w dzienniku zdarzeń na komputerze lokalnym lub komputerze zdalnym. Nie jest konieczne używanie tej metody do odczytu z dziennika zdarzeń.  
  
 Metodaużywa`sourceData` danychwejściowych<xref:System.Diagnostics.EventSourceCreationData.Source%2A> i<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>Właściwości do tworzenia wartości rejestru na komputerze docelowym dla nowego źródła i skojarzonego z nim dziennika zdarzeń. <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Nowa nazwa źródła nie może być taka sama jak istniejąca nazwa źródła lub istniejąca nazwa dziennika zdarzeń na komputerze docelowym. <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> Jeśli właściwość nie jest ustawiona, źródło zostanie zarejestrowane dla dziennika zdarzeń aplikacji. Jeśli nie <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> jest ustawiona, źródło zostanie zarejestrowane na komputerze lokalnym.  
  
> [!NOTE]
>  Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć uprawnienia administracyjne.  
>   
>  Przyczyną tego wymagania jest to, że wszystkie dzienniki zdarzeń, w tym zabezpieczenia, muszą być przeszukiwane w celu ustalenia, czy źródło zdarzenia jest unikatowe. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z <xref:System.Security.SecurityException> tym jest zgłaszany.  
>   
>  Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do dziennika zabezpieczeń, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
 Używanie <xref:System.Diagnostics.EventLog.WriteEvent%2A> i<xref:System.Diagnostics.EventLog.WriteEntry%2A> do zapisywania zdarzeń w dzienniku zdarzeń. Należy określić źródło zdarzenia do zapisywania zdarzeń; przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Można utworzyć źródło zdarzenia dla istniejącego dziennika zdarzeń lub nowego dziennika zdarzeń. Gdy tworzysz nowe źródło dla nowego dziennika zdarzeń, system rejestruje źródło tego dziennika, ale dziennik nie zostanie utworzony, dopóki nie zostanie do niego zapisany pierwszy wpis.  
  
 System operacyjny przechowuje dzienniki zdarzeń jako pliki. W przypadku użycia <xref:System.Diagnostics.EventLogInstaller> programu <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub do utworzenia nowego dziennika zdarzeń skojarzony plik jest przechowywany w katalogu%SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiana przez dołączenie pierwszych 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ". evt".  
  
 Każde źródło może zapisywać tylko w jednym dzienniku zdarzeń naraz; Jednak aplikacja może zapisywać w wielu dziennikach zdarzeń przy użyciu wielu źródeł. Na przykład aplikacja może wymagać wielu źródeł skonfigurowanych dla różnych dzienników zdarzeń lub różnych plików zasobów.  
  
 Źródło zdarzeń można zarejestrować przy użyciu zlokalizowanych plików zasobów dla kategorii zdarzeń i ciągów komunikatów. Aplikacja może zapisywać wpisy dziennika zdarzeń przy użyciu identyfikatorów zasobów zamiast określać rzeczywisty ciąg. Podgląd zdarzeń używa identyfikatora zasobu do znajdowania i wyświetlania odpowiedniego ciągu z zlokalizowanego pliku zasobów na podstawie bieżących ustawień języka. Można zarejestrować osobny plik dla kategorii zdarzeń, komunikatów i ciągów wstawiania parametrów lub można zarejestrować ten sam plik zasobu dla wszystkich trzech typów ciągów. Użyj właściwości <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A> ,,<xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A> i<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> , aby skonfigurować źródło do zapisywania zlokalizowanych wpisów w dzienniku zdarzeń. <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A> Jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń, nie trzeba ustawiać tych właściwości.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, należy usunąć źródło, a następnie utworzyć je przy użyciu nowej konfiguracji. Jeśli inne aplikacje lub składniki używają istniejącego źródła, należy utworzyć nowe źródło ze zaktualizowaną konfiguracją, a nie usunąć istniejące źródło.  
  
> [!NOTE]
>  Jeśli źródło jest skonfigurowane dla dziennika zdarzeń i ponownie skonfigurowane dla innego dziennika zdarzeń, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład określa, czy źródło zdarzeń o nazwie `SampleApplicationSource` jest zarejestrowane na komputerze lokalnym. Jeśli źródło zdarzenia nie istnieje, przykład ustawia plik zasobów wiadomości dla źródła i tworzy nowe źródło zdarzenia. Na koniec przykład ustawia zlokalizowaną nazwę wyświetlaną dla dziennika zdarzeń przy użyciu wartości identyfikator zasobu w `DisplayNameMsgId` i ścieżki pliku zasobu w. `messageFile`  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 W przykładzie zastosowano następujący plik tekstowy komunikatu, wbudowany w bibliotekę zasobów EventLogMsgs. dll. Plik tekstowy komunikatu jest źródłem, z którego tworzony jest plik zasobów wiadomości. Plik tekstowy komunikatu określa identyfikatory zasobów i tekst dla kategorii, komunikat zdarzenia i ciągi wstawiania parametrów. W przypadku zlokalizowanej nazwy dziennika zdarzeń jest zdefiniowany identyfikator zasobu 5001.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona nazwa komputera <paramref name="sourceData" /> jest nieprawidłowa.  
  
—lub— 
Nazwa źródła określona w <paramref name="sourceData" /> elemencie ma wartość. <see langword="null" />  
  
—lub— 
Podana nazwa dziennika <paramref name="sourceData" /> jest nieprawidłowa. Nazwy dzienników zdarzeń muszą zawierać znaki drukowalne i nie mogą zawierać znaków "*", "?" ani "\\".  
  
—lub— 
Nazwa dziennika określona w <paramref name="sourceData" /> jest nieprawidłowa dla tworzenia dziennika użytkownika. Nazwy dzienników zdarzeń AppEvent, SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
—lub— 
Nazwa dziennika jest zgodna z nazwą istniejącego źródła zdarzenia.  
  
—lub— 
Nazwa źródła określona w programie <paramref name="sourceData" /> daje w wyniku ścieżkę klucza rejestru dłuższą niż 254 znaków.  
  
—lub— 
Pierwsze 8 znaków nazwy dziennika określonej w <paramref name="sourceData" /> nie są unikatowe.  
  
—lub— 
Nazwa źródła określona w <paramref name="sourceData" /> jest już zarejestrowana.  
  
—lub— 
Nazwa źródła określona w programie <paramref name="sourceData" /> jest zgodna z nazwą istniejącego dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła, za pomocą którego aplikacja jest zarejestrowana na komputerze lokalnym.</param>
        <param name="logName">Nazwa dziennika, w którym są zapisywane wpisy źródła. Możliwe wartości to między innymi aplikacja, system lub dziennik zdarzeń niestandardowych.</param>
        <summary>Ustanawia określoną nazwę źródła jako prawidłowe Źródło zdarzenia do zapisu wpisów w dzienniku na komputerze lokalnym. Ta metoda umożliwia także utworzenie nowego dziennika niestandardowego na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie służy do tworzenia dziennika niestandardowego lub tworzenia i rejestrowania <xref:System.Diagnostics.EventLog.Source%2A> w istniejącym dzienniku na komputerze lokalnym.  
  
 Jeśli `logName` jest `null` lub jest pustym ciągiem ("") podczas wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, dziennik jest domyślnie używany w dzienniku aplikacji. Jeśli dziennik nie istnieje na komputerze lokalnym, system tworzy dziennik niestandardowy i rejestruje aplikację jako <xref:System.Diagnostics.EventLog.Source%2A> dla tego dziennika.  
  
> [!NOTE]
>  Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć uprawnienia administracyjne.  
>   
>  Przyczyną tego wymagania jest to, że wszystkie dzienniki zdarzeń, w tym zabezpieczenia, muszą być przeszukiwane w celu ustalenia, czy źródło zdarzenia jest unikatowe. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z <xref:System.Security.SecurityException> tym jest zgłaszany.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do dziennika zabezpieczeń, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
 Tylko wtedy, gdy zapisujesz dziennik zdarzeń, musisz utworzyć źródło zdarzenia. Przed zapisaniem wpisu w dzienniku zdarzeń należy zarejestrować Źródło zdarzenia w dzienniku zdarzeń jako prawidłowe źródło zdarzeń. Podczas pisania wpisu dziennika system używa programu <xref:System.Diagnostics.EventLog.Source%2A> w celu znalezienia odpowiedniego dziennika, w którym wpis zostanie umieszczony. W przypadku odczytywania dziennika zdarzeń można określić <xref:System.Diagnostics.EventLog.Source%2A>, <xref:System.Diagnostics.EventLog.Log%2A> lub a i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Nie jest wymagane, aby określić, <xref:System.Diagnostics.EventLog.MachineName%2A> czy łączysz się z dziennika na komputerze lokalnym. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> podczas odczytu z dziennika, przyjęty jest komputer lokalny (".").  
  
 Używanie <xref:System.Diagnostics.EventLog.WriteEvent%2A> i<xref:System.Diagnostics.EventLog.WriteEntry%2A> do zapisywania zdarzeń w dzienniku zdarzeń. Należy określić źródło zdarzenia do zapisywania zdarzeń; przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Można utworzyć źródło zdarzenia dla istniejącego dziennika zdarzeń lub nowego dziennika zdarzeń. Gdy tworzysz nowe źródło dla nowego dziennika zdarzeń, system rejestruje źródło tego dziennika, ale dziennik nie zostanie utworzony, dopóki nie zostanie do niego zapisany pierwszy wpis.  
  
 System operacyjny przechowuje dzienniki zdarzeń jako pliki. W przypadku użycia <xref:System.Diagnostics.EventLogInstaller> programu <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub do utworzenia nowego dziennika zdarzeń skojarzony plik jest przechowywany w katalogu%SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiana przez dołączenie pierwszych 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ". evt".  
  
 Źródło musi być unikatowe na komputerze lokalnym; Nowa nazwa źródła nie może być zgodna z nazwą istniejącego źródła lub nazwą istniejącego dziennika zdarzeń. Każde źródło może zapisywać tylko w jednym dzienniku zdarzeń naraz; Jednak aplikacja może zapisywać w wielu dziennikach zdarzeń przy użyciu wielu źródeł. Na przykład aplikacja może wymagać wielu źródeł skonfigurowanych dla różnych dzienników zdarzeń lub różnych plików zasobów.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, należy usunąć źródło, a następnie utworzyć je przy użyciu nowej konfiguracji. Jeśli inne aplikacje lub składniki używają istniejącego źródła, należy utworzyć nowe źródło ze zaktualizowaną konfiguracją, a nie usunąć istniejące źródło.  
  
> [!NOTE]
>  Jeśli źródło zostało już zamapowane na dziennik, a następnie zostało ono ponownie przypisane do nowego dziennika, aby zmiany zaczęły obowiązywać, konieczne jest ponowne uruchomienie komputera.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` , jeśli jeszcze nie istnieje, i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" />jest pustym ciągiem ("") lub <see langword="null" />.  
  
—lub— 
 <paramref name="logName" />nie jest prawidłową nazwą dziennika zdarzeń. Nazwy dzienników zdarzeń muszą zawierać znaki drukowalne i nie mogą zawierać znaków "*", "?" ani "\\".  
  
—lub— 
 <paramref name="logName" />nie jest prawidłowy dla tworzenia dziennika użytkownika. Nazwy dzienników zdarzeń AppEvent, SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
—lub— 
Nazwa dziennika jest zgodna z nazwą istniejącego źródła zdarzenia.  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.  
  
—lub— 
Pierwsze 8 znaków <paramref name="logName" /> pasuje do pierwszych 8 znaków istniejącej nazwy dziennika zdarzeń.  
  
—lub— 
Nie można zarejestrować źródła, ponieważ istnieje ono już na komputerze lokalnym.  
  
—lub— 
Nazwa źródła jest zgodna z nazwą istniejącego dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dziennika zdarzeń na komputerze lokalnym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="logName">Nazwa dziennika, w którym są zapisywane wpisy źródła. Możliwe wartości to między innymi aplikacja, system lub dziennik zdarzeń niestandardowych. Jeśli wartość nie zostanie określona, <paramref name="logName" /> wartością domyślną będzie aplikacja.</param>
        <param name="machineName">Nazwa komputera, w którym ma zostać zarejestrowane to źródło zdarzenia, lub "." dla komputera lokalnego.</param>
        <summary>Ustanawia określoną nazwę źródła jako prawidłowe Źródło zdarzenia do zapisu wpisów w dzienniku na określonym komputerze. Ta metoda służy również do tworzenia nowego dziennika niestandardowego na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie służy do tworzenia dziennika niestandardowego lub tworzenia i rejestrowania <xref:System.Diagnostics.EventLog.Source%2A> w istniejącym dzienniku na określonym komputerze.  
  
 Jeśli `logName` jest `null` lub jest pustym ciągiem ("") podczas wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, dziennik jest domyślnie używany w dzienniku aplikacji. Jeśli dziennik nie istnieje na określonym komputerze, system tworzy dziennik niestandardowy i rejestruje aplikację jako <xref:System.Diagnostics.EventLog.Source%2A> dla tego dziennika.  
  
 Tylko wtedy, gdy zapisujesz dziennik zdarzeń, musisz utworzyć źródło zdarzenia. Przed zapisaniem wpisu w dzienniku zdarzeń należy zarejestrować Źródło zdarzenia w dzienniku zdarzeń jako prawidłowe źródło zdarzeń. Podczas pisania wpisu dziennika system używa programu <xref:System.Diagnostics.EventLog.Source%2A> w celu znalezienia odpowiedniego dziennika, w którym wpis zostanie umieszczony. W przypadku odczytywania dziennika zdarzeń można określić <xref:System.Diagnostics.EventLog.Source%2A>, <xref:System.Diagnostics.EventLog.Log%2A> lub a i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć uprawnienia administracyjne.  
>   
>  Przyczyną tego wymagania jest to, że wszystkie dzienniki zdarzeń, w tym zabezpieczenia, muszą być przeszukiwane w celu ustalenia, czy źródło zdarzenia jest unikatowe. W systemie Windows Vista i nowszych użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z <xref:System.Security.SecurityException> tym jest zgłaszany.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do dziennika zabezpieczeń, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
 Używanie <xref:System.Diagnostics.EventLog.WriteEvent%2A> i<xref:System.Diagnostics.EventLog.WriteEntry%2A> do zapisywania zdarzeń w dzienniku zdarzeń. Należy określić źródło zdarzenia do zapisywania zdarzeń; przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Można utworzyć źródło zdarzenia dla istniejącego dziennika zdarzeń lub nowego dziennika zdarzeń. Gdy tworzysz nowe źródło dla nowego dziennika zdarzeń, system rejestruje źródło tego dziennika, ale dziennik nie zostanie utworzony, dopóki nie zostanie do niego zapisany pierwszy wpis.  
  
 System operacyjny przechowuje dzienniki zdarzeń jako pliki. W przypadku użycia <xref:System.Diagnostics.EventLogInstaller> programu <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub do utworzenia nowego dziennika zdarzeń skojarzony plik jest przechowywany w katalogu%SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiana przez dołączenie pierwszych 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ". evt".  
  
 Źródło musi być unikatowe na komputerze lokalnym; Nowa nazwa źródła nie może być zgodna z nazwą istniejącego źródła lub nazwą istniejącego dziennika zdarzeń. Każde źródło może zapisywać tylko w jednym dzienniku zdarzeń naraz; Jednak aplikacja może zapisywać w wielu dziennikach zdarzeń przy użyciu wielu źródeł. Na przykład aplikacja może wymagać wielu źródeł skonfigurowanych dla różnych dzienników zdarzeń lub różnych plików zasobów.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, należy usunąć źródło, a następnie utworzyć je przy użyciu nowej konfiguracji. Jeśli inne aplikacje lub składniki używają istniejącego źródła, należy utworzyć nowe źródło ze zaktualizowaną konfiguracją, a nie usunąć istniejące źródło.  
  
> [!NOTE]
>  Jeśli źródło zostało już zamapowane na dziennik, a następnie zostało ono ponownie przypisane do nowego dziennika, aby zmiany zaczęły obowiązywać, konieczne jest ponowne uruchomienie komputera.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` na komputerze `MyServer`i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie <paramref name="machineName" /> jest prawidłową nazwą komputera.  
  
—lub— 
 <paramref name="source" />jest pustym ciągiem ("") lub <see langword="null" />.  
  
—lub— 
 <paramref name="logName" />nie jest prawidłową nazwą dziennika zdarzeń. Nazwy dzienników zdarzeń muszą zawierać znaki drukowalne i nie mogą zawierać znaków "*", "?" ani "\\".  
  
—lub— 
 <paramref name="logName" />nie jest prawidłowy dla tworzenia dziennika użytkownika. Nazwy dzienników zdarzeń AppEvent, SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
—lub— 
Nazwa dziennika jest zgodna z nazwą istniejącego źródła zdarzenia.  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.  
  
—lub— 
Pierwsze 8 znaków <paramref name="logName" /> pasuje do pierwszych 8 znaków istniejącej nazwy dziennika zdarzeń na określonym komputerze.  
  
—lub— 
Nie można zarejestrować źródła, ponieważ istnieje ono już na określonym komputerze.  
  
—lub— 
Nazwa źródła pasuje do istniejącej nazwy źródła zdarzenia.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dziennika zdarzeń na określonym komputerze.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa zasób dziennika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do usunięcia. Możliwe wartości obejmują: Aplikacja, zabezpieczenia, system i wszystkie niestandardowe dzienniki zdarzeń na komputerze.</param>
        <summary>Usuwa dziennik zdarzeń z komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli dziennik, który chcesz usunąć, znajduje się na komputerze lokalnym. Możesz usunąć dowolny dziennik na komputerze, pod warunkiem, że masz odpowiednie uprawnienia do rejestru.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>usuwa dziennik określony przez `logName` program z komputera lokalnego. Jeśli chcesz usunąć tylko źródło zarejestrowane w dzienniku, wywołaj <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>polecenie. Jeśli chcesz usunąć tylko wpisy dziennika, wywołaj <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są`static` metodami, więc można je wywołać na samej klasie. Nie jest konieczne tworzenie nowego wystąpienia programu <xref:System.Diagnostics.EventLog> w celu wywołania żadnej z tych metod.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Metoda najpierw usuwa plik, który przechowuje zawartość dziennika. Następnie uzyskuje dostęp do rejestru i usuwa wszystkie źródła zdarzeń zarejestrowane dla tego dziennika. W przypadku ponownego utworzenia dziennika w późniejszym czasie należy ponownie zarejestrować źródła zdarzeń, jeśli zostaną one użyte do ponownego użycia. Jeśli nie zarejestrujesz źródeł zdarzeń i inni użytkownicy zapisują dane w źródle zdarzeń bez określenia nazwy dziennika, źródło zdarzeń zostanie utworzone w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były w stanie zapisywać wpisy w dzienniku usunięty i ponownie utworzony, będą zapisywać w dzienniku aplikacji, ponieważ teraz zawiera źródło zdarzenia.  
  
> [!NOTE]
>  Ponowne utworzenie dziennika zdarzeń może być trudnym procesem. Należy unikać usuwania wszelkich dzienników zdarzeń utworzonych przez system, takich jak dziennik aplikacji.  
  
 Usunięcie dziennika przez wywołanie w celu <xref:System.Diagnostics.EventLog.Delete%2A> automatycznego usunięcia źródeł zarejestrowanych w tym dzienniku. Może to spowodować, że inne aplikacje używają tego dziennika.  
  
   
  
## Examples  
 Poniższy przykład usuwa dziennik z komputera lokalnego. Przykład określa dziennik ze źródła.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisywać w dzienniku zdarzeń. Przed usunięciem dziennika niestandardowego upewnij się, że nie ma żadnych innych źródeł do zapisu w tym dzienniku.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" />jest pustym ciągiem ("") lub <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dziennika zdarzeń na komputerze lokalnym.  
  
—lub—
  
 Dziennik nie istnieje na komputerze lokalnym.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Dziennik zdarzeń nie został pomyślnie wyczyszczony.  
  
 —lub—  
  
 Nie można otworzyć dziennika. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do usunięcia. Możliwe wartości obejmują: Aplikacja, zabezpieczenia, system i wszystkie niestandardowe dzienniki zdarzeń na określonym komputerze.</param>
        <param name="machineName">Nazwa komputera, z którego ma zostać usunięty dziennik, lub "." na komputerze lokalnym.</param>
        <summary>Usuwa dziennik zdarzeń z określonego komputera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli dziennik, który chcesz usunąć, znajduje się na komputerze zdalnym. Możesz usunąć dowolny dziennik na komputerze, pod warunkiem, że masz odpowiednie uprawnienia do rejestru.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>usuwa dziennik określony przez `logName` program z komputera określonego przez. `machineName` Jeśli chcesz usunąć tylko źródło zarejestrowane w dzienniku, wywołaj <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>polecenie. Jeśli chcesz usunąć tylko wpisy dziennika, wywołaj <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są`static` metodami, więc można je wywołać na samej klasie. Nie jest konieczne utworzenie wystąpienia <xref:System.Diagnostics.EventLog> w celu wywołania żadnej z metod.  
  
 Ta metoda najpierw usuwa plik, który przechowuje zawartość dziennika. Następnie uzyskuje dostęp do rejestru i usuwa wszystkie źródła zdarzeń zarejestrowane dla tego dziennika. W przypadku ponownego utworzenia dziennika w późniejszym czasie należy ponownie zarejestrować źródła zdarzeń, jeśli zostaną one użyte do ponownego użycia. Jeśli nie zarejestrujesz źródeł zdarzeń i inni użytkownicy zapisują dane w źródle zdarzeń bez określenia nazwy dziennika, źródło zdarzeń zostanie utworzone w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były w stanie zapisywać wpisy w dzienniku usunięty i ponownie utworzony, będą zapisywać w dzienniku aplikacji, ponieważ teraz zawiera źródło zdarzenia.  
  
> [!NOTE]
>  Ponowne utworzenie dziennika zdarzeń może być trudnym procesem. Należy unikać usuwania wszelkich dzienników zdarzeń utworzonych przez system, takich jak dziennik aplikacji.  
  
 Usunięcie dziennika przez wywołanie w celu <xref:System.Diagnostics.EventLog.Delete%2A> automatycznego usunięcia źródeł zarejestrowanych w tym dzienniku. Może to spowodować, że inne aplikacje używają tego dziennika.  
  
   
  
## Examples  
 Poniższy przykład usuwa dziennik z określonego komputera. Przykład określa dziennik ze źródła.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisywać w dzienniku zdarzeń. Przed usunięciem dziennika niestandardowego upewnij się, że nie ma żadnych innych źródeł do zapisu w tym dzienniku.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" />jest pustym ciągiem ("") lub <see langword="null" />.  
  
—lub— 
 <paramref name="machineName" />nie jest prawidłową nazwą komputera.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dziennika zdarzeń na określonym komputerze.  
  
—lub—
  
 Dziennik nie istnieje na określonym komputerze.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Dziennik zdarzeń nie został pomyślnie wyczyszczony.  
  
 —lub—  
  
 Nie można otworzyć dziennika. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa rejestrację źródła zdarzeń aplikacji z dziennika zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa, za pomocą której aplikacja jest zarejestrowana w systemie dziennika zdarzeń.</param>
        <summary>Usuwa rejestrację źródła zdarzeń z dziennika zdarzeń komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do usuwania rejestracji <xref:System.Diagnostics.EventLog.Source%2A> z komputera lokalnego. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>uzyskuje dostęp do rejestru na komputerze lokalnym i usuwa rejestrację aplikacji jako prawidłowe źródło zdarzeń.  
  
 Składnik można usunąć jako prawidłowe źródło zdarzeń, jeśli nie jest już potrzebny do zapisu wpisów w tym dzienniku. Na przykład możesz to zrobić, jeśli trzeba zmienić składnik z jednego dziennika na inny. Ze względu na to, że źródło może być rejestrowane tylko w jednym dzienniku naraz, zmiana tego dziennika wymaga usunięcia bieżącej rejestracji.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>usuwa tylko źródło zarejestrowane w dzienniku. Jeśli chcesz usunąć sam dziennik, wywołaj <xref:System.Diagnostics.EventLog.Delete%2A>polecenie. Jeśli chcesz usunąć tylko wpisy dziennika, wywołaj <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są`static` metodami, więc można je wywołać na samej klasie. Nie jest konieczne utworzenie wystąpienia <xref:System.Diagnostics.EventLog> w celu wywołania żadnej z metod.  
  
 Usunięcie dziennika przez wywołanie w celu <xref:System.Diagnostics.EventLog.Delete%2A> automatycznego usunięcia źródeł zarejestrowanych w tym dzienniku. Może to spowodować, że inne aplikacje używają tego dziennika.  
  
> [!NOTE]
>  Jeśli źródło zostało już zamapowane na dziennik, a następnie zostało ono ponownie przypisane do nowego dziennika, aby zmiany zaczęły obowiązywać, konieczne jest ponowne uruchomienie komputera.  
  
   
  
## Examples  
 Poniższy przykład usuwa źródło z komputera lokalnego. Przykład określa dziennik ze źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisywać w dzienniku zdarzeń. Przed usunięciem dziennika niestandardowego upewnij się, że nie ma żadnych innych źródeł do zapisu w tym dzienniku.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Parametr nie istnieje w rejestrze komputera lokalnego.  
  
—lub— 
Nie masz dostępu do zapisu w kluczu rejestru dla dziennika zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa, za pomocą której aplikacja jest zarejestrowana w systemie dziennika zdarzeń.</param>
        <param name="machineName">Nazwa komputera, z którego ma zostać usunięta rejestracja, lub "." na komputerze lokalnym.</param>
        <summary>Usuwa rejestrację źródła zdarzeń aplikacji z określonego komputera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby usunąć rejestrację <xref:System.Diagnostics.EventLog.Source%2A> z komputera zdalnego. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>uzyskuje dostęp do rejestru na komputerze określonym przez `machineName` i usuwa rejestrację aplikacji jako prawidłowe źródło zdarzeń.  
  
 Składnik można usunąć jako prawidłowe źródło zdarzeń, jeśli nie jest już potrzebny do zapisu wpisów w tym dzienniku. Na przykład możesz to zrobić, jeśli trzeba zmienić składnik z jednego dziennika na inny. Ze względu na to, że źródło może być rejestrowane tylko w jednym dzienniku naraz, zmiana tego dziennika wymaga usunięcia bieżącej rejestracji.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>usuwa tylko źródło zarejestrowane w dzienniku. Jeśli chcesz usunąć sam dziennik, wywołaj <xref:System.Diagnostics.EventLog.Delete%2A>polecenie. Jeśli chcesz usunąć tylko wpisy dziennika, wywołaj <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A>i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są`static` metodami, więc można je wywołać na samej klasie. Nie jest konieczne utworzenie wystąpienia <xref:System.Diagnostics.EventLog> w celu wywołania żadnej z metod.  
  
 Usunięcie dziennika przez wywołanie w celu <xref:System.Diagnostics.EventLog.Delete%2A> automatycznego usunięcia źródeł zarejestrowanych w tym dzienniku. Może to spowodować, że inne aplikacje używają tego dziennika.  
  
> [!NOTE]
>  Jeśli źródło zostało już zamapowane na dziennik, a następnie zostało ono ponownie przypisane do nowego dziennika, aby zmiany zaczęły obowiązywać, konieczne jest ponowne uruchomienie komputera.  
  
   
  
## Examples  
 Poniższy przykład usuwa źródło z określonego komputera. Przykład określa dziennik ze źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisywać w dzienniku zdarzeń. Przed usunięciem dziennika niestandardowego upewnij się, że nie ma żadnych innych źródeł do zapisu w tym dzienniku.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> Parametr jest nieprawidłowy.  
  
—lub— 
<paramref name="source" /> Parametr nie istnieje w rejestrze określonego komputera.  
  
—lub— 
Nie masz dostępu do zapisu w kluczu rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />nie można usunąć, ponieważ w rejestrze klucz rejestru nadrzędny dla <paramref name="source" /> nie zawiera podklucza o takiej samej nazwie.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Diagnostics.EventLog" />program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość true, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Diagnostics.EventLog> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see langword="Dispose(Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see langword="Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, <see cref="T:System.Diagnostics.EventLog" /> czy odbiera <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> powiadomienia o zdarzeniach.</summary>
        <value><see langword="true" />Jeśli w <see cref="T:System.Diagnostics.EventLog" /> dzienniku zostanie zapisany wpis, w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość określa, czy zdarzenia <xref:System.Diagnostics.EventLog> wzbudzają, gdy wpisy są zapisywane w dzienniku. <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Gdy właściwość ma `true`wartość, składniki <xref:System.Diagnostics.EventLog.EntryWritten> otrzymujące zdarzenie otrzymają powiadomienie za każdym razem, gdy wpis jest zapisywana w dzienniku określonym we <xref:System.Diagnostics.EventLog.Log%2A> właściwości. Jeśli <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> jest`false`, żadne zdarzenia nie są zgłaszane.  
  
> [!NOTE]
>  Powiadomienia o zdarzeniach można odbierać tylko wtedy, gdy wpisy są zapisywane na komputerze lokalnym. Nie można odbierać powiadomień dotyczących wpisów zapisanych na komputerach zdalnych.  
  
   
  
## Examples  
 Poniższy przykład obsługuje <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenie.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dziennik zdarzeń znajduje się na komputerze zdalnym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka inicjalizację <see cref="T:System.Diagnostics.EventLog" /> użytą w formularzu lub przez inny składnik. Inicjalizacja odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] projektowe używa tej metody, aby zakończyć inicjalizację składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.BeginInit%2A> Metoda uruchamia inicjalizację. Użycie metod <xref:System.Diagnostics.EventLog.EndInit%2A> i uniemożliwia użycie kontrolki przed jej pełnym zainicjowaniem. <xref:System.Diagnostics.EventLog.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawartość dziennika zdarzeń.</summary>
        <value><see cref="T:System.Diagnostics.EventLogEntryCollection" /> Przechowywanie wpisów w dzienniku zdarzeń. Każdy wpis jest skojarzony z wystąpieniem <see cref="T:System.Diagnostics.EventLogEntry" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Entries%2A> Użyj elementu członkowskiego podczas odczytywania z dziennika zdarzeń.  
  
 Ponieważ właściwość jest tylko do odczytu, nie można modyfikować wpisu ani zapisywać do dziennika przy użyciu <xref:System.Diagnostics.EventLog.Entries%2A>. Zamiast tego należy określić <xref:System.Diagnostics.EventLog.Source%2A> wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> i napisać nowy wpis dziennika. Możesz użyć <xref:System.Diagnostics.EventLog.Entries%2A> , aby policzyć liczbę wpisów w dzienniku zdarzeń i wyświetlić każdy <xref:System.Diagnostics.EventLogEntry> w kolekcji. Użyj indeksowanego <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> elementu członkowskiego, aby pobrać informacje o konkretnym wpisie <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>takie jak <xref:System.Diagnostics.EventLogEntry.EntryType%2A> <xref:System.Diagnostics.EventLogEntry.Message%2A>,, lub.  
  
 Nie trzeba określać <xref:System.Diagnostics.EventLog.Source%2A> w przypadku odczytywania tylko z dziennika. Dla tego <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.MachineName%2A> wystąpieniamożnaokreślićtylkowłaściwościNazwai(nazwa<xref:System.Diagnostics.EventLog> komputera serwera). W obu przypadkach <xref:System.Diagnostics.EventLog.Entries%2A> element członkowski jest automatycznie wypełniany listą wpisów dziennika zdarzeń. Możesz wybrać odpowiedni indeks dla elementu na tej liście, aby odczytywać poszczególne wpisy.  
  
 Ważna różnica między odczytywaniem i zapisywaniem wpisów dziennika polega na tym, że nie jest konieczne jawne wywołanie metody Read. Po określeniu <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog.Log%2A> isąone<xref:System.Diagnostics.EventLog.Entries%2A> wypełniane automatycznie. Jeśli zmienisz wartość <xref:System.Diagnostics.EventLog.Log%2A> właściwości lub <xref:System.Diagnostics.EventLog.MachineName%2A> , <xref:System.Diagnostics.EventLog.Entries%2A> właściwość jest ponownie wypełniana przy następnym odczytaniu.  
  
> [!NOTE]
>  Nie jest wymagane, aby określić, <xref:System.Diagnostics.EventLog.MachineName%2A> czy łączysz się z dziennikiem. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, przyjmowany jest komputer lokalny, ".".  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "MyNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wpis jest zapisywana w dzienniku zdarzeń na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymywać powiadomienia o zdarzeniach, należy <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> ustawić `true`wartość. Powiadomienia o zdarzeniach można odbierać tylko wtedy, gdy wpisy są zapisywane na komputerze lokalnym. Nie można odbierać powiadomień dotyczących wpisów zapisanych na komputerach zdalnych.  
  
 Podczas tworzenia <xref:System.Diagnostics.EventLog.EntryWritten> delegata należy określić metodę, która będzie obsługiwać zdarzenie. Aby skojarzyć zdarzenie z programem obsługi zdarzeń, Dodaj wystąpienie delegata do zdarzenia. Procedura obsługi zdarzeń jest wywoływana za każdym razem, gdy wystąpi zdarzenie, do momentu usunięcia delegata. Aby uzyskać więcej informacji na temat obsługi zdarzeń z delegatami, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 System reaguje na <xref:System.Diagnostics.EventLog.WriteEntry%2A> tylko wtedy, gdy ostatnie zdarzenie zapisu wystąpiło co najmniej sześć sekund. Oznacza to, że tylko jedno <xref:System.Diagnostics.EventLog.EntryWritten> powiadomienie o zdarzeniu zostanie odebrane w ciągu sześciu sekund, nawet jeśli wystąpi więcej niż jedna zmiana w dzienniku zdarzeń. W przypadku wstawienia wystarczająco długiego interwału uśpienia (około 10 sekund) między <xref:System.Diagnostics.EventLog.WriteEntry%2A>wywołaniami do, zmniejszanie może pominąć zdarzenie. Jeśli jednak zdarzenia zapisu pojawiają się częściej, użytkownik może nie otrzymać powiadomienia o zdarzeniu do następnego interwału. Zazwyczaj pominięte powiadomienia o zdarzeniach nie są tracone, ale są opóźnione.  
  
   
  
## Examples  
 Poniższy przykład obsługuje zdarzenie zapisywane w zapisie.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy określony dziennik istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do wyszukania. Możliwe wartości obejmują: Aplikacje, zabezpieczenia, system, inne dzienniki specyficzne dla aplikacji (takie jak powiązane z Active Directory) lub Dziennik niestandardowy na komputerze.</param>
        <summary>Określa, czy dziennik istnieje na komputerze lokalnym.</summary>
        <returns><see langword="true" />Jeśli dziennik istnieje na komputerze lokalnym; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy dziennik istnieje na komputerze lokalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, wymagane są odpowiednie uprawnienia do rejestru na komputerze lokalnym; w przeciwnym razie zapytanie zwraca `false`wartość.  
  
 Ponieważ nie można nadać nowemu dziennikowi nazwy istniejącego dziennika na tym samym komputerze, Użyj tej metody przed utworzeniem nowego dziennika, aby określić, czy określony `logName` już istnieje na komputerze lokalnym. W `logName` parametrze nie jest rozróżniana wielkość liter.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>`static` jest metodą, dlatego można ją wywołać dla samej klasy. Nie jest konieczne tworzenie wystąpienia elementu <xref:System.Diagnostics.EventLog> do wywołania. <xref:System.Diagnostics.EventLog.Exists%2A>  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa jest <see langword="null" /> lub wartość jest pusta.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Dziennik, który ma zostać wyszukany. Możliwe wartości obejmują: Aplikacje, zabezpieczenia, system, inne dzienniki specyficzne dla aplikacji (takie jak powiązane z Active Directory) lub Dziennik niestandardowy na komputerze.</param>
        <param name="machineName">Nazwa komputera, na którym ma zostać wyszukany dziennik, lub "." na komputerze lokalnym.</param>
        <summary>Określa, czy dziennik istnieje na określonym komputerze.</summary>
        <returns><see langword="true" />Jeśli dziennik istnieje na określonym komputerze; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy dziennik istnieje na komputerze zdalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze zdalnym, użyj <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, wymagane są odpowiednie uprawnienia do rejestru na określonym komputerze; w przeciwnym razie zapytanie zwraca `false`wartość.  
  
 Ponieważ nie można nadać nowemu dziennikowi nazwy istniejącego dziennika na tym samym komputerze, Użyj tej metody przed utworzeniem nowego dziennika, aby określić, czy jeden z określonym `logName` już istnieje na serwerze określonym `machineName` przez parametr. W `logName` parametrach i `machineName` nie jest rozróżniana wielkość liter.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>`static` jest metodą, dlatego można ją wywołać dla samej klasy. Utworzenie nowego wystąpienia <xref:System.Diagnostics.EventLog> do wywołania <xref:System.Diagnostics.EventLog.Exists%2A>nie jest konieczne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> Parametr jest nieprawidłowym formatem. Upewnij się, że używasz właściwej składni dla komputera, na którym jest wykonywane wyszukiwanie.  
  
—lub— 
Wartość <paramref name="logName" /> is<see langword="null" /> lub jest pusta.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę dzienników zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyszukuje wszystkie dzienniki zdarzeń na komputerze lokalnym i tworzy tablicę <see cref="T:System.Diagnostics.EventLog" /> obiektów, które zawierają listę.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.EventLog" /> , która reprezentuje dzienniki na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica <xref:System.Diagnostics.EventLog> obiektów jest migawką wszystkich dzienników zdarzeń na komputerze lokalnym, gdy <xref:System.Diagnostics.EventLog.GetEventLogs%2A> wywołanie jest nawiązywane. Nie jest to kolekcja dynamiczna, dlatego nie odzwierciedla ona usuwania ani tworzenia dzienników w czasie rzeczywistym. Przed odczytaniem lub zapisaniem w tablicy należy sprawdzić, czy istnieje już dziennik. Tablica zwykle zawiera co najmniej trzy dzienniki: Aplikacja, system i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na komputerze lokalnym, zostaną one również wyświetlone w tablicy.  
  
 Aby pobrać listę dzienników zdarzeń, musisz mieć odpowiednie uprawnienia do rejestru. Te uprawnienia są identyczne z tymi, które są <xref:System.Diagnostics.EventLog.Exists%2A> wymagane <xref:System.Diagnostics.EventLog.SourceExists%2A>do wywołania i.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Nie masz dostępu do odczytu do rejestru.  
  
 —lub—  
  
 Na komputerze nie ma usługi dziennika zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, na którym mają zostać wyszukane dzienniki zdarzeń.</param>
        <summary>Wyszukuje wszystkie dzienniki zdarzeń na danym komputerze i tworzy tablicę <see cref="T:System.Diagnostics.EventLog" /> obiektów, które zawierają listę.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.EventLog" /> , która reprezentuje dzienniki na danym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica <xref:System.Diagnostics.EventLog> obiektów jest migawką wszystkich dzienników zdarzeń na komputerze określonym `machineName` przez <xref:System.Diagnostics.EventLog.GetEventLogs%2A> parametr podczas wywołania. Nie jest to kolekcja dynamiczna, dlatego nie odzwierciedla ona usuwania ani tworzenia dzienników w czasie rzeczywistym. Przed odczytaniem lub zapisaniem w tablicy należy sprawdzić, czy istnieje już dziennik. Tablica zwykle zawiera co najmniej trzy dzienniki: Aplikacja, system i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na określonym komputerze, zostaną one również wyświetlone w tablicy.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A>jest metodą, dlatego można ją wywołać <xref:System.Diagnostics.EventLog> dla samej klasy. `static` Utworzenie wystąpienia <xref:System.Diagnostics.EventLog> obiektu nie jest konieczne w celu wywołania metody.  
  
 Aby pobrać listę dzienników zdarzeń, musisz mieć odpowiednie uprawnienia do rejestru. Te uprawnienia są identyczne z tymi, które są <xref:System.Diagnostics.EventLog.Exists%2A> wymagane <xref:System.Diagnostics.EventLog.SourceExists%2A>do wywołania i.  
  
   
  
## Examples  
 Poniższy przykład pobiera listę dzienników na komputerze "i". Następnie wyświetla nazwę każdego dziennika.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> Parametr jest nieprawidłową nazwą komputera.</exception>
        <exception cref="T:System.InvalidOperationException">Nie masz dostępu do odczytu do rejestru.  
  
 —lub—  
  
 Na komputerze nie ma usługi dziennika zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę dziennika do odczytu lub zapisu.</summary>
        <value>Nazwa dziennika. Może to być aplikacja, system, zabezpieczenia lub nazwa dziennika niestandardowego. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trzy pliki dziennika są domyślnie dostępne na serwerze: Aplikacja, system i zabezpieczenia. Aplikacje i usługi korzystają z pliku dziennika aplikacji. Sterowniki urządzeń używają pliku dziennika systemowego. System generuje zdarzenia o powodzeniu i niepowodzeniu inspekcji w dzienniku zabezpieczeń, gdy inspekcja jest włączona. Jeśli masz zainstalowane inne aplikacje, takie jak Active Directory na serwerach z systemem Windows, mogą istnieć inne domyślne pliki dziennika. Ponadto można tworzyć niestandardowe pliki dziennika na komputerze lokalnym lub zdalnym. Dzienniki niestandardowe ułatwiają organizowanie wpisów w bardziej szczegółowy sposób, niż jest to dozwolone, gdy składniki zapisują zdarzenia do domyślnego dziennika aplikacji.  
  
> [!NOTE]
>  Nazwy dzienników są ograniczone do ośmiu znaków. Zgodnie z systemem MyLogSample1 i MyLogSample2 są tego samego dziennika.  
  
 Jeśli zapisujesz dane <xref:System.Diagnostics.EventLog.Log%2A> w dzienniku zdarzeń, nie jest wystarczające, aby określić właściwość. Należy skojarzyć <xref:System.Diagnostics.EventLog.Source%2A> właściwość z zasobem dziennika zdarzeń, aby połączyć ją z określonym dziennikiem. Nie trzeba określać <xref:System.Diagnostics.EventLog.Source%2A> w przypadku odczytywania danych z dziennika, ale Źródło zdarzenia musi być skojarzone z zasobem dziennika zdarzeń w rejestrze serwera. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwę i <xref:System.Diagnostics.EventLog.MachineName%2A> (nazwę komputera serwera) do odczytania.  
  
> [!NOTE]
>  Nie jest wymagane, aby określić, <xref:System.Diagnostics.EventLog.MachineName%2A> czy łączysz się z dziennikiem. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, zostanie przyjęty komputer lokalny (".").  
  
 Jeśli właściwość nie została określona, wywołanie do <xref:System.Diagnostics.EventLog.Log%2A> zwraca pusty ciąg, jeśli <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.Log%2A> nie został jawnie ustawiony (przez ustawienie właściwości lub przez konstruktora). <xref:System.Diagnostics.EventLog.Source%2A> Jeśli określono, <xref:System.Diagnostics.EventLog.Log%2A> zwraca nazwę dziennika, do którego zostało zarejestrowane to źródło. <xref:System.Diagnostics.EventLog.Source%2A>  
  
 Źródło może być rejestrowane tylko w jednym dzienniku naraz. <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog> Jeśli właściwość została ustawiona dla wystąpienia elementu, nie można zmienić właściwości dla tego elementu bez zmiany wartości lub wywołania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> pierwszej. <xref:System.Diagnostics.EventLog.Source%2A> Jeśli zmienisz <xref:System.Diagnostics.EventLog.Log%2A> Właściwość <xref:System.Diagnostics.EventLog.Source%2A> po ustawieniu właściwości, napisanie wpisu dziennika zgłasza wyjątek.  
  
 System operacyjny przechowuje dzienniki zdarzeń jako pliki. W przypadku użycia <xref:System.Diagnostics.EventLogInstaller> programu <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub do utworzenia nowego dziennika zdarzeń skojarzony plik jest przechowywany w katalogu%SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiana przez dołączenie pierwszych 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ". evt".  
  
 Nie można utworzyć nowego dziennika, używając <xref:System.Diagnostics.EventLog.Log%2A> samego właściwości (bez określania źródła dziennika). Można wywołać <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, przekazać w nowej nazwie dziennika jako parametr, a następnie wywołać metodę <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Jednak zamiarem jest zazwyczaj utworzenie (i zapisanie wpisów do) nowych dzienników specyficznych dla aplikacji lub odczyt z istniejących dzienników.  
  
 <xref:System.Diagnostics.EventLog.Log%2A> Jeśli wartość ulegnie zmianie, dziennik zdarzeń zostanie zamknięty i zostaną wydane wszystkie uchwyty zdarzeń.  
  
> [!CAUTION]
>  Jeśli ustawisz <xref:System.Diagnostics.EventLog.Log%2A> właściwość na nazwę dziennika, który nie istnieje, system dołączy <xref:System.Diagnostics.EventLog> do dziennika aplikacji, ale nie ostrzega o tym, że używa dziennika innego niż określony.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "NewEventLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przyjazną nazwę dziennika zdarzeń.</summary>
        <value>Nazwa, która reprezentuje dziennik zdarzeń w Podglądzie zdarzeń systemu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  W systemie Windows Vista i nowszych użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń. Jeśli korzystasz z systemu Windows Vista lub nowszego jako użytkownik, uzyskasz <xref:System.Security.SecurityException> próbę uzyskania dostępu do nazwy wyświetlanej zdarzenia w dzienniku zabezpieczeń.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do dziennika zabezpieczeń, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla <xref:System.Diagnostics.EventLog.LogDisplayName%2A> dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określona <see cref="P:System.Diagnostics.EventLog.Log" /> wartość nie istnieje w rejestrze dla tego komputera.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Możliwość odczytu wskazanego klucza rejestru. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Możliwość dostępu do wskazanego klucza rejestru, jeśli jest to klucz zdalny. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia.</param>
        <param name="machineName">Nazwa komputera, na którym należy szukać lub "." dla komputera lokalnego.</param>
        <summary>Pobiera nazwę dziennika, do którego zarejestrowano określone źródło.</summary>
        <returns>Nazwa dziennika skojarzonego z określonym źródłem w rejestrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródło zdarzenia wskazuje, co rejestruje zdarzenie. Często jest to nazwa aplikacji lub nazwa podskładniku aplikacji, jeśli aplikacja jest duża. Aplikacje i usługi powinny zapisywać w dzienniku aplikacji lub dzienniku niestandardowym. Sterowniki urządzeń powinny zapisywać dane w dzienniku systemu.  
  
 Podczas tworzenia nowego źródła, które może zapisywać tylko w jednym dzienniku naraz, system rejestruje swoją aplikację w dzienniku zdarzeń jako prawidłowe Źródło wpisów. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość może być dowolnym ciągiem, ale nazwy nie mogą być używane przez inne źródła na komputerze. Próba utworzenia zduplikowanej <xref:System.Diagnostics.EventLog.Source%2A> wartości zgłasza wyjątek. Jednak pojedynczy dziennik zdarzeń może zawierać wiele różnych źródeł.  
  
   
  
## Examples  
 Poniższy przykład usuwa źródło z komputera lokalnego. Przykład określa dziennik ze źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisywać w dzienniku zdarzeń. Przed usunięciem dziennika niestandardowego upewnij się, że nie ma żadnych innych źródeł do zapisu w tym dzienniku.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym mają być odczytywane lub zapisywane zdarzenia.</summary>
        <value>Nazwa serwera, na którym znajduje się dziennik zdarzeń. Wartość domyślna to komputer lokalny (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zapisywania w dzienniku zdarzeń należy skojarzyć <xref:System.Diagnostics.EventLog.Source%2A> z obiektem dziennika zdarzeń, aby połączyć go z określonym dziennikiem. Nie trzeba określać <xref:System.Diagnostics.EventLog.Source%2A> właściwości w przypadku odczytywania tylko z dziennika. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwę i <xref:System.Diagnostics.EventLog.MachineName%2A> (nazwę komputera serwera).  
  
> [!NOTE]
>  Nie musisz określać, <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się z dziennikiem. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, zostanie przyjęty komputer lokalny (".").  
  
 Źródło może być rejestrowane tylko w jednym dzienniku naraz. <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog> Jeśli właściwość została ustawiona dla wystąpienia elementu, nie można zmienić właściwości dla tego elementu bez zmiany wartości lub wywołania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> pierwszej. <xref:System.Diagnostics.EventLog.Source%2A> Jeśli zmienisz <xref:System.Diagnostics.EventLog.MachineName%2A> Właściwość <xref:System.Diagnostics.EventLog> , zamyka wszystkie uchwyty i ponownie dołącza do dziennika i źródła na nowym komputerze.  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> Wartość nie może być pustym ciągiem. Jeśli nie jest on jawnie ustawiony, domyślnie przyjmowany jest komputer lokalny (".").  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "NewEventLog" na określonym komputerze.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar dziennika zdarzeń w kilobajtach.</summary>
        <value>Maksymalny rozmiar dziennika zdarzeń w kilobajtach. Wartość domyślna to 512, co oznacza, że maksymalny rozmiar pliku wynosi 512 kilobajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Właściwość reprezentuje limit rozmiaru pliku dziennika zdarzeń. Gdy dziennik zdarzeń osiągnie limit rozmiaru, skonfigurowana <xref:System.Diagnostics.EventLog.OverflowAction%2A> wartość określa, czy nowe wpisy są odrzucane, czy nowe wpisy zastępują starsze wpisy.  
  
> [!NOTE]
>  Ta właściwość reprezentuje ustawienie konfiguracji dziennika zdarzeń reprezentowanego przez to wystąpienie. Gdy dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy, które są zapisywane przez wszystkie źródła zdarzeń zarejestrowane dla dziennika zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona wartość jest mniejsza niż 64 lub większa niż 4194240 lub nie jest parzystą wielokrotnością 64.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest prawidłową nazwą dziennika.  
  
—lub— 
Nie można otworzyć klucza rejestru dziennika zdarzeń na komputerze docelowym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę dni przechowywania wpisów w dzienniku zdarzeń.</summary>
        <value>Liczba dni przechowywania wpisów w dzienniku zdarzeń. Wartość domyślna to 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Użyj właściwości, aby przejrzeć bieżące ustawienie dla dziennika zdarzeń. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> , aby zmienić minimalną liczbę dni, w których należy zachować poszczególne wpisy w dzienniku zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wartość zależy od skonfigurowanego zachowania przepełnienia dziennika zdarzeń. Jeśli właściwość dziennika zdarzeń jest ustawiona na <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość jest równa 0. <xref:System.Diagnostics.OverflowAction> Jeśli właściwość dziennika zdarzeń jest ustawiona na <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość jest-1. <xref:System.Diagnostics.OverflowAction> Jeśli właściwość dla dziennika zdarzeń jest ustawiona na <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość jest większa od zera i reprezentuje liczbę dni przechowywania wpisów dziennika zdarzeń w przypadku zapełnienia dziennika zdarzeń. <xref:System.Diagnostics.OverflowAction>  
  
 Zachowanie przepełnienia występuje tylko wtedy, gdy dziennik zdarzeń osiągnie limit rozmiaru. Gdy <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.OverflowAction.OverwriteOlder>ma ustawioną wartość, a dziennik zdarzeń osiągnie maksymalny rozmiar, nowe wpisy są zapisywane tylko wtedy, gdy mogą zastąpić wpisy, których wiek przekracza <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> czas. <xref:System.Diagnostics.EventLog.OverflowAction%2A> Zachowywanie wpisów zdarzeń przez okres minimalny jest odpowiednie w przypadku regularnego archiwizowania dziennika zdarzeń. W przeciwnym razie użytkownik jest narażony na utratę nowych wpisów, gdy dziennik zdarzeń osiągnie limit. Aby uniknąć utraty nowych informacji o zdarzeniu, należy ustawić minimalną liczbę dni przechowywania dla zdarzeń na podstawie harmonogramu archiwum dla określonego dziennika zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Zachowanie przepełnienia podczas zapisywania nowych wpisów w dzienniku zdarzeń.</param>
        <param name="retentionDays">Minimalna liczba dni zachowywania każdego wpisu dziennika zdarzeń. Ten parametr jest używany tylko wtedy <paramref name="action" /> , gdy jest <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />ustawiony na.</param>
        <summary>Zmienia skonfigurowane zachowanie podczas zapisywania nowych wpisów, gdy dziennik zdarzeń osiągnie maksymalny rozmiar pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie przepełnienia dziennika zdarzeń określa, co się dzieje w przypadku zapisania nowych wpisów w dzienniku, który osiągnął maksymalny rozmiar pliku.  
  
> [!NOTE]
>  Zachowanie przepełnienia działa tylko wtedy, gdy dziennik zdarzeń osiągnie maksymalny rozmiar pliku. Zachowanie przepełnienia nie ma wpływu na zapisywanie nowego wpisu w dzienniku, który może obsłużyć dodatkowe wpisy dziennika zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Metoda konfiguruje zachowanie przepełnienia dziennika zdarzeń. <xref:System.Diagnostics.EventLog>np. Po wywołaniu tej metody dla dziennika zdarzeń określonego przez <xref:System.Diagnostics.EventLog.Log%2A> Właściwość <xref:System.Diagnostics.EventLog.OverflowAction%2A> , wartości właściwości i <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> odzwierciedlają nowo skonfigurowane zachowanie przepełnienia.  
  
> [!NOTE]
>  Ta właściwość reprezentuje ustawienie konfiguracji dziennika zdarzeń reprezentowanego przez to wystąpienie. Gdy dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy, które są zapisywane przez wszystkie źródła zdarzeń zarejestrowane dla dziennika zdarzeń.  
  
 Ustaw parametr na <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> , aby wskazać, że nowy wpis zastępuje najstarszą pozycję, gdy <xref:System.Diagnostics.EventLog> osiągnie maksymalny rozmiar. `action` Jeśli parametr jest ustawiony na <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, `retentionDays` wartość parametru jest ignorowana. `action`  
  
 Ustaw parametr na <xref:System.Diagnostics.OverflowAction.OverwriteOlder> , aby wskazać, że każdy nowy wpis zastępuje starsze wpisy, <xref:System.Diagnostics.EventLog> gdy osiągnie maksymalny rozmiar. `action` Określ liczbę dni, przez które zdarzenia muszą być przechowywane w dzienniku przy użyciu `retentionDays` parametru. Zdarzenia zapisywane w ramach zakresu przechowywania nie są zastępowane przez nowe wpisy.  
  
 Ustaw parametr na <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> , aby odrzucać nowe zdarzenia po osiągnięciu maksymalnego rozmiaru dziennika. `action` Jeśli parametr jest ustawiony na <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, `retentionDays` wartość parametru jest ignorowana. `action`  
  
> [!CAUTION]
>  Ustawienie zasad <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> przepełniania określa, że nowe wpisy są odrzucane po zapełnieniu dziennika zdarzeń. W przypadku użycia tego ustawienia upewnij się, że dziennik zdarzeń jest regularnie archiwizowany i czyszczony, aby uniknąć osiągnięcia maksymalnego limitu rozmiaru.  
  
   
  
## Examples  
 Poniższy przykład wyświetla skonfigurowane zasady przepełnienia dla określonego dziennika zdarzeń i umożliwia użytkownikowi wybranie nowego ustawienia zasad przepełnienia dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" />nie jest prawidłową <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> wartością.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retentionDays" />jest mniejsza niż 1 lub większa niż 365.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest prawidłową nazwą dziennika.  
  
—lub— 
Nie można otworzyć klucza rejestru dziennika zdarzeń na komputerze docelowym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera skonfigurowane zachowanie dotyczące przechowywania nowych wpisów, gdy dziennik zdarzeń osiągnie maksymalny rozmiar pliku dziennika.</summary>
        <value><see cref="T:System.Diagnostics.OverflowAction" /> Wartość, która określa skonfigurowane zachowanie przechowywania nowych wpisów, gdy dziennik zdarzeń osiągnie maksymalny rozmiar dziennika. Wartość domyślna to <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar dzienników zdarzeń zwiększa się w miarę zapisywania w nich nowych zdarzeń. Każdy dziennik zdarzeń ma skonfigurowany limit maksymalnego rozmiaru; <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Właściwość definiuje maksymalną liczbę kilobajtów dozwoloną dla rozmiaru pliku dziennika zdarzeń.  
  
 Użyj wartości <xref:System.Diagnostics.EventLog.OverflowAction%2A> właściwości, aby przejrzeć skonfigurowane zachowanie przepełnienia w dzienniku zdarzeń o maksymalnym rozmiarze. <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Użyj metody, aby zmienić zachowanie przepełnienia dziennika zdarzeń.  
  
> [!NOTE]
>  Zachowanie przepełnienia działa tylko wtedy, gdy dziennik zdarzeń osiągnie maksymalny rozmiar pliku. Zachowanie przepełnienia nie ma wpływu na zapisywanie nowego wpisu w dzienniku, który może obsłużyć dodatkowe wpisy dziennika zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">W pełni określona ścieżka do zlokalizowanego pliku zasobów.</param>
        <param name="resourceId">Identyfikator zasobu, który indeksuje zlokalizowany ciąg w pliku zasobów.</param>
        <summary>Określa zlokalizowaną nazwę dziennika zdarzeń, który jest wyświetlany na serwerze Podgląd zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> , aby zarejestrować i wyświetlić zlokalizowaną nazwę w Podgląd zdarzeń dla dzienników zdarzeń niestandardowych.  
  
 Określony identyfikator zasobu musi odpowiadać zlokalizowanemu ciągowi zdefiniowanemu w pliku zasobów. Podgląd zdarzeń wyświetla nazwę dziennika zdarzeń niestandardowych przy użyciu zlokalizowanego ciągu i bieżących ustawień kultury. Można na przykład zdefiniować wiele nazw dzienników zdarzeń zlokalizowanych dla różnych kultur w pliku zasobów. Podgląd zdarzeń wyświetla zlokalizowany ciąg odpowiadający ustawieniom kultury bieżącego użytkownika.  
  
 Jeśli Podgląd zdarzeń nie może załadować zlokalizowanego ciągu z pliku zasobów lub jeśli w dzienniku zdarzeń nie zarejestrowano żadnej nazwy wyświetlanej, Podgląd zdarzeń wyświetla nazwę dziennika zdarzeń zdefiniowaną w <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Nie trzeba rejestrować nazwy wyświetlanej dla wstępnie zdefiniowanych dzienników zdarzeń. System operacyjny rejestruje zlokalizowane nazwy wyświetlane dla dzienników zdarzeń aplikacji, systemu i zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykład określa, czy źródło zdarzeń o nazwie `SampleApplicationSource` jest zarejestrowane na komputerze lokalnym. Jeśli źródło zdarzenia nie istnieje, przykład ustawia plik zasobów wiadomości dla źródła i tworzy nowe źródło zdarzenia. Na koniec przykład ustawia zlokalizowaną nazwę wyświetlaną dla dziennika zdarzeń przy użyciu wartości identyfikator zasobu w `DisplayNameMsgId` i ścieżki pliku zasobu w. `messageFile`  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 W przykładzie zastosowano następujący plik tekstowy komunikatu, wbudowany w bibliotekę zasobów EventLogMsgs. dll. Plik tekstowy komunikatu jest źródłem, z którego tworzony jest plik zasobów wiadomości. Plik tekstowy komunikatu określa identyfikatory zasobów i tekst dla kategorii, komunikat zdarzenia i ciągi wstawiania parametrów. W przypadku zlokalizowanej nazwy dziennika zdarzeń jest zdefiniowany identyfikator zasobu 5001.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest prawidłową nazwą dziennika.  
  
—lub— 
Nie można otworzyć klucza rejestru dziennika zdarzeń na komputerze docelowym.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacjami dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę źródła do zarejestrowania i użycia podczas zapisywania w dzienniku zdarzeń.</summary>
        <value>Nazwa zarejestrowana w dzienniku zdarzeń jako źródło wpisów. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródło zdarzenia wskazuje, co rejestruje zdarzenie. Często jest to nazwa aplikacji lub nazwa podskładniku aplikacji, jeśli aplikacja jest duża. Aplikacje i usługi powinny zapisywać w dzienniku aplikacji lub dzienniku niestandardowym. Sterowniki urządzeń powinny zapisywać dane w dzienniku systemu.  
  
 Jeśli zapisujesz w dzienniku zdarzeń, musisz określić źródło zdarzenia. Przed zapisaniem wpisu w dzienniku zdarzeń należy zarejestrować Źródło zdarzenia w dzienniku zdarzeń jako prawidłowe źródło zdarzeń. Podczas pisania wpisu dziennika system używa <xref:System.Diagnostics.EventLog.Source%2A> właściwości, aby znaleźć odpowiedni dziennik, w którym ma zostać umieszczony wpis. W przypadku odczytywania dziennika zdarzeń można określić <xref:System.Diagnostics.EventLog.Source%2A>, <xref:System.Diagnostics.EventLog.Log%2A> lub a i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Nie jest wymagane, aby określić, <xref:System.Diagnostics.EventLog.MachineName%2A> czy łączysz się z dziennika na komputerze lokalnym. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, zostanie przyjęty komputer lokalny (".").  
  
 Używanie <xref:System.Diagnostics.EventLog.WriteEvent%2A> i<xref:System.Diagnostics.EventLog.WriteEntry%2A> do zapisywania zdarzeń w dzienniku zdarzeń. Należy określić źródło zdarzenia do zapisywania zdarzeń; przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Można utworzyć źródło zdarzenia dla istniejącego dziennika zdarzeń lub nowego dziennika zdarzeń. Gdy tworzysz nowe źródło dla nowego dziennika zdarzeń, system rejestruje źródło tego dziennika, ale dziennik nie zostanie utworzony, dopóki nie zostanie do niego zapisany pierwszy wpis.  
  
 Źródło musi być unikatowe na komputerze lokalnym; Nowa nazwa źródła nie może być zgodna z nazwą istniejącego źródła lub nazwą istniejącego dziennika zdarzeń. Każde źródło może zapisywać tylko w jednym dzienniku zdarzeń naraz; Jednak aplikacja może zapisywać w wielu dziennikach zdarzeń przy użyciu wielu źródeł. Na przykład aplikacja może wymagać wielu źródeł skonfigurowanych dla różnych dzienników zdarzeń lub różnych plików zasobów.  
  
 Zmiana <xref:System.Diagnostics.EventLog.Source%2A> wartości<xref:System.Diagnostics.EventLog> , na którą jest ona zarejestrowana, jest zamknięta i wszystkie uchwyty zdarzeń zostaną wydane.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, należy usunąć źródło, a następnie utworzyć je przy użyciu nowej konfiguracji. Jeśli inne aplikacje lub składniki używają istniejącego źródła, należy utworzyć nowe źródło ze zaktualizowaną konfiguracją, a nie usunąć istniejące źródło.  
  
> [!NOTE]
>  Jeśli źródło zostało już zamapowane na dziennik, a następnie zostało ono ponownie przypisane do nowego dziennika, aby zmiany zaczęły obowiązywać, konieczne jest ponowne uruchomienie komputera.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` , jeśli jeszcze nie istnieje, i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje w rejestrze komputera dla danego źródła zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia.</param>
        <summary>Określa, czy źródło zdarzenia jest zarejestrowane na komputerze lokalnym.</summary>
        <returns><see langword="true" />Jeśli źródło zdarzenia jest zarejestrowane na komputerze lokalnym; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy źródło zdarzenia istnieje na komputerze lokalnym. Jeśli chcesz określić, czy dziennik istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.Exists%2A>programu.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, wymagane są odpowiednie uprawnienia do rejestru na komputerze lokalnym; w przeciwnym razie zostanie zgłoszony. <xref:System.Security.SecurityException>  
  
> [!NOTE]
>  Aby wyszukać źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć uprawnienia administracyjne.  
>   
>  Przyczyną tego wymagania jest to, że wszystkie dzienniki zdarzeń, w tym zabezpieczenia, muszą być przeszukiwane w celu ustalenia, czy źródło zdarzenia jest unikatowe. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z <xref:System.Security.SecurityException> tym jest zgłaszany.  
>   
>  Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
> [!NOTE]
>  Usługa, która jest wykonywana w ramach <xref:System.ServiceProcess.ServiceAccount.LocalSystem> konta, nie ma uprawnień wymaganych do wykonania tej metody. Rozwiązanie polega na sprawdzeniu <xref:System.ServiceProcess.ServiceInstaller>, czy źródło zdarzenia istnieje w, i jeśli nie istnieje, aby utworzyć źródło w instalatorze.  
  
 Ponieważ nie można nadać nowemu źródłu nazwy istniejącego źródła na tym samym komputerze, Użyj tej metody przed podjęciem próby wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> , aby upewnić się, że źródło o nazwie określonej przez `source` nie istnieje jeszcze na komputerze lokalnym. W `source` parametrze nie jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` , jeśli jeszcze nie istnieje, i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" />nie znaleziono, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia.</param>
        <param name="machineName">Nazwa komputera, na którym należy szukać lub "." dla komputera lokalnego.</param>
        <summary>Określa, czy źródło zdarzenia jest zarejestrowane na określonym komputerze.</summary>
        <returns><see langword="true" />Jeśli źródło zdarzenia jest zarejestrowane na danym komputerze; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy źródło zdarzenia istnieje na komputerze określonym przez `machineName` parametr. Jeśli chcesz określić, czy na określonym komputerze istnieje dziennik, użyj <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, wymagane są odpowiednie uprawnienia do rejestru na danym serwerze; w przeciwnym razie zostanie zgłoszony. <xref:System.Security.SecurityException>  
  
> [!NOTE]
>  Aby wyszukać źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć uprawnienia administracyjne.  
>   
>  Przyczyną tego wymagania jest to, że wszystkie dzienniki zdarzeń, w tym zabezpieczenia, muszą być przeszukiwane w celu ustalenia, czy źródło zdarzenia jest unikatowe. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z <xref:System.Security.SecurityException> tym jest zgłaszany.  
>   
>  Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby wykonać kod, który uzyskuje dostęp do liczników wydajności, należy najpierw podnieść poziom uprawnień użytkownika standardowego do administratora. Można to zrobić podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikony aplikacji i wskazanie, że chcesz uruchomić program jako administrator.  
  
> [!NOTE]
>  Usługa, która jest wykonywana w ramach <xref:System.ServiceProcess.ServiceAccount.LocalSystem> konta, nie ma uprawnień wymaganych do wykonania tej metody. Rozwiązanie polega na sprawdzeniu <xref:System.ServiceProcess.ServiceInstaller>, czy źródło zdarzenia istnieje w, i jeśli nie istnieje, aby utworzyć źródło w instalatorze.  
  
 Ponieważ nie można nadać nowemu źródłu nazwy istniejącego źródła na tym samym komputerze, Użyj tej metody przed podjęciem próby wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> , aby upewnić się, że źródło o nazwie określonej przez `source` nie istnieje już na komputerze. W `source` parametrach i `machineName` nie jest rozróżniana wielkość liter.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A>`static` jest metodą, dlatego można ją wywołać dla samej klasy. Nie jest konieczne tworzenie wystąpienia elementu <xref:System.Diagnostics.EventLog> do wywołania. <xref:System.Diagnostics.EventLog.SourceExists%2A>  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` na komputerze `MyServer`i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" />jest nieprawidłową nazwą komputera.</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="source" />nie znaleziono, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, który został <see cref="T:System.Diagnostics.EventLog" /> wygenerowany w wyniku zdarzenia zapisywania.</summary>
        <value>Służy do organizowania wywołań obsługi zdarzeń wydawanych w wyniku <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> zdarzenia w dzienniku zdarzeń. <see cref="T:System.ComponentModel.ISynchronizeInvoke" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> tak `null`jest, metody obsługujące <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenie są wywoływane w wątku z puli wątków systemowych. Aby uzyskać więcej informacji na temat pul wątków systemowych <xref:System.Threading.ThreadPool>, zobacz.  
  
 <xref:System.Diagnostics.EventLog.EntryWritten> Gdy zdarzenie jest obsługiwane przez składnik Visual Windows Forms, taki jak przycisk, uzyskanie dostępu do składnika za pomocą puli wątków systemowych może nie zadziałać lub może spowodować wyjątek. W tym celu należy <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> to zrobić, ustawiając składnik Windows Forms, co powoduje, że <xref:System.Diagnostics.EventLog.EntryWritten> metody obsługujące zdarzenie mają być wywoływane w tym samym wątku, w którym został utworzony składnik.  
  
 Jeśli jest używana wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w projektancie Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> <xref:System.Diagnostics.EventLog>jest automatycznie ustawiana na kontrolkę zawierającą. <xref:System.Diagnostics.EventLog> Na przykład jeśli umieścisz <xref:System.Diagnostics.EventLog> w projektancie dla formularza Form1 (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Właściwość <xref:System.Diagnostics.EventLog> jest ustawiona na wystąpienie formularza Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wpis w dzienniku zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <summary>Zapisuje wpis typu informacji z danym tekstem komunikatu w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisywania wpisu informacji w dzienniku zdarzeń skojarzonym z tym <xref:System.Diagnostics.EventLog> wystąpieniem. Jeśli chcesz określić inne <xref:System.Diagnostics.EventLogEntryType>, użyj innego <xref:System.Diagnostics.EventLog.WriteEntry%2A>przeciążenia.  
  
> [!NOTE]
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
 Aby można było pisać <xref:System.Diagnostics.EventLog.Source%2A> wpisy w dzienniku <xref:System.Diagnostics.EventLog> , należy ustawić właściwość w składniku. Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Source%2A> Źródło określone we właściwości tego <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowane na komputerze, na którym jest zapisywany składnik, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołuje <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródło.  
  
> [!NOTE]
>  Jeśli <xref:System.Diagnostics.EventLog.MachineName%2A> nie określisz <xref:System.Diagnostics.EventLog> dla wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, przyjęty jest komputer lokalny (".").  
  
 Jeśli system musi <xref:System.Diagnostics.EventLog.Source%2A> zarejestrować się przez wywołanie do <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona w danym <xref:System.Diagnostics.EventLog> wystąpieniu, domyślnie jest używany dziennik aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej jest generowanych przez błędy wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli wpis zostanie zapisany na komputerze zdalnym, wartość komunikatu (ciąg tekstowy) może nie być oczekiwany, jeśli na komputerze zdalnym nie uruchomiono .NET Framework.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` , jeśli jeszcze nie istnieje, i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość<see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda podjęła próbę zarejestrowania nowego źródła zdarzenia, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowa.  
  
—lub— 
Źródło jest już zarejestrowane dla innego dziennika zdarzeń.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <summary>Zapisuje w dzienniku zdarzeń błąd, ostrzeżenie, informacje, inspekcję sukcesów lub wpis inspekcji niepowodzenia z danym komunikatem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby napisać wpis określony <xref:System.Diagnostics.EventLogEntryType> w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika.  
  
> [!NOTE]
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
 Aby można było pisać <xref:System.Diagnostics.EventLog.Source%2A> wpisy w dzienniku <xref:System.Diagnostics.EventLog> , należy ustawić właściwość w składniku. Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Source%2A> Źródło określone we właściwości tego <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowane na komputerze, na którym jest zapisywany składnik, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołuje <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródło.  
  
> [!NOTE]
>  Jeśli <xref:System.Diagnostics.EventLog.MachineName%2A> nie określisz <xref:System.Diagnostics.EventLog> dla wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, przyjęty jest komputer lokalny (".").  
  
 Jeśli system musi <xref:System.Diagnostics.EventLog.Source%2A> zarejestrować się przez wywołanie do <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona w danym <xref:System.Diagnostics.EventLog> wystąpieniu, domyślnie jest używany dziennik aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej jest generowanych przez błędy wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli wpis zostanie zapisany na komputerze zdalnym, wartość komunikatu (ciąg tekstowy) może nie być oczekiwany, jeśli na komputerze zdalnym nie uruchomiono .NET Framework.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis ostrzegawczy w dzienniku zdarzeń "MyNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość<see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda podjęła próbę zarejestrowania nowego źródła zdarzenia, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowa.  
  
—lub— 
Źródło jest już zarejestrowane dla innego dziennika zdarzeń.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <summary>Zapisuje wpis typu informacji z danym komunikatem tekstowym do dziennika zdarzeń przy użyciu określonego zarejestrowanego źródła zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisywania wpisu informacji w dzienniku zdarzeń przy użyciu źródła, które jest już zarejestrowane jako źródło zdarzenia dla odpowiedniego dziennika. Jeśli chcesz określić inne <xref:System.Diagnostics.EventLogEntryType>, użyj innego <xref:System.Diagnostics.EventLog.WriteEntry%2A>przeciążenia.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
>   
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródło `MySource` , jeśli jeszcze nie istnieje, i zapisuje wpis w dzienniku `MyNewLog`zdarzeń.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
—lub— 
<paramref name="source" /> Wartość to<see langword="null" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator specyficzny dla aplikacji dla zdarzenia.</param>
        <summary>Zapisuje w dzienniku zdarzeń wpis z określonym tekstem komunikatu i identyfikatorem zdarzenia zdefiniowanym przez aplikację.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby napisać wpis z aplikacją zdefiniowaną `eventID` w dzienniku zdarzeń. `eventID` Razem ze źródłem jednoznacznie identyfikują zdarzenie. Każda aplikacja może definiować własne, numerowane zdarzenia oraz ciągi opisów, na których są mapowane. Osoby przeglądające zdarzenia wyświetlają te wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle i jakie akcje należy wykonać.  
  
> [!NOTE]
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
 Oprócz identyfikatora zdarzenia można określić <xref:System.Diagnostics.EventLogEntryType> dla zdarzenia zapisywanego w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia to błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Aby można było pisać <xref:System.Diagnostics.EventLog.Source%2A> wpisy w dzienniku <xref:System.Diagnostics.EventLog> , należy ustawić właściwość w składniku. Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Source%2A> Źródło określone we właściwości tego <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowane na komputerze, na którym jest zapisywany składnik, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołuje <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródło.  
  
> [!NOTE]
>  Jeśli <xref:System.Diagnostics.EventLog.MachineName%2A> nie określisz <xref:System.Diagnostics.EventLog> dla wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, przyjęty jest komputer lokalny (".").  
  
 Jeśli system musi <xref:System.Diagnostics.EventLog.Source%2A> zarejestrować się przez wywołanie do <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona w danym <xref:System.Diagnostics.EventLog> wystąpieniu, domyślnie jest używany dziennik aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej jest generowanych przez błędy wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli wpis zostanie zapisany na komputerze zdalnym, wartość komunikatu (ciąg tekstowy) może nie być oczekiwany, jeśli na komputerze zdalnym nie uruchomiono .NET Framework.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość<see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda podjęła próbę zarejestrowania nowego źródła zdarzenia, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowa.  
  
—lub— 
Źródło jest już zarejestrowane dla innego dziennika zdarzeń.  
  
—lub— 
 <paramref name="eventID" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <summary>Zapisuje w dzienniku zdarzeń błąd, ostrzeżenie, informacje, inspekcję sukcesów lub wpis inspekcji niepowodzeń z danym komunikatem dotyczącym określonego zarejestrowanego źródła zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby napisać wpis określonego <xref:System.Diagnostics.EventLogEntryType> do dziennika zdarzeń przy użyciu źródła już zarejestrowanego jako źródło zdarzenia dla odpowiedniego dziennika. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika.  
  
> [!NOTE]
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis ostrzegawczy w dzienniku zdarzeń "MyNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
—lub— 
<paramref name="source" /> Wartość to<see langword="null" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator specyficzny dla aplikacji dla zdarzenia.</param>
        <param name="category">Podkategoria specyficzna dla aplikacji skojarzona z wiadomością.</param>
        <summary>Zapisuje wpis z uwzględnieniem danego tekstu komunikatu, identyfikatora zdarzenia zdefiniowanego przez aplikację oraz kategorii zdefiniowanej przez aplikację w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby napisać wpis z aplikacją zdefiniowaną `category` w dzienniku zdarzeń. Podgląd zdarzeń używa kategorii do filtrowania zdarzeń utworzonych przez Źródło zdarzenia. Podgląd zdarzeń może wyświetlić kategorię jako wartość liczbową lub użyć kategorii jako identyfikatora zasobu, aby wyświetlić zlokalizowany ciąg kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Ujemne wartości kategorii są wyświetlane jako uzupełniająca liczba dodatnia w Podgląd zdarzeń. Na przykład wartość-10 pojawia się jako 65 526, a-1 jako 65 535.  
  
> [!NOTE]
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
 Aby wyświetlić zlokalizowane ciągi kategorii w Podgląd zdarzeń, należy użyć źródła zdarzenia skonfigurowanego z plikiem zasobów kategorii i ustawić `category` wartość na identyfikator zasobu w kategorii plik zasobów. Jeśli źródło zdarzenia nie ma skonfigurowanego pliku zasobów kategorii lub określony `category` nie indeksuje ciąg w pliku zasobów kategorii, wówczas Podgląd zdarzeń wyświetla wartość liczbową kategorii dla tego wpisu. Skonfiguruj plik zasobów kategorii wraz z liczbą ciągów kategorii w pliku zasobu, używając <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> lub klasy.  
  
 Oprócz kategorii można określić identyfikator zdarzenia dla zdarzenia zapisywanego w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz ze źródłem zdarzenia, jednoznacznie identyfikują zdarzenie. Każda aplikacja może definiować własne, numerowane zdarzenia oraz ciągi opisów, na których są mapowane. Osoby przeglądające zdarzenia wyświetlają te wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle i jakie akcje należy wykonać.  
  
 <xref:System.Diagnostics.EventLogEntryType> Na koniec można określić dla zdarzenia zapisywanego w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia to błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Aby można było pisać <xref:System.Diagnostics.EventLog.Source%2A> wpisy w dzienniku <xref:System.Diagnostics.EventLog> , należy ustawić właściwość w składniku. Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Source%2A> Źródło określone we właściwości tego <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowane na komputerze, na którym jest zapisywany składnik, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołuje <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródło.  
  
> [!NOTE]
>  Jeśli <xref:System.Diagnostics.EventLog.MachineName%2A> nie określisz <xref:System.Diagnostics.EventLog> dla wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, przyjęty jest komputer lokalny (".").  
  
 Jeśli system musi <xref:System.Diagnostics.EventLog.Source%2A> zarejestrować się przez wywołanie do <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona w danym <xref:System.Diagnostics.EventLog> wystąpieniu, domyślnie jest używany dziennik aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej jest generowanych przez błędy wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli wpis zostanie zapisany na komputerze zdalnym, wartość komunikatu (ciąg tekstowy) może nie być oczekiwany, jeśli na komputerze zdalnym nie uruchomiono .NET Framework.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość<see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda podjęła próbę zarejestrowania nowego źródła zdarzenia, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowa.  
  
—lub— 
Źródło jest już zarejestrowane dla innego dziennika zdarzeń.  
  
—lub— 
 <paramref name="eventID" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator specyficzny dla aplikacji dla zdarzenia.</param>
        <summary>Zapisuje wpis z uwzględnieniem danego tekstu komunikatu i identyfikatora zdarzenia zdefiniowanego przez aplikację w dzienniku zdarzeń przy użyciu określonego zarejestrowanego źródła zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby napisać wpis z aplikacją zdefiniowaną `eventID` w dzienniku zdarzeń przy użyciu źródła już zarejestrowanego jako źródło zdarzenia dla odpowiedniego dziennika. `eventID`, Wraz ze źródłem, jednoznacznie Identyfikuj zdarzenie. Każda aplikacja może definiować własne, numerowane zdarzenia oraz ciągi opisów, na których są mapowane. Osoby przeglądające zdarzenia przedstawią te ciągi użytkownikowi, aby pomóc użytkownikowi zrozumieć, co poszło źle, i sugestię działania, które należy podjąć.  
  
> [!NOTE]
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
 Oprócz identyfikatora zdarzenia to Przeciążenie <xref:System.Diagnostics.EventLog.WriteEntry%2A> pozwala <xref:System.Diagnostics.EventLogEntryType> określić dla zdarzenia zapisywanego w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia to błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
—lub— 
<paramref name="source" /> Wartość to<see langword="null" />.  
  
—lub— 
 <paramref name="eventID" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator specyficzny dla aplikacji dla zdarzenia.</param>
        <param name="category">Podkategoria specyficzna dla aplikacji skojarzona z wiadomością.</param>
        <param name="rawData">Tablica bajtów, która przechowuje dane binarne skojarzone z wpisem.</param>
        <summary>Zapisuje wpis z uwzględnieniem danego tekstu komunikatu, identyfikatora zdarzenia zdefiniowanego przez aplikację oraz kategorii zdefiniowanej przez aplikację w dzienniku zdarzeń i dołącza dane binarne do komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby zapisać dane specyficzne dla określonego zdarzenia w dzienniku zdarzeń. Podgląd zdarzeń nie interpretuje tych danych; dane pierwotne są wyświetlane tylko w połączonym formacie szesnastkowym i tekstowym. Używaj danych specyficznych dla zdarzeń, w tym tylko wtedy, gdy masz pewność, że będzie ona przydatna do debugowania problemu. Dane specyficzne dla zdarzenia mogą być również używane do przechowywania informacji, które aplikacja może przetwarzać niezależnie od Podgląd zdarzeń. Można na przykład napisać Podgląd przeznaczony dla zdarzeń lub napisać program, który skanuje plik dziennika i tworzy raporty zawierające informacje z danych specyficznych dla zdarzenia.  
  
 Oprócz danych binarnych można określić kategorię zdefiniowaną przez aplikację i identyfikator zdarzenia zdefiniowanego przez aplikację. Podgląd zdarzeń używa kategorii do filtrowania zdarzeń utworzonych przez Źródło zdarzenia. Podgląd zdarzeń może wyświetlić kategorię jako wartość liczbową lub użyć kategorii jako identyfikatora zasobu, aby wyświetlić zlokalizowany ciąg kategorii.  
  
> [!NOTE]
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Ujemne wartości kategorii są wyświetlane jako uzupełniająca liczba dodatnia w Podgląd zdarzeń. Na przykład wartość-10 pojawia się jako 65 526, a-1 jako 65 535.  
  
 Aby wyświetlić zlokalizowane ciągi kategorii w Podgląd zdarzeń, należy użyć źródła zdarzenia skonfigurowanego z plikiem zasobów kategorii i ustawić `category` wartość na identyfikator zasobu w kategorii plik zasobów. Jeśli źródło zdarzenia nie ma skonfigurowanego pliku zasobów kategorii lub określony `category` nie indeksuje ciąg w pliku zasobów kategorii, wówczas Podgląd zdarzeń wyświetla wartość liczbową kategorii dla tego wpisu. Skonfiguruj plik zasobów kategorii wraz z liczbą ciągów kategorii w pliku zasobu, używając <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> lub klasy.  
  
 Identyfikatory zdarzeń, wraz ze źródłem zdarzenia, jednoznacznie identyfikują zdarzenie. Każda aplikacja może definiować własne, numerowane zdarzenia oraz ciągi opisów, na których są mapowane. Osoby przeglądające zdarzenia wyświetlają te wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle i jakie akcje należy wykonać.  
  
 <xref:System.Diagnostics.EventLogEntryType> Na koniec można określić dla zdarzenia zapisywanego w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia to błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Aby można było pisać <xref:System.Diagnostics.EventLog.Source%2A> wpisy w dzienniku <xref:System.Diagnostics.EventLog> , należy ustawić właściwość w składniku. Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia.  
  
 Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Source%2A> Źródło określone we właściwości tego <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowane na komputerze, na którym jest zapisywany składnik, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołuje <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródło.  
  
> [!NOTE]
>  Jeśli <xref:System.Diagnostics.EventLog.MachineName%2A> nie określisz <xref:System.Diagnostics.EventLog> dla wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, przyjęty jest komputer lokalny (".").  
  
 Jeśli system musi <xref:System.Diagnostics.EventLog.Source%2A> zarejestrować się przez wywołanie do <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwość nie została ustawiona w danym <xref:System.Diagnostics.EventLog> wystąpieniu, domyślnie jest używany dziennik aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej jest generowanych przez błędy wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli wpis zostanie zapisany na komputerze zdalnym, wartość komunikatu (ciąg tekstowy) może nie być oczekiwany, jeśli na komputerze zdalnym nie uruchomiono .NET Framework.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość<see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda podjęła próbę zarejestrowania nowego źródła zdarzenia, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowa.  
  
—lub— 
Źródło jest już zarejestrowane dla innego dziennika zdarzeń.  
  
—lub— 
 <paramref name="eventID" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator specyficzny dla aplikacji dla zdarzenia.</param>
        <param name="category">Podkategoria specyficzna dla aplikacji skojarzona z wiadomością.</param>
        <summary>Zapisuje w dzienniku zdarzeń wpis zawierający tekst komunikatu, identyfikator zdarzenia zdefiniowany przez aplikację oraz kategorię zdefiniowaną przez aplikację, korzystając z określonego zarejestrowanego źródła zdarzenia. <paramref name="category" /> Może być używany przez Podgląd zdarzeń do filtrowania zdarzeń w dzienniku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby napisać wpis z aplikacją zdefiniowaną `category` w dzienniku zdarzeń przy użyciu źródła, które jest już zarejestrowane jako źródło zdarzenia dla odpowiedniego dziennika. Podgląd zdarzeń używa kategorii do filtrowania zdarzeń utworzonych przez Źródło zdarzenia. Podgląd zdarzeń może wyświetlić kategorię jako wartość liczbową lub użyć kategorii jako identyfikatora zasobu, aby wyświetlić zlokalizowany ciąg kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Ujemne wartości kategorii są wyświetlane jako uzupełniająca liczba dodatnia w Podgląd zdarzeń. Na przykład wartość-10 pojawia się jako 65 526, a-1 jako 65 535.  
  
 Aby wyświetlić zlokalizowane ciągi kategorii w Podgląd zdarzeń, należy użyć źródła zdarzenia skonfigurowanego z plikiem zasobów kategorii i ustawić `category` wartość na identyfikator zasobu w kategorii plik zasobów. Jeśli źródło zdarzenia nie ma skonfigurowanego pliku zasobów kategorii lub określony `category` nie indeksuje ciąg w pliku zasobów kategorii, wówczas Podgląd zdarzeń wyświetla wartość liczbową kategorii dla tego wpisu. Skonfiguruj plik zasobów kategorii wraz z liczbą ciągów kategorii w pliku zasobu, używając <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> lub klasy.  
  
 Oprócz kategorii można określić identyfikator zdarzenia dla zdarzenia zapisywanego w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz ze źródłem zdarzenia, jednoznacznie identyfikują zdarzenie. Każda aplikacja może definiować własne, numerowane zdarzenia oraz ciągi opisów, na których są mapowane. Osoby przeglądające zdarzenia wyświetlają te wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle i jakie akcje należy wykonać.  
  
 <xref:System.Diagnostics.EventLogEntryType> Na koniec można określić dla zdarzenia zapisywanego w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia to błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
>   
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
—lub— 
<paramref name="source" /> Wartość to<see langword="null" />.  
  
—lub— 
 <paramref name="eventID" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedna z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator specyficzny dla aplikacji dla zdarzenia.</param>
        <param name="category">Podkategoria specyficzna dla aplikacji skojarzona z wiadomością.</param>
        <param name="rawData">Tablica bajtów, która przechowuje dane binarne skojarzone z wpisem.</param>
        <summary>Zapisuje w dzienniku zdarzeń wpis z określonym tekstem komunikatu, identyfikatorem zdarzenia zdefiniowanym przez aplikację i kategorią zdefiniowaną przez aplikację (przy użyciu określonego zarejestrowanego źródła zdarzenia) i dołącza dane binarne do komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisywania danych specyficznych dla określonego zdarzenia w dzienniku zdarzeń przy użyciu źródła już zarejestrowanego jako źródło zdarzenia dla odpowiedniego dziennika. Podgląd zdarzeń nie interpretuje tych danych; dane pierwotne są wyświetlane tylko w połączonym formacie szesnastkowym i tekstowym. Używaj danych specyficznych dla zdarzeń; Uwzględnij ją tylko wtedy, gdy masz pewność, że będzie ona przydatna. Dane specyficzne dla zdarzenia mogą być również używane do przechowywania informacji, które aplikacja może przetwarzać niezależnie od Podgląd zdarzeń. Można na przykład napisać Podgląd przeznaczony dla zdarzeń lub napisać program, który skanuje plik dziennika i tworzy raporty zawierające informacje z danych specyficznych dla zdarzenia.  
  
 Oprócz danych binarnych można określić kategorię zdefiniowaną przez aplikację i identyfikator zdarzenia zdefiniowanego przez aplikację. Podgląd zdarzeń używa kategorii do filtrowania zdarzeń utworzonych przez Źródło zdarzenia. Podgląd zdarzeń może wyświetlić kategorię jako wartość liczbową lub użyć kategorii jako identyfikatora zasobu, aby wyświetlić zlokalizowany ciąg kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Ujemne wartości kategorii są wyświetlane jako uzupełniająca liczba dodatnia w Podgląd zdarzeń. Na przykład wartość-10 będzie wyświetlana jako 65 526, a-1 jako 65 535.  
  
 Aby wyświetlić zlokalizowane ciągi kategorii w Podgląd zdarzeń, należy użyć źródła zdarzenia skonfigurowanego z plikiem zasobów kategorii i ustawić `category` wartość na identyfikator zasobu w kategorii plik zasobów. Jeśli źródło zdarzenia nie ma skonfigurowanego pliku zasobów kategorii lub określony `category` nie indeksuje ciąg w pliku zasobów kategorii, wówczas Podgląd zdarzeń wyświetla wartość liczbową kategorii dla tego wpisu. Skonfiguruj plik zasobów kategorii wraz z liczbą ciągów kategorii w pliku zasobu, używając <xref:System.Diagnostics.EventLogInstaller> <xref:System.Diagnostics.EventSourceCreationData> lub klasy.  
  
 Identyfikatory zdarzeń, wraz ze źródłem zdarzenia, jednoznacznie identyfikują zdarzenie. Każda aplikacja może definiować własne, numerowane zdarzenia oraz ciągi opisów, na których są mapowane. Osoby przeglądające zdarzenia wyświetlają te wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle i jakie akcje należy wykonać.  
  
 <xref:System.Diagnostics.EventLogEntryType> Na koniec można określić dla zdarzenia zapisywanego w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podgląd zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia to błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje dany ciąg bezpośrednio w dzienniku zdarzeń; nie używa lokalizowalnego pliku zasobów komunikatów. <xref:System.Diagnostics.EventLog.WriteEvent%2A> Użyj metody do zapisywania zdarzeń przy użyciu zlokalizowanego pliku zasobów komunikatów.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  `message` Jeśli parametr zawiera znak NUL, komunikat w dzienniku zdarzeń jest zakończony znakiem NUL.  
>   
>  Ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
—lub— 
<paramref name="source" /> Wartość to<see langword="null" />.  
  
—lub— 
 <paramref name="eventID" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
Ciąg komunikatu jest dłuższy niż 31 839 bajtów (32 766 bajtów w systemach operacyjnych Windows przed Windows Vista).  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" />jest nieprawidłowy <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zlokalizowany wpis zdarzenia w dzienniku zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie, które reprezentuje zlokalizowany wpis dziennika zdarzeń.</param>
        <param name="values">Tablica ciągów do scalenia z tekstem komunikatu wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje zlokalizowany wpis w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby zapisać zlokalizowany wpis w dzienniku zdarzeń. Należy określić właściwości zdarzenia przy użyciu identyfikatorów zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatorów zasobów do wyświetlania odpowiednich ciągów z zlokalizowanego pliku zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>. Przed zapisaniem zdarzeń przy użyciu identyfikatorów zasobów należy zarejestrować źródło z odpowiednim plikiem zasobów.  
  
 Wystąpienie danych `instance` wejściowych określa komunikat i właściwości zdarzenia. <xref:System.Diagnostics.EventInstance.InstanceId%2A>Ustawwartość wejściowądlazdefiniowanegokomunikatuwpliku`instance` zasobów wiadomości źródłowej. Opcjonalnie można ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> parametr i <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` , aby określić kategorię i typ zdarzenia wpisu zdarzenia. Możesz również określić tablicę ciągów niezależnych od języka, aby wstawić do zlokalizowanego tekstu komunikatu. Ustaw `values` na`null` , jeśli komunikat o zdarzeniu nie zawiera symboli zastępczych formatowania dla ciągów zastąpień.  
  
 Przed użyciem <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog> należy ustawićwłaściwośćskładnika.<xref:System.Diagnostics.EventLog.WriteEvent%2A> Określone źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów w dzienniku; Źródło musi mieć co najmniej zdefiniowany plik zasobów komunikatów.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Użyj metody <xref:System.Diagnostics.EventLog.WriteEntry%2A> , jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  W przypadku zapisania wpisu na komputerze zdalnym wartość `message` tego ciągu może nie być oczekiwana, jeśli na komputerze zdalnym nie uruchomiono .NET Framework. Ponadto ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład zapisuje dwa wpisy inspekcji w dzienniku `myNewLog`zdarzeń. Przykład tworzy nowe źródło zdarzeń i nowy dziennik zdarzeń, jeśli nie istnieją na komputerze lokalnym. Tekst komunikatu o zdarzeniu jest określany przy użyciu identyfikatora zasobu w pliku zasobów.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 W przykładzie zastosowano następujący plik tekstowy komunikatu, wbudowany w bibliotekę zasobów EventLogMsgs. dll. Plik tekstowy komunikatu jest źródłem, z którego tworzony jest plik zasobów wiadomości. Plik tekstowy komunikatu określa identyfikatory zasobów i tekst dla kategorii, komunikat zdarzenia i ciągi wstawiania parametrów.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość<see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda podjęła próbę zarejestrowania nowego źródła zdarzenia, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowa.  
  
—lub— 
Źródło jest już zarejestrowane dla innego dziennika zdarzeń.  
  
—lub— 
 <paramref name="instance.InstanceId" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
 <paramref name="values" />ma więcej niż 256 elementów.  
  
—lub— 
Jeden z <paramref name="values" /> elementów jest dłuższy niż 32766 bajtów.  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie, które reprezentuje zlokalizowany wpis dziennika zdarzeń.</param>
        <param name="data">Tablica bajtów, która przechowuje dane binarne skojarzone z wpisem.</param>
        <param name="values">Tablica ciągów do scalenia z tekstem komunikatu wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje wpis dziennika zdarzeń z danymi zdarzenia, ciągami zastępującymi komunikaty i skojarzonymi danymi binarnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby zapisać zlokalizowany wpis z dodatkowymi danymi specyficznymi dla zdarzenia w dzienniku zdarzeń. Należy określić właściwości zdarzenia przy użyciu identyfikatorów zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatorów zasobów do wyświetlania odpowiednich ciągów z zlokalizowanego pliku zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>. Przed zapisaniem zdarzeń przy użyciu identyfikatorów zasobów należy zarejestrować źródło z odpowiednim plikiem zasobów.  
  
 Wystąpienie danych `instance` wejściowych określa komunikat i właściwości zdarzenia. <xref:System.Diagnostics.EventInstance.InstanceId%2A>Ustawwartość wejściowądlazdefiniowanegokomunikatuwpliku`instance` zasobów wiadomości źródłowej. Opcjonalnie można ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> parametr i <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` , aby określić kategorię i typ zdarzenia wpisu zdarzenia. Możesz również określić tablicę ciągów niezależnych od języka, aby wstawić do zlokalizowanego tekstu komunikatu. Ustaw `values` na`null` , jeśli komunikat o zdarzeniu nie zawiera symboli zastępczych formatowania dla ciągów zastąpień.  
  
 Określ dane binarne ze zdarzeniem, gdy konieczne jest podanie dodatkowych informacji o zdarzeniu. Na przykład użyj `data` parametru, aby dołączyć informacje dotyczące konkretnego błędu. Podgląd zdarzeń nie interpretuje skojarzonych danych zdarzeń; Wyświetla dane w połączonym formacie szesnastkowym i tekstowym. Używaj danych specyficznych dla zdarzeń; Uwzględnij ją tylko wtedy, gdy masz pewność, że będzie ona przydatna. Dane specyficzne dla zdarzenia mogą być również używane do przechowywania informacji, które aplikacja może przetwarzać niezależnie od Podgląd zdarzeń. Można na przykład napisać Podgląd przeznaczony dla zdarzeń lub napisać program, który skanuje dziennik zdarzeń i tworzy raporty zawierające informacje z danych specyficznych dla zdarzenia.  
  
 Przed użyciem <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog> składnikanależyustawićwłaściwość<xref:System.Diagnostics.EventLog.WriteEvent%2A>składnika przed nim. Określone źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów w dzienniku; Źródło musi mieć co najmniej zdefiniowany plik zasobów komunikatów.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog> dla wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEvent%2A>, zostanie przyjęty komputer lokalny (".").  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Użyj metody <xref:System.Diagnostics.EventLog.WriteEntry%2A> , jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  W przypadku zapisania wpisu na komputerze zdalnym wartość `message` tego ciągu może nie być oczekiwana, jeśli na komputerze zdalnym nie uruchomiono .NET Framework. Ponadto ciąg nie może zawierać znaku%*n*, gdzie n jest wartością całkowitą (na przykład% 1), ponieważ Podgląd zdarzeń traktuje ją jako ciąg wstawiania. ** `message` Ponieważ protokół internetowy, w wersji 6 (IPv6) może zawierać tę sekwencję znaków, nie można rejestrować komunikatu o zdarzeniu zawierającego adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład zapisuje dwa wpisy inspekcji w dzienniku `myNewLog`zdarzeń. Przykład tworzy nowe źródło zdarzeń i nowy dziennik zdarzeń, jeśli nie istnieją na komputerze lokalnym. Tekst komunikatu o zdarzeniu jest określany przy użyciu identyfikatora zasobu w pliku zasobów.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 W przykładzie zastosowano następujący plik tekstowy komunikatu, wbudowany w bibliotekę zasobów EventLogMsgs. dll. Plik tekstowy komunikatu jest źródłem, z którego tworzony jest plik zasobów wiadomości. Plik tekstowy komunikatu określa identyfikatory zasobów i tekst dla kategorii, komunikat zdarzenia i ciągi wstawiania parametrów.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość<see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda podjęła próbę zarejestrowania nowego źródła zdarzenia, ale nazwa komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowa.  
  
—lub— 
Źródło jest już zarejestrowane dla innego dziennika zdarzeń.  
  
—lub— 
 <paramref name="instance.InstanceId" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
 <paramref name="values" />ma więcej niż 256 elementów.  
  
—lub— 
Jeden z <paramref name="values" /> elementów jest dłuższy niż 32766 bajtów.  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia zarejestrowanego dla aplikacji na określonym komputerze.</param>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie, które reprezentuje zlokalizowany wpis dziennika zdarzeń.</param>
        <param name="values">Tablica ciągów do scalenia z tekstem komunikatu wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje wpis dziennika zdarzeń z danymi zdarzeń i ciągami zastępczymi komunikatów przy użyciu określonego zarejestrowanego źródła zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby zapisać zlokalizowany wpis w dzienniku zdarzeń przy użyciu źródła już zarejestrowanego jako źródło zdarzenia dla odpowiedniego dziennika. Należy określić właściwości zdarzenia przy użyciu identyfikatorów zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatorów zasobów do wyświetlania odpowiednich ciągów z zlokalizowanego pliku zasobów dla źródła. Przed zapisaniem zdarzeń przy użyciu identyfikatorów zasobów należy zarejestrować źródło z odpowiednim plikiem zasobów.  
  
 Wystąpienie danych `instance` wejściowych określa komunikat i właściwości zdarzenia. <xref:System.Diagnostics.EventInstance.InstanceId%2A>Ustawwartość wejściowądlazdefiniowanegokomunikatuwpliku`instance` zasobów wiadomości źródłowej. Opcjonalnie można ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> parametr i <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` , aby określić kategorię i typ zdarzenia wpisu zdarzenia. Możesz również określić tablicę ciągów niezależnych od języka, aby wstawić do zlokalizowanego tekstu komunikatu. Ustaw `values` na`null` , jeśli komunikat o zdarzeniu nie zawiera symboli zastępczych formatowania dla ciągów zastąpień.  
  
 Określone źródło musi być zarejestrowane dla dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określone źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów w dzienniku; Źródło musi mieć co najmniej zdefiniowany plik zasobów komunikatów.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Użyj metody <xref:System.Diagnostics.EventLog.WriteEntry%2A> , jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
   
  
## Examples  
 Poniższy przykład zapisuje informacje o wpisie i wpisie zdarzenia ostrzegawczego w istniejącym dzienniku zdarzeń. Tekst komunikatu o zdarzeniu jest określany przy użyciu identyfikatora zasobu w pliku zasobów. W przykładzie przyjęto założenie, że odpowiedni plik zasobów został zarejestrowany dla źródła.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 W przykładzie zastosowano następujący plik tekstowy komunikatu, wbudowany w bibliotekę zasobów EventLogMsgs. dll. Plik tekstowy komunikatu jest źródłem, z którego tworzony jest plik zasobów wiadomości. Plik tekstowy komunikatu określa identyfikatory zasobów i tekst dla kategorii, komunikat zdarzenia i ciągi wstawiania parametrów.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
—lub— 
<paramref name="source" /> Wartość to<see langword="null" />.  
  
—lub— 
 <paramref name="instance.InstanceId" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
 <paramref name="values" />ma więcej niż 256 elementów.  
  
—lub— 
Jeden z <paramref name="values" /> elementów jest dłuższy niż 32766 bajtów.  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzenia zarejestrowanego dla aplikacji na określonym komputerze.</param>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> Wystąpienie, które reprezentuje zlokalizowany wpis dziennika zdarzeń.</param>
        <param name="data">Tablica bajtów, która przechowuje dane binarne skojarzone z wpisem.</param>
        <param name="values">Tablica ciągów do scalenia z tekstem komunikatu wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje wpis dziennika zdarzeń z danymi zdarzenia, ciągami zastępującymi komunikaty i skojarzonymi danymi binarnymi oraz z określonym zarejestrowanym źródłem zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby zapisać zlokalizowany wpis z dodatkowymi danymi specyficznymi dla zdarzenia w dzienniku zdarzeń przy użyciu źródła już zarejestrowanego jako źródło zdarzenia dla odpowiedniego dziennika. Należy określić właściwości zdarzenia przy użyciu identyfikatorów zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatorów zasobów do wyświetlania odpowiednich ciągów z zlokalizowanego pliku zasobów dla źródła. Przed zapisaniem zdarzeń przy użyciu identyfikatorów zasobów należy zarejestrować źródło z odpowiednim plikiem zasobów.  
  
 Wystąpienie danych `instance` wejściowych określa komunikat i właściwości zdarzenia. <xref:System.Diagnostics.EventInstance.InstanceId%2A>Ustawwartość wejściowądlazdefiniowanegokomunikatuwpliku`instance` zasobów wiadomości źródłowej. Opcjonalnie można ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> parametr i <xref:System.Diagnostics.EventInstance.EntryType%2A> `instance` , aby określić kategorię i typ zdarzenia wpisu zdarzenia. Możesz również określić tablicę ciągów niezależnych od języka, aby wstawić do zlokalizowanego tekstu komunikatu. Ustaw `values` na`null` , jeśli komunikat o zdarzeniu nie zawiera symboli zastępczych formatowania dla ciągów zastąpień.  
  
 Określ dane binarne ze zdarzeniem, gdy konieczne jest podanie dodatkowych informacji o zdarzeniu. Na przykład użyj `data` parametru, aby dołączyć informacje dotyczące konkretnego błędu. Podgląd zdarzeń nie interpretuje skojarzonych danych zdarzeń; Wyświetla dane w połączonym formacie szesnastkowym i tekstowym. Używaj danych specyficznych dla zdarzeń; Uwzględnij ją tylko wtedy, gdy masz pewność, że będzie ona przydatna. Dane specyficzne dla zdarzenia mogą być również używane do przechowywania informacji, które aplikacja może przetwarzać niezależnie od Podgląd zdarzeń. Można na przykład napisać Podgląd przeznaczony dla zdarzeń lub napisać program, który skanuje dziennik zdarzeń i tworzy raporty zawierające informacje z danych specyficznych dla zdarzenia.  
  
 Określone źródło musi być zarejestrowane dla dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określone źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów w dzienniku; Źródło musi mieć co najmniej zdefiniowany plik zasobów komunikatów.  
  
 Przed zapisaniem pierwszego wpisu ze źródłem należy utworzyć i skonfigurować źródło zdarzenia. Utwórz nowe źródło zdarzenia podczas instalacji aplikacji. Pozwala to czas na odświeżenie listy zarejestrowanych źródeł zdarzeń i ich konfiguracji przez system operacyjny. Jeśli system operacyjny nie odświeżył swojej listy źródeł zdarzeń i podjęto próbę zapisania zdarzenia z nowym źródłem, operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować przy użyciu <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> przy użyciu metody. Aby utworzyć nowe źródło zdarzeń, musisz mieć uprawnienia administracyjne na komputerze.  
  
 Źródło musi być skonfigurowane do zapisywania zlokalizowanych wpisów lub do pisania ciągów bezpośrednich. Użyj metody <xref:System.Diagnostics.EventLog.WriteEntry%2A> , jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisy przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągów, należy zarejestrować dwa oddzielne źródła. Na przykład Skonfiguruj jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodzie do zapisu wpisów przy użyciu identyfikatorów zasobów do dziennika zdarzeń. Następnie utwórz inne źródło bez plików zasobów i Użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodzie, aby pisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
   
  
## Examples  
 Poniższy przykład zapisuje informacje o wpisie i wpisie zdarzenia ostrzegawczego w istniejącym dzienniku zdarzeń. Tekst komunikatu o zdarzeniu jest określany przy użyciu identyfikatora zasobu w pliku zasobów. W przykładzie przyjęto założenie, że odpowiedni plik zasobów został zarejestrowany dla źródła.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 W przykładzie zastosowano następujący plik tekstowy komunikatu, wbudowany w bibliotekę zasobów EventLogMsgs. dll. Plik tekstowy komunikatu jest źródłem, z którego tworzony jest plik zasobów wiadomości. Plik tekstowy komunikatu określa identyfikatory zasobów i tekst dla kategorii, komunikat zdarzenia i ciągi wstawiania parametrów.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> Wartość jest pustym ciągiem ("").  
  
—lub— 
<paramref name="source" /> Wartość to<see langword="null" />.  
  
—lub— 
 <paramref name="instance.InstanceId" />jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
—lub— 
 <paramref name="values" />ma więcej niż 256 elementów.  
  
—lub— 
Jeden z <paramref name="values" /> elementów jest dłuższy niż 32766 bajtów.  
  
—lub— 
Nazwa źródła powoduje, że ścieżka klucza rejestru jest dłuższa niż 254 znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows jest niedostępny.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Skojarzone Wyliczenie:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e712e8166b046143e8f3fa5b8d098b53b92e8bb7" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48673051" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia interakcję z dzienników zdarzeń Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> Umożliwia dostęp lub dostosować Windows dzienniki zdarzeń, które rejestruje informacje o ważnych zdarzeniach oprogramowania lub sprzętu. Za pomocą <xref:System.Diagnostics.EventLog>, można odczytać z istniejących dzienników, zapisywania wpisów dzienników, tworzenie lub usunąć źródła zdarzeń, usunąć dzienniki i reagować na pozycje dziennika. Można również utworzyć nowe dzienniki podczas tworzenia źródła zdarzenia.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
 Oprócz zapewniania dostępu do poszczególnych dzienniki zdarzeń i ich wpisów <xref:System.Diagnostics.EventLog> klasy pozwala uzyskiwać dostęp do kolekcji wszystkie dzienniki zdarzeń. Możesz użyć `static` członkowie <xref:System.Diagnostics.EventLog> można usunąć dzienniki, Pobierz dziennik listy, utworzyć lub usunąć źródła lub ustal, czy komputer ma już zawiera określonego źródła.  
  
 Istnieją trzy dzienniki zdarzeń domyślne: aplikacji, System i zabezpieczenia. Dziennika zabezpieczeń jest tylko do odczytu. Inne aplikacje i usługi, zainstalowane przez użytkownika, takie jak Active Directory mogą mieć dodatkowe dzienniki zdarzeń.  
  
 Istnieją pewne zagadnienia dotyczące zabezpieczeń przy użyciu <xref:System.Diagnostics.EventLog> klasy. <xref:System.Diagnostics.EventLog> wymaga <xref:System.Diagnostics.EventLogPermission> uprawnienia dla określonych akcji w .NET Framework 2.0 i nowszych wersjach lub pełnego zaufania w programie .NET Framework 1.0 i 1.1. Zaleca się <xref:System.Diagnostics.EventLogPermission> nie udziela się częściowo zaufanego kodu.  Nigdy nie należy przekazywać dowolnego obiektu dziennika zdarzeń, w tym <xref:System.Diagnostics.EventLogEntryCollection> i <xref:System.Diagnostics.EventLogEntry> obiektów do mniej zaufanego kodu. Na przykład tworzenia <xref:System.Diagnostics.EventLog> obiektu zapisywania wpisu i następnie przekazywanie <xref:System.Diagnostics.EventLog> obiektu częściowo zaufanego kodu można utworzyć problem z zabezpieczeniami, ponieważ możliwość odczytu i zapisu w dzienniku zdarzeń pozwala na kod, aby wykonać akcje, takie jak Generowanie komunikaty dziennika zdarzeń nazwę innej aplikacji.  
  
 Począwszy od Windows Vista, Kontrola konta użytkownika (UAC) Określa poświadczenia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Aby uruchomić kod, który uzyskuje dostęp do dziennika zabezpieczeń, musisz najpierw podwyższenie swoje poświadczenia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, otwierając menu skrótów dla aplikacji (Jeśli używasz myszy, kliknij prawym przyciskiem myszy ikonę aplikacji) i wskazuje, że użytkownik chce uruchomić jako administrator.  
  
 Możesz użyć <xref:System.Diagnostics.EventLog> do tworzenia niestandardowych dzienników zdarzeń, które można wyświetlić za pośrednictwem serwera w Podglądzie zdarzeń. Użyj <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> metodę w celu wyświetlenia zlokalizowana nazwa dziennika zdarzeń w Podglądzie zdarzeń. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> metodę, aby skonfigurować działanie usługi dziennika zdarzeń, po osiągnięciu jej maksymalny rozmiar dziennika.  
  
 Aby zapoznać się z dziennika zdarzeń, należy określić nazwę dziennika (<xref:System.Diagnostics.EventLog.Log%2A> właściwości) i nazwę komputera serwera (<xref:System.Diagnostics.EventLog.MachineName%2A> właściwości w dzienniku zdarzeń. Jeśli nie określisz nazwę komputera serwera, komputer lokalny, ".", zakłada, że. Nie jest konieczne określanie źródła zdarzeń (<xref:System.Diagnostics.EventLog.Source%2A> właściwości), ponieważ źródłem jest wymagany tylko w przypadku zapisywania dzienników. <xref:System.Diagnostics.EventLog.Entries%2A> Właściwość zostanie automatycznie wypełniona lista wpisów w dzienniku zdarzeń.  
  
 Można zapisać do dziennika zdarzeń, należy określić lub tworzenie źródła zdarzeń (<xref:System.Diagnostics.EventLog.Source%2A> właściwości). Musi mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń. Źródło zdarzenia rejestruje aplikację z dziennika zdarzeń jako poprawne źródło wpisów. Źródło zdarzeń służy do zapisania w dzienniku tylko jedno w danym momencie. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość może być dowolnym ciągiem losowych, ale nazwa musi się różnić od innych źródeł na tym komputerze. Źródła zdarzeń zwykle jest nazwą aplikacji lub inny ciąg identyfikujący. Próbujesz utworzyć duplikat <xref:System.Diagnostics.EventLog.Source%2A> wartość zgłasza wyjątek. Jednak pojedynczy dziennik zdarzeń może być skojarzony z wielu źródeł.  
  
 Jeśli źródło zdarzenia w dzienniku zdarzeń skojarzonych z <xref:System.Diagnostics.EventLog> wystąpienie nie istnieje, jest tworzone nowe źródło zdarzeń. Aby utworzyć źródła zdarzeń w Windows Vista lub nowszym lub Windows Server 2003, musisz mieć poświadczenia administracyjne.  
  
 To wymaganie jest, ponieważ wszystkie dzienniki zdarzeń, w tym dzienniki zabezpieczeń musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> zgłaszany.  
  
> [!IMPORTANT]
>  Tworzenie lub usuwanie źródła zdarzeń wymaga synchronizacji podstawowy kod przy użyciu nazwanego obiektu mutex. W przypadku aplikacji o wysokim poziomie uprawnień blokady o nazwie obiektu mutex, próbuje utworzyć lub usunąć źródła zdarzeń powoduje, że aplikacja przestanie odpowiadać, dopóki blokada jest zwalniana. Aby uniknąć tego problemu, nigdy nie przyznać <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnienia do niezaufanego kodu. Ponadto <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> uprawnień potencjalnie umożliwia innych uprawnień, aby pominąć i może być przyznany wyłącznie do wysoce zaufanym kodem.  
  
 Aplikacje i usługi należy zapisać w dzienniku aplikacji lub dziennik niestandardowy. Sterowniki urządzeń należy zapisać w dzienniku systemu. Jeśli nie zostanie jawnie ustawiona <xref:System.Diagnostics.EventLog.Log%2A> właściwość, jest domyślnie ustawiona w dzienniku zdarzeń w dzienniku aplikacji.  
  
> [!NOTE]
>  Nie ma nic do ochronę aplikacji przed zapisywania jako dowolnego zarejestrowanego źródła.  Gdy aplikacja uzyska <xref:System.Diagnostics.EventLogPermissionAccess.Write> uprawnienie, może ono zapisać zdarzenia dla dowolnego prawidłowego źródła zarejestrowane na komputerze.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> metody, aby zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia można zapisać zdarzenia; należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżyć listy źródeł zdarzeń, a podczas próby zapisu zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować za pomocą <xref:System.Diagnostics.EventLogInstaller> obiektu lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Każde źródło może zapisywać tylko jeden dziennik zdarzeń jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników. Na przykład aplikacja może wymagać wielu źródeł, skonfigurowanych dla różnych dziennikach zdarzeń lub plików innego zasobu. Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Jeśli używasz istniejącego źródła, inne aplikacje lub składniki, Utwórz nowe źródło z zaktualizowaną konfiguracją zamiast usuwać istniejące źródło.  
  
 Za zarejestrowanie źródła zdarzeń i zlokalizowane zasoby dla ciągów kategorii i komunikat zdarzenia. Aplikację można napisać wpisy dziennika zdarzeń przy użyciu identyfikatorów zasobów zamiast określania wartości ciągu. Zapoznaj się <xref:System.Diagnostics.EventLogInstaller> i <xref:System.Diagnostics.EventSourceCreationData> klasy, aby uzyskać więcej informacji o konfigurowaniu źródła z plikami zasobów.  
  
 Aplikacja zapisuje wartości ciągu bezpośrednio do dziennika zdarzeń, nie trzeba ustawić zasobu właściwości pliku źródłowego. Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Podczas zapisywania zdarzenia, co najmniej należy określić ciąg komunikatu lub identyfikator zasobu ciągu wiadomości. Inne właściwości zdarzenia są opcjonalne. Następujące przykładowe ustawienia opcjonalne zdarzeń:  
  
-   Możesz ustawić <xref:System.Diagnostics.EventLogEntryType> można wybrać ikonę, która podglądu zdarzeń wyświetlane wpisu.  
  
-   Jeśli aplikacja używa kategorii do filtrowania zdarzeń, można określić identyfikatora kategorii zdarzenia.  
  
-   Można dołączyć dane binarne do zgłoszenia użytkownika zdarzeń, jeśli chcesz skojarzyć dodatkowe informacje z podanego zdarzenia.  
  
> [!IMPORTANT]
>  Rejestrowanie zdarzeń zajmuje miejsce na dysku, czas procesora i innych zasobów. Należy rejestrować tylko niezbędne informacje. Zaleca się, że wywołania dziennika zdarzeń w polu Ścieżka błędu, a nie w ścieżce głównej kodu, więc one nie negatywnie wpłynąć na wydajność.  
  
 Aby uzyskać listę początkowe wartości właściwości wystąpienia <xref:System.Diagnostics.EventLog>, zobacz <xref:System.Diagnostics.EventLog.%23ctor%2A> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład obejmuje tworzenie źródła zdarzeń `MySource` Jeśli go jeszcze nie istnieje i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
> [!NOTE]
>  Począwszy od Windows Vista, należy uruchomić tę aplikację jako administrator.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Wiąże wystąpienie z żadnych dzienników.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A> właściwość <xref:System.Diagnostics.EventLog> wystąpienia. Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A> z dziennika, można też określić tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Komputer lokalny (".").|  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` Jeśli jeszcze nie istnieje i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na komputerze lokalnym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dzienników na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A> właściwość `logName` parametru. Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A> właściwość <xref:System.Diagnostics.EventLog> wystąpienia. Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A> z dziennika, można też określić tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że. Tego przeciążenia konstruktora Określa <xref:System.Diagnostics.EventLog.Log%2A> właściwości, ale można zmienić przed przeczytaniem <xref:System.Diagnostics.EventLog.Entries%2A> właściwości.  
  
 Jeśli źródło określisz w <xref:System.Diagnostics.EventLog.Source%2A> właściwość jest unikatowy z innych źródeł na komputerze, kolejne wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A> tworzy dziennik z określoną nazwą, jeśli jeszcze nie istnieje.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametru.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Komputer lokalny (".").|  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "myNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na określonym komputerze.</param>
        <param name="machineName">Komputer, na którym znajduje się dziennika.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennika na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A> właściwości `logName` parametru i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwość `machineName` parametru. Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A> właściwość <xref:System.Diagnostics.EventLog>. Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A> z dziennika, można też określić tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości.  
  
> [!NOTE]
>  Tego przeciążenia konstruktora Określa <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości, ale można zmienić dowolne przed przeczytaniem <xref:System.Diagnostics.EventLog.Entries%2A> właściwości.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Ciąg pusty ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametru.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` Parametru.|  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń "myNewLog" na komputerze "myServer".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.  
  
—lub— 
Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika na określonym komputerze</param>
        <param name="machineName">Komputer, na którym znajduje się dziennika.</param>
        <param name="source">Źródło wpisy w dzienniku zdarzeń.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.EventLog" /> klasy. Kojarzy wystąpienie z dziennika na określonym komputerze i tworzy lub przypisuje określone źródło do <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawia ten konstruktor <xref:System.Diagnostics.EventLog.Log%2A> właściwości `logName` parametru <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości `machineName` parametru i <xref:System.Diagnostics.EventLog.Source%2A> właściwość `source` parametru. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość jest wymagana podczas zapisywania dziennika zdarzeń. Jednakże jeśli są tylko do odczytu z dziennika zdarzeń, tylko <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości są wymagane (tak długo, jak dziennik zdarzeń na serwerze ma już skojarzony z nim źródła). Jeśli masz tylko do odczytu z dziennika zdarzeń, może być wystarczające innego przeciążenia metody konstruktora.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Diagnostics.EventLog>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` Parametru.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` Parametru.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` Parametru.|  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis dziennika zdarzeń, "MyNewLog" na komputerze lokalnym przy użyciu źródła "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nazwa dziennika jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa dziennika jest nieprawidłowa.  
  
—lub— 
Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się inicjowanie <see cref="T:System.Diagnostics.EventLog" /> w formularzu lub używany przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.EndInit%2A> Metoda kończy się inicjowanie. Za pomocą <xref:System.Diagnostics.EventLog.BeginInit%2A> i <xref:System.Diagnostics.EventLog.EndInit%2A> metody uniemożliwić kontrolki przed jest w pełni zainicjowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> jest już zainicjowany.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie wpisy z dziennika zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzienniki zdarzeń są konfigurowane przy użyciu maksymalny rozmiar, który określa, jak wiele wpisów, które zawierają. Po zapełnieniu dziennika zdarzeń przestaje rejestrować nowe informacje o zdarzeniach lub rozpoczyna się w celu zastąpienia starszych wpisów. Jeśli zatrzymuje rejestrowanie zdarzeń, można użyć tej metody aby wyczyścić dziennik istniejące wpisy i umożliwić mu ponownie uruchomić rejestrowanie zdarzeń. Musi mieć uprawnienia administratora na komputerze, na którym znajduje się dziennik Wyczyść wpisy w dzienniku zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> powoduje zamknięcie dziennika zdarzeń, zwalnia uchwytów zdarzeń pobiera nowe Odczyt i zapis uchwyty i ponownie otworzy w dzienniku zdarzeń. Zdarzenia odebrane po wywołaniu metody nie zostaną wyczyszczone, wraz z istniejących zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład powoduje wyczyszczenie dziennika zdarzeń.  
  
> [!CAUTION]
>  Ponieważ aplikacji, System, zabezpieczenia i inne niż niestandardowe Dzienniki mogą zawierać ważnych informacji. Pamiętaj określić niestandardowy dziennik przed wykonaniem ten przykładowy kod. W tym przykładzie usuwa dziennik niestandardowy `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">W dzienniku zdarzeń nie zostało pomyślnie wyczyszczone.  
  
—lub— 
Nie można otworzyć dziennika. Kod błędu Windows nie jest dostępna.</exception>
        <exception cref="T:System.ArgumentException">Nie określono wartości dla <see cref="P:System.Diagnostics.EventLog.Log" /> właściwości. Upewnij się, że nazwa dziennika nie jest ciągiem pustym.</exception>
        <exception cref="T:System.InvalidOperationException">Dziennik nie istnieje.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka dziennika zdarzeń i zwalnia odczytu i zapisu uchwyty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A> Metoda jest wywoływana przez chronionego <xref:System.ComponentModel.Component.Dispose%2A> metody. Nie trzeba wywołać <xref:System.Diagnostics.EventLog.Close%2A> przed wywołaniem <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">W dzienniku zdarzeń uchwyt odczytu lub zapisu nie został wydany pomyślnie.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia aplikacji jako mogły zapisywać informacje dotyczące zdarzenia określonego dziennika w systemie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Właściwości konfiguracji dla źródła zdarzenia i jego docelowego dziennika zdarzeń.</param>
        <summary>Ustanawia źródłem zdarzeń prawidłowe do zapisywania zdarzeń zlokalizowanych komunikatów, za pomocą właściwości konfiguracji dla źródła zdarzeń i odpowiedniego dziennika zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby skonfigurować nowe źródło do zapisywania wpisów dziennika zdarzeń na komputerze lokalnym lub komputerze zdalnym, należy użyć tego przeciążenia. Nie jest konieczne użycie tej metody można odczytać z dziennika zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A> Metoda wykorzystuje dane wejściowe `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> i <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> właściwości w celu utworzenia wartości rejestru na komputerze docelowym dla nowego źródła i jego skojarzone dziennika zdarzeń. Nowej nazwy źródła nie może dopasować istniejącej nazwy źródła lub istniejącą nazwę dziennika zdarzeń na komputerze docelowym. Jeśli <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> właściwość nie jest ustawiona, źródło jest zarejestrowany w dzienniku zdarzeń aplikacji. Jeśli <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> nie jest ustawiona, źródło jest zarejestrowana na komputerze lokalnym.  
  
> [!NOTE]
>  Aby utworzyć źródła zdarzeń w Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyna tego wymagania jest, że wszystkie dzienniki zdarzeń, w tym zabezpieczeń, musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> zgłaszany.  
>   
>  Począwszy od Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia można zapisać zdarzenia; należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennika nie jest tworzony, dopóki pierwszy wpis jest zapisywany do niego.  
  
 Dzienniki zdarzeń systemu operacyjnego są przechowywane jako pliki. Kiedy używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do utworzenia nowego dziennika zdarzeń, skojarzony plik jest przechowywany w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona, dodając pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Każde źródło mogą zapisywać wyłącznie do tylko jednego dziennika zdarzeń jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników. Na przykład aplikacja może wymagać wielu źródeł, skonfigurowanych dla różnych dziennikach zdarzeń lub plików innego zasobu.  
  
 Za zarejestrowanie źródła zdarzeń i plików zasobów zlokalizowanych ciągów kategorii i komunikat zdarzenia. Aplikację można napisać wpisy dziennika zdarzeń przy użyciu identyfikatorów zasobów zamiast określania rzeczywistego ciągu. Podgląd zdarzeń używa identyfikatora zasobu, aby znaleźć i wyświetlić odpowiedni ciąg z pliku zlokalizowanych zasobów, w oparciu o bieżące ustawienia języka. Możesz zarejestrować osobny plik dla kategorii zdarzeń, komunikatów i ciągi wstawiania parametru lub można zarejestrować tego samego pliku zasobów dla wszystkich trzech typów ciągów znaków. Użyj <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, i <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> właściwości, aby skonfigurować źródła na zapisywanie wpisów zlokalizowanych w dzienniku zdarzeń. Jeśli aplikacja zapisuje wartości ciągów bezpośrednio do dziennika zdarzeń, nie musisz ustawić te właściwości.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Jeśli używasz istniejącego źródła, inne aplikacje lub składniki, Utwórz nowe źródło przy użyciu zaktualizowanej konfiguracji, a nie usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli źródłem jest skonfigurowany do dziennika zdarzeń, a następnie ponownie skonfigurować go dla innego dziennika zdarzeń, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład określa, czy źródło zdarzeń o nazwie `SampleApplicationSource` jest zarejestrowana na komputerze lokalnym. Jeśli nie ma źródła zdarzeń, przykład ustawia pliku zasobów komunikatów dla źródła i tworzy nowe źródło zdarzeń. Ponadto w przykładzie zlokalizowana nazwa wyświetlana dla dziennika zdarzeń, używając wartości identyfikatora zasobu w `DisplayNameMsgId` i ścieżka pliku zasobów w `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 W przykładzie użyto następującego pliku tekst komunikatu wbudowana w bibliotekę zasobu EventLogMsgs.dll. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatory zasobów i tekst dla kategorii, komunikatów o zdarzeniach i ciągi wstawiania parametru. W szczególności identyfikator zasobu 5001 jest zdefiniowany dla zlokalizowana nazwa dziennika zdarzeń.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa komputera określona w <paramref name="sourceData" /> jest nieprawidłowy.  
  
\- lub — 
Nazwa źródła, określony w <paramref name="sourceData" /> jest <see langword="null" />.  
  
\- lub — 
Nazwa dziennika, określona w <paramref name="sourceData" /> jest nieprawidłowy. Nazwy dziennika zdarzeń musi składać się z drukowalnych znaków i nie może zawierać znaków ' * ','?', lub "\\".  
  
\- lub — 
Nazwa dziennika, określona w <paramref name="sourceData" /> nie jest prawidłowa dla użytkownika tworzenia dziennika. Nazwy dziennika zdarzeń AppEvent SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
\- lub — 
Nazwa dziennika odpowiada istniejącej nazwy źródła zdarzeń.  
  
\- lub — 
Nazwa źródła, określony w <paramref name="sourceData" /> skutkuje dłuższa niż 254 znaki ścieżkę klucza rejestru.  
  
\- lub — 
Pierwsze 8 znaków nazwę dziennika, określona w <paramref name="sourceData" /> nie są unikatowe.  
  
\- lub — 
Nazwa źródła, określony w <paramref name="sourceData" /> jest już zarejestrowany.  
  
\- lub — 
Nazwa źródła, określony w <paramref name="sourceData" /> odpowiada istniejącej nazwy dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła za pomocą którego aplikacja jest zarejestrowana na komputerze lokalnym.</param>
        <param name="logName">Nazwa dziennika źródła wpisy są zapisywane. Możliwe wartości to aplikacji, systemu lub niestandardowy dziennik zdarzeń.</param>
        <summary>Określa nazwę określonego źródła jako źródło zdarzeń prawidłowe zapisywania wpisów dziennika na komputerze lokalnym. Tę metodę można również utworzyć nowy dziennik niestandardowy na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tego przeciążenia można utworzyć dziennika niestandardowego lub Utwórz i Zarejestruj <xref:System.Diagnostics.EventLog.Source%2A> do istniejącego dziennika na komputerze lokalnym.  
  
 Jeśli `logName` jest `null` ani być pustym ciągiem ("") podczas wywoływania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, domyślnie dziennika w dzienniku aplikacji. Jeśli dziennika nie istnieje na komputerze lokalnym, system tworzy dziennik niestandardowy i rejestruje aplikację jako <xref:System.Diagnostics.EventLog.Source%2A> dla tego dziennika.  
  
> [!NOTE]
>  Aby utworzyć źródła zdarzeń w Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyna tego wymagania jest, że wszystkie dzienniki zdarzeń, w tym zabezpieczeń, musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> zgłaszany.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Musisz utworzyć źródła zdarzeń, jeśli piszesz w dzienniku zdarzeń. Przed zapisaniem wpis dziennika zdarzeń, należy zarejestrować źródła zdarzeń z dziennika zdarzeń jako poprawne źródło zdarzeń. Podczas zapisywania wpisów dziennika, wówczas system używa <xref:System.Diagnostics.EventLog.Source%2A> można znaleźć odpowiedniego dziennika, w której chcesz umieścić zgłoszenia użytkownika. Jeśli podczas odczytu dziennika zdarzeń, można określić <xref:System.Diagnostics.EventLog.Source%2A>, lub <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Nie musisz określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się dziennika na komputerze lokalnym. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> podczas odczytywania dziennika, na komputerze lokalnym (".") zakłada, że.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia można zapisać zdarzenia; należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennika nie jest tworzony, dopóki pierwszy wpis jest zapisywany do niego.  
  
 Dzienniki zdarzeń systemu operacyjnego są przechowywane jako pliki. Kiedy używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do utworzenia nowego dziennika zdarzeń, skojarzony plik jest przechowywany w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona, dodając pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Źródłowy musi być unikatowa na komputerze lokalnym. nowej nazwy źródła nie może dopasować istniejącej nazwy źródła lub istniejącą nazwę dziennika zdarzeń. Każde źródło może zapisywać tylko jeden dziennik zdarzeń jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników. Na przykład aplikacja może wymagać wielu źródeł, skonfigurowanych dla różnych dziennikach zdarzeń lub plików innego zasobu.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Jeśli używasz istniejącego źródła, inne aplikacje lub składniki, Utwórz nowe źródło przy użyciu zaktualizowanej konfiguracji, a nie usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli ponownie mapować je na nowy dziennik źródła został już zmapowany do dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` Jeśli jeszcze nie istnieje i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> jest pustym ciągiem ("") lub <see langword="null" />.  
  
\- lub — 
 <paramref name="logName" /> nie jest prawidłową nazwę dziennika zdarzeń. Nazwy dziennika zdarzeń musi składać się z drukowalnych znaków i nie może zawierać znaków ' * ','?', lub "\\".  
  
\- lub — 
 <paramref name="logName" /> nie jest prawidłowa dla użytkownika tworzenia dziennika. Nazwy dziennika zdarzeń AppEvent SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
\- lub — 
Nazwa dziennika odpowiada istniejącej nazwy źródła zdarzeń.  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.  
  
\- lub — 
Pierwsze 8 znaków <paramref name="logName" /> dopasowania pierwsze 8 znaków istniejącą nazwę dziennika zdarzeń.  
  
\- lub — 
Nie można zarejestrować źródła, ponieważ już istnieje na komputerze lokalnym.  
  
\- lub — 
Nazwa źródła odpowiada istniejącej nazwy dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze lokalnym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="logName">Nazwa dziennika źródła wpisy są zapisywane. Możliwe wartości to aplikacji, systemu lub niestandardowy dziennik zdarzeń. Jeśli nie określisz wartości, <c>Nazwa_dziennika</c> wartości domyślne do aplikacji.</param>
        <param name="machineName">Nazwa komputera, aby zarejestrować tego źródła zdarzeń, lub "." na komputerze lokalnym.</param>
        <summary>Określa nazwę określonego źródła jako źródło zdarzeń prawidłowe zapisywania wpisów dziennika na określonym komputerze. Tę metodę można również utworzyć nowy dziennik niestandardowy na określonym komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tego przeciążenia można utworzyć dziennika niestandardowego lub Utwórz i Zarejestruj <xref:System.Diagnostics.EventLog.Source%2A> do istniejącego dziennika na określonym komputerze.  
  
 Jeśli `logName` jest `null` ani być pustym ciągiem ("") podczas wywoływania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, domyślnie dziennika w dzienniku aplikacji. Jeśli dziennika nie istnieje na określonym komputerze, system tworzy dziennik niestandardowy i rejestruje aplikację jako <xref:System.Diagnostics.EventLog.Source%2A> dla tego dziennika.  
  
 Musisz utworzyć źródła zdarzeń, jeśli piszesz w dzienniku zdarzeń. Przed zapisaniem wpis dziennika zdarzeń, należy zarejestrować źródła zdarzeń z dziennika zdarzeń jako poprawne źródło zdarzeń. Podczas zapisywania wpisów dziennika, wówczas system używa <xref:System.Diagnostics.EventLog.Source%2A> można znaleźć odpowiedniego dziennika, w której chcesz umieścić zgłoszenia użytkownika. Jeśli podczas odczytu dziennika zdarzeń, można określić <xref:System.Diagnostics.EventLog.Source%2A>, lub <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Aby utworzyć źródła zdarzeń w Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administratora.  
>   
>  Przyczyna tego wymagania jest, że wszystkie dzienniki zdarzeń, w tym zabezpieczeń, musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Windows Vista i nowszych użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> zgłaszany.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia można zapisać zdarzenia; należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennika nie jest tworzony, dopóki pierwszy wpis jest zapisywany do niego.  
  
 Dzienniki zdarzeń systemu operacyjnego są przechowywane jako pliki. Kiedy używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do utworzenia nowego dziennika zdarzeń, skojarzony plik jest przechowywany w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona, dodając pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Źródłowy musi być unikatowa na komputerze lokalnym. nowej nazwy źródła nie może dopasować istniejącej nazwy źródła lub istniejącą nazwę dziennika zdarzeń. Każde źródło może zapisywać tylko jeden dziennik zdarzeń jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników. Na przykład aplikacja może wymagać wielu źródeł, skonfigurowanych dla różnych dziennikach zdarzeń lub plików innego zasobu.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Jeśli używasz istniejącego źródła, inne aplikacje lub składniki, Utwórz nowe źródło przy użyciu zaktualizowanej konfiguracji, a nie usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli ponownie mapować je na nowy dziennik źródła został już zmapowany do dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` na komputerze `MyServer`i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Nie jest prawidłową nazwą komputera.  
  
\- lub — 
 <paramref name="source" /> jest pustym ciągiem ("") lub <see langword="null" />.  
  
\- lub — 
 <paramref name="logName" /> nie jest prawidłową nazwę dziennika zdarzeń. Nazwy dziennika zdarzeń musi składać się z drukowalnych znaków i nie może zawierać znaków ' * ','?', lub "\\".  
  
\- lub — 
 <paramref name="logName" /> nie jest prawidłowa dla użytkownika tworzenia dziennika. Nazwy dziennika zdarzeń AppEvent SysEvent i SecEvent są zarezerwowane do użycia przez system.  
  
\- lub — 
Nazwa dziennika odpowiada istniejącej nazwy źródła zdarzeń.  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.  
  
\- lub — 
Pierwsze 8 znaków <paramref name="logName" /> dopasowanie pierwsze 8 znaków istniejącego dziennika zdarzeń imię i nazwisko na określonym komputerze.  
  
\- lub — 
Nie można zarejestrować źródła, ponieważ już istnieje na określonym komputerze.  
  
\- lub — 
Nazwa źródła odpowiada istniejącej nazwy źródła zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na określonym komputerze.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa zasób dziennika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do usunięcia. Możliwe wartości to: aplikacji, zabezpieczeń, systemu i wszystkie niestandardowe dzienniki zdarzeń na komputerze.</param>
        <summary>Usuwa dziennik zdarzeń z komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, gdy dziennik, który chcesz usunąć znajduje się na komputerze lokalnym. Każdy dziennik na komputerze, można usunąć, pod warunkiem posiadania odpowiednich uprawnień rejestru.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Usuwa dziennika określony przez `logName` z komputera lokalnego. Jeśli chcesz usunąć tylko określone źródło zarejestrowane w dzienniku, wywołania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, dzięki czemu można wywołać w samej klasy. Nie jest konieczne utworzyć nowe wystąpienie klasy <xref:System.Diagnostics.EventLog> do wywoływania jednej z metod.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Metoda najpierw usuwa plik, który przechowuje zawartość dziennika. Następnie uzyskuje dostęp do rejestru i spowoduje usunięcie wszystkich źródeł zdarzeń zarejestrowane dla tego dziennika. Jeśli możesz odtworzyć dziennik, który w przyszłości, należy zarejestrować źródła zdarzeń ponownie, jeśli mają być używane ponownie. Jeśli nie zarejestrujesz źródła zdarzeń i innych użytkowników zapisu ze źródłem zdarzeń bez określenia nazwy dziennika, źródła zdarzeń zostaną utworzone w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były możliwość zapisywania wpisów dziennika, należy usunąć i ponownie utworzyć będzie zapisywać w dzienniku aplikacji zamiast tego, ponieważ zawiera ona teraz źródła zdarzeń.  
  
> [!NOTE]
>  Ponowne tworzenie dziennika zdarzeń może być trudne procesu. Nie usuwaj żadnego z dzienników zdarzeń utworzonych przez system, takie jak dziennik aplikacji.  
  
 Usuwanie dziennika za pomocą wywołania <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Dzięki temu może być inne aplikacje korzystające z tego dziennika niedziałających.  
  
   
  
## Examples  
 Poniższy przykład usuwa dziennik z komputera lokalnego. W przykładzie następuje dzienników ze źródła.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennika niestandardowego, upewnij się, brak innych źródeł, zapisywanie do tego dziennika.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> jest pustym ciągiem ("") lub <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze lokalnym.  
  
\- lub — 
Dziennik nie istnieje na komputerze lokalnym.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">W dzienniku zdarzeń nie zostało pomyślnie wyczyszczone.  
  
—lub— 
Nie można otworzyć dziennika. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do usunięcia. Możliwe wartości to: aplikacji, zabezpieczeń, systemu i wszelkie niestandardowe dzienniki zdarzeń na określonym komputerze.</param>
        <param name="machineName">Nazwa komputera, można usunąć dziennika, lub "." na komputerze lokalnym.</param>
        <summary>Usuwa dziennik zdarzeń z określonego komputera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, gdy dziennik, który chcesz usunąć znajduje się na komputerze zdalnym. Każdy dziennik na komputerze, można usunąć, pod warunkiem posiadania odpowiednich uprawnień rejestru.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Usuwa dziennika określony przez `logName` z komputera określonego przez `machineName`. Jeśli chcesz usunąć tylko określone źródło zarejestrowane w dzienniku, wywołania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, dzięki czemu można wywołać w samej klasy. Nie jest niezbędne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> do wywoływania jednej z metod.  
  
 Ta metoda usuwa pierwszy plik, który przechowuje zawartość dziennika. Następnie uzyskuje dostęp do rejestru i spowoduje usunięcie wszystkich źródeł zdarzeń zarejestrowane dla tego dziennika. Jeśli możesz odtworzyć dziennik, który w przyszłości, należy zarejestrować źródła zdarzeń ponownie, jeśli mają być używane ponownie. Jeśli nie zarejestrujesz źródła zdarzeń i innych użytkowników zapisu ze źródłem zdarzeń bez określenia nazwy dziennika, źródła zdarzeń zostaną utworzone w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były możliwość zapisywania wpisów dziennika, należy usunąć i ponownie utworzyć będzie zapisywać w dzienniku aplikacji zamiast tego, ponieważ zawiera ona teraz źródła zdarzeń.  
  
> [!NOTE]
>  Ponowne tworzenie dziennika zdarzeń może być trudne procesu. Nie usuwaj żadnego z dzienników zdarzeń utworzonych przez system, takie jak dziennik aplikacji.  
  
 Usuwanie dziennika za pomocą wywołania <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Dzięki temu może być inne aplikacje korzystające z tego dziennika niedziałających.  
  
   
  
## Examples  
 Poniższy przykład usuwa dziennik z określonego komputera. W przykładzie następuje dzienników ze źródła.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennika niestandardowego, upewnij się, brak innych źródeł, zapisywanie do tego dziennika.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> jest pustym ciągiem ("") lub <see langword="null" />.  
  
\- lub — 
 <paramref name="machineName" /> nie jest prawidłową nazwą komputera.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń na określonym komputerze.  
  
\- lub — 
Dziennik nie istnieje na określonym komputerze.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">W dzienniku zdarzeń nie zostało pomyślnie wyczyszczone.  
  
—lub— 
Nie można otworzyć dziennika. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa rejestrację źródła zdarzeń aplikacji z dziennika zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa, za pomocą którego aplikacja jest zarejestrowana w dzienniku zdarzeń systemu.</param>
        <summary>Usuwa rejestrację źródła zdarzeń z dziennika zdarzeń komputera lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do usunięcia rejestracji <xref:System.Diagnostics.EventLog.Source%2A> z komputera lokalnego. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> uzyskuje dostęp do rejestru na komputerze lokalnym i usuwa rejestrację aplikacji jako poprawne źródło zdarzeń.  
  
 Jeśli nie potrzebujesz już go na zapisywanie wpisów w tym dzienniku, możesz usunąć składnik jako poprawne źródło zdarzeń. Na przykład może być w tym jeśli potrzebujesz zmienić składnika z jednego dziennika. Ponieważ źródła można zarejestrować tylko jeden dziennik w czasie, zmiana w dzienniku wymaga usunięcia bieżącego rejestracji.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Usuwa tylko określone źródło, które są zarejestrowane w dzienniku. Jeśli chcesz usunąć plik samego dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Delete%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, dzięki czemu można wywołać w samej klasy. Nie jest niezbędne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> do wywoływania jednej z metod.  
  
 Usuwanie dziennika za pomocą wywołania <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Dzięki temu może być inne aplikacje korzystające z tego dziennika niedziałających.  
  
> [!NOTE]
>  Jeśli ponownie mapować je na nowy dziennik źródła został już zmapowany do dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład usuwa źródła z komputera lokalnego. Przykład określa dzienników ze źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennika niestandardowego, upewnij się, brak innych źródeł, zapisywanie do tego dziennika.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Parametr nie istnieje w rejestrze komputera lokalnego.  
  
\- lub — 
Nie masz dostępu do zapisu w kluczu rejestru dla dziennika zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa, za pomocą którego aplikacja jest zarejestrowana w dzienniku zdarzeń systemu.</param>
        <param name="machineName">Nazwa komputera, aby usunąć rejestrację, lub "." na komputerze lokalnym.</param>
        <summary>Usuwa rejestrację źródła zdarzeń aplikacji z określonego komputera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby usunąć rejestrację <xref:System.Diagnostics.EventLog.Source%2A> z komputera zdalnego. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> uzyskuje dostęp do rejestru na komputerze określonym przez `machineName` i usuwa rejestrację aplikacji jako poprawne źródło zdarzeń.  
  
 Jeśli nie potrzebujesz już go na zapisywanie wpisów w tym dzienniku, możesz usunąć składnik jako poprawne źródło zdarzeń. Na przykład może być w tym jeśli potrzebujesz zmienić składnika z jednego dziennika. Ponieważ źródła można zarejestrować tylko jeden dziennik w czasie, zmiana w dzienniku wymaga usunięcia bieżącego rejestracji.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Usuwa tylko określone źródło, które są zarejestrowane w dzienniku. Jeśli chcesz usunąć plik samego dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Delete%2A>. Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> są `static` metod, dzięki czemu można wywołać w samej klasy. Nie jest niezbędne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> do wywoływania jednej z metod.  
  
 Usuwanie dziennika za pomocą wywołania <xref:System.Diagnostics.EventLog.Delete%2A> automatycznie usuwa źródeł zarejestrowany dla tego dziennika. Dzięki temu może być inne aplikacje korzystające z tego dziennika niedziałających.  
  
> [!NOTE]
>  Jeśli ponownie mapować je na nowy dziennik źródła został już zmapowany do dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład usuwa źródła z określonego komputera. Przykład określa dzienników ze źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennika niestandardowego, upewnij się, brak innych źródeł, zapisywanie do tego dziennika.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest nieprawidłowy.  
  
\- lub — 
<paramref name="source" /> Parametr nie istnieje w rejestrze określonego komputera.  
  
\- lub — 
Nie masz dostępu do zapisu w kluczu rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> Nie można usunąć, ponieważ w rejestrze, klucz rejestru nadrzędnego <paramref name="source" /> nie zawiera podklucz o takiej samej nazwie.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Diagnostics.EventLog" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną `Dispose()` metody i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` równa `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Diagnostics.EventLog> odwołania. Ta metoda wywołuje `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" /> Uważaj, aby nie odwołują się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see langword="Dispose(Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.Diagnostics.EventLog" /> odbiera <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> powiadomienia o zdarzeniach.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Diagnostics.EventLog" /> otrzymuje powiadomienie, gdy wpis jest napisane w dzienniku; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Właściwość określa, czy <xref:System.Diagnostics.EventLog> wywołuje zdarzenia, gdy wpisy są zapisywane w dzienniku. Jeśli właściwość jest `true`, składniki, które odbierają <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenie zostanie wysłane powiadomienie ilekroć wpis dziennika, który jest określony w <xref:System.Diagnostics.EventLog.Log%2A> właściwości. Jeśli <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> jest `false`, żadne zdarzenia nie są wywoływane.  
  
> [!NOTE]
>  Może odbierać powiadomienia o zdarzeniach, tylko wtedy, gdy wpisy są zapisywane na komputerze lokalnym. Nie może otrzymywać powiadomienia o wpisy zapisywane na komputerach zdalnych.  
  
   
  
## Examples  
 Następujące uchwyty przykład <xref:System.Diagnostics.EventLog.EntryWritten> zdarzeń.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dziennik zdarzeń znajduje się na komputerze zdalnym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Diagnostics.EventLog" /> używane w formularzu lub przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.BeginInit%2A> Metoda uruchamia inicjowania. Za pomocą <xref:System.Diagnostics.EventLog.BeginInit%2A> i <xref:System.Diagnostics.EventLog.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawartość w dzienniku zdarzeń.</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLogEntryCollection" /> Zawierający wpisy w dzienniku zdarzeń. Każdy wpis jest skojarzony z wystąpieniem <see cref="T:System.Diagnostics.EventLogEntry" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.EventLog.Entries%2A> element członkowski podczas odczytu dziennika zdarzeń.  
  
 Ponieważ właściwość jest tylko do odczytu, nie można zmodyfikować wpisu lub zapisu do dziennika przy użyciu <xref:System.Diagnostics.EventLog.Entries%2A>. Zamiast tego należy określić <xref:System.Diagnostics.EventLog.Source%2A> i wywołać <xref:System.Diagnostics.EventLog.WriteEntry%2A> można zapisać nowego wpisu dziennika. Możesz użyć <xref:System.Diagnostics.EventLog.Entries%2A> liczbę wpisów w dzienniku zdarzeń w celu wyświetlenia każdego <xref:System.Diagnostics.EventLogEntry> w kolekcji. Użyj indeksowanej <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> Członkowskie można pobrać informacji na temat określonego wpisu, taki jak <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, lub <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Nie jest konieczne określić <xref:System.Diagnostics.EventLog.Source%2A> gdy tylko do odczytu z dziennika. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwy i <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości (nazwa komputera serwera) <xref:System.Diagnostics.EventLog> wystąpienia. W obu przypadkach <xref:System.Diagnostics.EventLog.Entries%2A> element członkowski zostanie automatycznie wypełniona lista wpisów w dzienniku zdarzeń. Na tej liście można odczytać poszczególne wpisy można wybrać odpowiedni indeks elementu.  
  
 Na istotną różnicę między odczytywania i zapisywania wpisów dziennika jest, że nie jest konieczne jawnie wywołać metodę odczytu. Po <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A> są określone, <xref:System.Diagnostics.EventLog.Entries%2A> właściwość jest wypełniane automatycznie. Jeśli zmienisz wartość <xref:System.Diagnostics.EventLog.Log%2A> lub <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości <xref:System.Diagnostics.EventLog.Entries%2A> właściwość jest wypełniona przy następnym go odczytać.  
  
> [!NOTE]
>  Nie musisz określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się w dzienniku. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny, ".", zakłada, że.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń, "MyNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wpis jest zapisywane w dzienniku zdarzeń na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać powiadomienia o zdarzeniach, należy ustawić <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> do `true`. Może odbierać powiadomienia o zdarzeniach, gdy wpisy są zapisywane na komputerze lokalnym. Nie może otrzymywać powiadomienia o wpisy zapisywane na komputerach zdalnych.  
  
 Po utworzeniu <xref:System.Diagnostics.EventLog.EntryWritten> delegata, możesz zidentyfikować metody, która będzie obsługiwać zdarzenia. Aby skojarzyć zdarzenia z programu obsługi zdarzeń, należy dodać wystąpienie delegata zdarzenia. Program obsługi zdarzeń jest wywoływana zawsze wtedy, gdy wystąpi zdarzenie, dopóki nie usuniesz delegata. Aby uzyskać więcej informacji na temat obsługi zdarzeń przy użyciu delegatów, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 Zachowuje się system w celu <xref:System.Diagnostics.EventLog.WriteEntry%2A> tylko wtedy, gdy ostatnie zdarzenie zapisu wystąpił co najmniej sześciu sekund wcześniej. Oznacza to, zostanie wyświetlony tylko jeden <xref:System.Diagnostics.EventLog.EntryWritten> powiadomień o zdarzeniach w ramach 6 sekundowego interwału, nawet wtedy, gdy więcej niż jedno zdarzenie dziennika zmian występuje. W przypadku wstawiania interwał wystarczająco długi, uśpienia (około 10 sekund), między wywołaniami <xref:System.Diagnostics.EventLog.WriteEntry%2A>, jest mniej prawdopodobne ominęło Cię wydarzenie. Jednak jeśli zapisu zdarzenia pojawiają się częściej, może nie odbierać powiadomień o zdarzeniach do następnego interwału. Zwykle powiadomienia o zdarzeniach brakujących są nie utracony, ale opóźnione.  
  
   
  
## Examples  
 Poniższy przykład obsługuje wpis zapisywane zdarzenie.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy istnieje określony dziennik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nazwa dziennika do wyszukania. Możliwe wartości to: aplikacji, zabezpieczeń, System, innych dzienników dotyczących aplikacji (np. związane z usługą Active Directory) lub żadnych dzienników niestandardowych na komputerze.</param>
        <summary>Określa, czy dziennik istnieje na komputerze lokalnym.</summary>
        <returns>
          <see langword="true" /> Jeśli dziennik istnieje na komputerze lokalnym. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest przydatna do ustalenia, czy dziennik istnieje na komputerze lokalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na komputerze lokalnym. w przeciwnym razie zapytanie zwraca `false`.  
  
 Ponieważ nowy dziennik nie można nadać nazwę istniejącego dziennika na tym samym komputerze, ta metoda przed utworzeniem nowego dziennika do określenia, czy określony `logName` już istnieje na komputerze lokalnym. `logName` Parametr nie jest uwzględniana wielkość liter.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> jest `static` metody, dzięki czemu można wywołać w samej klasy. Nie jest niezbędne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> do wywołania <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jest Nazwa_dziennika <see langword="null" /> lub wartość jest pusta.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Dziennik, który chcesz wyszukać. Możliwe wartości to: aplikacji, zabezpieczeń, System, innych dzienników dotyczących aplikacji (np. związane z usługą Active Directory) lub żadnych dzienników niestandardowych na komputerze.</param>
        <param name="machineName">Nazwa komputera, na którym należy szukać w dzienniku lub "." na komputerze lokalnym.</param>
        <summary>Określa, czy dziennik istnieje na określonym komputerze.</summary>
        <returns>
          <see langword="true" /> Jeśli dziennik istnieje na określonym komputerze. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest przydatna do ustalenia, czy dziennik istnieje na komputerze zdalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze zdalnym, użyj <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na określonym komputerze. w przeciwnym razie zapytanie zwraca `false`.  
  
 Ponieważ nowy dziennik nie można nadać nazwę istniejącego dziennika na tym samym komputerze, ta metoda przed utworzeniem nowego dziennika do określenia, czy jest to jeden z określonym `logName` już istnieje na serwerze określonym przez `machineName` parametru. `logName` i `machineName` parametry nie są z uwzględnieniem wielkości liter.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> jest `static` metody, dzięki czemu można wywołać w samej klasy. Nie jest konieczne utworzyć nowe wystąpienie klasy <xref:System.Diagnostics.EventLog> do wywołania <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr ma nieprawidłowy format. Upewnij się, że używasz poprawnej składni dla komputera, w przypadku wyszukiwania.  
  
—lub— 
<paramref name="logName" /> Jest <see langword="null" /> lub wartość jest pusta.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy tablicę z dzienników zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przeszukuje wszystkie dzienniki zdarzeń na komputerze lokalnym i tworzy tablicę <see cref="T:System.Diagnostics.EventLog" /> obiektów, które zawierają listy.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.EventLog" /> reprezentujący dzienniki na komputerze lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica <xref:System.Diagnostics.EventLog> obiektów jest migawką wszystkie dzienniki zdarzeń na komputerze lokalnym po wywołaniu <xref:System.Diagnostics.EventLog.GetEventLogs%2A> składa się. To nie jest kolekcję dynamiczne, dzięki czemu nie będzie odzwierciedlał usuwania lub tworzenia dzienników w czasie rzeczywistym. Należy sprawdzić, czy dziennik w tablicy istnieje przed odczytu lub zapisu do niego. Tablica zawiera zazwyczaj co najmniej trzech dzienników: aplikacji, System i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na komputerze lokalnym, pojawią się one w tablicy, jak również.  
  
 Aby pobrać listę dzienników zdarzeń, musi mieć odpowiednich uprawnień rejestru. Te uprawnienia są identyczne z tymi wymagane do wywołania <xref:System.Diagnostics.EventLog.Exists%2A> i <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Nie masz dostępu do odczytu do rejestru.  
  
—lub— 
Nie ma żadnej usługi dziennika zdarzeń na komputerze.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, na którym należy szukać w dziennikach zdarzeń.</param>
        <summary>Przeszukuje wszystkie dzienniki zdarzeń na danym komputerze i tworzy tablicę <see cref="T:System.Diagnostics.EventLog" /> obiektów, które zawierają listy.</summary>
        <returns>Tablica typu <see cref="T:System.Diagnostics.EventLog" /> reprezentujący dzienniki na danym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica <xref:System.Diagnostics.EventLog> obiektów jest migawką wszystkie dzienniki zdarzeń na komputerze określonym przez `machineName` parametru po wywołaniu <xref:System.Diagnostics.EventLog.GetEventLogs%2A> składa się. To nie jest kolekcję dynamiczne, dzięki czemu nie będzie odzwierciedlał usuwania lub tworzenia dzienników w czasie rzeczywistym. Należy sprawdzić, czy dziennik w tablicy istnieje przed odczytu lub zapisu do niego. Tablica zawiera zazwyczaj co najmniej trzech dzienników: aplikacji, System i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na określonym komputerze, pojawią się one w tablicy, jak również.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> jest `static` metody, dzięki czemu można wywołać dla <xref:System.Diagnostics.EventLog> samej klasy. Nie jest niezbędne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> obiekt do wywołania metody.  
  
 Aby pobrać listę dzienników zdarzeń, musi mieć odpowiednich uprawnień rejestru. Te uprawnienia są identyczne z tymi wymagane do wywołania <xref:System.Diagnostics.EventLog.Exists%2A> i <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Poniższy przykład pobiera listę dzienniki na komputerze "myServer". Wyświetla nazwę każdego dziennika.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametru jest nieprawidłowa nazwa komputera.</exception>
        <exception cref="T:System.InvalidOperationException">Nie masz dostępu do odczytu do rejestru.  
  
—lub— 
Nie ma żadnej usługi dziennika zdarzeń na komputerze.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę dziennika do odczytu lub zapisu.</summary>
        <value>Nazwa dziennika. Może to być aplikacji "," System "," zabezpieczenia "lub" Nazwa dziennika niestandardowego. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trzy pliki dziennika znajdują się domyślnie na serwerze: aplikacji, System i zabezpieczenia. Aplikacje i usługi, należy użyć pliku dziennika aplikacji. Sterowniki urządzeń, użyj pliku dziennika systemowego. Po włączeniu inspekcji, sukcesów i niepowodzeń zdarzenia inspekcji w dzienniku zabezpieczeń wygenerowany przez system. Jeśli masz inne aplikacje zainstalowane, takich jak usługi Active Directory na serwerach Windows może być inne domyślne pliki dziennika. Ponadto można tworzyć pliki dzienników niestandardowych na komputerze lokalnym lub zdalnym. Niestandardowe dzienniki pomagają zorganizować wpisy w sposób bardziej szczegółowe niż jest dozwolone, gdy składniki zapis zdarzeń w dzienniku aplikacji domyślnej.  
  
> [!NOTE]
>  Nazwy dzienników mogą zawierać maksymalnie osiem znaków. Zgodnie z systemu MyLogSample1 i MyLogSample2 są tego samego dziennika.  
  
 Jeśli piszesz w dzienniku zdarzeń nie jest wystarczająco, aby określić <xref:System.Diagnostics.EventLog.Log%2A> właściwości. Musisz skojarzyć <xref:System.Diagnostics.EventLog.Source%2A> właściwości z zasobem usługi dziennika zdarzeń, aby podłączyć ją do określonego dziennika. Nie jest konieczne określić <xref:System.Diagnostics.EventLog.Source%2A> gdy tylko do odczytu z dziennika, ale źródłem zdarzenia muszą być skojarzone z zasobu dziennika zdarzeń w rejestrze serwera. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwy i <xref:System.Diagnostics.EventLog.MachineName%2A> (nazwa komputera serwera) można odczytać z niego.  
  
> [!NOTE]
>  Nie musisz określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się w dzienniku. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Source%2A> właściwość nie została określona, wywołanie <xref:System.Diagnostics.EventLog.Log%2A> zwraca pusty ciąg, jeśli <xref:System.Diagnostics.EventLog.Log%2A> nie została jawnie ustawiona (przez ustawienie <xref:System.Diagnostics.EventLog.Log%2A> właściwości lub za pomocą konstruktora). Jeśli <xref:System.Diagnostics.EventLog.Source%2A> została określona, <xref:System.Diagnostics.EventLog.Log%2A> zwraca nazwę dziennika, do którego zarejestrowano to źródło.  
  
 Źródła można zarejestrować tylko jeden dziennik w czasie. Jeśli <xref:System.Diagnostics.EventLog.Source%2A> właściwość została ustawiona dla wystąpienia programu <xref:System.Diagnostics.EventLog>, nie można zmienić <xref:System.Diagnostics.EventLog.Log%2A> właściwość, która <xref:System.Diagnostics.EventLog> bez konieczności zmieniania wartości <xref:System.Diagnostics.EventLog.Source%2A> lub wywoływania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> pierwszy. Jeśli zmienisz <xref:System.Diagnostics.EventLog.Log%2A> właściwości po <xref:System.Diagnostics.EventLog.Source%2A> właściwość została ustawiona, zapisywania wpisów dziennika zgłasza wyjątek.  
  
 Dzienniki zdarzeń systemu operacyjnego są przechowywane jako pliki. Kiedy używasz <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do utworzenia nowego dziennika zdarzeń, skojarzony plik jest przechowywany w katalogu %SystemRoot%\System32\Config na określonym komputerze. Nazwa pliku jest ustawiona, dodając pierwsze 8 znaków <xref:System.Diagnostics.EventLog.Log%2A> właściwości z rozszerzeniem nazwy pliku ".evt".  
  
 Nie można utworzyć nowego dziennika przy użyciu <xref:System.Diagnostics.EventLog.Log%2A> właściwość samodzielnie (bez określania źródła dla dziennika). Możesz wywołać <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, przekazując nazwę dziennika jako parametr, a następnie wywołaj <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Jednak celem jest zwykle albo utwórz (i zapisywanie wpisów, aby) nowe dzienniki specyficzne dla aplikacji, lub do odczytu z istniejących dzienników.  
  
 Jeśli <xref:System.Diagnostics.EventLog.Log%2A> zmiany wartości w dzienniku zdarzeń zostanie zamknięte, a wszystkie uchwyty zdarzeń są zwalniane.  
  
> [!CAUTION]
>  Jeśli ustawisz <xref:System.Diagnostics.EventLog.Log%2A> właściwość na nazwę dziennika, który nie istnieje, system dołączy <xref:System.Diagnostics.EventLog> w dzienniku aplikacji, ale nie ostrzega użytkownika że korzysta on dziennika innej niż określono.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń, "NewEventLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przyjazną nazwę dziennika zdarzeń.</summary>
        <value>Nazwa, która reprezentuje dziennika zdarzeń w Podglądzie zdarzeń systemu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Windows Vista i nowszych użytkownicy mają uprawnienia dostępu do dziennika zabezpieczeń. Jeśli korzystasz z Windows Vista lub nowszym jako użytkownik, zostanie wyświetlony <xref:System.Security.SecurityException> podczas próby dostępu nazwę wyświetlaną dla zdarzenia w dzienniku zabezpieczeń.  
>   
>  W systemie Windows Vista i nowszych Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla <xref:System.Diagnostics.EventLog.LogDisplayName%2A> dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Określony <see cref="P:System.Diagnostics.EventLog.Log" /> nie istnieje w rejestrze dla tego komputera.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Możliwość odczytu wskazanego klucza rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Możliwość dostępu do wskazanego klucza rejestru, jeśli jest to klucz zdalny. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzeń.</param>
        <param name="machineName">Nazwa komputera, na którym do wyszukiwania, lub "." na komputerze lokalnym.</param>
        <summary>Pobiera nazwę dziennika, w której jest zarejestrowana określonego źródła.</summary>
        <returns>Nazwa dziennika skojarzonych z określonego źródła w rejestrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródło zdarzeń wskazuje, które dzienniki zdarzeń. Często jest nazwa aplikacji lub nazwy podskładnika aplikacji, jeśli aplikacja jest duży. Aplikacje i usługi należy zapisać w dzienniku aplikacji lub dziennik niestandardowy. Sterowniki urządzeń należy zapisać w dzienniku systemu.  
  
 Podczas tworzenia nowego źródła w danym momencie tylko może zapisywać w jednym dzienniku, system rejestruje aplikację z dziennika zdarzeń jako poprawne źródło wpisów. <xref:System.Diagnostics.EventLog.Source%2A> Właściwość może być dowolnym ciągiem, ale nazwa nie może używać innych źródeł na tym komputerze. Próba utworzenia zduplikowanych <xref:System.Diagnostics.EventLog.Source%2A> wartość zgłasza wyjątek. Jednak pojedynczy dziennik zdarzeń może mieć wielu różnych źródeł, zapisywanie do niego.  
  
   
  
## Examples  
 Poniższy przykład usuwa źródła z komputera lokalnego. Przykład określa dzienników ze źródła, a następnie usuwa dziennik.  
  
> [!NOTE]
>  Więcej niż jedno źródło może zapisać do dziennika zdarzeń. Przed usunięciem dziennika niestandardowego, upewnij się, brak innych źródeł, zapisywanie do tego dziennika.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym do odczytu lub zapisu zdarzenia.</summary>
        <value>Nazwa serwera, na którym znajduje się w dzienniku zdarzeń. Wartość domyślna to komputer lokalny (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli piszesz w dzienniku zdarzeń, należy skojarzyć <xref:System.Diagnostics.EventLog.Source%2A> z obiektem dziennika zdarzeń do nawiązywania połączenia z określonego dziennika. Nie jest konieczne określić <xref:System.Diagnostics.EventLog.Source%2A> właściwości tylko do odczytu z dziennika. Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A> nazwy i <xref:System.Diagnostics.EventLog.MachineName%2A> (nazwa komputera serwera).  
  
> [!NOTE]
>  Nie trzeba określać <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się w dzienniku. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 Źródła można zarejestrować tylko jeden dziennik w czasie. Jeśli <xref:System.Diagnostics.EventLog.Source%2A> właściwość została ustawiona dla wystąpienia programu <xref:System.Diagnostics.EventLog>, nie można zmienić <xref:System.Diagnostics.EventLog.MachineName%2A> właściwość, która <xref:System.Diagnostics.EventLog> bez konieczności zmieniania wartości <xref:System.Diagnostics.EventLog.Source%2A> lub wywoływania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> pierwszy. Jeśli zmienisz <xref:System.Diagnostics.EventLog.MachineName%2A> właściwości <xref:System.Diagnostics.EventLog> zamyka wszystkie dojścia i ponowne dołączenie następuje ponowne dziennika i źródła na nowym komputerze.  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A> Wartość nie może być ciągiem pustym. Jeśli nie jest jawnie ustawiona wartość domyślna to komputer lokalny (".").  
  
   
  
## Examples  
 Poniższy przykład odczytuje wpisy w dzienniku zdarzeń, "NewEventLog" na określonym komputerze.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa komputera jest nieprawidłowa.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar dziennika zdarzeń w kilobajtach.</summary>
        <value>Maksymalny rozmiar dziennika zdarzeń w kilobajtach. Wartość domyślna to 512, wskazujący maksymalny rozmiar pliku 512 kilobajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> Właściwość reprezentuje limit rozmiaru pliku dziennika zdarzeń. Jeśli dziennik zdarzeń osiągnie limit rozmiaru skonfigurowanych <xref:System.Diagnostics.EventLog.OverflowAction%2A> wartość określa, czy nowe wpisy zostaną odrzucone lub tego, czy nowe wpisy zastąpienie starszych wpisów.  
  
> [!NOTE]
>  Ta właściwość reprezentuje ustawienia konfiguracji dla dziennika zdarzeń, reprezentowane przez to wystąpienie. Jeśli dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy zapisywane przez wszystkie źródła zdarzenia zarejestrowane w dzienniku zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona wartość jest większa niż 64, większe niż 4194240 lub nie jest wielokrotnością 64.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest nazwą prawidłowego dziennika.  
  
\- lub — 
Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze docelowym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę dni przechowywania wpisów w dzienniku zdarzeń.</summary>
        <value>Liczba dni, które są przechowywane wpisy w dzienniku zdarzeń. Wartość domyślna to 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> właściwości, aby sprawdzić bieżące ustawienia dziennika zdarzeń. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> zmienić minimalną liczbę dni, które muszą zostać zachowane każdego wpisu w dzienniku zdarzeń.  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> Wartość zależy od zachowania skonfigurowanego przepełnienia dziennika zdarzeń. Jeśli <xref:System.Diagnostics.OverflowAction> do dziennika zdarzeń zostaje ustalona <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, a następnie <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość jest równa 0. Jeśli <xref:System.Diagnostics.OverflowAction> do dziennika zdarzeń zostaje ustalona <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, a następnie <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość -1. Jeśli <xref:System.Diagnostics.OverflowAction> do dziennika zdarzeń zostaje ustalona <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, a następnie <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartość jest większa od zera i reprezentuje liczbę dni przechowywania wpisów dziennika zdarzeń po zapełnieniu dziennika zdarzeń.  
  
 Zachowanie przepełnienie występuje tylko w przypadku, gdy dziennik zdarzeń osiągnie limit rozmiaru. Gdy <xref:System.Diagnostics.EventLog> ma jego <xref:System.Diagnostics.EventLog.OverflowAction%2A> równa <xref:System.Diagnostics.OverflowAction.OverwriteOlder>i dziennik zdarzeń osiągnie maksymalny rozmiar, a następnie nowe wpisy są zapisywane tylko jeśli one zastąpić wpisy, których wiek przekracza <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> okres. Zachowywanie zdarzeń wpisów przez co najmniej jest odpowiednie w przypadku, gdy w dzienniku zdarzeń zostaje zarchiwizowany regularnie. W przeciwnym razie istnieje ryzyko utraty nowe wpisy, gdy dziennik zdarzeń osiągnie limit. Aby uniknąć utraty nowych informacji o zdarzeniach, należy ustawić dni co najmniej zdarzenia oparte na harmonogramie archiwum dla określonego dziennika zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Zachowanie przepełnienie w pisaniu nowych wpisów w dzienniku zdarzeń.</param>
        <param name="retentionDays">Minimalna liczba dni, przez które każdy wpis dziennika zdarzeń są zachowywane. Ten parametr jest używany tylko wtedy, gdy <c>akcji</c> ustawiono <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Zmienia zachowanie skonfigurowanego do tworzenia nowych wpisów, gdy dziennik zdarzeń osiągnie rozmiar maksymalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie przepełnienia dziennika zdarzeń określa, co się stanie, gdy nowe wpisy, które mają być zapisywane w dzienniku, który osiągnął maksymalny rozmiar.  
  
> [!NOTE]
>  Zachowanie przepełnienie działa tylko wtedy, gdy dziennik zdarzeń osiągnie rozmiar maksymalny. Zachowanie przepełnienie nie ma wpływu na zapisywania nowego wpisu dziennika, która może pomieścić wpisy w dzienniku zdarzeń dodatkowe.  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> Metody określa zachowanie przepełnienia dziennika zdarzeń. <xref:System.Diagnostics.EventLog> wystąpienie. Po wywołaniu tej metody dla dziennika zdarzeń określony przez <xref:System.Diagnostics.EventLog.Log%2A> właściwości <xref:System.Diagnostics.EventLog.OverflowAction%2A> i <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> wartości właściwości odzwierciedlają zachowanie nowo skonfigurowanego przepełnienia.  
  
> [!NOTE]
>  Ta właściwość reprezentuje ustawienia konfiguracji dla dziennika zdarzeń, reprezentowane przez to wystąpienie. Jeśli dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy zapisywane przez wszystkie źródła zdarzenia zarejestrowane w dzienniku zdarzeń.  
  
 Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> do wskazania, że nowy wpis zastępuje najstarsza podczas <xref:System.Diagnostics.EventLog> osiągnie maksymalny rozmiar. Jeśli `action` parametr ma wartość <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, `retentionDays` wartość parametru jest ignorowana.  
  
 Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction.OverwriteOlder> do wskazania, że każdy nowy wpis zastępuje starsze wpisy podczas <xref:System.Diagnostics.EventLog> osiągnie maksymalny rozmiar. Określ liczbę dni, które muszą zostać zachowane zdarzenia w dzienniku, używając `retentionDays` parametru. Zdarzeń zapisanych w zakresie przechowywania nie są zastępowane przez nowe wpisy.  
  
 Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> można odrzucić nowe zdarzenia po osiągnięciu maksymalnego rozmiaru dziennika. Jeśli `action` parametr ma wartość <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, `retentionDays` wartość parametru jest ignorowana.  
  
> [!CAUTION]
>  Ustawienie zasad przepełnienie <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> Określa, że nowe wpisy zostaną odrzucone po zapełnieniu dziennika zdarzeń. Jeśli używasz tego ustawienia, upewnij się, regularnie zarchiwizowane i wyczyszczone, aby uniknąć osiągnięcia limit maksymalnego rozmiaru dziennika zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zasady przepełnienie skonfigurowanego dla określonego dziennika zdarzeń i umożliwia użytkownikowi wybranie nowe ustawienie zasad przepełnienia dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> nie jest prawidłowym <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> wartość.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> jest mniejsza niż, większe niż 365.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest nazwą prawidłowego dziennika.  
  
\- lub — 
Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze docelowym.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zachowanie skonfigurowane do przechowywania nowe wpisy, gdy dziennik zdarzeń osiągnie jej maksymalny rozmiar pliku dziennika.</summary>
        <value>
          <see cref="T:System.Diagnostics.OverflowAction" /> Wartość, która określa zachowanie skonfigurowane do przechowywania nowe wpisy, gdy dziennik zdarzeń osiągnie jej maksymalny rozmiar dziennika. Wartość domyślna to <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzienniki zdarzeń zwiększanie rozmiaru jak nowe zdarzenia są zapisywane do nich. Każdy dziennik zdarzeń obowiązuje limit maksymalnego skonfigurowanego rozmiaru; <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> właściwość definiuje maksymalną liczbę kilobajtów dozwolony rozmiar pliku dziennika zdarzeń.  
  
 Użyj <xref:System.Diagnostics.EventLog.OverflowAction%2A> wartości właściwości, aby sprawdzić zachowanie skonfigurowanego przepełnienia dziennika zdarzeń w maksymalnego rozmiaru. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> metodę, aby zmienić zachowanie przepełnienia dziennika zdarzeń.  
  
> [!NOTE]
>  Zachowanie przepełnienie działa tylko wtedy, gdy dziennik zdarzeń osiągnie rozmiar maksymalny. Zachowanie przepełnienie nie ma wpływu na zapisywania nowego wpisu dziennika, która może pomieścić wpisy w dzienniku zdarzeń dodatkowe.  
  
   
  
## Examples  
 Poniższy przykład wylicza dzienniki zdarzeń zdefiniowane na komputerze lokalnym i wyświetla szczegóły konfiguracji dla każdego dziennika zdarzeń.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Pełna ścieżka do zlokalizowanego pliku zasobu.</param>
        <param name="resourceId">Identyfikator zasobu, która indeksuje zlokalizowany ciąg w pliku zasobów.</param>
        <summary>Określa zlokalizowana nazwa dziennika zdarzeń, który jest wyświetlany na serwerze programu Podgląd zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> zarejestrowania się i zlokalizowane nazwy wyświetlanej w Podglądzie zdarzeń niestandardowych dzienników zdarzeń.  
  
 Zlokalizowany ciąg zdefiniowane w pliku zasobów musi odpowiadać identyfikator określonego zasobu. Podgląd zdarzeń wyświetla nazwę niestandardowy dziennik zdarzeń przy użyciu zlokalizowany ciąg i bieżące ustawienia kultury. Na przykład można zdefiniować wiele nazw dziennika zdarzeń zlokalizowane dla różnych kultur, w pliku zasobów. Podgląd zdarzeń wyświetla zlokalizowany ciąg odpowiadający ustawienia kultury bieżącego użytkownika.  
  
 Jeśli Podgląd zdarzeń, nie można załadować zlokalizowany ciąg z pliku zasobów lub jeśli nazwa wyświetlana nie został zarejestrowany do dziennika zdarzeń, następnie Podgląd zdarzeń wyświetla nazwę dziennika zdarzeń zdefiniowanych w <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Nie trzeba zarejestrować nazwę wyświetlaną dla wstępnie zdefiniowanej dzienników zdarzeń. System operacyjny rejestruje nazwy wyświetlane zlokalizowane dzienniki zdarzeń aplikacji, System i zabezpieczenia.  
  
   
  
## Examples  
 Poniższy przykład określa, czy źródło zdarzeń o nazwie `SampleApplicationSource` jest zarejestrowana na komputerze lokalnym. Jeśli nie ma źródła zdarzeń, przykład ustawia pliku zasobów komunikatów dla źródła i tworzy nowe źródło zdarzeń. Ponadto w przykładzie zlokalizowana nazwa wyświetlana dla dziennika zdarzeń, używając wartości identyfikatora zasobu w `DisplayNameMsgId` i ścieżka pliku zasobów w `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 W przykładzie użyto następującego pliku tekst komunikatu wbudowana w bibliotekę zasobu EventLogMsgs.dll. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatory zasobów i tekst dla kategorii, komunikatów o zdarzeniach i ciągi wstawiania parametru. W szczególności identyfikator zasobu 5001 jest zdefiniowany dla zlokalizowana nazwa dziennika zdarzeń.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> Wartość nie jest nazwą prawidłowego dziennika.  
  
\- lub — 
Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze docelowym.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do administrowania informacje w dzienniku zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę źródła do zarejestrowania i używania podczas zapisywania w dzienniku zdarzeń.</summary>
        <value>Nazwa zarejestrowany jako źródło wpisów w dzienniku zdarzeń. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródło zdarzeń wskazuje, które dzienniki zdarzeń. Często jest nazwa aplikacji lub nazwy podskładnika aplikacji, jeśli aplikacja jest duży. Aplikacje i usługi należy zapisać w dzienniku aplikacji lub dziennik niestandardowy. Sterowniki urządzeń należy zapisać w dzienniku systemu.  
  
 Należy określić źródło zdarzenia, jeśli będą zapisywane do dziennika zdarzeń. Przed zapisaniem wpis dziennika zdarzeń, należy zarejestrować źródła zdarzeń z dziennika zdarzeń jako poprawne źródło zdarzeń. Podczas zapisywania wpisów dziennika, wówczas system używa <xref:System.Diagnostics.EventLog.Source%2A> właściwości, aby znaleźć odpowiedniego dziennika, w której chcesz umieścić zgłoszenia użytkownika. Jeśli podczas odczytu dziennika zdarzeń, można określić <xref:System.Diagnostics.EventLog.Source%2A>, lub <xref:System.Diagnostics.EventLog.Log%2A> i <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Nie musisz określić <xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli łączysz się dziennika na komputerze lokalnym. Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (".") zakłada, że.  
  
 Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> i <xref:System.Diagnostics.EventLog.WriteEntry%2A> się zapisać zdarzeń do dziennika zdarzeń. Należy określić źródło zdarzenia można zapisać zdarzenia; należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennika nie jest tworzony, dopóki pierwszy wpis jest zapisywany do niego.  
  
 Źródłowy musi być unikatowa na komputerze lokalnym. nowej nazwy źródła nie może dopasować istniejącej nazwy źródła lub istniejącą nazwę dziennika zdarzeń. Każde źródło może zapisywać tylko jeden dziennik zdarzeń jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników. Na przykład aplikacja może wymagać wielu źródeł, skonfigurowanych dla różnych dziennikach zdarzeń lub plików innego zasobu.  
  
 Jeśli zmienisz <xref:System.Diagnostics.EventLog.Source%2A> wartość <xref:System.Diagnostics.EventLog> do którego został on zarejestrowany jest zamknięte, a wszystkie uchwyty zdarzeń są zwalniane.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
 Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Jeśli używasz istniejącego źródła, inne aplikacje lub składniki, Utwórz nowe źródło przy użyciu zaktualizowanej konfiguracji, a nie usunięcie istniejącego źródła.  
  
> [!NOTE]
>  Jeśli ponownie mapować je na nowy dziennik źródła został już zmapowany do dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` Jeśli jeszcze nie istnieje i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje w rejestrze komputera dla danego źródła zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzeń.</param>
        <summary>Określa, czy źródłem zdarzenia jest zarejestrowany na komputerze lokalnym.</summary>
        <returns>
          <see langword="true" /> Jeśli źródło zdarzenia jest zarejestrowany na komputerze lokalnym. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest przydatna w celu ustalenia, czy źródło zdarzenia istnieje na komputerze lokalnym. Jeśli chcesz określić, czy dziennik istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na komputerze lokalnym. w przeciwnym razie <xref:System.Security.SecurityException> zostanie zgłoszony.  
  
> [!NOTE]
>  Aby wyszukać źródła zdarzeń w Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administracyjne.  
>   
>  Przyczyna tego wymagania jest, że wszystkie dzienniki zdarzeń, w tym zabezpieczeń, musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> zgłaszany.  
>   
>  Począwszy od Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
> [!NOTE]
>  Usługi, które jest wykonywane w ramach <xref:System.ServiceProcess.ServiceAccount.LocalSystem> konto nie ma uprawnienia wymagane do wykonania tej metody. Rozwiązaniem jest sprawdzenie, czy źródło zdarzenia istnieje w <xref:System.ServiceProcess.ServiceInstaller>, a jeśli on nie istnieje, można utworzyć źródła w Instalatorze.  
  
 Ponieważ nowe źródło nie można nadać nazwę istniejącego źródła na tym samym komputerze, ta metoda umożliwia przed podjęciem próby wykonania wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do upewnij się, że źródło o nazwie określonej przez `source` jeszcze nie istnieje na komputerze lokalnym. `source` Parametr nie jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` Jeśli jeszcze nie istnieje i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> Nie można odnaleźć, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzeń.</param>
        <param name="machineName">Nazwa komputera, na którym do wyszukiwania, lub "." na komputerze lokalnym.</param>
        <summary>Określa, czy źródłem zdarzenia jest zarejestrowany na określonym komputerze.</summary>
        <returns>
          <see langword="true" /> Jeśli źródło zdarzenia jest zarejestrowany na danym komputerze. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do określenia, czy źródło zdarzenia istnieje na komputerze określonym przez `machineName` parametru. Jeśli chcesz określić, czy dziennik istnieje na określonym komputerze, użyj <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na danym serwerze; w przeciwnym razie <xref:System.Security.SecurityException> zostanie zgłoszony.  
  
> [!NOTE]
>  Aby wyszukać źródła zdarzeń w Windows Vista lub nowszym lub Windows Server 2003, musi mieć uprawnienia administracyjne.  
>   
>  Przyczyna tego wymagania jest, że wszystkie dzienniki zdarzeń, w tym zabezpieczeń, musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od Windows Vista, użytkownicy nie mają uprawnień dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException> zgłaszany.  
>   
>  Począwszy od Windows Vista, Kontrola konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem wbudowanej grupy Administratorzy, masz przypisane dwa tokeny dostępu w czasie wykonywania: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie jesteś w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musisz najpierw podwyższenie swoje uprawnienia z użytkownika standardowego do administratora. Można to zrobić, po uruchomieniu aplikacji, kliknij prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.  
  
> [!NOTE]
>  Usługi, które jest wykonywane w ramach <xref:System.ServiceProcess.ServiceAccount.LocalSystem> konto nie ma uprawnienia wymagane do wykonania tej metody. Rozwiązaniem jest sprawdzenie, czy źródło zdarzenia istnieje w <xref:System.ServiceProcess.ServiceInstaller>, a jeśli on nie istnieje, można utworzyć źródła w Instalatorze.  
  
 Ponieważ nowe źródło nie można nadać nazwę istniejącego źródła na tym samym komputerze, ta metoda umożliwia przed podjęciem próby wykonania wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> do upewnij się, że źródło o nazwie określonej przez `source` jeszcze nie istnieje na komputerze. `source` i `machineName` parametry nie są z uwzględnieniem wielkości liter.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> jest `static` metody, dzięki czemu można wywołać w samej klasy. Nie jest niezbędne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog> do wywołania <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` na komputerze `MyServer`i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> jest prawidłową nazwą komputera.</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="source" /> Nie można odnaleźć, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane na <see cref="T:System.Diagnostics.EventLog" /> wpis zapisywane zdarzenie.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Używany do organizowania wywołania programu obsługi zdarzeń na <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> zdarzenia w dzienniku zdarzeń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> jest `null`, metody obsługi <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenie są wywoływane w wątku z puli wątków systemu. Aby uzyskać więcej informacji na temat pul wątków systemu, zobacz <xref:System.Threading.ThreadPool>.  
  
 Gdy <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenie jest obsługiwane przez visual formularze Windows składnika, takiego jak przycisk, dostęp do składnika za pośrednictwem puli wątków systemu mogą nie działać i może prowadzić do wyjątku. Tego uniknąć, ustawiając <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> do składnika Windows Forms, co powoduje, że metody obsługi <xref:System.Diagnostics.EventLog.EntryWritten> zdarzenie ma być wywołane na tym samym wątku, na którym została utworzona składnika.  
  
 Jeśli <xref:System.Diagnostics.EventLog> jest używana wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w Projektancie Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> automatycznie zostaje ustawiony poziom kontroli zawierający <xref:System.Diagnostics.EventLog>. Na przykład jeśli umieścisz <xref:System.Diagnostics.EventLog> w Projektancie formularza Form1 (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> właściwość <xref:System.Diagnostics.EventLog> jest ustawiona na wystąpienie formularza Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wpis dziennika zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <summary>Zapisuje wpis typu informacji z tekstem danej komunikatów w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu informacji w dzienniku zdarzeń skojarzonych z tym <xref:System.Diagnostics.EventLog> wystąpienia. Jeśli chcesz określić inne <xref:System.Diagnostics.EventLogEntryType>, użyj innego przeciążenia <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwość swoje <xref:System.Diagnostics.EventLog> składnika, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwość to <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowana na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> za pomocą wywołania <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwości nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane przez błędy zgłoszone podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli piszesz wpis z komputerem zdalnym wartość komunikatu (ciąg tekstowy) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiona w .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` Jeśli jeszcze nie istnieje i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwę komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
\- lub — 
Źródło jest już zarejestrowany dla różnych dziennika zdarzeń.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <summary>Zapisuje błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub błąd inspekcji wpisu z tekstem danej komunikatów w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu określonego <xref:System.Diagnostics.EventLogEntryType> w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwość swoje <xref:System.Diagnostics.EventLog> składnika, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwość to <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowana na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> za pomocą wywołania <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwości nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane przez błędy zgłoszone podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli piszesz wpis z komputerem zdalnym wartość komunikatu (ciąg tekstowy) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiona w .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis ostrzeżenie dziennik zdarzeń "MyNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwę komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
\- lub — 
Źródło jest już zarejestrowany dla różnych dziennika zdarzeń.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <summary>Zapisuje wpis typu informacji o tekst danego komunikatu dziennika zdarzeń, przy użyciu źródła określonego zdarzenia zarejestrowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapisu informacji w dzienniku zdarzeń, korzystanie ze źródła, która jest już zarejestrowana jako źródła zdarzeń dla odpowiedniego dziennika. Jeśli chcesz określić inne <xref:System.Diagnostics.EventLogEntryType>, użyj innego przeciążenia <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
>   
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład tworzy źródła `MySource` Jeśli jeszcze nie istnieje i zapisuje wpis dziennika zdarzeń `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest ciągiem pustym ("").  
  
\- lub — 
<paramref name="source" /> Wartość <see langword="null" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <summary>Zapisuje wpis z podanym komunikatem tekstu i identyfikator zdarzenia, zdefiniowany przez aplikację w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu przy użyciu zdefiniowanych przez aplikację `eventID` w dzienniku zdarzeń. `eventID` Wraz z źródła identyfikują zdarzenie. Każda aplikacja można zdefiniować własne zdarzenia numerowanej i ciągi opisów, które mapują. Osoby przeglądające zdarzeń wyświetlania tych wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle, a także sugerują, jakie działania należy podjąć.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
 Oprócz identyfikator zdarzenia można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwość swoje <xref:System.Diagnostics.EventLog> składnika, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwość to <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowana na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> za pomocą wywołania <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwości nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane przez błędy zgłoszone podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli piszesz wpis z komputerem zdalnym wartość komunikatu (ciąg tekstowy) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiona w .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwę komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
\- lub — 
Źródło jest już zarejestrowany dla różnych dziennika zdarzeń.  
  
\- lub — 
 <paramref name="eventID" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <summary>Zapisuje dziennik zdarzeń przy użyciu źródła określonego zdarzenia zarejestrowane błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub błąd inspekcji wpisu z tekstem z podanym komunikatem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu określonego <xref:System.Diagnostics.EventLogEntryType> w dzienniku zdarzeń korzystanie ze źródła już zarejestrowany jako źródła zdarzeń dla odpowiedniego dziennika. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis ostrzeżenie dziennik zdarzeń "MyNewLog" na komputerze lokalnym.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest ciągiem pustym ("").  
  
\- lub — 
<paramref name="source" /> Wartość <see langword="null" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <summary>Zapisuje wpis z podanym komunikatem tekstu, identyfikator zdarzenia, zdefiniowany przez aplikację i kategorii zdefiniowanych przez aplikację w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu przy użyciu zdefiniowanych przez aplikację `category` w dzienniku zdarzeń. Podgląd zdarzeń używa kategorii, aby filtrować zdarzenia zapisywane przez źródła zdarzenia. Podgląd zdarzeń, można wyświetlić kategorii jako wartość liczbową lub kategorii go używać jako identyfikator zasobu, do wyświetlenia ciągu zlokalizowanej kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Negatywna Kategoria wartości są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 pojawia się jako 65,526, -1 jako 65 535.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzeń skonfigurowany z pliku zasobów kategorii, a następnie ustaw `category` identyfikator zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie jest plikiem zasobów skonfigurowanych kategorii lub określone `category` indeksowania ciąg w pliku zasobów kategorii, Podgląd zdarzeń będzie wyświetlać wartość liczbową kategorii dla tego wpisu. Konfigurowanie pliku zasobów kategorii, wraz z liczbą parametrów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Oprócz danej kategorii możesz określić identyfikator zdarzenia dla zdarzenia są zapisywane w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz z źródła zdarzeń jednoznacznie identyfikują zdarzenie. Każda aplikacja można zdefiniować własne zdarzenia numerowanej i ciągi opisów, które mapują. Osoby przeglądające zdarzeń wyświetlania tych wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle, a także sugerują, jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwość swoje <xref:System.Diagnostics.EventLog> składnika, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwość to <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowana na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> za pomocą wywołania <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwości nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane przez błędy zgłoszone podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli piszesz wpis z komputerem zdalnym wartość komunikatu (ciąg tekstowy) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiona w .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwę komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
\- lub — 
Źródło jest już zarejestrowany dla różnych dziennika zdarzeń.  
  
\- lub — 
 <paramref name="eventID" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <summary>Zapisuje wpis z podanym komunikatem tekstu i identyfikator zdarzenia, zdefiniowany przez aplikację do dziennika zdarzeń przy użyciu źródła określonego zdarzenia zarejestrowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu przy użyciu zdefiniowanych przez aplikację `eventID` w dzienniku zdarzeń korzystanie ze źródła już zarejestrowany jako źródła zdarzeń dla odpowiedniego dziennika. `eventID`, Wraz ze źródła, identyfikują zdarzenie. Każda aplikacja można zdefiniować własne zdarzenia numerowanej i ciągi opisów, które mapują. Osoby przeglądające zdarzenia są wyświetlane te ciągi użytkownika, aby pomóc użytkownikowi zrozumieć, co poszło źle, a także sugerują, jakie działania należy podjąć.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
 Oprócz identyfikatora zdarzenia to przeciążenia <xref:System.Diagnostics.EventLog.WriteEntry%2A> umożliwia określenie <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest ciągiem pustym ("").  
  
\- lub — 
<paramref name="source" /> Wartość <see langword="null" />.  
  
\- lub — 
 <paramref name="eventID" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <param name="rawData">Tablicę bajtów zawierającą dane binarne skojarzone z wpisem.</param>
        <summary>Zapisuje wpis z podanym komunikatem tekstu, identyfikator zdarzenia, zdefiniowany przez aplikację i kategorii zdefiniowanych przez aplikację do dziennika zdarzeń i dołącza dane binarne do wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można zapisać danych specyficznych dla zdarzeń zdefiniowanych przez aplikację do dziennika zdarzeń. Podgląd zdarzeń nie interpretuje tych danych; nieprzetworzone dane są wyświetlane tylko w formacie szesnastkowym i tekstowym połączone. Za pomocą danych dotyczących zdarzeń rzadko, takiego jak go tylko wtedy, gdy masz pewność, że są one przydatne do kogoś debugowanie problemu. Umożliwia także dane dotyczące zdarzeń do przechowywania informacji, które aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Na przykład można napisać przeglądarka specjalnie dla zdarzeń lub napisz program, który skanuje plik dziennika, która tworzy raporty, które zawierają informacje z danych specyficznych dla zdarzeń.  
  
 Oprócz danych binarnych można określić kategorii zdefiniowanych przez aplikację i identyfikator zdarzenia, zdefiniowany przez aplikację. Podgląd zdarzeń używa kategorii, aby filtrować zdarzenia zapisywane przez źródła zdarzenia. Podgląd zdarzeń, można wyświetlić kategorii jako wartość liczbową lub kategorii go używać jako identyfikator zasobu, do wyświetlenia ciągu zlokalizowanej kategorii.  
  
> [!NOTE]
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Negatywna Kategoria wartości są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 pojawia się jako 65,526, -1 jako 65 535.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzeń skonfigurowany z pliku zasobów kategorii, a następnie ustaw `category` identyfikator zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie jest plikiem zasobów skonfigurowanych kategorii lub określone `category` indeksowania ciąg w pliku zasobów kategorii, Podgląd zdarzeń będzie wyświetlać wartość liczbową kategorii dla tego wpisu. Konfigurowanie pliku zasobów kategorii, wraz z liczbą parametrów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Identyfikatory zdarzeń, wraz z źródła zdarzeń jednoznacznie identyfikują zdarzenie. Każda aplikacja można zdefiniować własne zdarzenia numerowanej i ciągi opisów, które mapują. Osoby przeglądające zdarzeń wyświetlania tych wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle, a także sugerują, jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwość swoje <xref:System.Diagnostics.EventLog> składnika, aby można było tworzyć wpisy w dzienniku. Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem.  
  
 Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A> właściwość to <xref:System.Diagnostics.EventLog> wystąpienia nie jest zarejestrowana na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A> wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A> i rejestruje źródła.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A> lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (".") zakłada, że.  
  
 Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A> za pomocą wywołania <xref:System.Diagnostics.EventLog.WriteEntry%2A> i <xref:System.Diagnostics.EventLog.Log%2A> właściwości nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog> wystąpienia, domyślnie dziennika w dzienniku aplikacji.  
  
> [!NOTE]
>  Wiele wyjątków wymienionych powyżej są generowane przez błędy zgłoszone podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli piszesz wpis z komputerem zdalnym wartość komunikatu (ciąg tekstowy) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiona w .NET Framework.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwę komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
\- lub — 
Źródło jest już zarejestrowany dla różnych dziennika zdarzeń.  
  
\- lub — 
 <paramref name="eventID" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <summary>Zapisuje wpis z podanym komunikatem tekstu, identyfikator zdarzenia, zdefiniowany przez aplikację i kategorii zdefiniowanych przez aplikację do dziennika zdarzeń przy użyciu źródła określonego zdarzenia zarejestrowane. <paramref name="category" /> Mogą być używane przez Podgląd zdarzeń, aby filtrować zdarzenia w dzienniku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do zapisu przy użyciu zdefiniowanych przez aplikację `category` w dzienniku zdarzeń za pomocą źródła, która jest już zarejestrowana jako źródła zdarzeń dla odpowiedniego dziennika. Podgląd zdarzeń używa kategorii, aby filtrować zdarzenia zapisywane przez źródła zdarzenia. Podgląd zdarzeń, można wyświetlić kategorii jako wartość liczbową lub kategorii go używać jako identyfikator zasobu, do wyświetlenia ciągu zlokalizowanej kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Negatywna Kategoria wartości są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 pojawia się jako 65,526, -1 jako 65 535.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzeń skonfigurowany z pliku zasobów kategorii, a następnie ustaw `category` identyfikator zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie jest plikiem zasobów skonfigurowanych kategorii lub określone `category` indeksowania ciąg w pliku zasobów kategorii, Podgląd zdarzeń będzie wyświetlać wartość liczbową kategorii dla tego wpisu. Konfigurowanie pliku zasobów kategorii, wraz z liczbą parametrów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Oprócz danej kategorii możesz określić identyfikator zdarzenia dla zdarzenia są zapisywane w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz z źródła zdarzeń jednoznacznie identyfikują zdarzenie. Każda aplikacja można zdefiniować własne zdarzenia numerowanej i ciągi opisów, które mapują. Osoby przeglądające zdarzeń wyświetlania tych wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle, a także sugerują, jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
>   
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest ciągiem pustym ("").  
  
\- lub — 
<paramref name="source" /> Wartość <see langword="null" />.  
  
\- lub — 
 <paramref name="eventID" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Źródło, za pomocą którego aplikacja jest zarejestrowana na określonym komputerze.</param>
        <param name="message">Ciąg do zapisu w dzienniku zdarzeń.</param>
        <param name="type">Jedną z <see cref="T:System.Diagnostics.EventLogEntryType" /> wartości.</param>
        <param name="eventID">Identyfikator zdarzenia specyficzne dla aplikacji.</param>
        <param name="category">Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością.</param>
        <param name="rawData">Tablicę bajtów zawierającą dane binarne skojarzone z wpisem.</param>
        <summary>Zapisuje wpis z podanym komunikatem tekstu, identyfikator zdarzenia, zdefiniowany przez aplikację i kategorii zdefiniowanych przez aplikację w dzienniku zdarzeń (przy użyciu źródła określonego zdarzenia zarejestrowane) i dołącza dane binarne do wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody można zapisać danych specyficznych dla zdarzeń zdefiniowanych przez aplikację do dziennika zdarzeń, korzystanie ze źródła już zarejestrowany jako źródła zdarzeń dla odpowiedniego dziennika. Podgląd zdarzeń nie interpretuje tych danych; nieprzetworzone dane są wyświetlane tylko w formacie szesnastkowym i tekstowym połączone. Korzystanie z danych specyficznych dla zdarzeń oszczędnie; Uwzględnij go tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane dotyczące zdarzeń do przechowywania informacji, które aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Na przykład można napisać przeglądarka specjalnie dla zdarzeń lub napisz program, który skanuje plik dziennika, która tworzy raporty, które zawierają informacje z danych specyficznych dla zdarzeń.  
  
 Oprócz danych binarnych można określić kategorii zdefiniowanych przez aplikację i identyfikator zdarzenia, zdefiniowany przez aplikację. Podgląd zdarzeń używa kategorii, aby filtrować zdarzenia zapisywane przez źródła zdarzenia. Podgląd zdarzeń, można wyświetlić kategorii jako wartość liczbową lub kategorii go używać jako identyfikator zasobu, do wyświetlenia ciągu zlokalizowanej kategorii.  
  
> [!NOTE]
>  `category` Parametr powinien być wartością dodatnią. Negatywna Kategoria wartości są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 pojawi się jako 65,526, -1 jako 65 535.  
  
 Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzeń skonfigurowany z pliku zasobów kategorii, a następnie ustaw `category` identyfikator zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie jest plikiem zasobów skonfigurowanych kategorii lub określone `category` indeksowania ciąg w pliku zasobów kategorii, Podgląd zdarzeń będzie wyświetlać wartość liczbową kategorii dla tego wpisu. Konfigurowanie pliku zasobów kategorii, wraz z liczbą parametrów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller> lub <xref:System.Diagnostics.EventSourceCreationData> klasy.  
  
 Identyfikatory zdarzeń, wraz z źródła zdarzeń jednoznacznie identyfikują zdarzenie. Każda aplikacja można zdefiniować własne zdarzenia numerowanej i ciągi opisów, które mapują. Osoby przeglądające zdarzeń wyświetlania tych wartości ciągu, aby pomóc użytkownikowi zrozumieć, co poszło źle, a także sugerują, jakie działania należy podjąć.  
  
 Ponadto można określić <xref:System.Diagnostics.EventLogEntryType> zdarzenia są zapisywane w dzienniku zdarzeń. `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. <xref:System.Diagnostics.EventLog.WriteEntry%2A> Metoda zapisuje podany ciąg bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów Lokalizowalny wiadomości. Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodę, aby zapisać zdarzenia przy użyciu pliku zasobów komunikatów zlokalizowanego.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.  
>   
>  `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest ciągiem pustym ("").  
  
\- lub — 
<paramref name="source" /> Wartość <see langword="null" />.  
  
\- lub — 
 <paramref name="eventID" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
Ciąg komunikatu jest dłuższa niż 31,839 bajtów (w bajtach 32 766 w systemach operacyjnych Windows przed Windows Vista).  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> nie jest prawidłowym <see cref="T:System.Diagnostics.EventLogEntryType" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wpis zlokalizowane zdarzenia w dzienniku zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienia, która reprezentuje wejścia zlokalizowany dziennika zdarzeń.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje wejścia zlokalizowany w dzienniku zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowane zapisu w dzienniku zdarzeń. Można określić właściwości zdarzenia z identyfikatorów zasobów, a nie wartości parametrów. Podgląd zdarzeń użyto identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródła przy użyciu odpowiedniego pliku zasobów.  
  
 Dane wejściowe `instance` wystąpienia określa komunikat zdarzenia i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` dane wejściowe na potrzeby wiadomości zdefiniowanej w źródłowym pliku zasobów komunikatów. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe, aby zdefiniować typ kategorii i zdarzenia zgłoszenia użytkownika zdarzeń. Można również określić tablicę ciągów niezależny od języka do wstawienia do tekstu komunikatów zlokalizowanego. Ustaw `values` do `null` Jeśli komunikatów o zdarzeniach nie zawiera symbole zastępcze formatowania ciągów zastępczych.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwość swoje <xref:System.Diagnostics.EventLog> składnik przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określona źródłowa musi być skonfigurowany do zapisywania zlokalizowanego wpisy w Dzienniku; co najmniej źródłowej musi mieć zdefiniowane pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli piszesz wpis z komputerem zdalnym, a wartość `message` ciąg może być oczekiwany Jeśli komputer zdalny nie jest uruchomiona w .NET Framework. Ponadto `message` ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład zapisuje dwa wpisy w dzienniku zdarzeń inspekcji `myNewLog`. Ten przykład tworzy nowe źródło zdarzeń i utworzenie nowego dziennika zdarzeń, jeśli nie istnieją na komputerze lokalnym. Tekst komunikatu o zdarzeniu jest określony, przy użyciu identyfikatora zasobu w pliku zasobów.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 W przykładzie użyto następującego pliku tekst komunikatu wbudowana w bibliotekę zasobu EventLogMsgs.dll. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatory zasobów i tekst dla kategorii, komunikatów o zdarzeniach i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwę komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
\- lub — 
Źródło jest już zarejestrowany dla różnych dziennika zdarzeń.  
  
\- lub — 
 <paramref name="instance.InstanceId" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
\- lub — 
Jedną z <paramref name="values" /> elementów jest dłuższa niż 32766 bajtów.  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienia, która reprezentuje wejścia zlokalizowany dziennika zdarzeń.</param>
        <param name="data">Tablicę bajtów zawierającą dane binarne skojarzone z wpisem.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje wpis dziennika zdarzeń z danymi podanego zdarzenia, ciągi wymiany komunikatów i skojarzone dane binarne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowane zapisu wraz z dodatkowymi danymi określonych zdarzeń w dzienniku zdarzeń. Można określić właściwości zdarzenia z identyfikatorów zasobów, a nie wartości parametrów. Podgląd zdarzeń użyto identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródła przy użyciu odpowiedniego pliku zasobów.  
  
 Dane wejściowe `instance` wystąpienia określa komunikat zdarzenia i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` dane wejściowe na potrzeby wiadomości zdefiniowanej w źródłowym pliku zasobów komunikatów. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe, aby zdefiniować typ kategorii i zdarzenia zgłoszenia użytkownika zdarzeń. Można również określić tablicę ciągów niezależny od języka do wstawienia do tekstu komunikatów zlokalizowanego. Ustaw `values` do `null` Jeśli komunikatów o zdarzeniach nie zawiera symbole zastępcze formatowania ciągów zastępczych.  
  
 Określ dane binarne do zdarzenia, gdy jest to konieczne w celu dostarczenie dodatkowych szczegółów zdarzenia. Na przykład użyć `data` parametru, aby podać informacje dotyczące określonego błędu. Podgląd zdarzeń nie interpretuje dane skojarzone ze zdarzeniem; dane są wyświetlane w formacie szesnastkowym i tekstowym połączone. Korzystanie z danych specyficznych dla zdarzeń oszczędnie; Uwzględnij go tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane dotyczące zdarzeń do przechowywania informacji, które aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Na przykład można napisać przeglądarka specjalnie dla zdarzeń lub napisz program, który skanowania dziennika zdarzeń, która tworzy raporty, które zawierają informacje z danych specyficznych dla zdarzeń.  
  
 Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A> właściwość swoje <xref:System.Diagnostics.EventLog> składnik przed składnik przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określona źródłowa musi być skonfigurowany do zapisywania zlokalizowanego wpisy w Dzienniku; co najmniej źródłowej musi mieć zdefiniowane pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
> [!NOTE]
>  Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A> dla Twojego <xref:System.Diagnostics.EventLog> wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEvent%2A>, komputer lokalny (".") zakłada, że.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
> [!NOTE]
>  Jeśli piszesz wpis z komputerem zdalnym, a wartość `message` ciąg może być oczekiwany Jeśli komputer zdalny nie jest uruchomiona w .NET Framework. Ponadto `message` ciąg nie może zawierać %*n*, gdzie *n* jest wartość całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciąg wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to znak sekwencji, nie może rejestrować komunikat zdarzenia, który zawiera adres IPv6.  
  
   
  
## Examples  
 Poniższy przykład zapisuje dwa wpisy w dzienniku zdarzeń inspekcji `myNewLog`. Ten przykład tworzy nowe źródło zdarzeń i utworzenie nowego dziennika zdarzeń, jeśli nie istnieją na komputerze lokalnym. Tekst komunikatu o zdarzeniu jest określony, przy użyciu identyfikatora zasobu w pliku zasobów.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 W przykładzie użyto następującego pliku tekst komunikatu wbudowana w bibliotekę zasobu EventLogMsgs.dll. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatory zasobów i tekst dla kategorii, komunikatów o zdarzeniach i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> Właściwość <see cref="T:System.Diagnostics.EventLog" /> nie została ustawiona.  
  
—lub— 
Metoda próbował zarejestrować nowe źródło zdarzeń, ale nazwę komputera w <see cref="P:System.Diagnostics.EventLog.MachineName" /> jest nieprawidłowy.  
  
\- lub — 
Źródło jest już zarejestrowany dla różnych dziennika zdarzeń.  
  
\- lub — 
 <paramref name="instance.InstanceId" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
\- lub — 
Jedną z <paramref name="values" /> elementów jest dłuższa niż 32766 bajtów.  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzeń zarejestrowane dla aplikacji na określonym komputerze.</param>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienia, która reprezentuje wejścia zlokalizowany dziennika zdarzeń.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje wpis dziennika zdarzeń przy użyciu podanego zdarzenia, dane i komunikat ciągów zastępczych przy użyciu źródła określonego zdarzenia zarejestrowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowane zapisu w dzienniku zdarzeń, korzystanie ze źródła już zarejestrowany jako źródła zdarzeń dla odpowiedniego dziennika. Można określić właściwości zdarzenia z identyfikatorów zasobów, a nie wartości parametrów. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie parametry z pliku zlokalizowanych zasobów dla źródła. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródła przy użyciu odpowiedniego pliku zasobów.  
  
 Dane wejściowe `instance` wystąpienia określa komunikat zdarzenia i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` dane wejściowe na potrzeby wiadomości zdefiniowanej w źródłowym pliku zasobów komunikatów. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe, aby zdefiniować typ kategorii i zdarzenia zgłoszenia użytkownika zdarzeń. Można również określić tablicę ciągów niezależny od języka do wstawienia do tekstu komunikatów zlokalizowanego. Ustaw `values` do `null` Jeśli komunikatów o zdarzeniach nie zawiera symbole zastępcze formatowania ciągów zastępczych.  
  
 Określona źródłowa musi być zarejestrowana do dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określona źródłowa musi być skonfigurowany do zapisywania zlokalizowanego wpisy w Dzienniku; co najmniej źródłowej musi mieć zdefiniowane pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis zdarzenie informacyjne i wpis zdarzeń ostrzeżenie istniejącego dziennika zdarzeń. Tekst komunikatu o zdarzeniu jest określony, przy użyciu identyfikatora zasobu w pliku zasobów. W przykładzie założono, że odpowiedni plik zasobów została zarejestrowana dla źródła.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 W przykładzie użyto następującego pliku tekst komunikatu wbudowana w bibliotekę zasobu EventLogMsgs.dll. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatory zasobów i tekst dla kategorii, komunikatów o zdarzeniach i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest ciągiem pustym ("").  
  
\- lub — 
<paramref name="source" /> Wartość <see langword="null" />.  
  
\- lub — 
 <paramref name="instance.InstanceId" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
\- lub — 
Jedną z <paramref name="values" /> elementów jest dłuższa niż 32766 bajtów.  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nazwa źródła zdarzeń zarejestrowane dla aplikacji na określonym komputerze.</param>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> Wystąpienia, która reprezentuje wejścia zlokalizowany dziennika zdarzeń.</param>
        <param name="data">Tablicę bajtów zawierającą dane binarne skojarzone z wpisem.</param>
        <param name="values">Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń.</param>
        <summary>Zapisuje zdarzenie wpis dziennika z danymi podanego zdarzenia, ciągi wymiany komunikatów i skojarzone dane binarne, a także przy użyciu określonego zarejestrowane źródło zdarzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zlokalizowane zapisu wraz z dodatkowymi danymi określonych zdarzeń w dzienniku zdarzeń, korzystanie ze źródła już zarejestrowany jako źródła zdarzeń dla odpowiedniego dziennika. Można określić właściwości zdarzenia z identyfikatorów zasobów, a nie wartości parametrów. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie parametry z pliku zlokalizowanych zasobów dla źródła. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródła przy użyciu odpowiedniego pliku zasobów.  
  
 Dane wejściowe `instance` wystąpienia określa komunikat zdarzenia i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A> z `instance` dane wejściowe na potrzeby wiadomości zdefiniowanej w źródłowym pliku zasobów komunikatów. Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A> i <xref:System.Diagnostics.EventInstance.EntryType%2A> z `instance` dane wejściowe, aby zdefiniować typ kategorii i zdarzenia zgłoszenia użytkownika zdarzeń. Można również określić tablicę ciągów niezależny od języka do wstawienia do tekstu komunikatów zlokalizowanego. Ustaw `values` do `null` Jeśli komunikatów o zdarzeniach nie zawiera symbole zastępcze formatowania ciągów zastępczych.  
  
 Określ dane binarne do zdarzenia, gdy jest to konieczne w celu dostarczenie dodatkowych szczegółów zdarzenia. Na przykład użyć `data` parametru, aby podać informacje dotyczące określonego błędu. Podgląd zdarzeń nie interpretuje dane skojarzone ze zdarzeniem; dane są wyświetlane w formacie szesnastkowym i tekstowym połączone. Korzystanie z danych specyficznych dla zdarzeń oszczędnie; Uwzględnij go tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane dotyczące zdarzeń do przechowywania informacji, które aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Na przykład można napisać przeglądarka specjalnie dla zdarzeń lub napisz program, który skanowania dziennika zdarzeń, która tworzy raporty, które zawierają informacje z danych specyficznych dla zdarzeń.  
  
 Określona źródłowa musi być zarejestrowana do dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>. Określona źródłowa musi być skonfigurowany do zapisywania zlokalizowanego wpisy w Dzienniku; co najmniej źródłowej musi mieć zdefiniowane pliku zasobów komunikatów.  
  
 Należy utworzyć i skonfigurować źródła zdarzeń przed zapisaniem pierwszy wpis ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas na odświeżenie listy źródeł zarejestrowanych zdarzeń i konfiguracji systemu operacyjnego. Jeśli system operacyjny nie odświeżył swoją listę źródeł zdarzeń, a użytkownik podejmie próbę zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Można skonfigurować nowe źródła, używając <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metody. Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.  
  
 Źródło musi być skonfigurowany dla zapisywania zlokalizowanego wpisy lub zapisywanie bezpośrednie ciągów. Użyj <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, jeśli aplikacja zapisuje wartości ciągu bezpośrednio w dzienniku zdarzeń.  
  
 Jeśli aplikacja zapisuje wpisów za pomocą identyfikatorów zasobów i wartości ciągu, należy zarejestrować dwóch oddzielnych źródeł. Na przykład skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A> metody na zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń. Następnie utwórz inne źródło bez plików zasobów i użyć tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodę, aby zapisać ciągi bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wpis zdarzenie informacyjne i wpis zdarzeń ostrzeżenie istniejącego dziennika zdarzeń. Tekst komunikatu o zdarzeniu jest określony, przy użyciu identyfikatora zasobu w pliku zasobów. W przykładzie założono, że odpowiedni plik zasobów została zarejestrowana dla źródła.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 W przykładzie użyto następującego pliku tekst komunikatu wbudowana w bibliotekę zasobu EventLogMsgs.dll. Plik tekstowy komunikat jest źródło, z którego jest tworzony pliku zasobów komunikatów. Plik tekstowy komunikat definiuje identyfikatory zasobów i tekst dla kategorii, komunikatów o zdarzeniach i ciągi wstawiania parametru.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> Wartość jest ciągiem pustym ("").  
  
\- lub — 
<paramref name="source" /> Wartość <see langword="null" />.  
  
\- lub — 
 <paramref name="instance.InstanceId" /> jest mniejsza od zera lub większa niż <see cref="F:System.UInt16.MaxValue" />.  
  
\- lub — 
 <paramref name="values" /> ma więcej niż 256 elementów.  
  
\- lub — 
Jedną z <paramref name="values" /> elementów jest dłuższa niż 32766 bajtów.  
  
\- lub — 
Nazwa źródłowego powoduje dłuższa niż 254 znaki ścieżkę klucza rejestru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć klucza rejestru dla dziennika zdarzeń.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu Windows nie jest dostępna.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">do zapisywania informacji dziennika zdarzeń na komputerze. Wyliczenie skojarzone: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>
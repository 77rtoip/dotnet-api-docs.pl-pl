<Type Name="SessionStateStoreProviderBase" FullName="System.Web.SessionState.SessionStateStoreProviderBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f67b526b76fe2727eda8b0a31e7600ff75016c6f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37602815" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SessionStateStoreProviderBase : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SessionStateStoreProviderBase extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.SessionState.SessionStateStoreProviderBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SessionStateStoreProviderBase&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionStateStoreProviderBase abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type SessionStateStoreProviderBase = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje wymagane elementy dostawcę stanu sesji dla magazynu danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan sesji programu ASP.NET odczytuje i zapisuje dane sesji z i do magazynu danych przy użyciu stanu sesji przechowywania dostawcy. Dostawca magazynu stanu sesji jest klasa, która dziedziczy <xref:System.Web.SessionState.SessionStateStoreProviderBase> klasy abstrakcyjnej i zastąpienia jej członków z implementacjami specyficzne dla danych są przechowywane. Dostawca magazynu stanu sesji jest wywoływany przez <xref:System.Web.SessionState.SessionStateModule> klasy podczas przetwarzania strony programu ASP.NET do komunikowania się z magazynem danych do przechowywania i pobierania zmienne sesji i sesji powiązane informacje, takie jak wartość limitu czasu.  
  
 Dane sesji w ramach każdej aplikacji ASP.NET były przechowywane osobno dla każdego <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> właściwości. Aplikacje ASP.NET nie należy udostępniać dane sesji.  
  
 Można określić niestandardowego <xref:System.Web.SessionState.SessionStateStoreProviderBase> wdrożenia dla aplikacji ASP.NET, ustawiając `mode` atrybutu `sessionState` element konfiguracji do <xref:System.Web.SessionState.SessionStateMode.Custom> i `customProvider` atrybutu jako nazwę niestandardowego dostawcy pokazano w przykładzie w tym temacie.  
  
## <a name="locking-session-store-data"></a>Blokowanie Data Store sesji  
 Ponieważ wielowątkowe umożliwiają reagowanie na współbieżnych żądań aplikacji ASP.NET, jest możliwe, jednoczesnych żądań może próbować uzyskać dostęp do tych samych informacji sesji. Rozważmy scenariusz, w której wiele ramek w zestawie ramek wszystkich dostęp do tej samej aplikacji. Oddzielne żądania dla każdej ramki w zestawie ramek mogą być wykonywane na serwerze sieci Web, jednocześnie w różnych wątkach. Strony ASP.NET dla każdego źródła ramek dostęp do zmiennych stanu sesji, może mieć wiele wątków jednocześnie dostęp do magazynu sesji.  
  
 Aby uniknąć konfliktów danych w magazynie sesji i nieoczekiwane zachowanie stanu sesji, <xref:System.Web.SessionState.SessionStateModule> i <xref:System.Web.SessionState.SessionStateStoreProviderBase> klas obejmują funkcje blokady wyłącznie blokuje elementu magazynu sesji dla określonej sesji na czas trwania wykonywanie strony ASP.NET. Należy pamiętać, że nawet jeśli <xref:System.Web.Configuration.PagesSection.EnableSessionState%2A> atrybut jest oznaczony jako `ReadOnly`, innych stron ASP.NET, w tej samej aplikacji może mieć możliwość zapisu w magazynie sesji, więc żądanie sesji tylko do odczytu danych z magazynu może nadal się to zakończyć oczekiwanie na zablokowane dane mogą być zwolniona.  
  
 Blokady jest ustawiony na sesji magazynu danych na początku żądania, w wywołaniu <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metody. Po ukończeniu żądania blokada jest zwalniana podczas wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetAndReleaseItemExclusive%2A> metody.  
  
 Jeśli <xref:System.Web.SessionState.SessionStateModule> podczas wywołania obiektu napotka dane sesji zablokowane <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> lub <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> metody ponownie zażąda on dane sesji w odstępach czasu pół sekundy, dopóki blokada jest zwalniana albo ilość czasu, który został zablokowany w dane sesji przekracza wartość <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A> właściwości. Jeśli zostanie przekroczony limit czasu wykonywania, <xref:System.Web.SessionState.SessionStateModule> wywoła obiektu <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metody z bezpłatnymi data store sesji i żądań sesji przechowywania danych w tym czasie.  
  
 Ponieważ zablokowany sesji magazynu danych może być zwolniony przez wywołanie <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metody w oddzielnym wątku przed wywołaniem do <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetAndReleaseItemExclusive%2A> metody dla bieżącej odpowiedzi, może zostać podjęta próba i wersji danych magazynu stanu sesji, który ma już zwolnione i zmodyfikowane przez inną sesję. Aby uniknąć tej sytuacji <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> i <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metody zwracają Identyfikator blokady. Ten identyfikator blokady musi być dołączone do każdego żądania do modyfikowania danych zablokowane magazynu sesji. Sesja magazyn danych jest modyfikowany tylko wtedy, gdy jest to identyfikator blokady w magazynie danych jest zgodny z identyfikatorem blokady, w dostarczonych przez <xref:System.Web.SessionState.SessionStateModule>.  
  
## <a name="deleting-expired-session-store-data"></a>Usuwanie danych z wygasłych sesji Store  
 Gdy <xref:System.Web.SessionState.HttpSessionState.Abandon%2A> metoda jest wywoływana dla określonej sesji, dane dla tej sesji, zostaną usunięte z magazynu danych przy użyciu <xref:System.Web.SessionState.SessionStateStoreProviderBase.RemoveItem%2A> metody; w przeciwnym razie dane pozostaną w magazynie danych sesji do przyszłych żądań serwera dla sesji. Do <xref:System.Web.SessionState.SessionStateStoreProviderBase> implementacji, aby usunąć dane wygasłych sesji.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 Poniższy przykład kodu pokazuje pliku Web.config dla aplikacji ASP.NET, który jest skonfigurowany do używania dostawcy niestandardowego magazynu stanu sesji.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="OdbcSessionServices" connectionString="DSN=SessionState;" />  
  </connectionStrings>  
  
  <system.web>  
    <sessionState   
      mode="Custom"  
      customProvider="OdbcSessionProvider">  
      <providers>  
        <add name="OdbcSessionProvider"  
             type="Samples.AspNet.Session.OdbcSessionStateStore"  
             connectionStringName="OdbcSessionServices" />  
      </providers>  
    </sessionState>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SessionStateStoreProviderBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SessionStateStoreProviderBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.SessionState.SessionStateStoreProviderBase" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy zaimplementować konstruktora dla klasy, która dziedziczy <xref:System.Web.SessionState.SessionStateStoreProviderBase> klasy abstrakcyjnej. Inicjowanie wartości <xref:System.Web.SessionState.SessionStateStoreProviderBase> wdrożenia są przekazywane do <xref:System.Configuration.Provider.ProviderBase.Initialize%2A> implementacji metody.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNewStoreData">
      <MemberSignature Language="C#" Value="public abstract System.Web.SessionState.SessionStateStoreData CreateNewStoreData (System.Web.HttpContext context, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.SessionState.SessionStateStoreData CreateNewStoreData(class System.Web.HttpContext context, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.CreateNewStoreData(System.Web.HttpContext,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateNewStoreData (context As HttpContext, timeout As Integer) As SessionStateStoreData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::SessionState::SessionStateStoreData ^ CreateNewStoreData(System::Web::HttpContext ^ context, int timeout);" />
      <MemberSignature Language="F#" Value="abstract member CreateNewStoreData : System.Web.HttpContext * int -&gt; System.Web.SessionState.SessionStateStoreData" Usage="sessionStateStoreProviderBase.CreateNewStoreData (context, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.SessionStateStoreData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="timeout">Stan sesji <see cref="P:System.Web.SessionState.HttpSessionState.Timeout" /> wartość dla nowej klasy <see cref="T:System.Web.SessionState.SessionStateStoreData" />.</param>
        <summary>Tworzy nową <see cref="T:System.Web.SessionState.SessionStateStoreData" /> obiekt ma być używany dla bieżącego żądania.</summary>
        <returns>Nowy <see cref="T:System.Web.SessionState.SessionStateStoreData" /> dla bieżącego żądania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateNewStoreData%2A> metodę na początku żądanie dla strony ASP.NET, podczas <xref:System.Web.HttpApplication.AcquireRequestState> zdarzeń. <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateNewStoreData%2A> Metoda jest wywoływana, gdy:  
  
-   żądanie przychodzące ma Brak Identyfikatora sesji lub  
  
-   żądanie przychodzące ma identyfikator sesji, ale sesja nie znajduje się w magazynie danych.  
  
 <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateNewStoreData%2A> Metoda tworzy nowy <xref:System.Web.SessionState.SessionStateStoreData> obiektu z pustą <xref:System.Web.SessionState.ISessionStateItemCollection> obiektu <xref:System.Web.HttpStaticObjectsCollection> kolekcji i określonego `timeout` wartość. <xref:System.Web.HttpStaticObjectsCollection> Kolekcji dla aplikacji ASP.NET można pobrać przy użyciu <xref:System.Web.SessionState.SessionStateUtility.GetSessionStaticObjects%2A> metody.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitializedItem">
      <MemberSignature Language="C#" Value="public abstract void CreateUninitializedItem (System.Web.HttpContext context, string id, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateUninitializedItem(class System.Web.HttpContext context, string id, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.CreateUninitializedItem(System.Web.HttpContext,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub CreateUninitializedItem (context As HttpContext, id As String, timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void CreateUninitializedItem(System::Web::HttpContext ^ context, System::String ^ id, int timeout);" />
      <MemberSignature Language="F#" Value="abstract member CreateUninitializedItem : System.Web.HttpContext * string * int -&gt; unit" Usage="sessionStateStoreProviderBase.CreateUninitializedItem (context, id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="id">
          <see cref="P:System.Web.SessionState.HttpSessionState.SessionID" /> Dla bieżącego żądania.</param>
        <param name="timeout">Sesja <see cref="P:System.Web.SessionState.HttpSessionState.Timeout" /> dla bieżącego żądania.</param>
        <summary>Dodaje nowy element stanu sesji w magazynie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateUninitializedItem%2A> Metoda jest używana z sesji podczas `cookieless` i `regenerateExpiredSessionId` atrybuty są oba `true`. Posiadanie `regenerateExpiredSessionId attribute` równa `true` powoduje, że <xref:System.Web.SessionState.SessionStateModule> obiekt, aby wygenerować nowy <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartości w przypadku wygasłych <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> napotkano wartość.  
  
 Proces generowania nowego <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartość wymaga przekierowania folderu w przeglądarce adres URL, który zawiera nowo wygenerowane <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartość. <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateUninitializedItem%2A> Metoda jest wywoływana podczas wstępnego żądania, który zawiera wygasłe <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartość. Po <xref:System.Web.SessionState.SessionStateModule> obiektu uzyskuje się nowy <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartość, aby zastąpić wartość wygasłe, wywołuje <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateUninitializedItem%2A> metodę, aby dodać wpis niezainicjowanej z magazynem danych stanu sesji. Przeglądarka jest następnie przekierowywane do adresu URL zawierająca nowo wygenerowane <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartość. Istnienie niezainicjowanej zapisu w magazynie danych sesji zapewnia, że przekierowane żądanie, która zawiera nowo wygenerowane <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartość dla żądania wygasłych sesji nie zostanie odczytany i zamiast tego traktowane jako nowej sesji.  
  
 Niezainicjowane zapisu w magazynie danych sesji jest skojarzony z nowo wygenerowane <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> wartości i zawiera tylko wartości domyślne, w tym datę wygaśnięcia, czas i wartość, która odnosi się do `actionFlags` parametru <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A>i <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metody. Niezainicjowane zapisu w magazynie stanów sesji powinien zawierać `actionFlags` wartość równą <xref:System.Web.SessionState.SessionStateActions.InitializeItem> wartość wyliczenia. Ta wartość jest przekazywana do <xref:System.Web.SessionState.SessionStateModule> obiektu przez <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> i <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metod i informuje <xref:System.Web.SessionState.SessionStateModule> obiekt bieżącej sesji nowe ale niezainicjowane sesji. <xref:System.Web.SessionState.SessionStateModule> Obiektu spowoduje zainicjowanie nowej sesji i podnieść `Session_OnStart` zdarzeń.  
  
 Aby uzyskać więcej informacji o sesjach cookieless zobacz <xref:System.Web.SessionState.HttpSessionState.IsCookieless%2A> właściwości.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public abstract void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit" Usage="sessionStateStoreProviderBase.Dispose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Web.SessionState.SessionStateStoreProviderBase" /> implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateStoreProviderBase.Dispose%2A?displayProperty=nameWithType> Metoda jest wywoływana, gdy <xref:System.Web.SessionState.SessionStateModule.Dispose%2A?displayProperty=nameWithType> metoda jest wykonywana na zamknięcie domeny aplikacji. Klasy, które dziedziczą <xref:System.Web.SessionState.SessionStateStoreProviderBase> klasy można użyć tej metody można zwolnić wszystkie zasoby, które nie są już w użyciu.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRequest">
      <MemberSignature Language="C#" Value="public abstract void EndRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.EndRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub EndRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void EndRequest(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member EndRequest : System.Web.HttpContext -&gt; unit" Usage="sessionStateStoreProviderBase.EndRequest context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <summary>Wywoływane przez <see cref="T:System.Web.SessionState.SessionStateModule" /> obiektu na końcu żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.EndRequest%2A> metodę na końcu żądanie dla strony ASP.NET, podczas <xref:System.Web.HttpApplication.EndRequest> zdarzeń. Możesz użyć <xref:System.Web.SessionState.SessionStateStoreProviderBase.EndRequest%2A> metodę, aby wykonać wymagane przez dostawcę magazynu stanu sesji na żądanie czyszczenia.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItem">
      <MemberSignature Language="C#" Value="public abstract System.Web.SessionState.SessionStateStoreData GetItem (System.Web.HttpContext context, string id, out bool locked, out TimeSpan lockAge, out object lockId, out System.Web.SessionState.SessionStateActions actions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.SessionState.SessionStateStoreData GetItem(class System.Web.HttpContext context, string id, [out] bool&amp; locked, [out] valuetype System.TimeSpan&amp; lockAge, [out] object&amp; lockId, [out] valuetype System.Web.SessionState.SessionStateActions&amp; actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.GetItem(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetItem (context As HttpContext, id As String, ByRef locked As Boolean, ByRef lockAge As TimeSpan, ByRef lockId As Object, ByRef actions As SessionStateActions) As SessionStateStoreData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::SessionState::SessionStateStoreData ^ GetItem(System::Web::HttpContext ^ context, System::String ^ id, [Runtime::InteropServices::Out] bool % locked, [Runtime::InteropServices::Out] TimeSpan % lockAge, [Runtime::InteropServices::Out] System::Object ^ % lockId, [Runtime::InteropServices::Out] System::Web::SessionState::SessionStateActions % actions);" />
      <MemberSignature Language="F#" Value="abstract member GetItem : System.Web.HttpContext * string *  *  *  *  -&gt; System.Web.SessionState.SessionStateStoreData" Usage="sessionStateStoreProviderBase.GetItem (context, id, locked, lockAge, lockId, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.SessionStateStoreData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="locked" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="lockAge" Type="System.TimeSpan&amp;" RefType="out" />
        <Parameter Name="lockId" Type="System.Object&amp;" RefType="out" />
        <Parameter Name="actions" Type="System.Web.SessionState.SessionStateActions&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="id">
          <see cref="P:System.Web.SessionState.HttpSessionState.SessionID" /> Dla bieżącego żądania.</param>
        <param name="locked">Po powrocie z tej metody zawiera wartość logiczna, która jest równa <see langword="true" /> Jeśli element Żądana sesja jest zablokowana w magazynie danych sesji; w przeciwnym razie <see langword="false" />.</param>
        <param name="lockAge">Po powrocie z tej metody zawiera <see cref="T:System.TimeSpan" /> obiektu, który jest ustawiony na czas, który został zablokowany element w magazynie danych sesji.</param>
        <param name="lockId">Po powrocie z tej metody zawiera obiekt, który jest ustawiony na identyfikator blokady dla bieżącego żądania. Szczegółowe informacje dotyczące Identyfikator blokady, zobacz "Blokowanie dane sesji Store" w <see cref="T:System.Web.SessionState.SessionStateStoreProviderBase" /> klasy podsumowania.</param>
        <param name="actions">Po powrocie z tej metody zawiera jeden z <see cref="T:System.Web.SessionState.SessionStateActions" /> wartości, wskazującą, czy bieżąca sesja jest niezainicjowany, cookieless "session".</param>
        <summary>Zwraca dane stanu sesji tylko do odczytu z magazynu danych sesji.</summary>
        <returns>A <see cref="T:System.Web.SessionState.SessionStateStoreData" /> wypełniane przy użyciu wartości sesji i informacji z magazynu danych sesji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> metody na początku żądania podczas <xref:System.Web.HttpApplication.AcquireRequestState> zdarzenie, kiedy <xref:System.Web.Configuration.PagesSection.EnableSessionState%2A> ma ustawioną wartość atrybutu `ReadOnly`. Jeśli <xref:System.Web.Configuration.PagesSection.EnableSessionState%2A> ma ustawioną wartość atrybutu `true`, <xref:System.Web.SessionState.SessionStateModule> zamiast tego obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metody.  
  
 <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> Metoda zwraca <xref:System.Web.SessionState.SessionStateStoreData> obiektu wypełniane przy użyciu informacji o sesji z magazynu danych i aktualizuje daty wygaśnięcia dane sesji. Jeśli żadne dane element sesji znajduje się w magazynie danych <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> metody ustawia `locked` `out` parametr `false` i zwraca `null`. Powoduje to, że <xref:System.Web.SessionState.SessionStateModule> obiekt do wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateNewStoreData%2A> metodę, aby utworzyć element Nowa sesja w magazynie danych.  
  
 Jeśli element sesji danych znajduje się w magazynie danych, ale danych jest zablokowany, <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> metody ustawia `locked` `out` parametr `true`, ustawia `lockAge` `out` parametr do bieżącej daty i godziny pomniejszoną o datę i czasu, gdy ten element został zablokowany (które są pobierane z magazynu danych), ustawia `lockId` `out` parametru, aby identyfikator blokady pobierane z magazynu danych i zwraca `null`. Powoduje to, że <xref:System.Web.SessionState.SessionStateModule> obiekt do wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> metoda ponownie za pół sekundowego interwału próbuje pobrać element sesji.  
  
 Jeśli wartość która `lockAge` `out` parametr ma wartość przekracza <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A> wartości, a następnie <xref:System.Web.SessionState.SessionStateModule> obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metodę, aby wyczyścić blokady na element sesji danych, a następnie wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> ponownie metodą.  
  
 `actionFlags` Parametr jest używany, gdy zarówno `cookieless` i `regenerateExpiredSessionId` atrybuty są ustawione na `true`. `actionFlags` Wartość <xref:System.Web.SessionState.SessionStateActions.InitializeItem> wskazuje, że wpis w magazynie danych sesji jest nową sesję, który wymaga inicjowania. Niezainicjowane zapisy w magazynie danych sesji są tworzone przez wywołanie <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateUninitializedItem%2A> metody. Jeśli element z magazynu danych sesji nie jest niezainicjowany element `actionFlags` parametr zostanie ustawiony na wartość zero.  
  
 Implementacji niestandardowego magazynu stanu sesji, obsługujące cookieless sesji należy ustawić `actionFlags` `out` wartość zwracana z magazynu danych sesji dla bieżącego elementu. Jeśli `actionFlags` elementu jest równa wartości parametru dla żądanego magazynu sesji <xref:System.Web.SessionState.SessionStateActions.InitializeItem> wartość wyliczenia, a następnie <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> metoda powinna ustawiać wartość w magazynie danych do zera po ustawieniu `actionFlags` `out` parametru.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemExclusive">
      <MemberSignature Language="C#" Value="public abstract System.Web.SessionState.SessionStateStoreData GetItemExclusive (System.Web.HttpContext context, string id, out bool locked, out TimeSpan lockAge, out object lockId, out System.Web.SessionState.SessionStateActions actions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.SessionState.SessionStateStoreData GetItemExclusive(class System.Web.HttpContext context, string id, [out] bool&amp; locked, [out] valuetype System.TimeSpan&amp; lockAge, [out] object&amp; lockId, [out] valuetype System.Web.SessionState.SessionStateActions&amp; actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetItemExclusive (context As HttpContext, id As String, ByRef locked As Boolean, ByRef lockAge As TimeSpan, ByRef lockId As Object, ByRef actions As SessionStateActions) As SessionStateStoreData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::SessionState::SessionStateStoreData ^ GetItemExclusive(System::Web::HttpContext ^ context, System::String ^ id, [Runtime::InteropServices::Out] bool % locked, [Runtime::InteropServices::Out] TimeSpan % lockAge, [Runtime::InteropServices::Out] System::Object ^ % lockId, [Runtime::InteropServices::Out] System::Web::SessionState::SessionStateActions % actions);" />
      <MemberSignature Language="F#" Value="abstract member GetItemExclusive : System.Web.HttpContext * string *  *  *  *  -&gt; System.Web.SessionState.SessionStateStoreData" Usage="sessionStateStoreProviderBase.GetItemExclusive (context, id, locked, lockAge, lockId, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.SessionStateStoreData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="locked" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="lockAge" Type="System.TimeSpan&amp;" RefType="out" />
        <Parameter Name="lockId" Type="System.Object&amp;" RefType="out" />
        <Parameter Name="actions" Type="System.Web.SessionState.SessionStateActions&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="id">
          <see cref="P:System.Web.SessionState.HttpSessionState.SessionID" /> Dla bieżącego żądania.</param>
        <param name="locked">Po powrocie z tej metody zawiera wartość logiczna, która jest równa <see langword="true" /> Jeśli blokada jest pomyślnie uzyskanej; w przeciwnym razie <see langword="false" />.</param>
        <param name="lockAge">Po powrocie z tej metody zawiera <see cref="T:System.TimeSpan" /> obiektu, który jest ustawiony na czas, który został zablokowany element w magazynie danych sesji.</param>
        <param name="lockId">Po powrocie z tej metody zawiera obiekt, który jest ustawiony na identyfikator blokady dla bieżącego żądania. Szczegółowe informacje dotyczące Identyfikator blokady, zobacz "Blokowanie dane sesji Store" w <see cref="T:System.Web.SessionState.SessionStateStoreProviderBase" /> klasy podsumowania.</param>
        <param name="actions">Po powrocie z tej metody zawiera jeden z <see cref="T:System.Web.SessionState.SessionStateActions" /> wartości, wskazującą, czy bieżąca sesja jest niezainicjowany, cookieless "session".</param>
        <summary>Zwraca dane stanu sesji tylko do odczytu z magazynu danych sesji.</summary>
        <returns>A <see cref="T:System.Web.SessionState.SessionStateStoreData" /> wypełniane przy użyciu wartości sesji i informacji z magazynu danych sesji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metody na początku żądania podczas <xref:System.Web.HttpApplication.AcquireRequestState> zdarzenie, kiedy <xref:System.Web.Configuration.PagesSection.EnableSessionState%2A> ma ustawioną wartość atrybutu `true`, co jest ustawieniem domyślnym. Jeśli <xref:System.Web.Configuration.PagesSection.EnableSessionState%2A> ma ustawioną wartość atrybutu `ReadOnly`, <xref:System.Web.SessionState.SessionStateModule> zamiast tego obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItem%2A> metody.  
  
 <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> Metoda zwraca <xref:System.Web.SessionState.SessionStateStoreData> obiektu wypełniane przy użyciu informacji o sesji z magazynu danych aktualizacji daty wygaśnięcia przechowywanych danych i blokuje dane element sesji w magazynie danych, czas trwania żądania. Jeśli żadne dane element sesji znajduje się w magazynie danych <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metody ustawia `locked` `out` parametr `false` i zwraca `null`. Powoduje to, że <xref:System.Web.SessionState.SessionStateModule> obiekt do wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateNewStoreData%2A> metodę, aby utworzyć element Nowa sesja w magazynie danych. Jeśli element sesji danych znajduje się w magazynie danych, ale danych jest zablokowany, <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metody ustawia `locked` `out` parametr `true`, ustawia `lockAge` `out` parametr do bieżącej daty i godziny pomniejszoną o datę i czasu, gdy ten element został zablokowany (które są pobierane z magazynu danych), ustawia `lockId` `out` parametru, aby identyfikator blokady pobierane z magazynu danych i zwraca `null`. Powoduje to, że <xref:System.Web.SessionState.SessionStateModule> obiekt do wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metoda ponownie za pół sekundowego interwału próbuje pobrać element sesji i nałożyć blokady na danych. Jeśli wartość która `lockAge` `out` parametr ma wartość przekracza <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A> wartości, a następnie <xref:System.Web.SessionState.SessionStateModule> wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metodę, aby wyczyścić blokady na element sesji danych, a następnie wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> ponownie metodą.  
  
 `actionFlags` Parametr jest używany podczas `cookieless` i `regenerateExpiredSessionId` atrybuty są ustawione na `true`. `actionFlags` Wartość <xref:System.Web.SessionState.SessionStateActions.InitializeItem> wskazuje, że wpis w magazynie danych sesji jest nową sesję, który wymaga inicjowania. Niezainicjowane zapisy w magazynie danych sesji są tworzone przez wywołanie <xref:System.Web.SessionState.SessionStateStoreProviderBase.CreateUninitializedItem%2A> metody. Jeśli element z magazynu danych sesji nie jest niezainicjowany element `actionFlags` parametr zostanie ustawiony na wartość zero.  
  
 Implementacji niestandardowego magazynu stanu sesji, obsługujące cookieless sesji należy ustawić `actionFlags` `out` wartość zwracana z magazynu danych sesji dla bieżącego elementu. Jeśli `actionFlags` elementu jest równa wartości parametru dla żądanego magazynu sesji <xref:System.Web.SessionState.SessionStateActions.InitializeItem> wartość wyliczenia, a następnie <xref:System.Web.SessionState.SessionStateStoreProviderBase.GetItemExclusive%2A> metoda powinna ustawiać wartość w magazynie danych do zera po ustawieniu `actionFlags` `out` parametru.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeRequest">
      <MemberSignature Language="C#" Value="public abstract void InitializeRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InitializeRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.InitializeRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub InitializeRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void InitializeRequest(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member InitializeRequest : System.Web.HttpContext -&gt; unit" Usage="sessionStateStoreProviderBase.InitializeRequest context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <summary>Wywoływane przez <see cref="T:System.Web.SessionState.SessionStateModule" /> obiektu inicjowania danego żądania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.InitializeRequest%2A> metoda przed wywołaniem innych <xref:System.Web.SessionState.SessionStateStoreProviderBase> metody. Możesz użyć <xref:System.Web.SessionState.SessionStateStoreProviderBase.InitializeRequest%2A> metodę w celu inicjowanie wymagane przez dostawcę magazynu stanu sesji na żądanie.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseItemExclusive">
      <MemberSignature Language="C#" Value="public abstract void ReleaseItemExclusive (System.Web.HttpContext context, string id, object lockId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseItemExclusive(class System.Web.HttpContext context, string id, object lockId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive(System.Web.HttpContext,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReleaseItemExclusive (context As HttpContext, id As String, lockId As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReleaseItemExclusive(System::Web::HttpContext ^ context, System::String ^ id, System::Object ^ lockId);" />
      <MemberSignature Language="F#" Value="abstract member ReleaseItemExclusive : System.Web.HttpContext * string * obj -&gt; unit" Usage="sessionStateStoreProviderBase.ReleaseItemExclusive (context, id, lockId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="lockId" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="id">Identyfikator sesji dla bieżącego żądania.</param>
        <param name="lockId">Identyfikator blokady dla bieżącego żądania.</param>
        <summary>Przechowywanie wersji blokady na element w dane sesji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metodę, aby zaktualizować datę wygaśnięcia i zwolnić blokady na element w magazynie danych sesji. Jest to na końcu żądania podczas <xref:System.Web.HttpApplication.ReleaseRequestState> zdarzeń, jeśli wartości sesji są bez zmian. W przypadku modyfikowania wartości sesji <xref:System.Web.SessionState.SessionStateModule> zamiast tego obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetAndReleaseItemExclusive%2A> metody.  
  
 <xref:System.Web.SessionState.SessionStateModule> Również wywołuje obiekt <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metody, gdy został przekroczony blokady na element w magazynie danych sesji <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A> wartość. Aby uzyskać więcej informacji na temat blokowania i szczegółowe informacje o identyfikator blokady, zobacz "Blokowanie dane sesji Store" w <xref:System.Web.SessionState.SessionStateStoreProviderBase> klasa — Przegląd.  
  
 <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> Metoda tylko Usuwa blokadę z elementu w magazynie danych sesji dla bieżącej aplikacji, który odpowiada podanej sesji `id` i `lockId` wartości. Jeśli `lockId` pasuje do nazwy w magazynie danych <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metoda nic nie robi.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="public abstract void RemoveItem (System.Web.HttpContext context, string id, object lockId, System.Web.SessionState.SessionStateStoreData item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveItem(class System.Web.HttpContext context, string id, object lockId, class System.Web.SessionState.SessionStateStoreData item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.RemoveItem(System.Web.HttpContext,System.String,System.Object,System.Web.SessionState.SessionStateStoreData)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub RemoveItem (context As HttpContext, id As String, lockId As Object, item As SessionStateStoreData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void RemoveItem(System::Web::HttpContext ^ context, System::String ^ id, System::Object ^ lockId, System::Web::SessionState::SessionStateStoreData ^ item);" />
      <MemberSignature Language="F#" Value="abstract member RemoveItem : System.Web.HttpContext * string * obj * System.Web.SessionState.SessionStateStoreData -&gt; unit" Usage="sessionStateStoreProviderBase.RemoveItem (context, id, lockId, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="lockId" Type="System.Object" />
        <Parameter Name="item" Type="System.Web.SessionState.SessionStateStoreData" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="id">Identyfikator sesji dla bieżącego żądania.</param>
        <param name="lockId">Identyfikator blokady dla bieżącego żądania.</param>
        <param name="item">
          <see cref="T:System.Web.SessionState.SessionStateStoreData" /> Reprezentujący elementu do usunięcia z magazynu danych.</param>
        <summary>Usuwa element danych z magazynu danych sesji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.RemoveItem%2A> metody na końcu żądania podczas <xref:System.Web.HttpApplication.ReleaseRequestState> zdarzeń, aby usunąć dane dla elementu sesji z magazynu danych sesji, jeśli <xref:System.Web.SessionState.HttpSessionState.Abandon%2A> została wywołana metoda. Tylko dane sesji dla bieżącej aplikacji, który odpowiada podanej sesji `id` i `lockId` wartości zostanie usunięty. Aby uzyskać więcej informacji na temat blokowania i szczegółowe informacje o identyfikator blokady, zobacz "Blokowanie dane sesji Store" w <xref:System.Web.SessionState.SessionStateStoreProviderBase> klasa — Przegląd.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetItemTimeout">
      <MemberSignature Language="C#" Value="public abstract void ResetItemTimeout (System.Web.HttpContext context, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetItemTimeout(class System.Web.HttpContext context, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.ResetItemTimeout(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResetItemTimeout (context As HttpContext, id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResetItemTimeout(System::Web::HttpContext ^ context, System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member ResetItemTimeout : System.Web.HttpContext * string -&gt; unit" Usage="sessionStateStoreProviderBase.ResetItemTimeout (context, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="id">Identyfikator sesji dla bieżącego żądania.</param>
        <summary>Aktualizacji, datę i godzinę wygaśnięcia elementu w magazynie danych sesji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.ResetItemTimeout%2A> metodę, aby zaktualizować datę i godzinę wygaśnięcia sesji do bieżącej daty i godziny powiększoną o sesji <xref:System.Web.SessionState.HttpSessionState.Timeout%2A> wartość przy albo:  
  
-   <xref:System.Web.Configuration.PagesSection.EnableSessionState%2A> atrybut jest `true`, lub  
  
-   żądanie nie wygenerował <xref:System.Web.HttpApplication.AcquireRequestState> i <xref:System.Web.HttpApplication.ReleaseRequestState> zdarzeń z powodu błędu.  
  
 Jeśli wymagana jest strony ASP.NET i <xref:System.Web.Configuration.PagesSection.EnableSessionState%2A> ma ustawioną wartość atrybutu `false`, <xref:System.Web.SessionState.SessionStateStoreProviderBase.ResetItemTimeout%2A> metoda nadal jest wywoływana, aby zaktualizować datę i godzinę wygaśnięcia danych w magazynie danych sesji.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAndReleaseItemExclusive">
      <MemberSignature Language="C#" Value="public abstract void SetAndReleaseItemExclusive (System.Web.HttpContext context, string id, System.Web.SessionState.SessionStateStoreData item, object lockId, bool newItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetAndReleaseItemExclusive(class System.Web.HttpContext context, string id, class System.Web.SessionState.SessionStateStoreData item, object lockId, bool newItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.SetAndReleaseItemExclusive(System.Web.HttpContext,System.String,System.Web.SessionState.SessionStateStoreData,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetAndReleaseItemExclusive (context As HttpContext, id As String, item As SessionStateStoreData, lockId As Object, newItem As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetAndReleaseItemExclusive(System::Web::HttpContext ^ context, System::String ^ id, System::Web::SessionState::SessionStateStoreData ^ item, System::Object ^ lockId, bool newItem);" />
      <MemberSignature Language="F#" Value="abstract member SetAndReleaseItemExclusive : System.Web.HttpContext * string * System.Web.SessionState.SessionStateStoreData * obj * bool -&gt; unit" Usage="sessionStateStoreProviderBase.SetAndReleaseItemExclusive (context, id, item, lockId, newItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="item" Type="System.Web.SessionState.SessionStateStoreData" />
        <Parameter Name="lockId" Type="System.Object" />
        <Parameter Name="newItem" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> Dla bieżącego żądania.</param>
        <param name="id">Identyfikator sesji dla bieżącego żądania.</param>
        <param name="item">
          <see cref="T:System.Web.SessionState.SessionStateStoreData" /> Obiekt, który zawiera wartości bieżącej sesji, które mają być przechowywane.</param>
        <param name="lockId">Identyfikator blokady dla bieżącego żądania.</param>
        <param name="newItem">
          <see langword="true" /> Aby zidentyfikować element sesji jako nowy element; <see langword="false" /> do identyfikowania element sesji jako istniejącego elementu.</param>
        <summary>Aktualizuje informacje element sesji w magazynie danych stanu sesji przy użyciu wartości z bieżącego żądania, a następnie usuwa blokadę danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetAndReleaseItemExclusive%2A> metody na końcu żądania podczas <xref:System.Web.HttpApplication.ReleaseRequestState> zdarzeń, aby wstawić informacji bieżący element sesji do magazynu danych lub zaktualizowanie istniejących informacji element sesji, w magazynie danych przy użyciu bieżących wartości Aby zaktualizować czas wygaśnięcia w elemencie i zwolnić blokady na danych. Tylko dane sesji dla bieżącej aplikacji, który odpowiada podanej sesji `id` i `lockId` zaktualizować wartości. Aby uzyskać więcej informacji na temat blokowania, zobacz "Blokowanie sesji Store dane" w <xref:System.Web.SessionState.SessionStateStoreProviderBase> klasa — Przegląd.  
  
 Jeśli nie zostały zmodyfikowane wartości sesję dla bieżącego żądania, <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetAndReleaseItemExclusive%2A> nie jest wywoływana metoda. Zamiast tego <xref:System.Web.SessionState.SessionStateStoreProviderBase.ReleaseItemExclusive%2A> metoda jest wywoływana.  
  
 Jeśli <xref:System.Web.SessionState.HttpSessionState.Abandon%2A> została wywołana metoda <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetAndReleaseItemExclusive%2A> nie jest wywoływana metoda. Zamiast tego <xref:System.Web.SessionState.SessionStateModule> obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.RemoveItem%2A> metodę, aby usunąć element sesji dane ze źródła danych.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItemExpireCallback">
      <MemberSignature Language="C#" Value="public abstract bool SetItemExpireCallback (System.Web.SessionState.SessionStateItemExpireCallback expireCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetItemExpireCallback(class System.Web.SessionState.SessionStateItemExpireCallback expireCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.SessionState.SessionStateStoreProviderBase.SetItemExpireCallback(System.Web.SessionState.SessionStateItemExpireCallback)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SetItemExpireCallback (expireCallback As SessionStateItemExpireCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool SetItemExpireCallback(System::Web::SessionState::SessionStateItemExpireCallback ^ expireCallback);" />
      <MemberSignature Language="F#" Value="abstract member SetItemExpireCallback : System.Web.SessionState.SessionStateItemExpireCallback -&gt; bool" Usage="sessionStateStoreProviderBase.SetItemExpireCallback expireCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expireCallback" Type="System.Web.SessionState.SessionStateItemExpireCallback" />
      </Parameters>
      <Docs>
        <param name="expireCallback">
          <see cref="T:System.Web.SessionState.SessionStateItemExpireCallback" /> Delegata dla wszystkich <see langword="Session_OnEnd" /> zdarzenia zdefiniowane w pliku Global.asax.</param>
        <summary>Ustawia odwołanie <see cref="T:System.Web.SessionState.SessionStateItemExpireCallback" /> delegata dla wszystkich <see langword="Session_OnEnd" /> zdarzenia zdefiniowane w pliku Global.asax.</summary>
        <returns>
          <see langword="true" /> Jeśli dostawca magazynu stanu sesji obsługuje wywoływania <see langword="Session_OnEnd" /> zdarzenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.SessionState.SessionStateModule> Obiektu wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetItemExpireCallback%2A> metody, gdy moduł jest inicjowany, aby określić, czy wywołania `Session_OnEnd` zdarzeń są obsługiwane przez <xref:System.Web.SessionState.SessionStateStoreProviderBase> implementacji oraz powiązywania <xref:System.Web.SessionState.SessionStateItemExpireCallback> delegowanie przy użyciu `Session_OnEnd` zdarzeń.  
  
 Implementacje dostawcy niestandardowego magazynu stanu sesji należy używać <xref:System.Web.SessionState.SessionStateStoreProviderBase.SetItemExpireCallback%2A> metodę, aby poinformować <xref:System.Web.SessionState.SessionStateModule> obiektu czy wywołania `Session_OnEnd` zdarzeń są obsługiwane i ustawienie lokalnego odwołania <xref:System.Web.SessionState.SessionStateItemExpireCallback> dostarczonych przez delegata`expireCallback` parametru. Implementacja niestandardowa należy określić, kiedy lokalnej <xref:System.Web.SessionState.SessionStateItemExpireCallback> delegata, który zostanie wywołany. Na przykład delegata można wywołać podczas wywołania <xref:System.Web.SessionState.SessionStateStoreProviderBase.RemoveItem%2A> metody, która jest wywoływana, gdy sesja zostanie porzucony.  
  
   
  
## Examples  
 Na przykład implementacja dostawcy magazynu stanu sesji zobacz [implementowanie dostawcy stanu sesji Store](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
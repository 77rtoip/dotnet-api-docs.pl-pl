<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdbb31adc0ae8f212f39e294be512775a7c110ec" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52193114" /></Metadata><TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia zestaw metod pomagające w zarządzaniu kompilacją aplikacji ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Compilation.BuildManager> Klasa zarządza procesem kompilowanie zestawów i stron aplikacji. Klasa zapieczętowana jest i nie może być dziedziczona.  
  
 <xref:System.Web.Compilation.BuildManager> zawiera statyczne elementy członkowskie, które zawierają informacje o skompilowanych zestawów.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dependency">Ciąg, który reprezentuje zależność.</param>
        <summary>Określa ciąg, który reprezentuje zależność, która korzysta z menedżerem kompilacji w celu określenia, czy konieczne jest czysta kompilacja.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda musi zostać wywołane podczas `Application_PreStartInit` etapu aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="dependency" /> Parametr jest <see langword="null" /> ani być pustym ciągiem.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda została wywołana po <see langword="Application_PreStartInit" /> etapu aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Zestaw do dodania.</param>
        <summary>Dodaje zestaw, do zestawu aplikacji przywoływanych zestawów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest odpowiednikiem dodawania zestawu do pliku Web.config aplikacji. Metoda musi zostać wywołane podczas `Application_PreStartInit` etapu aplikacji.  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> Metoda zwróci zbiór zestawów, które są ustalane na podstawie plików konfiguracji i dowolne zestawy, które zostały dodane za pomocą tej metody.  
  
 Jeśli zostanie podjęta próba można dodać zestawu, który został już dodany, zduplikowany wpis zostanie zignorowany.  
  
 Ta metoda musi zostać wywołana przed `Application_Start` wystąpienia zdarzenia w pliku Global.asax.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> Parametr jest <see langword="null" /> lub jest pusty.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda nie została wywołana przed <see langword="Application_Start" /> wystąpiło zdarzenie w pliku Global.asax.</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy włączono kompilacji wsadowej.</summary>
        <value><see langword="true" /> Jeśli kompilacja wsadowa jest zawsze włączone, <see langword="false" /> Jeśli wsadów nigdy nie jest włączona, lub <see langword="null" /> Jeśli ustawienia kompilacji jest określana na podstawie pliku konfiguracji. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia włączanie wsadów lub wyłączanie programowo. Odnosi się do `batch` atrybutu `compilation` elementu w pliku Web.config. Aby uzyskać więcej informacji, zobacz [kompilacji elementu (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/7c319582-074a-4d2a-a787-03b9d4541c12).  
  
 Właściwość można ustawić tylko w `PreApplicationStart` metody. Aby uzyskać więcej informacji na temat `PreApplicationStart` metody, zobacz <xref:System.Web.PreApplicationStartMethodAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości <see langword="PreApplicationStart" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę zestawów zbudowanych z katalogu App_Code.</summary>
        <value><see cref="T:System.Collections.IList" /> Kolekcji, która zawiera zestawy skompilowane z katalogu App_Code.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku do utworzenia.</param>
        <summary>Tworzy plik buforowany.</summary>
        <returns><see cref="T:System.IO.Stream" /> Obiektu dla nowego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda i <xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A> metody umożliwiają wykonywanie, buforowanie, są utrwalane w aplikacja domeny uruchamia się ponownie w środowisku częściowego zaufania. Jest on używany przez platformę MVC w celu buforowania wyników wyszukiwania kontrolera.  
  
 Do danych w pamięci podręcznej zapisu do <xref:System.IO.Stream> obiekt, który jest zwracany przez tę metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna pliku do utworzenia wystąpienia.</param>
        <param name="requiredBaseType">Typ podstawowy, który definiuje obiekt, który ma zostać utworzony.</param>
        <summary>Plik jest przetwarzany, podaniu jego ścieżki wirtualnej, a następnie tworzy wystąpienie wyniku.</summary>
        <returns><see cref="T:System.Object" /> Reprezentujący wystąpienie przetwarzania plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A> Metoda działa w przypadku skompilowanych i skompilować wg stron.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca zależności kompilacji zestawu z pamięci podręcznej platformy ASP.NET.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">Kontekst żądania.</param>
        <param name="virtualPath">Ustaw ścieżkę wirtualną, z którego można określić zależność kompilacji.</param>
        <summary>Zwraca zależność kompilacji, ustaw dla ścieżki wirtualnej, jeśli ścieżka znajduje się w pamięci podręcznej platformy ASP.NET.</summary>
        <returns>A <see cref="T:System.Web.Compilation.BuildDependencySet" /> obiekt, który jest przechowywany w pamięci podręcznej, lub <see langword="null" /> Jeśli <see cref="T:System.Web.Compilation.BuildDependencySet" /> nie można pobrać obiektu z pamięci podręcznej.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="context">Kontekst żądania.</param>
        <param name="virtualPath">Ustaw ścieżkę wirtualną, z którego można określić zależność kompilacji.</param>
        <param name="ensureIsUpToDate"><see langword="true" /> Aby określić, że tylko bieżącej kompilacji zależności zestawu ma zostać zwrócone, lub <see langword="false" /> do wskazania, czy ma zostać zwrócone każdego zestawu zależności kompilacji dostępne, nawet jeśli nie jest aktualna. Wartość domyślna to <see langword="true" />.</param>
        <summary>Zwraca zależność kompilacji, ustaw dla ścieżki wirtualnej, jeśli ścieżka znajduje się w pamięci podręcznej programu ASP.NET, nawet jeśli zawartość nie jest aktualna.</summary>
        <returns>A <see cref="T:System.Web.Compilation.BuildDependencySet" /> obiekt, który jest przechowywany w pamięci podręcznej, lub <see langword="null" /> Jeśli <see cref="T:System.Web.Compilation.BuildDependencySet" /> nie można pobrać obiektu z pamięci podręcznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `ensureIsUpToDate` parametr ma wartość `true`, <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> przeciążenie metody zachowuje się jak <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> przeciążenie metody. Oba przeciążenia Zwraca bieżące zależność kompilacji, ustaw, jeśli taki istnieje, w przeciwnym razie zwracają `null`.  
  
 Jednak <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> przeciążenie metody zawiera opcję do zwrócenia każdego zestawu zależności kompilacji, która jest dostępna, nawet jednego nieaktualne. Jeśli `ensureIsUpToDate` parametr ma wartość `false`, który zwróci metoda każdego zestawu zależności kompilacji dostępne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna do zestawu.</param>
        <summary>Kompiluje plik do zestawu przy użyciu określonej ścieżki wirtualnej.</summary>
        <returns><see cref="T:System.Reflection.Assembly" /> Obiektu, który jest kompilowany z określonej ścieżki wirtualnej są buforowane, albo pamięci lub na dysku.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna pliku w celu utworzenia.</param>
        <summary>Kompiluje plik po podaniu jego ścieżki wirtualnej i zwraca ciąg niestandardowy, który dostawca kompilacji utrzymuje się w pamięci podręcznej.</summary>
        <returns>Ciąg, ponieważ zwróciło <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" /> metody, który jest buforowana na dysku lub pamięci.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna do typu.</param>
        <summary>Kompiluje plik po podaniu jego ścieżki wirtualnej i zwraca typ skompilowany.</summary>
        <returns>Element <see cref="T:System.Type" /> obiektu, który reprezentuje typ, generowany na podstawie kompilowanie ścieżki wirtualnej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Wystąpił błąd podczas kompilowania ścieżki wirtualnej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który reprezentuje typ skompilowany w pliku Global.asax.</summary>
        <returns>Obiekt, który reprezentuje typ skompilowany w pliku Global.asax.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek jest generowany, jeśli ta metoda jest wywoływana przed w pliku Global.asax został skompilowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aby wywołać tę metodę, zanim został skompilowany strony Global.asax nastąpiła próba.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna.</param>
        <param name="throwIfNotFound"><see langword="true" /> Aby zgłosić błąd, jeśli ścieżka wirtualna nie istnieje; w przeciwnym razie <see langword="false" />. Jeśli ścieżka wirtualna nie istnieje i <paramref name="throwIfNotFound" /> jest <see langword="false" />, Metoda ta zwraca <see langword="null" />.</param>
        <summary>Pobiera fabrykę obiektu dla określonej ścieżki wirtualnej.</summary>
        <returns>Fabryka obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca obiekt, który umożliwia generowanie typu przez skompilowanie ścieżki wirtualnej. Zwraca obiekt, niezależnie od tego, czy witryny sieci Web są wstępnie skompilowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Ścieżka wirtualna nie istnieje.  
  
—lub— 
Wyjątek wyższego poziomu już istniała, gdy ta metoda została wywołana.  
  
—lub— 
Ta metoda została wywołana, gdy proces kompilacji w budowaniu najwyższego poziomu plików.  
  
—lub— 
Jest to wstępnie skompilowanych aplikacji, a ścieżka wirtualna nie został znaleziony w pamięci podręcznej.  
  
—lub— 
Wykryto odwołanie cykliczne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę odwołań do zestawów, które musi odwoływać się wszystkie kompilacje strony.</summary>
        <returns><see cref="T:System.Collections.ICollection" /> Kolekcji odwołania do zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zbiór zestawów, które są zwracane z <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> metoda zawiera zestawy określone w elemencie w pliku Web.config, zestawami skompilowanymi z kodu niestandardowego w katalogu App_Code i zestawy w innych folderach najwyższego poziomu.  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> został wprowadzony w .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje programu .NET Framework i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Znajduje typ w zestawy najwyższego poziomu lub w zestawach, które są zdefiniowane w konfiguracji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najwyższego poziomu zestawu odwołuje się do pliku Global.asax lub do pliku, który znajduje się w katalogu App_GlobalResources, App_WebReferences, App_Code lub App_Browsers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu.</param>
        <param name="throwOnError"><see langword="true" /> Aby zgłosić wyjątek, jeśli <see cref="T:System.Type" /> obiekt nie może być wygenerowany dla nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Odnajduje typ, zespoły najwyższego poziomu lub w zestawach, które są zdefiniowane w konfiguracji i opcjonalnie zgłasza wyjątek w przypadku niepowodzenia.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje żądany <paramref name="typeName" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najwyższego poziomu zestawu odwołuje się do pliku Global.asax lub do pliku, który znajduje się w katalogu App_GlobalResources, App_WebReferences, App_Code lub App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> jest nieprawidłowy.  
  
\- lub — 
 <paramref name="typeName" /> jest niejednoznaczna.  
  
\- lub — 
 <paramref name="typeName" /> Nie można odnaleźć, i <paramref name="throwOnError" /> jest <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu.</param>
        <param name="throwOnError"><see langword="true" /> Aby zgłosić wyjątek, jeśli <see cref="T:System.Type" /> nie może być wygenerowany dla nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <param name="ignoreCase"><see langword="true" /> Jeśli <paramref name="typeName" /> jest rozróżniana wielkość liter; w przeciwnym razie <see langword="false" />.</param>
        <summary>Znajduje typ w zestawy najwyższego poziomu lub w zestawach, które są zdefiniowane w konfiguracji przy użyciu wyszukiwania bez uwzględniania wielkości liter i opcjonalnie zostanie zgłoszony wyjątek w przypadku niepowodzenia.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje żądany <paramref name="typeName" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najwyższego poziomu zestawu odwołuje się do pliku Global.asax lub do pliku, który znajduje się w katalogu App_GlobalResources, App_WebReferences, App_Code lub App_Browsers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> jest nieprawidłowy.  
  
\- lub — 
 <paramref name="typeName" /> jest niejednoznaczna.  
  
\- lub — 
 <paramref name="typeName" /> Nie można odnaleźć, i <paramref name="throwOnError" /> jest <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ścieżka wirtualna używana w celu określenia zależności.</param>
        <summary>Zawiera kolekcję zależności ścieżkę wirtualną określonej ścieżki wirtualnej.</summary>
        <returns><see cref="T:System.Collections.ICollection" /> Zbiór plików reprezentowanych przez ścieżki wirtualne, które są buforowania zależności dla ścieżki wirtualnej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy aplikacja jest wstępnie skompilowany.</summary>
        <value><see langword="true" /> Jeśli aplikacja jest wstępnie skompilowanym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy aplikacja jest wstępnie skompilowany jako nadaje się do aktualizacji.</summary>
        <value><see langword="true" /> Jeśli aplikacja jest wstępnie skompilowanym jako aktualizowalnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku do odczytu.</param>
        <summary>Odczytuje plik buforowany.</summary>
        <returns><see cref="T:System.IO.Stream" /> Obiektu dla pliku lub <see langword="null" /> Jeśli plik nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda i <xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A> metody umożliwiają wykonywanie, buforowanie, są utrwalane w aplikacja domeny uruchamia się ponownie w środowisku częściowego zaufania. Jest on używany przez platformę MVC w celu buforowania wyników wyszukiwania kontrolera.  
  
 Aby pobrać dane w pamięci podręcznej, możesz odczytywać <xref:System.IO.Stream> obiekt, który jest zwracany przez tę metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję docelową .NET Framework dla bieżącej witryny sieci Web.</summary>
        <value>Wersję docelową .NET Framework dla bieżącej witryny sieci Web.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość obsługuje funkcji wielowersyjność kodu ASP.NET, która umożliwia używanie najnowszej wersji programu Visual Studio do opracowywania aplikacji, które będą uruchamiane w starszych wersjach programu .NET Framework. Dostawcę konstrukcji można użyć tej właściwości, aby upewnić się, że dostawca generuje kod, który jest odpowiedni dla wersji docelowej programu .NET Framework. Na przykład warto wygenerować inny kod, w zależności od tego, czy cele witryny sieci Web [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] lub [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]. Aby uzyskać więcej informacji na temat wielowersyjnością kodu – zobacz [.NET Framework Wielowersyjność kodu dla projektów sieci Web platformy ASP.NET](https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76).  
  
 Jeśli witryna sieci Web nie ma on pliku Web.config, ASP.NET założeniu, że wersji platformy docelowej wersji, która jest skojarzona z puli aplikacji usług IIS, w lokacji działa. Dla witryny sieci Web systemu plików, który jest uruchomiony w programie Visual Studio wersja platformy domyślną jest bieżąca wersja programu .NET Framework.  
  
 Jeśli witryna sieci Web ma on pliku Web.config, platformy ASP.NET określa platformę docelową, sprawdzając plik Web.config.  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>Witryny sieci Web dla środowiska .NET Framework w wersji 2.0  
 Aplikacje internetowe, których platformą docelową [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] są kompilowane tak, jakby były docelowego [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]. Proces kompilacji nie rozróżnienia między [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] i [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] ponieważ plik Web.config nie wskazuje kompilatora wersji lub target framework, gdy jedna z tych wersji architekturą docelową jest. (Dla [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)], plik Web.config określa wersji kompilatora i [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], plik Web.config Określa platformę docelową.) W związku z tym, dla aplikacji sieci Web przeznaczonych [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], właściwość ta zwraca monikerem platformy docelowej, która wskazuje [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)].  
  
 Zwykle nie powoduje żadnych problemów. Program Visual Studio uniemożliwia tworzenie odwołań do [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] funkcji w projekcie, który jest przeznaczony dla [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]. Na przykład programu Visual Studio nie zapewnia szablony elementów usług WCF w projekcie, który jest przeznaczony dla [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], ponieważ WCF została wprowadzona w systemach [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] i nie jest zgodny z [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 Jeśli planujesz Wdrażanie witryny sieci Web w [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] środowiska wykonawczego i użyć narzędzia innego niż program Visual Studio do funkcji odwołania, które są zgodne tylko z [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], projektu mogą kompilować bez generowania błędy lub ostrzeżenia. Jednak aplikacja może generować błędy w witrynie sieci Web działa na [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
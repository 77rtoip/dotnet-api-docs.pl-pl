<Type Name="IArgumentProvider" FullName="System.Linq.Expressions.IArgumentProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bb1b0a12225c49cd06302a4822210d08cda2957f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30457053" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IArgumentProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IArgumentProvider" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.IArgumentProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface IArgumentProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class IArgumentProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Interfejs wewnętrzny do uzyskiwania dostępu do argumentów wiele węzłów drzewa (DynamicExpression, ElementInit MethodCallExpression, InvocationExpression, NewExpression i InexExpression).  Nie należy używać tego interfejsu API.  Tylko publiczne z powodu refaktoryzacji biblioteki DLL i jest istnieje tylko w przypadku optymalizacji wydajności wewnętrznego.  
  
 Dzięki temu dwie funkcje optymalizacji, które zmniejszyć rozmiar drzewa wyrażeń.  Pierwszy umożliwia węzły drzewa do przechowywania na interfejsie IList&lt;T&gt; zamiast ReadOnlyCollection.  IList&lt;T&gt; zapisuje koszt przydziału ReadOnlyCollection dla każdego węzła.  Drugi umożliwia tworzenie podklasy specjalne, których są przechowywane na określoną liczbę argumentów (na przykład Block2, Block3, Block4).  W związku z tym te węzły unikać zarówno ReadOnlyCollection, jak i tablicy do przechowywania swoich elementów, zapisywanie 32 bajtów w każdym węźle.  
  
 Węzły drzewa wyrażenia w dalszym ciągu udostępnić oryginalne właściwości ReadOnlyCollections LINQ.  Węzły w tym celu ponownie za pomocą pola do przechowywania zarówno tablicy lub element, który normalnie powinny być przechowywane w tablicy.  
  
 W przypadku tablicy kolekcji jest wpisana do IList&lt;T&gt; zamiast ReadOnlyCollection&lt;T&gt;.  Gdy węzeł jest początkowo utworzony jest tablicą.  Gdy kompilator uzyskuje dostęp do elementów członkowskich używa tego interfejsu.  Uzyskiwanie dostępu do elementów tablicy zamienia tablicy, tak aby ReadOnlyCollection.  
  
 W przypadku obiektu pierwszy argument są przechowywane w polu wpisany do obiektu.  Gdy węzeł jest początkowo utworzony, pole zawiera wyrażenie.  Kompilator uzyskuje dostęp do argumentów za pośrednictwem tego interfejsu i dostępu dla pierwszego argumentu za pomocą Expression.ReturnObject obiekt, który obsługuje przypadek wyrażenie lub wartość ReadOnlyCollection.  Gdy użytkownik uzyskuje dostęp do ReadOnlyCollection, pole obiektu jest aktualizowana do przechowywania bezpośrednio na wartość ReadOnlyCollection.  
  
 Należy pamiętać, że wyrażeń stale zwracają tego samego ReadOnlyCollection.  W przeciwnym razie przerwie walkera drzewa modułu ponownego zapisywania.  Jest istotne zmiany od v1 LINQ do zwrócenia innego ReadOnlyCollections tworzą tego samego węzła wyrażenia.  Obecnie użytkownicy mogą polegać na tożsamość obiektu stwierdzić, czy węzeł został zmieniony.  Przechowywanie ReadOnlyCollection przeciążone pola zarówno zmniejsza zużycie pamięci i obsługuje zgodności dla publiczny interfejs API.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ArgumentCount">
      <MemberSignature Language="C#" Value="public int ArgumentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ArgumentCount" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArgumentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ArgumentCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca liczbę argumentów do węzła drzewa wyrażenia.  Nie należy używać tego typu.  Jest on tylko publiczne z powodu zestawu refaktoryzacji i jest używana wewnętrznie do optymalizacji wydajności.</summary>
        <value>Liczba argumentów dla węzła drzewa wyrażenia jako <see cref="T:System.Int32" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArgument">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression GetArgument (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression GetArgument(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArgument (index As Integer) As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ GetArgument(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks argumentu.</param>
        <summary>Zwraca argument w indeksie, wyrzucanie Jeśli indeks jest poza zakresem.  Nie należy używać tego typu.  Jest on tylko publiczne z powodu zestawu refaktoryzacji i jest używana wewnętrznie do optymalizacji wydajności.</summary>
        <returns>Argument w indeksie, wyrzucanie Jeśli indeks jest poza zakresem jako <see cref="T:System.Linq.Expressions.Expression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
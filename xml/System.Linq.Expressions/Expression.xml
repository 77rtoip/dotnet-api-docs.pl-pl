<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4e9615e4182e6b650a9cbb9024f593836bd0e0ca" />
    <Meta Name="ms.sourcegitcommit" Value="1b899505ed6d42225f2b3c9150bfdc080d0d1f9b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/28/2018" />
    <Meta Name="ms.locfileid" Value="32090637" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia klasę podstawową, od których pochodzą klasy, które reprezentują węzły drzewa wyrażenia. Zawiera także <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodami factory, aby utworzyć różne typy węzłów. Jest to <see langword="abstract" /> klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia bloku. Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Można ustawić jako typ węzła.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Tego <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana z konstruktorów w klasach pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Obiekt odwiedzający odwiedź ten węzeł z.</param>
        <summary>Wysyła do konkretnych można znaleźć metody dla tego typu węzła. Na przykład <see cref="T:System.Linq.Expressions.MethodCallExpression" /> wywołania <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
        <returns>Wynik tego węzła na stronę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta domyślna implementacja dla <xref:System.Linq.Expressions.ExpressionType.Extension> wywołania węzłów <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>. Przesłonić tę metodę do wywołania do bardziej szczegółowych metody w klasie pochodnej odwiedzający z <xref:System.Linq.Expressions.ExpressionVisitor> klasy. Obsługuje on jednak powinien nadal nieznany odwiedzających przez wywołanie metody <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który dodaje dwie liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która nie ma sprawdzanie przepełnienia. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> a operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które dodaje wartość do zmiennej całkowitą, a następnie przypisuje wynik operacji do zmiennej.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> a operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku predefiniowanych bitowe `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `AND` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje logicznej operacji AND na dwóch wartości logicznych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bitowe <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku predefiniowanych bitowe `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `AND` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="AND" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="AND" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="true" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkowe `AND` operator jest oceniane przy użyciu operatora testu koniunkcji `AND` operatora. W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wykonuje logiczną i operacji na jego dwóch argumentów operacji tylko wtedy, gdy pierwszy argument operacji daje w wyniku `true`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bitowe <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  
  
 —lub—  
  
 <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="AND" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument nie zostanie rozwiązany na wartość true. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkowe `AND` operator jest oceniane przy użyciu operatora testu koniunkcji `AND` operatora. W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">Wyrażenie reprezentuje tablicy wielowymiarowej.</param>
        <param name="indexes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierające wyrażenia używane do indeksu tablicy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> można uzyskać dostępu do tablicy wielowymiarowej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie, które reprezentuje tablicę można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metody, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zmienić wartość elementu w tablicy wielowymiarowej przy użyciu `ArrayAccess` metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Wyrażenie reprezentujący indeksu tablicy.</param>
        <param name="indexes">Tablica zawiera wyrażenia używane do indeksu tablicy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie, które reprezentuje tablicę można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metody, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
 Tablice wielowymiarowe, można użyć <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób zmiany wartości elementu tablicy za pomocą `ArrayAccess` metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący zastosowanie operatora indeksu tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości.</param>
        <param name="indexes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy na tablicę rangi więcej niż jeden.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typu tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.  
  
 Jeśli rangę `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.  
  
 Jeśli rangę `array`. Typ jest więcej niż jeden, ta metoda zwraca <xref:System.Linq.Expressions.MethodCallExpression>. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> metody wystąpienia publicznego, który opisuje `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący przeprowadzane jest indeksowanie do tablicą dwuwymiarową.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie odpowiada typowi tablicy.  
  
 —lub—  
  
 Rangę <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="index">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zastosowanie operatora indeksu tablicy na tablicę rangi jeden.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` musi reprezentować indeksu typu <xref:System.Int32>.  
  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest `null`, a oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest taki sam typ elementu `array`. Typ. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="index" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie odpowiada typowi tablicy.  
  
 —lub—  
  
 <paramref name="array" />. Typ reprezentuje typ tablicy, której pozycję nie jest 1.  
  
 —lub—  
  
 <paramref name="index" />. Typ nie reprezentuje <see cref="T:System.Int32" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Tablica <see cref="T:System.Linq.Expressions.Expression" /> wystąpienia - indeksów dla operacji indeksu tablicy.</param>
        <param name="indexes">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy do tablicy wielowymiarowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typu tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.  
  
 Jeśli rangę `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.  
  
 Jeśli rangę `array`. Typ jest więcej niż jeden, ta metoda zwraca <xref:System.Linq.Expressions.MethodCallExpression>. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> metody wystąpienia publicznego, który opisuje `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący przeprowadzane jest indeksowanie do tablicą dwuwymiarową.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie odpowiada typowi tablicy.  
  
 —lub—  
  
 Rangę <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia dla uzyskania długość tablicy jednowymiarowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typem tablicy.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> jest równa <xref:System.Int32>. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość jest `null`, a oba <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są ustawione na `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie odpowiada typowi tablicy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operatora przypisania.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Assign` Wyrażenie kopiuje wartości dla typów wartości i kopiuje punkt odniesienia dla typów referencyjnych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje operatora przypisania.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie elementu członkowskiego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie pola lub właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być można przypisać do typu reprezentowanego przez <xref:System.Reflection.FieldInfo.FieldType%2A> lub <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość `member`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> lub <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentować pole lub właściwość.  
  
 —lub—  
  
 Właściwości reprezentowanej przez <paramref name="member" /> nie ma <see langword="set" /> metody dostępu.  
  
 —lub—  
  
 <paramref name="expression" />. Typ nie jest można przypisać do typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę dostępu właściwości.</param>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie elementu członkowskiego przy użyciu metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ustawioną właściwość <paramref name="expression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być można przypisać do typu reprezentowanego przez <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwości dostęp do właściwości `propertyAccessor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> lub <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.  
  
 —lub—  
  
 Właściwość, do której dostęp <paramref name="propertyAccessor" /> nie ma <see langword="set" /> metody dostępu.  
  
 —lub—  
  
 <paramref name="expression" />. Typ nie jest można przypisać do typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera danego wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera danego wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia bloku. Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak przekazać parametr do wyrażenia bloku i przetworzenie tego parametru w bloku.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera dwa wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> która zawiera danego wyrażenia, nie ma zmiennych i ma typ określony wynik.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> która zawiera danego wyrażenia, nie ma zmiennych i ma typ określony wynik.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzeci wyrażenie w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera trzy wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzeci wyrażenie w bloku.</param>
        <param name="arg3">Czwartym wyrażenie w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera cztery wyrażeń i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzeci wyrażenie w bloku.</param>
        <param name="arg3">Czwartym wyrażenie w bloku.</param>
        <param name="arg4">Piątym wyrażenie w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera pięć wyrażeń i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i wartość null do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.LoopExpression> obiekt, który używa <xref:System.Linq.Expressions.Expression.Break%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="value">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break. Można określić wartość przekazana do etykiety na przejście.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="value">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem. Można określić wartość przekazana do etykiety na przejście.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania metody wystąpienia (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która nie przyjmuje żadnych argumentów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) — metoda, Przekaż `null` dla `instance` parametru, gdy ta metoda jest wywoływana.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwe przypisanie typ deklarujący metodzie reprezentowany przez `method`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest taki sam zwracany typ metody reprezentowany przez `method`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wywołuje metodę bez argumentów.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metody wystąpienia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody docelowej.</param>
        <param name="arguments">Kolekcja <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący argumenty wywołania.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej (Shared w języku Visual Basic).</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodę, która przyjmuje jeden argument.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie, które wywołuje `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodę, aby ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `arguments` nie jest `null`, musi mieć taką samą liczbę elementów jak liczba parametrów metody reprezentowany przez `method`. Każdy element `arguments` nie może być `null` i musi być możliwe przypisanie z odpowiadającym parametrem elementu `method`, prawdopodobnie po *zamykający*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy jako `arguments`, niektóre z nich mogą zostać podane.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody reprezentowany przez `method`. <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Jest właściwość `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="arguments" /> nie równa się z liczbą parametrów metody reprezentowany przez <paramref name="method" />.  
  
 —lub—  
  
 Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwa do przypisania do odpowiadającego mu parametru w metodzie reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) — metoda, Przekaż `null` dla `instance` parametr podczas wywoływania tej metody, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwe przypisanie typ deklarujący metodzie reprezentowany przez `method`.  
  
 Jeśli `arguments` nie jest `null`, musi mieć taką samą liczbę elementów jak liczba parametrów metody reprezentowany przez `method`. Każdy element `arguments` nie może być `null` i musi być możliwe przypisanie z odpowiadającym parametrem elementu `method`, prawdopodobnie po *zamykający*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy jako `arguments`, niektóre z nich mogą zostać podane.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody reprezentowany przez `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metody wystąpienia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="method" />.  
  
 —lub—  
  
 Liczba elementów w <paramref name="arguments" /> nie równa się z liczbą parametrów metody reprezentowany przez <paramref name="method" />.  
  
 —lub—  
  
 Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwa do przypisania do odpowiadającego mu parametru w metodzie reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania metody wystąpienia (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) — metoda, Przekaż `null` dla `instance` parametr podczas wywoływania tej metody, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwe przypisanie typ deklarujący metodzie reprezentowany przez `method`.  
  
 Jeśli `arguments` nie jest `null`, musi mieć taką samą liczbę elementów jak liczba parametrów metody reprezentowany przez `method`. Każdy element `arguments` nie może być `null` i musi być możliwe przypisanie z odpowiadającym parametrem elementu `method`, prawdopodobnie po *zamykający*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy jako `arguments`, niektóre z nich mogą zostać podane.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody reprezentowany przez `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metody wystąpienia.  
  
 —lub—  
  
 <paramref name="arguments" /> nie jest <see langword="null" /> i co najmniej jeden z jego elementów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="method" />.  
  
 —lub—  
  
 Liczba elementów w <paramref name="arguments" /> nie równa się z liczbą parametrów metody reprezentowany przez <paramref name="method" />.  
  
 —lub—  
  
 Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwa do przypisania do odpowiadającego mu parametru w metodzie reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, który przyjmuje dwa argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia. (należy przekazać wartość null dla metody statyczne (Shared w języku Visual Basic)).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody docelowej.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje dwa argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, która wywołuje metodę wystąpienia, która ma dwa argumenty.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> wartość właściwości ma zostać wyszukany określonej metody.</param>
        <param name="methodName">Nazwa metody.</param>
        <param name="typeArguments">Tablica <see cref="T:System.Type" /> obiektów, które określają parametrów typu metody ogólnej. Ten argument musi mieć wartość null, gdy methodName wskazuje metodę nierodzajową.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które reprezentuje argumenty metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, wywołując metodę odpowiednie fabryki.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawioną <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę określonego wystąpienia i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ustawioną określonych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak metody o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.  
  
 —lub—  
  
 Więcej niż jedną metodę o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, który przyjmuje trzy argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> , Który określa typ, który zawiera określony <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda.</param>
        <param name="methodName">Nazwa metody.</param>
        <param name="typeArguments">Tablica <see cref="T:System.Type" /> obiektów, które określają parametrów typu metody ogólnej. Ten argument musi mieć wartość null, gdy methodName wskazuje metodę nierodzajową.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda, przez wywołanie metody odpowiednie fabryki.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawioną właściwość <see cref="T:System.Reflection.MethodInfo" /> reprezentujący określonego <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> Właściwość do określonych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`. <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Jest właściwość `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak metody o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="type" /> ani jego typach podstawowych.  
  
 —lub—  
  
 Więcej niż jedną metodę o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="type" /> ani jego typach podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia. (należy przekazać wartość null dla metody statyczne (Shared w języku Visual Basic)).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody docelowej.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody pobierającej trzech argumentów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <param name="arg3">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, który przyjmuje cztery argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <param name="arg3">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</param>
        <param name="arg4">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący piąty argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie statycznej metody pobierającej argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy można zmniejszyć węzła do węzła prostsze. Jeśli zostanie zwrócona wartość true, Reduce() można wywołać w celu utworzenia zmniejszenie formularza.</summary>
        <value>Wartość true, jeśli węzeł może być obniżona, w przeciwnym razie wartość false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcji catch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołanie do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcji catch z odwołaniem do zgłoszony <see cref="T:System.Exception" /> obiekt do użycia w treści procedury obsługi.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</param>
        <param name="body">Treść instrukcji catch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcji catch.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> z <xref:System.Exception> wychwycony może być określony, ale żadne odwołanie do <xref:System.Exception> obiekt będzie dostępny do użycia w <xref:System.Linq.Expressions.CatchBlock>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołanie do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z <see cref="T:System.Exception" /> filtru i odwołania do zgłoszony <see cref="T:System.Exception" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z <see cref="T:System.Exception" /> filtru, ale żadne odwołanie do zgłoszony <see cref="T:System.Exception" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> czyszczenie punktu sekwencji.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> dla proces czyszczenia punktu sekwencji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący łączącego operację.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący łączącego operację.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest `null` i oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest taki sam typ wyniku operacji łączącego. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
#### <a name="result-type"></a>Typ wyniku  
 Typ wyniku określa następujące reguły:  
  
-   Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie przekonwertować typu odpowiadającego wartości null, typ wyniku jest odpowiednikiem wartości null `left`. Typ.  
  
-   W przeciwnym razie, jeśli `right`. Typ jest niejawnie przekonwertować `left`. Typ jest typ wyniku `left`. Typ.  
  
-   W przeciwnym razie, jeśli odpowiednikiem wartości null `left`. Typ jest niejawnie przekonwertować `right`. Typ jest typ wyniku `right`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartości null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego podanej funkcji konwersji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest `null` i oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest taki sam typ wyniku operacji łączącego.  
  
 Typ wyniku określa następujące reguły:  
  
-   Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie przekonwertować typu odpowiadającego wartości null, typ wyniku jest odpowiednikiem wartości null `left`. Typ.  
  
-   W przeciwnym razie, jeśli `right`. Typ jest niejawnie przekonwertować `left`. Typ jest typ wyniku `left`. Typ.  
  
-   W przeciwnym razie, jeśli odpowiednikiem wartości null `left`. Typ jest niejawnie przekonwertować `right`. Typ jest typ wyniku `right`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie.  
  
 —lub—  
  
 <paramref name="conversion" /> nie jest <see langword="null" /> i <paramref name="conversion" />. Typ jest typem delegowanym, który nie przyjmuje dokładnie jeden argument.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartości null.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> reprezentuje typ, który nie jest możliwa do przypisania do typu parametru typu delegata <paramref name="conversion" />. Typ.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="right" /> nie jest taki sam typ zwracany typ delegowany <paramref name="conversion" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ConditionalExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `ifTrue`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który reprezentuje instrukcji warunkowej. Jeśli pierwszy argument ma wartość `true`, drugi argument jest wykonane; w przeciwnym razie, trzeci argument jest wykonywana.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="test" /> lub <paramref name="ifTrue" /> lub <paramref name="ifFalse" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="test" />. Typ nie jest <see cref="T:System.Boolean" />.  
  
 —lub—  
  
 <paramref name="ifTrue" />. Typ nie jest równa <paramref name="ifFalse" />. Typ.</exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia wyraźnie widać typ wyniku wyrażenia warunkowego, w przypadkach, gdy typy `ifTrue` i `ifFalse` wyrażenia nie są takie same. Oba rodzaje `ifTrue` i `ifFalse` musi być niejawnie odniesienia można przypisać do typu wyniku. `type` Może być <xref:System.Void>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ConstantExpression> jest taki sam typ `value`. Jeśli `value` jest `null`, <xref:System.Linq.Expressions.Expression.Type%2A> jest równa <xref:System.Object>.  
  
 Do reprezentowania `null`, można również użyć <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> metody, z którą można jawnie określić typ.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje wartość stałą.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być przydatne w przypadku reprezentujących wartości typy dopuszczające wartości zerowe.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia reprezentuje stałą typu dopuszczającego wartości null i ustaw dla niego wartość `null`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see langword="null" /> i <paramref name="type" /> nie jest możliwa do przypisania z typu dynamicznego <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i wartość null do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia pętli, który używa <xref:System.Linq.Expressions.Expression.Continue%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />i wartość null do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.  
  
    -   Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` jest typem wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio zniesienia węzła.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.  
  
-   W przeciwnym razie jest unosiło węzła.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia reprezentujący operację umożliwić konwersję typu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, dla którego określono implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli metoda nie jest `null`, jest to metoda implementującej. Musi reprezentować inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument.  
  
-   W przeciwnym razie, jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.  
  
    -   Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` są typu wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio, węzeł została wyjęta.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.  
  
-   W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.  
  
 —lub—  
  
 <paramref name="expression" />. Typ nie jest możliwa do przypisania do typu argumentu metodę reprezentowaną przez <paramref name="method" />.  
  
 —lub—  
  
 Zwracany typ metody reprezentowany przez <paramref name="method" /> nie jest możliwa do przypisania do <paramref name="type" />.  
  
 —lub—  
  
 <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartości null i odpowiedni typ niedopuszczający wartości null nie jest równa typu argumentu lub typ zwracany odpowiednio metody reprezentowany przez <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jedną metodę, która odpowiada <paramref name="method" /> opis został znaleziony.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.  
  
    -   Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` są typu wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio, węzeł została wyjęta.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.  
  
-   W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony i dla którego określono implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli metoda nie jest `null`, jest to metoda implementującej. Musi reprezentować inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument.  
  
-   W przeciwnym razie, jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.  
  
    -   Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` są typu wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio, węzeł została wyjęta.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.  
  
-   W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.  
  
 —lub—  
  
 <paramref name="expression" />. Typ nie jest możliwa do przypisania do typu argumentu metodę reprezentowaną przez <paramref name="method" />.  
  
 —lub—  
  
 Zwracany typ metody reprezentowany przez <paramref name="method" /> nie jest możliwa do przypisania do <paramref name="type" />.  
  
 —lub—  
  
 <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartości null i odpowiedni typ niedopuszczający wartości null nie jest równa typu argumentu lub typ zwracany odpowiednio metody reprezentowany przez <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jedną metodę, która odpowiada <paramref name="method" /> opis został znaleziony.</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</param>
        <param name="startLine">Wiersz początkowy <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Musi być większa niż 0.</param>
        <param name="startColumn">Kolumna start <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Musi być większa niż 0.</param>
        <param name="endLine">Do zakończenia wiersza to <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Musi być mniejsza niż start wiersza.</param>
        <param name="endColumn">Końcowa kolumny tego <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Jeśli wiersz końcowy jest taki sam jak wiersz początkowy, jego musi być większy lub równy niż kolumna rozpoczęcia. W każdym przypadku musi być większa niż 0.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> z określonego zakresu.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszany wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie tego substracts 1 z danej wartości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszany wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DefaultExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość określonego typu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje vaule domyślny dla danego typu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku dzielenia wstępnie zdefiniowanego operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku dzielenia wstępnie zdefiniowanego operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, która dzieli bez reszty jej pierwszy parametr przez jej drugi argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator dzielenia nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku dzielenia wstępnie zdefiniowanego operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku dzielenia wstępnie zdefiniowanego operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator dzielenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <param name="arg3">Czwarty argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, używając podanych <see cref="T:System.Collections.Generic.IEnumerable`1" /> jako drugi argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ElementInit" /> Mający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` Parametru musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter). Metoda add musi mieć taką samą liczbę parametrów jako liczba elementów w `arguments`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiadającego mu parametru metody add prawdopodobnie po *zamykający*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Metoda który <paramref name="addMethod" /> reprezentuje nie ma nazwy "Dodaj" (bez uwzględniania wielkości liter).  
  
 —lub—  
  
 Metoda który <paramref name="addMethod" /> reprezentuje nie jest metodą wystąpienia.  
  
 —lub—  
  
 <paramref name="arguments" /> nie zawiera taką samą liczbę elementów jako liczba parametrów metody który <paramref name="addMethod" /> reprezentuje.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru metody który <paramref name="addMethod" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, podanej tablicy wartości jako drugi argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ElementInit" /> Mający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` Parametru musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter). Metoda add musi mieć taką samą liczbę parametrów jako liczba elementów w `arguments`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiadającego mu parametru metody add prawdopodobnie po *zamykający*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Metodę, która nie jest addMethod reprezentuje o nazwie "Dodaj" (bez uwzględniania wielkości liter).  
  
 —lub—  
  
 Metoda czy reprezentuje addMethod nie jest metodą wystąpienia.  
  
 —lub—  
  
 argumenty nie zawierać taką samą liczbę elementów w postaci z liczbą parametrów metody reprezentuje tego addMethod.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru metody który <paramref name="addMethod" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy puste wyrażenie, które ma <see cref="T:System.Void" /> typu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puste wyrażenie może służyć, gdy wyrażenie jest oczekiwany, ale jest potrzebne żadne działanie. Na przykład używając puste wyrażenie jako ostatni wyrażenie w wyrażeniu bloku. W takim przypadku wartość zwrotna wyrażenie bloku jest nieważne.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia puste wyrażenie i dodać je do wyrażenia bloku.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator równości <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które sprawdza, czy wartości dwa argumenty są takie same.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator równości <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operację, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku predefiniowanych `XOR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych `XOR` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje operacji XOR logicznej.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="XOR" /> Operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operację, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybrana implementacja metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku predefiniowanych `XOR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych `XOR` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i <see langword="XOR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR operacji przypisania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR przypisania operacji, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR przypisania operacji, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR przypisania operacji, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości. Aby uzyskać <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), <c>wyrażenie</c> musi być <see langword="null" />.</param>
        <param name="field">
          <see cref="T:System.Reflection.FieldInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość `field`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> jest <see langword="null" />.  
  
 —lub—  
  
 Pole reprezentowany przez <paramref name="field" /> nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie jest można przypisać do pola reprezentowane przez typ deklarujący <paramref name="field" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Których <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera pole o nazwie <c>fieldName</c>. Może to być wartość null dla pola statyczne.</param>
        <param name="fieldName">Nazwa pola, aby można było uzyskać dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola nazwę pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.FieldInfo" /> reprezentująca pole wskazywane przez <paramref name="fieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość <xref:System.Reflection.FieldInfo> reprezentująca pole wskazywane przez `fieldName`.  
  
 Ta metoda szuka `expression`. Typ i jego typów podstawowych dla pola o nazwie `fieldName`. Pola publiczne są preferowane względem niepublicznych pól. Jeśli zostanie znaleziony zgodnego pola, ta metoda przekazuje `expression` i <xref:System.Reflection.FieldInfo> reprezentujący to pole, aby <xref:System.Linq.Expressions.Expression.Field%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje podczas uzyskiwania dostępu do pola.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="fieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Brak pola o nazwie <paramref name="fieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Obiekt zawierający pola. Może to być wartość null dla pola statyczne.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierającego pole.</param>
        <param name="fieldName">Pole ma być uzyskiwany dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica do sixteen <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Action" /> typ delegata.</param>
        <summary>Tworzy <see cref="T:System.Type" /> obiekt, który reprezentuje ogólnego <c>elementu System.Action</c> przekazać typ, który ma argumenty określonego typu.</summary>
        <returns>Typ <c>elementu System.Action</c> delegata, który ma argumenty określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, powstałe w ten sposób <xref:System.Type> obiekt reprezentuje typ delegata skonstruowane `System.Action<T1,…,Tn>` w języku C# lub `System.Action(Of T1,…,Tn)` w języku Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> zawiera więcej niż szesnastu elementy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Argumenty typu delegata.</param>
        <summary>Pobiera <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> lub <c>elementu System.Action</c> przekazać typ, który ma argumenty określonego typu.</summary>
        <returns>Typ delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ostatni argument typu określa typ zwracany delegata. Nie Func akcji jest ani wystarczająco duży, wygeneruje typu delegata niestandardowych.  
  
 Podobnie jak w przypadku Func, ostatni argument jest typu zwracanego. Można można ustawić na System.Void wygenerowało akcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica co do seventeen <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Func" /> typ delegata.</param>
        <summary>Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> przekazać typ, który ma argumenty określonego typu. Ostatni argument typu określa typ zwracany delegata utworzony.</summary>
        <returns>Typ <c>System.Func</c> delegata, który ma argumenty określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs` musi zawierać co najmniej jedną i maksymalnie siedemnaście elementów.  
  
 Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, powstałe w ten sposób <xref:System.Type> obiekt reprezentuje typ delegata skonstruowane `System.Func<T1,…,Tn>` w języku C# lub `System.Func(Of T1,…,Tn)` w języku Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> zawiera mniej niż jeden lub więcej niż siedemnaście elementów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwość do przekazania do etykiety docelowej na przechodzenie do określonej wartości, a wartość null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.GotoExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="value">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do". Można określić wartość przekazana do etykiety na przejście.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> zestaw do określonej wartości właściwości <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />i wartość null do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="value">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem. Można określić wartość przekazana do etykiety na przejście.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie liczbowe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie liczbowe.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie liczbowe. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie liczbowe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie liczbowe.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie liczbowe.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego z <see langword="if" /> instrukcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, właściwości mają określone wartości. <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> Właściwość jest ustawiona na wyrażenie wartości domyślnej i typ powstałe w ten sposób <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracane przez tę metodę jest <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje blok warunkowego.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego z <see langword="if" /> i <see langword="else" /> instrukcje.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> właściwości mają określone wartości. Typ wyniku <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracane przez tę metodę jest <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje blok warunkowego.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększając wartość wyrażenia o 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Przyrost.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększając wartość wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększany wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartość obiektu, który jest przekazywany do niego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje operacji przyrostu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Przyrost.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przyroście wyrażenie 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększany wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartość obiektu, który jest przekazywany do niego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda ma zostać zastosowany do.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> dotyczący delegat lub wyrażenie lambda listę wyrażenia argumentów.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> reprezentuje typ zwracany delegata, który jest reprezentowany przez `expression`. Typ.  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy jako `arguments` z wyjątkiem, że niektóre z nich <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowaną*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiadającego mu parametru delegata reprezentowany przez `expression` jest typu <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie odpowiada typowi obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru delegowanego reprezentowany przez <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla delegata reprezentowany przez <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda ma zostać zastosowany.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> dotyczący delegat lub wyrażenie lambda listę wyrażenia argumentów.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> reprezentuje typ zwracany delegata, który jest reprezentowany przez `expression`. Typ.  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy jako `arguments` z wyjątkiem, że niektóre z nich <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowaną*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiadającego mu parametru delegata reprezentowany przez `expression` jest typu <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie odpowiada typowi obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru delegowanego reprezentowany przez <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla delegata reprezentowany przez <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca, czy wyrażenie ma wartość false.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <summary>Zwraca, czy wyrażenie ma wartość false.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Zwraca, czy wyrażenie ma wartość false.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca, czy wyrażenie daje w wyniku wartość true.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <summary>Zwraca, czy wyrażenie daje w wyniku wartość true.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Zwraca, czy wyrażenie daje w wyniku wartość true.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z typu void i bez nazwy.</summary>
        <returns>Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.LabelTarget> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Której ta <see cref="T:System.Linq.Expressions.LabelExpression" /> zostanie skojarzona.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący Etykieta bez wartości domyślnej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LabelExpression" /> bez wartości domyślnej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa etykiety.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety typu void o podanej nazwie.</summary>
        <returns>Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiet.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem.</summary>
        <returns>Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.LabelTarget> w wyrażeniu pętli.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Której ta <see cref="T:System.Linq.Expressions.LabelExpression" /> zostanie skojarzona.</param>
        <param name="defaultValue">Wartość tego <see cref="T:System.Linq.Expressions.LabelExpression" /> po osiągnięciu przez przepływu sterowania regularne etykiety.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący etykiety z daną wartość domyślną.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LabelExpression" /> z daną wartość domyślną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiet.</param>
        <param name="name">Nazwa etykiety.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem i nazwą.</summary>
        <returns>Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy drzewo wyrażenia, który reprezentuje wyrażenie lambda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym tworzeniu typem obiektu delegowanego.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `parameters` Parametr nie może mieć więcej niż szesnastu elementów.  
  
 Elementy `parameters` odwołania musi być równa wyrażeń w `body`.  
  
 Ta metoda tworzy typ delegata odpowiednie z jednego z `System.Func` delegatów. Następnie przekazuje typ delegata do jednego z <xref:System.Linq.Expressions.ExpressionType.Lambda> metodami factory, aby utworzyć <xref:System.Linq.Expressions.LambdaExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" /> zawiera więcej niż szesnastu elementy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa lambda. Używane w celu emisji informacji o debugowaniu.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="T:System.Type" /> reprezentujący podpis delegata lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym tworzeniu typem obiektu delegowanego. Można go po typie delegata nie jest znany w czasie kompilacji.</summary>
        <returns>Obiekt, który reprezentuje wyrażenie lambda, które ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany z tej funkcji jest typu <xref:System.Linq.Expressions.Expression%601>. <xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.  
  
 Liczba parametrów dla typu delegata reprezentowany przez`delegateType` musi być równa długości `parameters`.  
  
 Elementy `parameters` odwołania musi być równa wyrażeń w `body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt jest taki sam `delegateType`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje wyrażenie lambda, które dodaje 1 do przekazany argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.  
  
 —lub—  
  
 Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.  
  
 —lub—  
  
 <paramref name="body" />. Typ reprezentuje typ, który nie jest można przypisać do typ zwracany typ delegowany reprezentowany przez <paramref name="delegateType" />.  
  
 —lub—  
  
 <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata reprezentowany przez <paramref name="delegateType" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu z odpowiadającym typem parametru na typ delegata reprezentowany przez <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="T:System.Type" /> reprezentujący podpis delegata lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym tworzeniu typem obiektu delegowanego. Można go po typie delegata nie jest znany w czasie kompilacji.</summary>
        <returns>Obiekt, który reprezentuje wyrażenie lambda, które ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany z tej funkcji jest typu <xref:System.Linq.Expressions.Expression%601>. <xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.  
  
 Liczba parametrów dla typu delegata reprezentowany przez `delegateType` musi być równa długości `parameters`.  
  
 Elementy `parameters` odwołania musi być równa wyrażeń w `body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt jest taki sam `delegateType`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.  
  
 —lub—  
  
 Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.  
  
 —lub—  
  
 <paramref name="body" />. Typ reprezentuje typ, który nie jest można przypisać do typ zwracany typ delegowany reprezentowany przez <paramref name="delegateType" />.  
  
 —lub—  
  
 <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata reprezentowany przez <paramref name="delegateType" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu z odpowiadającym typem parametru na typ delegata reprezentowany przez <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa lambda. Używane w celu emisji informacji o debugowaniu.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa lambda. Używane w celu emisji informacji o debugowaniu.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa lambda. Używane w celu emisji informacji o debugowaniu.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ obiektu delegowanego.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.  
  
 Elementy `parameters` odwołania musi być równa wyrażeń w `body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt reprezentuje typ `TDelegate`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> jest <see langword="null" />.  
  
 —lub—  
  
 Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> nie jest typem delegowanym.  
  
 —lub—  
  
 <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwa do przypisania do zwracanego typu <paramref name="TDelegate" />.  
  
 —lub—  
  
 <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów <paramref name="TDelegate" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu danego parametru typu <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ obiektu delegowanego.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.  
  
 Elementy `parameters` odwołania musi być równa wyrażeń w`body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt reprezentuje typ `TDelegate`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> jest <see langword="null" />.  
  
 —lub—  
  
 Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> nie jest typem delegowanym.  
  
 —lub—  
  
 <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwa do przypisania do zwracanego typu <paramref name="TDelegate" />.  
  
 —lub—  
  
 <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów <paramref name="TDelegate" />.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu danego parametru typu <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa lambda. Używany do generowania informacji o debugowaniu.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa lambda. Używany do generowania informacji debugowania.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w lewo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w lewo, <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w lewo, <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator przesunięcia w lewo dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównanie liczbowe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównanie liczbowe.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównanie liczbowe.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie liczbowe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie liczbowe.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie liczbowe.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest on polem ani właściwością.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentować pole lub właściwość.  
  
 —lub—  
  
 <see cref="P:System.Reflection.FieldInfo.FieldType" /> Lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest on polem ani właściwością.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentować pole lub właściwość.  
  
 —lub—  
  
 <see cref="P:System.Reflection.FieldInfo.FieldType" /> Lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę dostępu właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> na podstawie metody dostępu określonej właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.MemberInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.  
  
 —lub—  
  
 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> Właściwości, która metoda reprezentowany przez <paramref name="propertyAccessor" /> dostępy nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę dostępu właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu oparte na metodę dostępu określonej właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.MemberInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.  
  
 —lub—  
  
 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> Właściwości, która metoda reprezentowany przez <paramref name="propertyAccessor" /> dostępy nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> które używa określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiektów do zainicjowania kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowe wystąpienie słownika z dwóch par klucz wartość.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą metodę o nazwie "Dodaj" można dodać elementów do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Typ argumentu musi być możliwa do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości pierwszego elementu obiektu `initializers`.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metody add, który został wykryty na `newExpression`. Typ lub jego typ podstawowy.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie istnieje metoda wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter) zadeklarowany w <paramref name="newExpression" />. Typ lub jego typ podstawowy.  
  
 —lub—  
  
 Metoda add na <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jeden argument.  
  
 —lub—  
  
 Typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości pierwszego elementu obiektu <paramref name="initializers" /> nie można przypisać do typu argumentu metody add na <paramref name="newExpression" />. Typ lub jego typ podstawowy.  
  
 —lub—  
  
 Istnieje więcej niż jedna metoda zgodnego argumentu o nazwie "Dodaj" (bez uwzględniania wielkości liter) na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> które używa określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiektów do zainicjowania kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowe wystąpienie słownika z dwóch par klucz wartość.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą metodę o nazwie "Dodaj" można dodać elementów do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Typ argumentu musi być możliwa do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości pierwszego elementu obiektu `initializers`.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metody add, który został wykryty na `newExpression`. Typ lub jego typ podstawowy.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie istnieje metoda wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter) zadeklarowany w <paramref name="newExpression" />. Typ lub jego typ podstawowy.  
  
 —lub—  
  
 Metoda add na <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jeden argument.  
  
 —lub—  
  
 Typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości pierwszego elementu obiektu <paramref name="initializers" /> nie można przypisać do typu argumentu metody add na <paramref name="newExpression" />. Typ lub jego typ podstawowy.  
  
 —lub—  
  
 Istnieje więcej niż jedna metoda zgodnego argumentu o nazwie "Dodaj" (bez uwzględniania wielkości liter) na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który dodaje element do kolekcji.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą określonej metody do dodawania elementów w kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Jeśli `addMethod` nie jest `null`, musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który ma dokładnie jeden parametr. Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.  
  
 —lub—  
  
 <paramref name="addMethod" /> nie jest <see langword="null" /> i nie reprezentuje metodę wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który przyjmuje dokładnie jeden argument.  
  
 —lub—  
  
 <paramref name="addMethod" /> nie jest <see langword="null" /> i typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody który <paramref name="addMethod" /> reprezentuje.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienia o nazwie "Dodaj", który przyjmuje jeden argument typu zgodnego istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę wystąpienia, który przyjmuje jeden argument, który dodaje element do kolekcji.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą określonej metody do dodawania elementów w kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Jeśli `addMethod` nie jest `null`, musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który ma dokładnie jeden parametr. Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.  
  
 —lub—  
  
 <paramref name="addMethod" /> nie jest <see langword="null" /> i nie reprezentuje metodę wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który przyjmuje dokładnie jeden argument.  
  
 —lub—  
  
 <paramref name="addMethod" /> nie jest <see langword="null" /> i typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody który <paramref name="addMethod" /> reprezentuje.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienia o nazwie "Dodaj", który przyjmuje jeden argument typu zgodnego istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Treści pętli.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Treści pętli.</param>
        <param name="break">Obiekt docelowy podziału używane przez treści pętli.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> z danym elementem docelowym treści i podziału.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia bloku, który zawiera <xref:System.Linq.Expressions.LoopExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Treści pętli.</param>
        <param name="break">Obiekt docelowy podziału używane przez treści pętli.</param>
        <param name="continue">Obiekt docelowy Kontynuuj używane przez treści pętli.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> przez wywołanie metody odpowiednie fabryki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację binarną.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący Lewy argument operacji.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy argument operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podanych argumentów operacji lewy i prawy przez wywołanie metody odpowiednie fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> ta metoda wywołuje metodę fabryki. Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> metodę w celu utworzenia <xref:System.Linq.Expressions.BinaryExpression> reprezentujący odejmowania jeden numer z innej.  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> nie odpowiada na węzeł wyrażenie binarne.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację binarną.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący Lewy argument operacji.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy argument operacji.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , który określa implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand i wdrażanie — metoda, przez wywołanie metody odpowiednie fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki będzie wywoływać tej metody. Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>. `liftToNull` i `method` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> nie odpowiada na węzeł wyrażenie binarne.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację binarną.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący Lewy argument operacji.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy argument operacji.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , który określa implementującej metody.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> reprezentujący funkcji konwersji typu. Ten parametr jest używany tylko wtedy, gdy <c>binaryType</c> jest <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> lub przydział złożony.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand implementacja metody i wpisz przez wywołanie metody fabryki odpowiedniej funkcji konwersji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki będzie wywoływać tej metody. Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>. `liftToNull`, `method` i `conversion` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> nie odpowiada na węzeł wyrażenie binarne.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</param>
        <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołanie do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z określonych elementów.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` muszą być niezerowe i zgodny z typem `variable` (jeśli go podano).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i jeden argument.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i dwa argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i trzech argumentów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <param name="arg3">Czwarty argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i cztery argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">
          <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> z <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="value">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący skoku określonego <see cref="T:System.Linq.Expressions.GotoExpressionKind" />. Można także określić wartość przekazana do etykiety na przejście.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa <paramref name="kind" />, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Powinna ona mieć wartość null, jeśli właściwość jest <see langword="static" /> (<see langword="shared" /> w języku Visual Basic).</param>
        <param name="indexer">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujące właściwość do indeksu.</param>
        <param name="arguments">
          <c>IEnumerable&lt;wyrażenie&gt; </c> (<c>IEnumerable (o wyrażenie)</c> w języku Visual Basic) zawiera argumenty, które będą używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący uzyskiwania dostępu do właściwości indeksowanych w obiekcie.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący element członkowski należy do obiektu. Może to być wartość null dla statycznych elementów członkowskich.</param>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> Opisujący pola lub właściwości, aby można było uzyskać dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący uzyskiwania dostępu do pola lub właściwości.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia <xref:System.Linq.Expressions.MemberExpression> reprezentujący uzyskiwania dostępu do pola lub właściwości, w zależności od typu `member`. Jeśli `member` jest typu <xref:System.Reflection.FieldInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Field%2A> do utworzenia <xref:System.Linq.Expressions.MemberExpression>. Jeśli `member` jest typu <xref:System.Reflection.PropertyInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Property%2A> do utworzenia <xref:System.Linq.Expressions.MemberExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentować pole lub właściwość.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku wyrażenia try. Jeśli wartość null, bodh i wszystkich programów obsługi muszą mieć taki sam typ.</param>
        <param name="body">Treść bloku try.</param>
        <param name="finally">Treść bloku finally. Należy przekazać wartość null, jeśli blok try ma nie koniec bloku skojarzonych z nim.</param>
        <param name="fault">Treść bloku błędów. Należy przekazać wartość null, jeśli blok try ma nie bloku błędów skojarzonych z nim.</param>
        <param name="handlers">Kolekcja <see cref="T:System.Linq.Expressions.CatchBlock" />s reprezentujący instrukcji catch ma zostać skojarzony z bloku try.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z określonych elementów.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> przez wywołanie metody odpowiednie fabryki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</param>
        <param name="operand">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</param>
        <param name="type">
          <see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument przez wywołanie metody odpowiednie fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> ta metoda wywołuje metodę fabryki. Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>. `type`Parametru jest ignorowana, jeśli nie ma zastosowania do metody fabryki, która jest wywoływana.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</param>
        <param name="operand">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</param>
        <param name="type">
          <see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument i wdrażanie — metoda, przez wywołanie metody fabryki odpowiednie.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> ta metoda wywołuje metodę fabryki. Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>. `type` i `method` parametry są ignorowane, jeśli nie mają zastosowania do metody fabryki, która jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich elementu członkowskiego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich pola lub właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` Parametru musi reprezentować pole lub właściwość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentować pole lub właściwość.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich pola lub właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` Parametru musi reprezentować pole lub właściwość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentować pole lub właściwość.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę dostępu właściwości.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich elementu członkowskiego, który jest dostępny za pomocą metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu właściwości używane przez metodę który <paramref name="propertyAccessor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę dostępu właściwości.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich elementu członkowskiego, który jest dostępny za pomocą metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu właściwości używane przez metodę który <paramref name="propertyAccessor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwości obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</param>
        <summary>Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwości obiektu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wyrażenie, które tworzy nowy obiekt i inicjuje właściwości obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu który <paramref name="newExpression" />. Wpisz reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MemberInitExpression> reprezentujący inicjowania nowego obiektu dwóch członków.  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu który <paramref name="newExpression" />. Wpisz reprezentuje.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator modulo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator modulo wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typowi wynik operatora modulo wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator modulo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator modulo wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typowi wynik operatora modulo wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia mnoży dwie wartości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator mnożenia nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczne mnożenie, który ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczne mnożenie, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator mnożenia nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczne mnożenie, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje operacji arytmetycznych negacji.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.  
  
 —lub—  
  
 <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne, która ma sprawdzanie przepełnienia. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.  
  
 —lub—  
  
 <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor, który nie przyjmuje żadnych argumentów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> są puste kolekcje. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość reprezentuje typ deklarujący reprezentowany przez konstruktora `constructor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Konstruktor, który <paramref name="constructor" /> reprezentuje ma co najmniej jeden parametr.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> mający konstruktora, który nie przyjmuje żadnych argumentów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego typu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> ustawioną właściwość <see cref="T:System.Reflection.ConstructorInfo" /> reprezentujący konstruktor bez parametrów dla określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` Parametru musi reprezentować typu, który ma konstruktor bez parametrów.  
  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> są puste kolekcje. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest równa `type`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.New%28System.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.NewExpression> reprezentujący utworzenie nowego wystąpienia obiektu słownika przez wywołanie konstruktora bez parametrów.  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ który <paramref name="type" /> reprezentuje nie ma konstruktora bez parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`. Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący reprezentowany przez konstruktora `constructor`. <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość ma pustą kolekcję.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> Parametru nie zawiera taką samą liczbę elementów jak liczba parametrów konstruktora który <paramref name="constructor" /> reprezentuje.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`. Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący reprezentowany przez konstruktora `constructor`. <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość ma pustą kolekcję.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="arguments" /> jest zgodna z liczbą parametrów dla konstruktora który <paramref name="constructor" /> reprezentuje.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <param name="members">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami. Elementy członkowskie, które uzyskują dostęp do pola zainicjowany konstruktor został określony.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`. Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.  
  
 Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji. Jeśli `members` nie jest `null`, musi mieć taką samą liczbę elementów jako `arguments` i nie może być każdy element `null`. Każdy element `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia na typ deklarujący reprezentowany przez konstruktora `constructor`. Jeśli termin reprezentuje właściwością, musi mieć właściwość `get` metody dostępu. Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego który `members` reprezentuje element.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora który `constructor` reprezentuje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="arguments" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="members" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> Parametru nie zawiera taką samą liczbę elementów jak liczba parametrów konstruktora który <paramref name="constructor" /> reprezentuje.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.  
  
 —lub—  
  
 <paramref name="members" /> Parametru nie ma taką samą liczbę elementów jako <paramref name="arguments" />.  
  
 —lub—  
  
 Element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość, która reprezentuje typ, który nie jest możliwa do przypisania do typu elementu członkowskiego reprezentowanego przez odpowiedni element <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <param name="members">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami. Elementy członkowskie, które uzyskują dostęp do pola zainicjowany konstruktor są określone jako tablicy.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`. Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.  
  
 Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji. Jeśli `members` nie jest `null`, musi mieć taką samą liczbę elementów jako `arguments` i nie może być każdy element `null`. Każdy element `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia na typ deklarujący reprezentowany przez konstruktora `constructor`. Jeśli termin reprezentuje właściwość, właściwość musi być może pobrać wartości pola skojarzone. Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego który `members` reprezentuje element.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora który `constructor` reprezentuje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="arguments" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="members" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> Parametru nie zawiera taką samą liczbę elementów jak liczba parametrów konstruktora który <paramref name="constructor" /> reprezentuje.  
  
 —lub—  
  
 <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.  
  
 —lub—  
  
 <paramref name="members" /> Parametru nie ma taką samą liczbę elementów jako <paramref name="arguments" />.  
  
 —lub—  
  
 Element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość, która reprezentuje typ, który nie jest możliwa do przypisania do typu elementu członkowskiego reprezentowanego przez odpowiedni element <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicę, która ma określony rangę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="bounds">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicę, która ma określony rangę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której pozycję jest równa długości `bounds` i o typie elementu `type`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi przedstawiać typ całkowity.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy ciągów, które ma pozycję 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="bounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="bounds" /> nie reprezentuje typ całkowity.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="bounds">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicę, która ma określony rangę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której pozycję jest równa długości `bounds` i o typie elementu `type`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi przedstawiać typ całkowity.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy ciągów, które ma pozycję 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="bounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="bounds" /> nie reprezentuje typ całkowity.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenia tablicą jednowymiarową i inicjowania go z listy elementów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenia tablicą jednowymiarową i inicjowania go z listy elementów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typu, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jest *cytowaną*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablica której pozycję to 1, którego typ elementu `type`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy jednowymiarowej tablicy ciągów, które jest inicjowany z listy wyrażeń ciągu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="initializers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwa do przypisania do typu który <paramref name="type" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenia tablicą jednowymiarową i inicjowania go z listy elementów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typu, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jest *cytowaną*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>. Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablica której pozycję to 1, którego typ elementu `type`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy jednowymiarowej tablicy ciągów, które jest inicjowany z listy wyrażeń ciągu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="initializers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwa do przypisania do typu <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ węzła <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <value>Jeden z <see cref="T:System.Linq.Expressions.ExpressionType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość zawiera opis wyspecjalizowanego <xref:System.Linq.Expressions.Expression> niż tylko jego typu pochodnego. Na przykład <xref:System.Linq.Expressions.BinaryExpression> może służyć do reprezentowania różne rodzaje wyrażenia binarne, takie jak "większe niż" operacja lub operacji dzielenia. <xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość czy opisano te wyrażenia binarne jako <xref:System.Linq.Expressions.ExpressionType.Divide> i <xref:System.Linq.Expressions.ExpressionType.GreaterThan>odpowiednio.  
  
 Typ CLR statyczny wyrażenia który <xref:System.Linq.Expressions.Expression> reprezentuje obiekt jest reprezentowana przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który określa jednoargumentowy not operator <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ typu liczbowego lub typu Boolean, metoda wykonawcze jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje logicznych nie operacji.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego. Można określić implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który określa jednoargumentowy not operator <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.  
  
 —lub—  
  
 <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest <xref:System.Boolean>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator nierówności nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator nierówności dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyrażenie odpowiadające te dopełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Zwraca wyrażenie odpowiadające te dopełnienia.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Zwraca wyrażenie odpowiadające te dopełnienia.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku predefiniowanych bitowe `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `OR` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje logicznej operacji lub.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bitowe <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typ wyniku predefiniowanych bitowe `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `OR` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="OR" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy operatora daje w wyniku <see langword="false" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="OR" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="false" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkowe `OR` operator jest oceniane przy użyciu operatora testu koniunkcji `OR` operatora. W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób utworzyć wyrażenie reprezentuje logicznych `OR` operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku `false`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bitowe <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  
  
 —lub—  
  
 <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="OR" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="false" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkowe `OR` operator jest oceniane przy użyciu operatora testu koniunkcji `OR` operatora. W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła o określonej nazwie i typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.MethodCallExpression> obiekt, który wyświetla wartość <xref:System.Linq.Expressions.ParameterExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <param name="name">Nazwa parametr lub zmienna, używana do debugowania lub drukowania tylko do celów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> i <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne dekrementacja 1 oryginalne wyrażenie wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne dekrementacja 1 oryginalne wyrażenie wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne dekrementacja 1 oryginalne wyrażenie wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne przyrostu 1 oryginalne wyrażenie wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne przyrostu 1 oryginalne wyrażenie wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne przyrostu 1 oryginalne wyrażenie wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podniesienia liczby do potęgi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podniesienia liczby do potęgi.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator wykładniczy <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator wykładniczy nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  
  
 —lub—  
  
 <paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podniesienia liczby do potęgi.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator wykładniczy <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator wykładniczy dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  
  
 —lub—  
  
 <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zwiększa wyrażenie 1 i przypisuje wynik wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zwiększa wyrażenie 1 i przypisuje wynik wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zwiększa wyrażenie 1 i przypisuje wynik wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości. Może to być wartość null dla właściwości statycznej.</param>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę dostępu właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości, za pomocą metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Jeśli metoda reprezentowany przez `propertyAccessor` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> jest <see langword="null" />.  
  
 —lub—  
  
 Metoda który <paramref name="propertyAccessor" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="propertyAccessor" />.  
  
 —lub—  
  
 Metoda który <paramref name="propertyAccessor" /> reprezentuje nie jest metodą dostępu właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości. Może to być wartość null dla właściwości statycznej.</param>
        <param name="property">
          <see cref="T:System.Reflection.PropertyInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Jeśli właściwość reprezentowany przez `property` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="property" /> jest <see langword="null" />.  
  
 —lub—  
  
 Właściwość który <paramref name="property" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie jest możliwa do przypisania do właściwości typ deklarujący który <paramref name="property" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Których <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość o nazwie <c>propertyName</c>. Może to być <see langword="null" /> właściwości statycznej.</param>
        <param name="propertyName">Nazwa właściwości, aby można było uzyskać dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący właściwość oznaczona <paramref name="propertyName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Reflection.PropertyInfo> reprezentujący właściwość oznaczona `propertyName`.  
  
 Ta metoda szuka `expression`. Typ i jego typów podstawowych dla właściwości o nazwie `propertyName`. Właściwości publiczne są preferowane względem niepublicznych właściwości. Jeśli zostanie znaleziony zgodnej właściwości, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> reprezentujący tej właściwości, aby <xref:System.Linq.Expressions.Expression.Property%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie reprezentuje podczas uzyskiwania dostępu do właściwości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="propertyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie ma właściwości o nazwie <paramref name="propertyName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Jeśli właściwość jest statyczna/udostępnionego, może mieć wartości null.</param>
        <param name="indexer">
          <see cref="T:System.Reflection.PropertyInfo" /> Reprezentujący właściwość do indeksu.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które są używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostępu do właściwości indeksowanej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Jeśli właściwość jest statyczna/udostępnionego, może mieć wartości null.</param>
        <param name="indexer">
          <see cref="T:System.Reflection.PropertyInfo" /> Reprezentujący właściwość do indeksu.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które są używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostępu do właściwości indeksowanej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Jeśli właściwość jest statyczna/udostępnionego, może mieć wartości null.</param>
        <param name="propertyName">Nazwa indeksatora.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które są używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostępu do właściwości indeksowanej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Obiekt zawierający właściwości. Może to być wartość null dla właściwości statycznej.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierający właściwości.</param>
        <param name="propertyName">Właściwość, aby można było uzyskać dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> podczas uzyskiwania dostępu do właściwości.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Których <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość lub pole o nazwie <c>propertyOrFieldName</c>. Może to być wartość null dla statycznych elementów członkowskich.</param>
        <param name="propertyOrFieldName">Nazwa właściwości lub pola, aby można było uzyskać dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości lub pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> lub <see cref="T:System.Reflection.FieldInfo" /> reprezentujący właściwości lub pola wskazywane przez <paramref name="propertyOrFieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> lub <xref:System.Reflection.FieldInfo.FieldType%2A> właściwości <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo>odpowiednio reprezentujący właściwość lub pole wskazywane przez `propertyOrFieldName`.  
  
 Ta metoda szuka `expression`. Typ i jego typów podstawowych właściwości lub pola o nazwie `propertyOrFieldName`. Właściwości publiczne i pola są preferowane względem niepublicznych właściwości i pola. Ponadto właściwości są preferowane względem pola. Jeśli zostanie znaleziony zgodnej właściwości ani pola, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo> reprezentujący tej właściwości lub pola do <xref:System.Linq.Expressions.Expression.Property%2A> lub <xref:System.Linq.Expressions.Expression.Field%2A>odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenie reprezentuje podczas uzyskiwania dostępu do właściwości lub pola.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="propertyOrFieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie właściwości lub pola o nazwie <paramref name="propertyOrFieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie, które ma stałej wartości typu <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> reprezentuje utworzony typ <xref:System.Linq.Expressions.Expression%601>, gdzie argument typu jest reprezentowana przez typ `expression`. Typ. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Jest właściwość `null`. Zarówno <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ogranicza ten węzeł do wyrażenia prostsze. Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie. Ta metoda może zwracać innego węzła, które muszą zostać zmniejszona.</summary>
        <returns>Zmniejszenie wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ogranicza ten węzeł do wyrażenia prostsze. Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie. Ta metoda może zwracać innego węzła, które muszą zostać zmniejszona.</summary>
        <returns>Zmniejszenie wyrażenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od Zmniejsz ta metoda sprawdza, czy węzeł zmniejszenie spełnia niektórych invariants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza wyrażenie z typem węzła znane (który nie jest węzłem rozszerzenia) lub po prostu zwraca wyrażenie, jeśli jest on już znanego typu.</summary>
        <returns>Zmniejszenie wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości odwołań.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie nierówności odwołań.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Nowe <see cref="T:System.Type" /> wyrażenia.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątek z danym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i wartość null do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="value">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return. Można określić wartość przekazana do etykiety na przejście.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.Expression.Return%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />i wartość null do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</param>
        <param name="value">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return z określonym typem. Można określić wartość przekazana do etykiety na przejście.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w prawo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w prawo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, która odnosi się do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w prawo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, która odnosi się do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Kolekcja <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie odejmuje argumentu z pierwszym argumentem.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator odejmowania dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są one `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.  
  
 Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta. Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła. Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator odejmowania dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość do sprawdzenia przed każdym przypadku.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję bez przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć ten sam typ, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawne `break` instrukcja, która oznacza, że nie Brak niejawnego poniżej od jednej etykiety case do innej.  
  
 Jeśli `switchValue` nie pasuje do żadnego przypadków, nie wyjątku.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje przełącznik instrukcję bez przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość do sprawdzenia przed każdym przypadku.</param>
        <param name="defaultBody">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć ten sam typ, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawne `break` instrukcja, która oznacza, że nie Brak niejawnego poniżej od jednej etykiety case do innej.  
  
 Jeśli `switchValue` nie pasuje do żadnego przypadkach przypadek domyślny reprezentowany przez `defaultBody` jest uruchamiany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje przełącznik instrukcję, która ma przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość do sprawdzenia przed każdym przypadku.</param>
        <param name="defaultBody">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość do sprawdzenia przed każdym przypadku.</param>
        <param name="defaultBody">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku przełącznika.</param>
        <param name="switchValue">Wartość do sprawdzenia przed każdym przypadku.</param>
        <param name="defaultBody">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku przełącznika.</param>
        <param name="switchValue">Wartość do sprawdzenia przed każdym przypadku.</param>
        <param name="defaultBody">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektu do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Treść wielkość liter.</param>
        <param name="testValues">Wartości testowe sprawy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektu do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć ten sam typ, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawne `break` instrukcja, która oznacza, że nie Brak niejawnego poniżej od jednej etykiety case do innej.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje przełącznik instrukcję, która ma przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treść wielkość liter.</param>
        <param name="testValues">Wartości testowe sprawy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> właściwość o określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <param name="language">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ustawiono wartość określonej właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <param name="language">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</param>
        <param name="languageVendor">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ustawiono wartość określonej właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <param name="language">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</param>
        <param name="languageVendor">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</param>
        <param name="documentType">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ustawiono wartość określonej właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Zgłaszanie wyjątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Zgłaszanie wyjątku.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiekt, który używa <xref:System.Linq.Expressions.Expression.Throw%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="type">Nowe <see cref="T:System.Type" /> wyrażenia.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zgłaszanie wyjątków z danym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tekstową reprezentację wartości <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>Tekstową reprezentację wartości <see cref="T:System.Linq.Expressions.Expression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="handlers">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch ma zostać skojarzony z bloku try.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolnej liczby catch instrukcji i ani błędów ani bloku finally.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="finally">Treść bloku finally.</param>
        <param name="handlers">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch ma zostać skojarzony z bloku try.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolną liczbę instrukcji catch i bloku finally.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch i finally instrukcji.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="fault">Treść bloku błędów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z blokiem błąd i nie catch instrukcji.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="finally">Treść bloku finally.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> bloku try przy reprezentujący koniec instrukcji catch bloku i nie.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica obiektów typu, które określają argumentów typu dla typu delegata elementu System.Action.</param>
        <param name="actionType">Po powrocie z tej metody zawiera typu ogólnego delegat elementu System.Action, która przyjmuje argumenty określonego typu. Zawiera wartość null, jeśli nie delegat elementu System.Action ogólny zgodny <c>typeArgs</c>. Ten parametr jest przekazywany jako niezainicjowany.</param>
        <summary>Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje typu ogólnego delegat elementu System.Action, która przyjmuje argumenty określonego typu.</summary>
        <returns>wartość true, jeśli ogólny typ delegata elementu System.Action został utworzony dla konkretnego <paramref name="typeArgs" />false w przeciwnym razie wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica obiektów typu, które określają argumentów typu dla typu delegata System.Func.</param>
        <param name="funcType">Gdy metoda zwróci wartość, zawiera ogólny typ delegata System.Func, który ma argumenty określonego typu. Zawiera wartość null, jeśli nie Delegat ogólny System.Func, który odpowiada <c>typeArgs</c>. Ten parametr jest przekazywany jako niezainicjowany.</param>
        <summary>Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólny typ delegata System.Func, który zawiera argumenty określonego typu. Ostatni argument typu określa typ zwracany delegata utworzony.</summary>
        <returns>wartość true, jeśli utworzono ogólny typ delegata System.Func określonych <paramref name="typeArgs" />false w przeciwnym razie wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ statyczny wyrażenia, który to <see cref="T:System.Linq.Expressions.Expression" /> reprezentuje.</summary>
        <value>
          <see cref="T:System.Type" /> Reprezentujący typ statyczny wyrażenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.NodeType%2A> Jest typ węzła drzewa wyrażenia, podczas gdy <xref:System.Linq.Expressions.Expression.Type%2A> reprezentuje wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR) typ statyczny wyrażenia, który reprezentuje węzeł. Na przykład dwa węzły o różnych typach węzłów może mieć takie same <xref:System.Linq.Expressions.Expression.Type%2A>, jak pokazano w poniższym przykładzie kodu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawnego odwołania lub konwersji pakującej gdzie <see langword="null" /> jest dostarczany w razie niepowodzenia konwersji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> jest `null`. <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> właściwości są `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.UnaryExpression> reprezentujący konwersji odwołania wyrażenia liczby całkowitej wartości null na typ integer wartości null.  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="T:System.Linq.Expressions.Expression" /> równa właściwości.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> który porównuje tożsamości typu run-time.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> i dla których <see cref="T:System.Linq.Expressions.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> równa właściwości.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> i dla których <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione na określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> reprezentuje <xref:System.Boolean>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.TypeBinaryExpression> reprezentujący typ testu wartość ciągu przed <xref:System.Int32> typu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jednoargumentowe plus operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jednoargumentowe plus operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typ jest zdefiniowany przez użytkownika typu, który definiuje jednoargumentowe plus operatora, <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowe plus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jednoargumentowe plus operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typ jest zdefiniowany przez użytkownika typu, który definiuje jednoargumentowe plus operatora, <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementujący nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła. Typ węzła jest zwracany typ metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.  
  
    -   Zwracany typ metody implementującej to typ niedopuszczający wartości null.  
  
 Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta. W przeciwnym razie jest unosiło węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i jednoargumentowe plus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.  
  
 —lub—  
  
 <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do unbox —.</param>
        <param name="type">Nowe <see cref="T:System.Type" /> wyrażenia.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Rozpakowywanie jawnego.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła o określonej nazwie i typ</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <param name="name">Nazwa parametru lub zmiennej. Ta nazwa jest używana do debugowania lub drukowania tylko do celów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła o określonej nazwie i typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Wystąpienie <see cref="T:System.Func`2" />.</param>
        <summary>Zmniejsza węzeł, a następnie wywołuje delegata dla gości na zmniejszenie wyrażenia. Metoda zgłasza wyjątek, jeśli węzeł nie jest możliwe do zredukowania.</summary>
        <returns>Wyrażenie odwiedzana lub wyrażenie, które powinny zostać użyte w drzewie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przesłonić tę metodę w celu zapewnienia logiki przeprowadzenie elementów podrzędnych węzła. Typowa implementacja wywołuje obiekt odwiedzający. Odwiedź na wszystkich jego elementów podrzędnych i czy je zmienić, powinien zwrócić nową kopię samego zmodyfikowanego podrzędnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
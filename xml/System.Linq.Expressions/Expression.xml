<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc5fc73f4d181f975b2a4702ba91f867a8124526" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="0a691-101">Udostępnia klasę podstawową, od których pochodzą klasy, które reprezentują węzły drzewa wyrażenia.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0a691-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span>
      </span>
      <span data-ttu-id="0a691-102">Zawiera także <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodami factory, aby utworzyć różne typy węzłów.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0a691-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span>
      </span>
      <span data-ttu-id="0a691-103">Jest to <see langword="abstract" /> klasy.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0a691-103">This is an <see langword="abstract" /> class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-104">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="0a691-105">Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0a691-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-106">Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-107">Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">
          <span data-ttu-id="0a691-108">
            <see cref="T:System.Linq.Expressions.ExpressionType" /> Można ustawić jako typ węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-109">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Tego <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-110">Inicjuje nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-111">Ten konstruktor jest wywoływana z konstruktorów w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="0a691-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">
          <span data-ttu-id="0a691-112">Obiekt odwiedzający odwiedź ten węzeł z.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-112">The visitor to visit this node with.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-113">Wysyła do konkretnych można znaleźć metody dla tego typu węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-113">Dispatches to the specific visit method for this node type.</span>
          </span>
          <span data-ttu-id="0a691-114">Na przykład <see cref="T:System.Linq.Expressions.MethodCallExpression" /> wywołania <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-115">Wynik tego węzła na stronę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-115">The result of visiting this node.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-116">Ta domyślna implementacja dla <xref:System.Linq.Expressions.ExpressionType.Extension> wywołania węzłów <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="0a691-117">Przesłonić tę metodę do wywołania do bardziej szczegółowych metody w klasie pochodnej odwiedzający z <xref:System.Linq.Expressions.ExpressionVisitor> klasy.</span><span class="sxs-lookup"><span data-stu-id="0a691-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="0a691-118">Obsługuje on jednak powinien nadal nieznany odwiedzających przez wywołanie metody <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-119">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-120">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-121">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-122">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-124">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-125"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-126">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-127">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-128"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-129">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-130">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-130">Implementing Method</span></span>  
 <span data-ttu-id="0a691-131">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-132">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-133">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-134">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-135">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-136">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-137">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-138">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-139">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-140">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-141">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-142">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-143">Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="0a691-144">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-145">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-146">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który dodaje dwie liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0a691-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-147">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-147">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-148">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-149">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-150">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-151">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-152">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
          <span data-ttu-id="0a691-153">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-153">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-155">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-156"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-157">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-158">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-159"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-160">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-161">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-161">Implementing Method</span></span>  
 <span data-ttu-id="0a691-162">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-163">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-164">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-165">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-166">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-167">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-168">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-169">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-170">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-171">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-172">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-173">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-174">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-175">Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="0a691-176">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-177">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-178">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-178">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-179">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-179">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-180">
            <paramref name="method" /> jest <see langword="null" /> a operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-180">
              <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-181">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-182">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-183">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-184">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-186">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które dodaje wartość do zmiennej całkowitą, a następnie przypisuje wynik operacji do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="0a691-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-187">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-188">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-189">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-190">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-192">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-193">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-194">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-196">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-198">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-199">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-200">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-201">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-203">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-204">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-205">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-206">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-208">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-209">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-210">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-212">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-214">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-215">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-216">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-217">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-219">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-220"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-221">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-222">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-223"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-224">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-225">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-225">Implementing Method</span></span>  
 <span data-ttu-id="0a691-226">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-227">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-228">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-229">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-230">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-231">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-232">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-233">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-234">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-235">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-236">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-237">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-238">Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="0a691-239">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-240">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-241">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-241">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-242">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-243">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-244">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-245">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-246">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
          <span data-ttu-id="0a691-247">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-247">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-249">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-250"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-251">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-252">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-253"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-254">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-255">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-255">Implementing Method</span></span>  
 <span data-ttu-id="0a691-256">Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:</span><span class="sxs-lookup"><span data-stu-id="0a691-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="0a691-257">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-258">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dodawania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-259">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-260">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-261">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-262">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-263">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-264">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-265">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-266">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-267">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-268">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-269">Typ węzła jest typu wyników operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="0a691-270">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-271">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator dodawania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-272">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-272">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-273">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-273">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-274">
            <paramref name="method" /> jest <see langword="null" /> a operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-274">
              <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-275">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-276">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-277">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-278">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-280">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-281"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-282">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-283">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-284"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-285">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-286">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-286">Implementing Method</span></span>  
 <span data-ttu-id="0a691-287">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-288">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-289">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-290">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-291">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-292">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-293">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-294">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-295">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-296">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-297">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-298">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-299">Typ węzła jest typ wyniku predefiniowanych bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="0a691-300">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-301">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-302">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje logicznej operacji AND na dwóch wartości logicznych.</span><span class="sxs-lookup"><span data-stu-id="0a691-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-303">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-303">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-304">Bitowe <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-305">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-306">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-307">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-308">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
          <span data-ttu-id="0a691-309">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-309">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-311">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-312"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-313">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-314">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-315"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-316">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-317">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-317">Implementing Method</span></span>  
 <span data-ttu-id="0a691-318">Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:</span><span class="sxs-lookup"><span data-stu-id="0a691-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="0a691-319">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-320">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-321">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-322">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-323">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-324">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-325">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-326">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-327">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-328">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-329">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-330">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-331">Typ węzła jest typ wyniku predefiniowanych bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="0a691-332">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-333">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-334">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-334">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-335">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-335">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-336">
            <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-336">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-337">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="AND" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-338">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-339">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-340">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="AND" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-342">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-343"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-344">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-345">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-346"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-347">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-348">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-348">Implementing Method</span></span>  
 <span data-ttu-id="0a691-349">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-350">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="0a691-351">Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0a691-351">The conditional `AND` operator cannot be overloaded in C# or [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span></span> <span data-ttu-id="0a691-352">Jednak warunkowe `AND` operator jest oceniane przy użyciu operatora testu koniunkcji `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="0a691-353">W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="0a691-354">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-355">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-356">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-357">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-358">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-359">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-360">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-361">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-362">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-363">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="0a691-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="0a691-364">Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-365">Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="0a691-366">Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-367">Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-368">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wykonuje logiczną i operacji na jego dwóch argumentów operacji tylko wtedy, gdy pierwszy argument operacji daje w wyniku `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-369">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-369">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-370">Bitowe <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-371">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-371">-or-</span>
          </span>
          <span data-ttu-id="0a691-372">
            <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-372">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-373">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-374">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-375">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-376">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="AND" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument nie zostanie rozwiązany na wartość true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span>
          </span>
          <span data-ttu-id="0a691-377">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-377">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-379">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-380"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-381">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-382">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-383"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-384">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-385">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-385">Implementing Method</span></span>  
 <span data-ttu-id="0a691-386">Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:</span><span class="sxs-lookup"><span data-stu-id="0a691-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="0a691-387">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-388">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="0a691-389">Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0a691-389">The conditional `AND` operator cannot be overloaded in C# or [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span></span> <span data-ttu-id="0a691-390">Jednak warunkowe `AND` operator jest oceniane przy użyciu operatora testu koniunkcji `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="0a691-391">W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="0a691-392">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-393">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-394">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-395">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-396">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-397">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-398">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-399">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-400">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-401">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="0a691-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="0a691-402">Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-403">Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="0a691-404">Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-405">Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-406">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-406">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-407">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-407">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-408">
            <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-408">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-409">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-409">-or-</span>
          </span>
          <span data-ttu-id="0a691-410">
            <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-410">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-411">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-412">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-413">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-414">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-416">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-417">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-418">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-419">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-421">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-422">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-423">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-425">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania i.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-427">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0a691-428">Wyrażenie reprezentuje tablicy wielowymiarowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-428">An expression that represents the multidimensional array.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="0a691-429">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierające wyrażenia używane do indeksu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-430">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> można uzyskać dostępu do tablicy wielowymiarowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-431">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-432">Wyrażenie, które reprezentuje tablicę można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metody, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-433">Poniższy przykład kodu pokazuje, jak zmienić wartość elementu w tablicy wielowymiarowej przy użyciu `ArrayAccess` metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0a691-434">Wyrażenie reprezentujący indeksu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-434">An expression representing the array to index.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="0a691-435">Tablica zawiera wyrażenia używane do indeksu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-435">An array that contains expressions used to index the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-436">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-437">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-438">Wyrażenie, które reprezentuje tablicę można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metody, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="0a691-439">Tablice wielowymiarowe, można użyć <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-440">Poniższy przykład kodu pokazuje sposób zmiany wartości elementu tablicy za pomocą `ArrayAccess` metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-441">Tworzy <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący zastosowanie operatora indeksu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0a691-442">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="0a691-443">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-444">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy na tablicę rangi więcej niż jeden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-446">Każdy element `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="0a691-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="0a691-447"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typu tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.</span><span class="sxs-lookup"><span data-stu-id="0a691-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="0a691-448">Jeśli rangę `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="0a691-449"><xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`.</span><span class="sxs-lookup"><span data-stu-id="0a691-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="0a691-450"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="0a691-451">Jeśli rangę `array`. Typ jest więcej niż jeden, ta metoda zwraca <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="0a691-452"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> metody wystąpienia publicznego, który opisuje `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.</span><span class="sxs-lookup"><span data-stu-id="0a691-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-453">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący przeprowadzane jest indeksowanie do tablicą dwuwymiarową.</span><span class="sxs-lookup"><span data-stu-id="0a691-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-454">
            <paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-454">
              <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-455">
            <paramref name="array" />. Typ nie odpowiada typowi tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-455">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="0a691-456">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-456">-or-</span>
          </span>
          <span data-ttu-id="0a691-457">Rangę <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span>
          </span>
          <span data-ttu-id="0a691-458">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-458">-or-</span>
          </span>
          <span data-ttu-id="0a691-459">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0a691-460">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="0a691-461">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-462">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zastosowanie operatora indeksu tablicy na tablicę rangi jeden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-464">`index` musi reprezentować indeksu typu <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="0a691-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="0a691-465"><xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest `null`, a oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="0a691-466"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest taki sam typ elementu `array`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="0a691-467"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-468">
            <paramref name="array" /> lub <paramref name="index" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-468">
              <paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-469">
            <paramref name="array" />. Typ nie odpowiada typowi tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-469">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="0a691-470">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-470">-or-</span>
          </span>
          <span data-ttu-id="0a691-471">
            <paramref name="array" />. Typ reprezentuje typ tablicy, której pozycję nie jest 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-471">
              <paramref name="array" />.Type represents an array type whose rank is not 1.</span>
          </span>
          <span data-ttu-id="0a691-472">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-472">-or-</span>
          </span>
          <span data-ttu-id="0a691-473">
            <paramref name="index" />. Typ nie reprezentuje <see cref="T:System.Int32" /> typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-473">
              <paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0a691-474">Tablica <see cref="T:System.Linq.Expressions.Expression" /> wystąpienia - indeksów dla operacji indeksu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="0a691-475">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-476">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy do tablicy wielowymiarowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-478">Każdy element `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="0a691-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="0a691-479"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typu tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.</span><span class="sxs-lookup"><span data-stu-id="0a691-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="0a691-480">Jeśli rangę `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="0a691-481"><xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`.</span><span class="sxs-lookup"><span data-stu-id="0a691-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="0a691-482"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="0a691-483">Jeśli rangę `array`. Typ jest więcej niż jeden, ta metoda zwraca <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="0a691-484"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> metody wystąpienia publicznego, który opisuje `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.</span><span class="sxs-lookup"><span data-stu-id="0a691-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-485">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentujący przeprowadzane jest indeksowanie do tablicą dwuwymiarową.</span><span class="sxs-lookup"><span data-stu-id="0a691-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-486">
            <paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-486">
              <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-487">
            <paramref name="array" />. Typ nie odpowiada typowi tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-487">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="0a691-488">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-488">-or-</span>
          </span>
          <span data-ttu-id="0a691-489">Rangę <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span>
          </span>
          <span data-ttu-id="0a691-490">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-490">-or-</span>
          </span>
          <span data-ttu-id="0a691-491">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="0a691-492">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-493">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia dla uzyskania długość tablicy jednowymiarowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości <paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-495"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typem tablicy.</span><span class="sxs-lookup"><span data-stu-id="0a691-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="0a691-496"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> jest równa <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="0a691-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="0a691-497"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość jest `null`, a oba <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-498">
            <paramref name="array" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-498">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-499">
            <paramref name="array" />. Typ nie odpowiada typowi tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-499">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-500">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-501">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-502">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operatora przypisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-504">`Assign` Wyrażenie kopiuje wartości dla typów wartości i kopiuje punkt odniesienia dla typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="0a691-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-505">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje operatora przypisania.</span><span class="sxs-lookup"><span data-stu-id="0a691-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-506">Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie elementu członkowskiego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="0a691-507">A <see cref="T:System.Reflection.MemberInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="expression">
          <span data-ttu-id="0a691-508">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-509">Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie pola lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-511"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być można przypisać do typu reprezentowanego przez <xref:System.Reflection.FieldInfo.FieldType%2A> lub <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość `member`.</span><span class="sxs-lookup"><span data-stu-id="0a691-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-512">
            <paramref name="member" /> lub <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-512">
              <paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-513">
            <paramref name="member" /> nie reprezentować pole lub właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-513">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="0a691-514">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-514">-or-</span>
          </span>
          <span data-ttu-id="0a691-515">Właściwości reprezentowanej przez <paramref name="member" /> nie ma <see langword="set" /> metody dostępu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span>
          </span>
          <span data-ttu-id="0a691-516">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-516">-or-</span>
          </span>
          <span data-ttu-id="0a691-517">
            <paramref name="expression" />. Typ nie jest można przypisać do typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-517">
              <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="0a691-518">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="expression">
          <span data-ttu-id="0a691-519">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-520">Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie elementu członkowskiego przy użyciu metody dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ustawioną właściwość <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-522"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być można przypisać do typu reprezentowanego przez <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwości dostęp do właściwości `propertyAccessor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-523">
            <paramref name="propertyAccessor" /> lub <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-523">
              <paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-524">
            <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-524">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="0a691-525">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-525">-or-</span>
          </span>
          <span data-ttu-id="0a691-526">Właściwość, do której dostęp <paramref name="propertyAccessor" /> nie ma <see langword="set" /> metody dostępu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span>
          </span>
          <span data-ttu-id="0a691-527">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-527">-or-</span>
          </span>
          <span data-ttu-id="0a691-528">
            <paramref name="expression" />. Typ nie jest można przypisać do typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-528">
              <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-529">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">
          <span data-ttu-id="0a691-530">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-530">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-531">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera danego wyrażenia i nie ma zmiennych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-532">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-533">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">
          <span data-ttu-id="0a691-534">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-534">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-535">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera danego wyrażenia i nie ma zmiennych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-536">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-537">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-538">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="0a691-539">Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0a691-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="0a691-540">Zmienne w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-540">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="0a691-541">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-541">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-542">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-543">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-544">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-545">Poniższy przykład kodu pokazuje, jak przekazać parametr do wyrażenia bloku i przetworzenie tego parametru w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="0a691-546">Zmienne w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-546">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="0a691-547">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-547">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-548">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-549">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-550">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="0a691-551">Pierwsze wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-551">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-552">Drugie wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-552">The second expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-553">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera dwa wyrażenia i nie ma zmiennych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-554">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-555">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-556">Typ wyniku bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-556">The result type of the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="0a691-557">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-557">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-558">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> która zawiera danego wyrażenia, nie ma zmiennych i ma typ określony wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-559">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-560">Typ wyniku bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-560">The result type of the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="0a691-561">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-561">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-562">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> która zawiera danego wyrażenia, nie ma zmiennych i ma typ określony wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-563">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="0a691-564">Pierwsze wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-564">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-565">Drugie wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-565">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-566">Trzeci wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-566">The third expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-567">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera trzy wyrażenia i nie ma zmiennych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-568">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-569">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-570">Typ wyniku bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-570">The result type of the block.</span>
          </span>
        </param>
        <param name="variables">
          <span data-ttu-id="0a691-571">Zmienne w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-571">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="0a691-572">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-572">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-573">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-574">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-575">Typ wyniku bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-575">The result type of the block.</span>
          </span>
        </param>
        <param name="variables">
          <span data-ttu-id="0a691-576">Zmienne w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-576">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="0a691-577">Wyrażenia w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-577">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-578">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-579">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="0a691-580">Pierwsze wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-580">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-581">Drugie wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-581">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-582">Trzeci wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-582">The third expression in the block.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="0a691-583">Czwartym wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-583">The fourth expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-584">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera cztery wyrażeń i nie ma zmiennych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-585">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-586">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="0a691-587">Pierwsze wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-587">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-588">Drugie wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-588">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-589">Trzeci wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-589">The third expression in the block.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="0a691-590">Czwartym wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-590">The fourth expression in the block.</span>
          </span>
        </param>
        <param name="arg4">
          <span data-ttu-id="0a691-591">Piątym wyrażenie w bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-591">The fifth expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-592">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> czy zawiera pięć wyrażeń i nie ma zmiennych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-593">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-594">Podczas wykonywania wyrażenia bloku zwraca wartość wyrażenia ostatniego w bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-595">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-596">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-597">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i wartość null do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-599">W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.LoopExpression> obiekt, który używa <xref:System.Linq.Expressions.Expression.Break%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-600">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0a691-601">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-601">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-602">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
          <span data-ttu-id="0a691-603">Można określić wartość przekazana do etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-603">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-605">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-606">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-607">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-609">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0a691-610">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-610">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-611">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-612">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span>
          </span>
          <span data-ttu-id="0a691-613">Można określić wartość przekazana do etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-613">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa podziału, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-615">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-616">
            <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania metody wystąpienia (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-617">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-618">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która nie przyjmuje żadnych argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-620">Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) — metoda, Przekaż `null` dla `instance` parametru, gdy ta metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="0a691-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="0a691-621">Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwe przypisanie typ deklarujący metodzie reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="0a691-622"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta.</span><span class="sxs-lookup"><span data-stu-id="0a691-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="0a691-623"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest taki sam zwracany typ metody reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-624">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wywołuje metodę bez argumentów.</span><span class="sxs-lookup"><span data-stu-id="0a691-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-625">
            <paramref name="method" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-625">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-626">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-626">-or-</span>
          </span>
          <span data-ttu-id="0a691-627">
            <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metody wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-627">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-628">
            <paramref name="instance" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-628">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="0a691-629">
            <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody docelowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-630">Kolekcja <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący argumenty wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-631">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej (Shared w języku Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="0a691-633">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-634">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-635">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodę, która przyjmuje jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-637">W poniższym przykładzie pokazano, jak utworzyć wyrażenie, które wywołuje `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-638">
            <paramref name="method" /> ma wartość null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-638">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="0a691-639">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodę, aby ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-640">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-641">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda, która przyjmuje argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-643">Jeśli `arguments` nie jest `null`, musi mieć taką samą liczbę elementów jak liczba parametrów metody reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="0a691-644">Każdy element `arguments` nie może być `null` i musi być możliwe przypisanie z odpowiadającym parametrem elementu `method`, prawdopodobnie po *zamykający*.</span><span class="sxs-lookup"><span data-stu-id="0a691-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-645">Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-646">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-647">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="0a691-648"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeśli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="0a691-649">W przeciwnym razie zawiera te same elementy jako `arguments`, niektóre z nich mogą zostać podane.</span><span class="sxs-lookup"><span data-stu-id="0a691-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="0a691-650"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="0a691-651"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-652">
            <paramref name="method" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-652">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-653">Liczba elementów w <paramref name="arguments" /> nie równa się z liczbą parametrów metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="0a691-654">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-654">-or-</span>
          </span>
          <span data-ttu-id="0a691-655">Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwa do przypisania do odpowiadającego mu parametru w metodzie reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-656">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-657">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-658">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-659">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-661">Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) — metoda, Przekaż `null` dla `instance` parametr podczas wywoływania tej metody, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0a691-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="0a691-662">Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwe przypisanie typ deklarujący metodzie reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="0a691-663">Jeśli `arguments` nie jest `null`, musi mieć taką samą liczbę elementów jak liczba parametrów metody reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="0a691-664">Każdy element `arguments` nie może być `null` i musi być możliwe przypisanie z odpowiadającym parametrem elementu `method`, prawdopodobnie po *zamykający*.</span><span class="sxs-lookup"><span data-stu-id="0a691-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-665">Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-666">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-667">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="0a691-668"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeśli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="0a691-669">W przeciwnym razie zawiera te same elementy jako `arguments`, niektóre z nich mogą zostać podane.</span><span class="sxs-lookup"><span data-stu-id="0a691-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="0a691-670"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-671">
            <paramref name="method" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-671">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-672">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-672">-or-</span>
          </span>
          <span data-ttu-id="0a691-673">
            <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metody wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-673">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-674">
            <paramref name="instance" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-674">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="0a691-675">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-675">-or-</span>
          </span>
          <span data-ttu-id="0a691-676">Liczba elementów w <paramref name="arguments" /> nie równa się z liczbą parametrów metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="0a691-677">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-677">-or-</span>
          </span>
          <span data-ttu-id="0a691-678">Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwa do przypisania do odpowiadającego mu parametru w metodzie reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-679">
            <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania metody wystąpienia (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-680">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-681">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-682">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-684">Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) — metoda, Przekaż `null` dla `instance` parametr podczas wywoływania tej metody, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0a691-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="0a691-685">Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwe przypisanie typ deklarujący metodzie reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="0a691-686">Jeśli `arguments` nie jest `null`, musi mieć taką samą liczbę elementów jak liczba parametrów metody reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="0a691-687">Każdy element `arguments` nie może być `null` i musi być możliwe przypisanie z odpowiadającym parametrem elementu `method`, prawdopodobnie po *zamykający*.</span><span class="sxs-lookup"><span data-stu-id="0a691-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-688">Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-689">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-690">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="0a691-691"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeśli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="0a691-692">W przeciwnym razie zawiera te same elementy jako `arguments`, niektóre z nich mogą zostać podane.</span><span class="sxs-lookup"><span data-stu-id="0a691-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="0a691-693"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody reprezentowany przez `method`.</span><span class="sxs-lookup"><span data-stu-id="0a691-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-694">
            <paramref name="method" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-694">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-695">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-695">-or-</span>
          </span>
          <span data-ttu-id="0a691-696">
            <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metody wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-696">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
          <span data-ttu-id="0a691-697">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-697">-or-</span>
          </span>
          <span data-ttu-id="0a691-698">
            <paramref name="arguments" /> nie jest <see langword="null" /> i co najmniej jeden z jego elementów jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-698">
              <paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-699">
            <paramref name="instance" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-699">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="0a691-700">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-700">-or-</span>
          </span>
          <span data-ttu-id="0a691-701">Liczba elementów w <paramref name="arguments" /> nie równa się z liczbą parametrów metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="0a691-702">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-702">-or-</span>
          </span>
          <span data-ttu-id="0a691-703">Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwa do przypisania do odpowiadającego mu parametru w metodzie reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="0a691-704">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-705">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-706">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-707">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, który przyjmuje dwa argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-709">
            <paramref name="method" /> ma wartość null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-709">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-710">
            <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span>
          </span>
          <span data-ttu-id="0a691-711">(należy przekazać wartość null dla metody statyczne (Shared w języku Visual Basic)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-711">(pass null for a static (Shared in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-712">
            <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody docelowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-713">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-714">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-715">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje dwa argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-717">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, która wywołuje metodę wystąpienia, która ma dwa argumenty.</span><span class="sxs-lookup"><span data-stu-id="0a691-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-718">
            <see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> wartość właściwości ma zostać wyszukany określonej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span>
          </span>
        </param>
        <param name="methodName">
          <span data-ttu-id="0a691-719">Nazwa metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-719">The name of the method.</span>
          </span>
        </param>
        <param name="typeArguments">
          <span data-ttu-id="0a691-720">Tablica <see cref="T:System.Type" /> obiektów, które określają parametrów typu metody ogólnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span>
          </span>
          <span data-ttu-id="0a691-721">Ten argument musi mieć wartość null, gdy methodName wskazuje metodę nierodzajową.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-721">This argument should be null when methodName specifies a non-generic method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-722">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które reprezentuje argumenty metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-723">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, wywołując metodę odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawioną <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę określonego wystąpienia i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ustawioną określonych argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-725"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-726">
            <paramref name="instance" /> lub <paramref name="methodName" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-726">
              <paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-727">Brak metody o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span>
          </span>
          <span data-ttu-id="0a691-728">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-728">-or-</span>
          </span>
          <span data-ttu-id="0a691-729">Więcej niż jedną metodę o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="0a691-730">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-731">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-732">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-733">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-734">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, który przyjmuje trzy argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-736">
            <paramref name="method" /> ma wartość null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-736">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-737">
            <see cref="T:System.Type" /> , Który określa typ, który zawiera określony <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-737">The <see cref="T:System.Type" /> that specifies the type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span>
          </span>
        </param>
        <param name="methodName">
          <span data-ttu-id="0a691-738">Nazwa metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-738">The name of the method.</span>
          </span>
        </param>
        <param name="typeArguments">
          <span data-ttu-id="0a691-739">Tablica <see cref="T:System.Type" /> obiektów, które określają parametrów typu metody ogólnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span>
          </span>
          <span data-ttu-id="0a691-740">Ten argument musi mieć wartość null, gdy methodName wskazuje metodę nierodzajową.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-740">This argument should be null when methodName specifies a non-generic method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-741">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-742">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda, przez wywołanie metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawioną właściwość <see cref="T:System.Reflection.MethodInfo" /> reprezentujący określonego <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) — metoda i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> Właściwość do określonych argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-744"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="0a691-745"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-746">
            <paramref name="type" /> lub <paramref name="methodName" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-746">
              <paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-747">Brak metody o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="type" /> ani jego typach podstawowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span>
          </span>
          <span data-ttu-id="0a691-748">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-748">-or-</span>
          </span>
          <span data-ttu-id="0a691-749">Więcej niż jedną metodę o nazwie <paramref name="methodName" />, którego parametry typu zgodne <paramref name="typeArguments" />, oraz którego parametr typów dopasowania <paramref name="arguments" /> znajduje się w <paramref name="type" /> ani jego typach podstawowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-750">
            <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span>
          </span>
          <span data-ttu-id="0a691-751">(należy przekazać wartość null dla metody statyczne (Shared w języku Visual Basic)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-751">(pass null for a static (Shared in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-752">
            <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody docelowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-753">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-754">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-755">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-756">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody pobierającej trzech argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="0a691-758">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-759">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-760">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-761">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="0a691-762">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-763">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, który przyjmuje cztery argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-765">
            <paramref name="method" /> ma wartość null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-765">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="0a691-766">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-767">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący pierwszy argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-768">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-769">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="0a691-770">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span>
          </span>
        </param>
        <param name="arg4">
          <span data-ttu-id="0a691-771">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący piąty argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-772">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie statycznej metody pobierającej argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-774">
            <paramref name="method" /> ma wartość null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-774">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-775">Wskazuje, czy można zmniejszyć węzła do węzła prostsze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-775">Indicates that the node can be reduced to a simpler node.</span>
          </span>
          <span data-ttu-id="0a691-776">Jeśli zostanie zwrócona wartość true, Reduce() można wywołać w celu utworzenia zmniejszenie formularza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-776">If this returns true, Reduce() can be called to produce the reduced form.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a691-777">Wartość true, jeśli węzeł może być obniżona, w przeciwnym razie wartość false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-777">True if the node can be reduced, otherwise false.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-778">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcji catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <span data-ttu-id="0a691-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołanie do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-780">Treść instrukcji catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-780">The body of the catch statement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-781">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcji catch z odwołaniem do zgłoszony <see cref="T:System.Exception" /> obiekt do użycia w treści procedury obsługi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-782">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-783">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-784">Treść instrukcji catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-784">The body of the catch statement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-785">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcji catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-786">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-787"><xref:System.Linq.Expressions.Expression.Type%2A> z <xref:System.Exception> wychwycony może być określony, ale żadne odwołanie do <xref:System.Exception> obiekt będzie dostępny do użycia w <xref:System.Linq.Expressions.CatchBlock>.</span><span class="sxs-lookup"><span data-stu-id="0a691-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <span data-ttu-id="0a691-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołanie do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-789">Treść instrukcji catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-789">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="0a691-790">Treść <see cref="T:System.Exception" /> filtru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-790">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-791">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z <see cref="T:System.Exception" /> filtru i odwołania do zgłoszony <see cref="T:System.Exception" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-792">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-793">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-794">Treść instrukcji catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-794">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="0a691-795">Treść <see cref="T:System.Exception" /> filtru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-795">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-796">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z <see cref="T:System.Exception" /> filtru, ale żadne odwołanie do zgłoszony <see cref="T:System.Exception" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-797">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="0a691-798">
            <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-799">Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> czyszczenie punktu sekwencji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-800">Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> dla proces czyszczenia punktu sekwencji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-801">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący łączącego operację.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-802">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-803">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-804">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący łączącego operację.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-806"><xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest `null` i oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="0a691-807"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest taki sam typ wyniku operacji łączącego.</span><span class="sxs-lookup"><span data-stu-id="0a691-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="0a691-808"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="0a691-809">Typ wyniku</span><span class="sxs-lookup"><span data-stu-id="0a691-809">Result Type</span></span>  
 <span data-ttu-id="0a691-810">Typ wyniku określa następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="0a691-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="0a691-811">Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie przekonwertować typu odpowiadającego wartości null, typ wyniku jest odpowiednikiem wartości null `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="0a691-812">W przeciwnym razie, jeśli `right`. Typ jest niejawnie przekonwertować `left`. Typ jest typ wyniku `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="0a691-813">W przeciwnym razie, jeśli odpowiednikiem wartości null `left`. Typ jest niejawnie przekonwertować `right`. Typ jest typ wyniku `right`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-814">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-814">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-815">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartości null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-816">
            <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-816">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-817">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-817">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-818">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-818">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-819">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-819">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-820">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego podanej funkcji konwersji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-820">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-821">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-821">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-822"><xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest `null` i oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-822">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="0a691-823"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> jest taki sam typ wyniku operacji łączącego.</span><span class="sxs-lookup"><span data-stu-id="0a691-823">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="0a691-824">Typ wyniku określa następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="0a691-824">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="0a691-825">Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie przekonwertować typu odpowiadającego wartości null, typ wyniku jest odpowiednikiem wartości null `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-825">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="0a691-826">W przeciwnym razie, jeśli `right`. Typ jest niejawnie przekonwertować `left`. Typ jest typ wyniku `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-826">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="0a691-827">W przeciwnym razie, jeśli odpowiednikiem wartości null `left`. Typ jest niejawnie przekonwertować `right`. Typ jest typ wyniku `right`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-827">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-828">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-828">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-829">
            <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-829">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span>
          </span>
          <span data-ttu-id="0a691-830">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-830">-or-</span>
          </span>
          <span data-ttu-id="0a691-831">
            <paramref name="conversion" /> nie jest <see langword="null" /> i <paramref name="conversion" />. Typ jest typem delegowanym, który nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-831">
              <paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-832">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartości null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-832">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span>
          </span>
          <span data-ttu-id="0a691-833">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-833">-or-</span>
          </span>
          <span data-ttu-id="0a691-834">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> reprezentuje typ, który nie jest możliwa do przypisania do typu parametru typu delegata <paramref name="conversion" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-835">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-835">-or-</span>
          </span>
          <span data-ttu-id="0a691-836">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="right" /> nie jest taki sam typ zwracany typ delegowany <paramref name="conversion" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-837">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-837">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="0a691-838">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-838">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="0a691-839">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-839">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="0a691-840">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-841">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-841">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-842">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-842">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-843"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ConditionalExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `ifTrue`.</span><span class="sxs-lookup"><span data-stu-id="0a691-843">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-844">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który reprezentuje instrukcji warunkowej.</span><span class="sxs-lookup"><span data-stu-id="0a691-844">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="0a691-845">Jeśli pierwszy argument ma wartość `true`, drugi argument jest wykonane; w przeciwnym razie, trzeci argument jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="0a691-845">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-846">
            <paramref name="test" /> lub <paramref name="ifTrue" /> lub <paramref name="ifFalse" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-846">
              <paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-847">
            <paramref name="test" />. Typ nie jest <see cref="T:System.Boolean" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-847">
              <paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span>
          </span>
          <span data-ttu-id="0a691-848">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-848">-or-</span>
          </span>
          <span data-ttu-id="0a691-849">
            <paramref name="ifTrue" />. Typ nie jest równa <paramref name="ifFalse" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-849">
              <paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span>
          </span>
        </exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="0a691-850">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-850">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="0a691-851">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-851">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="0a691-852">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-853">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-853">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-854">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-854">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-855">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-855">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-856">Ta metoda umożliwia wyraźnie widać typ wyniku wyrażenia warunkowego, w przypadkach, gdy typy `ifTrue` i `ifFalse` wyrażenia nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="0a691-856">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="0a691-857">Oba rodzaje `ifTrue` i `ifFalse` musi być niejawnie odniesienia można przypisać do typu wyniku.</span><span class="sxs-lookup"><span data-stu-id="0a691-857">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="0a691-858">`type` Może być <xref:System.Void>.</span><span class="sxs-lookup"><span data-stu-id="0a691-858">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-859">Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-859">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0a691-860">
            <see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-860">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-861">Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-862">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-862">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-863"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ConstantExpression> jest taki sam typ `value`.</span><span class="sxs-lookup"><span data-stu-id="0a691-863">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="0a691-864">Jeśli `value` jest `null`, <xref:System.Linq.Expressions.Expression.Type%2A> jest równa <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="0a691-864">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="0a691-865">Do reprezentowania `null`, można również użyć <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> metody, z którą można jawnie określić typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-865">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-866">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje wartość stałą.</span><span class="sxs-lookup"><span data-stu-id="0a691-866">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0a691-867">
            <see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-867">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-868">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-868">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-869">Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-869">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-870">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-870">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-871">Ta metoda może być przydatne w przypadku reprezentujących wartości typy dopuszczające wartości zerowe.</span><span class="sxs-lookup"><span data-stu-id="0a691-871">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-872">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia reprezentuje stałą typu dopuszczającego wartości null i ustaw dla niego wartość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-872">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-873">
            <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-873">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-874">
            <paramref name="value" /> nie jest <see langword="null" /> i <paramref name="type" /> nie jest możliwa do przypisania z typu dynamicznego <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-874">
              <paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-875">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-875">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-876">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-876">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-877">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-878">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i wartość null do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-878">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-879">Poniższy przykład przedstawia sposób tworzenia wyrażenia pętli, który używa <xref:System.Linq.Expressions.Expression.Continue%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-879">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-880">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-880">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-881">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-881">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-882">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue z określonym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-882">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-883">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />i wartość null do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-883">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-884">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-884">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-885">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-885">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-886">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-886">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-887">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-887">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-888">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-888">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-889"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-889">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-890"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-890">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="0a691-891">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-891">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="0a691-892">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-892">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-893">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-893">Implementing Method</span></span>  
 <span data-ttu-id="0a691-894">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-894">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-895">Jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-895">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-896">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="0a691-896">Otherwise:</span></span>  
  
    -   <span data-ttu-id="0a691-897">Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-897">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="0a691-898">Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-898">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="0a691-899">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-899">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-900">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-900">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-901">Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-901">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-902">Jeśli jeden lub oba z `expression`. Typ lub `type` jest typem wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio zniesienia węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-902">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="0a691-903">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-903">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-904">Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-904">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-905">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-905">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-906">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia reprezentujący operację umożliwić konwersję typu.</span><span class="sxs-lookup"><span data-stu-id="0a691-906">The following code example shows how to create an expression that represents a type convertion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-907">
            <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-907">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-908">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-908">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-909">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-909">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-910">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-910">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-911">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-911">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-912">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, dla którego określono implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-912">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-913">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-913">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-914"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-914">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-915"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-915">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="0a691-916">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-916">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="0a691-917">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-917">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-918">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-918">Implementing Method</span></span>  
 <span data-ttu-id="0a691-919">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-919">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-920">Jeśli metoda nie jest `null`, jest to metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-920">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="0a691-921">Musi reprezentować inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-921">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="0a691-922">W przeciwnym razie, jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-922">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-923">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="0a691-923">Otherwise:</span></span>  
  
    -   <span data-ttu-id="0a691-924">Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-924">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="0a691-925">Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-925">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="0a691-926">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-926">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-927">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-927">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-928">Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-928">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-929">Jeśli jeden lub oba z `expression`. Typ lub `type` są typu wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio, węzeł została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-929">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="0a691-930">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-930">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-931">Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-931">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-932">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-932">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-933">
            <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-933">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-934">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-934">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-935">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-935">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="0a691-936">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-936">-or-</span>
          </span>
          <span data-ttu-id="0a691-937">
            <paramref name="expression" />. Typ nie jest możliwa do przypisania do typu argumentu metodę reprezentowaną przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-937">
              <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="0a691-938">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-938">-or-</span>
          </span>
          <span data-ttu-id="0a691-939">Zwracany typ metody reprezentowany przez <paramref name="method" /> nie jest możliwa do przypisania do <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-939">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="0a691-940">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-940">-or-</span>
          </span>
          <span data-ttu-id="0a691-941">
            <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartości null i odpowiedni typ niedopuszczający wartości null nie jest równa typu argumentu lub typ zwracany odpowiednio metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-941">
              <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="0a691-942">Więcej niż jedną metodę, która odpowiada <paramref name="method" /> opis został znaleziony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-942">More than one method that matches the <paramref name="method" /> description was found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-943">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-943">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-944">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-944">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-945">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-945">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-946">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-946">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-947">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-947">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-948"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-948">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-949"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-949">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="0a691-950">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-950">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="0a691-951">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-951">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-952">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-952">Implementing Method</span></span>  
 <span data-ttu-id="0a691-953">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-953">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-954">Jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-954">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-955">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="0a691-955">Otherwise:</span></span>  
  
    -   <span data-ttu-id="0a691-956">Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-956">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="0a691-957">Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-957">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="0a691-958">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-958">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-959">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-959">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-960">Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-960">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-961">Jeśli jeden lub oba z `expression`. Typ lub `type` są typu wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio, węzeł została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-961">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="0a691-962">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-962">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-963">Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-963">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-964">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-964">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-965">
            <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-965">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-966">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-966">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-967">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-967">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-968">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-968">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-969">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-969">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-970">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony i dla którego określono implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-970">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-971">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-971">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-972"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-972">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-973"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Jest właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-973">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="0a691-974">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-974">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="0a691-975">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-975">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-976">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-976">Implementing Method</span></span>  
 <span data-ttu-id="0a691-977">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-977">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-978">Jeśli metoda nie jest `null`, jest to metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-978">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="0a691-979">Musi reprezentować inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-979">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="0a691-980">W przeciwnym razie, jeśli dowolny `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który określa operatora konwersji jawnych ani niejawnych <xref:System.Reflection.MethodInfo> reprezentujący który operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-980">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-981">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="0a691-981">Otherwise:</span></span>  
  
    -   <span data-ttu-id="0a691-982">Jeśli oba `expression`. Typ i `type` reprezentować typu liczbowego lub typu Boolean lub Typy wyliczeniowe wartości null ani wartości null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-982">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="0a691-983">Jeśli dowolny `expression`. Typ lub `type` Typ referencyjny, a jawnej konwersji boxing Rozpakowywanie, lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-983">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="0a691-984">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-984">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-985">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-985">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-986">Jeśli `expression`. Typ jest można przypisać do typu argumentu implementującej metody i typ zwracany metody wykonawcze jest można przypisać do `type`, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-986">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-987">Jeśli jeden lub oba z `expression`. Typ lub `type` są typu wartości null i odpowiednie typy wartości nieprzyjmujące wartości są równe typ argumentu i zwracany typ metody implementującej odpowiednio, węzeł została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-987">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="0a691-988">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-988">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-989">Jeśli oba `expression`. Typ i `type` są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-989">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="0a691-990">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-990">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-991">
            <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-991">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-992">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-992">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-993">Żaden operator konwersji zdefiniowany jest między <paramref name="expression" />. Typ i <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-993">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="0a691-994">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-994">-or-</span>
          </span>
          <span data-ttu-id="0a691-995">
            <paramref name="expression" />. Typ nie jest możliwa do przypisania do typu argumentu metodę reprezentowaną przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-995">
              <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="0a691-996">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-996">-or-</span>
          </span>
          <span data-ttu-id="0a691-997">Zwracany typ metody reprezentowany przez <paramref name="method" /> nie jest możliwa do przypisania do <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-997">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="0a691-998">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-998">-or-</span>
          </span>
          <span data-ttu-id="0a691-999">
            <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartości null i odpowiedni typ niedopuszczający wartości null nie jest równa typu argumentu lub typ zwracany odpowiednio metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-999">
              <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="0a691-1000">Więcej niż jedną metodę, która odpowiada <paramref name="method" /> opis został znaleziony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1000">More than one method that matches the <paramref name="method" /> description was found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="0a691-1001">
            <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1001">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span>
          </span>
        </param>
        <param name="startLine">
          <span data-ttu-id="0a691-1002">Wiersz początkowy <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1002">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="0a691-1003">Musi być większa niż 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1003">Must be greater than 0.</span>
          </span>
        </param>
        <param name="startColumn">
          <span data-ttu-id="0a691-1004">Kolumna start <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1004">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="0a691-1005">Musi być większa niż 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1005">Must be greater than 0.</span>
          </span>
        </param>
        <param name="endLine">
          <span data-ttu-id="0a691-1006">Do zakończenia wiersza to <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1006">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="0a691-1007">Musi być mniejsza niż start wiersza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1007">Must be greater or equal than the start line.</span>
          </span>
        </param>
        <param name="endColumn">
          <span data-ttu-id="0a691-1008">Końcowa kolumny tego <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1008">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="0a691-1009">Jeśli wiersz końcowy jest taki sam jak wiersz początkowy, jego musi być większy lub równy niż kolumna rozpoczęcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1009">If the end line is the same as the start line, it must be greater or equal than the start column.</span>
          </span>
          <span data-ttu-id="0a691-1010">W każdym przypadku musi być większa niż 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1010">In any case, must be greater than 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1011">Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> z określonego zakresu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1011">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1012">Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1012">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1013">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1013">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1014">
            <see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1014">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1015">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1016">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszany wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1016">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1017">To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.</span><span class="sxs-lookup"><span data-stu-id="0a691-1017">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1018">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie tego substracts 1 z danej wartości.</span><span class="sxs-lookup"><span data-stu-id="0a691-1018">The following code example shows how to create an expression that substracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1019">
            <see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1019">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1020">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1020">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1021">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1021">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1022">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszany wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1022">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1023">To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.</span><span class="sxs-lookup"><span data-stu-id="0a691-1023">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-1024">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1024">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1025">Tworzy <see cref="T:System.Linq.Expressions.DefaultExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1025">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1026">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1026">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-1027">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje vaule domyślny dla danego typu.</span><span class="sxs-lookup"><span data-stu-id="0a691-1027">The following code example shows how to create an expression that represents a default vaule for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1028">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1028">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1029">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1029">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1030">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1030">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1031">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1031">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1032">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1032">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1033">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1033">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1034"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1034">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1035">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1035">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-1036">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1036">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-1037"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1037">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1038">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1038">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1039">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1039">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1040">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1040">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1041">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1041">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1042">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1042">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1043">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1043">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1044">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1044">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1045">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1045">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1046">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1046">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1047">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-1047">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-1048">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1048">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1049">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-1049">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-1050">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1050">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1051">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1051">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1052">Typ węzła jest typ wyniku dzielenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1052">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="0a691-1053">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1053">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1054">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku dzielenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1054">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1055">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, która dzieli bez reszty jej pierwszy parametr przez jej drugi argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-1055">The following code example shows how to create an expression that divides divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1056">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1056">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1057">Operator dzielenia nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1057">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1058">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1058">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1059">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1059">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1060">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1060">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1061">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1061">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
          <span data-ttu-id="0a691-1062">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1062">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1063">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1063">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1064">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1064">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1065"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1065">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1066">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1066">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-1067">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1067">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-1068"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1068">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1069">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1069">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1070">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1070">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1071">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1071">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1072">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1072">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-1073">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1073">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1074">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1074">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1075">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1075">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1076">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1076">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1077">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1077">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1078">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1078">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1079">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-1079">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-1080">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1080">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1081">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-1081">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-1082">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1082">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1083">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1083">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1084">Typ węzła jest typ wyniku dzielenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1084">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="0a691-1085">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1085">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1086">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku dzielenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1086">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1087">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1087">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1088">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1088">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1089">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator dzielenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1089">
              <paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1090">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1090">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1091">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1091">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1092">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1092">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1093">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1093">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1094">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1094">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1095">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1095">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1096">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1096">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1097">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1097">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1098">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1098">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1099">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1099">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1100">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1100">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1101">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1101">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1102">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1102">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-1103">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1103">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1104">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dzielenia, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1104">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1105">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1105">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1106">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1106">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="0a691-1107">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1107">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="0a691-1108">Typ wyniku wyrażenia dynamicznego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1108">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-1109">Argumenty operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1109">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1110">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1110">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1111">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1111">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1112"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="0a691-1112">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="0a691-1113">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1113">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="0a691-1114">Typ wyniku wyrażenia dynamicznego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1114">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-1115">Pierwszy argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1115">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1116">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1116">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1117">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1117">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1118"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="0a691-1118">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="0a691-1119">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1119">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="0a691-1120">Typ wyniku wyrażenia dynamicznego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1120">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-1121">Argumenty operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1121">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1122">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1122">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1123">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1123">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1124"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="0a691-1124">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="0a691-1125">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1125">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="0a691-1126">Typ wyniku wyrażenia dynamicznego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1126">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-1127">Pierwszy argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1127">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-1128">Drugi argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1128">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1129">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1129">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1130">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1130">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1131"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="0a691-1131">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="0a691-1132">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1132">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="0a691-1133">Typ wyniku wyrażenia dynamicznego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1133">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-1134">Pierwszy argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1134">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-1135">Drugi argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1135">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-1136">Trzeci argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1136">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1137">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1137">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1138">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1138">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1139"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="0a691-1139">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="0a691-1140">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1140">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="0a691-1141">Typ wyniku wyrażenia dynamicznego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1141">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-1142">Pierwszy argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1142">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-1143">Drugi argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1143">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-1144">Trzeci argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1144">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="0a691-1145">Czwarty argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1145">The fourth argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1146">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1146">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1147">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1147">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1148"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wynik będzie można wywnioskować na podstawie typów argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="0a691-1148">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1149">Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1149">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">
          <span data-ttu-id="0a691-1150">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1150">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-1151">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1151">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1152">Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, używając podanych <see cref="T:System.Collections.Generic.IEnumerable`1" /> jako drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1152">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1153">
            <see cref="T:System.Linq.Expressions.ElementInit" /> Mający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1153">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1154">`addMethod` Parametru musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="0a691-1154">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="0a691-1155">Metoda add musi mieć taką samą liczbę parametrów jako liczba elementów w `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1155">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="0a691-1156"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiadającego mu parametru metody add prawdopodobnie po *zamykający*.</span><span class="sxs-lookup"><span data-stu-id="0a691-1156">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-1157">Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1157">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-1158">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1158">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-1159">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1159">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1160">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.</span><span class="sxs-lookup"><span data-stu-id="0a691-1160">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1161">
            <paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1161">
              <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1162">Metoda który <paramref name="addMethod" /> reprezentuje nie ma nazwy "Dodaj" (bez uwzględniania wielkości liter).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1162">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span>
          </span>
          <span data-ttu-id="0a691-1163">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1163">-or-</span>
          </span>
          <span data-ttu-id="0a691-1164">Metoda który <paramref name="addMethod" /> reprezentuje nie jest metodą wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1164">The method that <paramref name="addMethod" /> represents is not an instance method.</span>
          </span>
          <span data-ttu-id="0a691-1165">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1165">-or-</span>
          </span>
          <span data-ttu-id="0a691-1166">
            <paramref name="arguments" /> nie zawiera taką samą liczbę elementów jako liczba parametrów metody który <paramref name="addMethod" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1166">
              <paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span>
          </span>
          <span data-ttu-id="0a691-1167">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1167">-or-</span>
          </span>
          <span data-ttu-id="0a691-1168">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru metody który <paramref name="addMethod" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1168">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">
          <span data-ttu-id="0a691-1169">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1169">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-1170">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1170">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1171">Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, podanej tablicy wartości jako drugi argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1171">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1172">
            <see cref="T:System.Linq.Expressions.ElementInit" /> Mający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1172">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1173">`addMethod` Parametru musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="0a691-1173">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="0a691-1174">Metoda add musi mieć taką samą liczbę parametrów jako liczba elementów w `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1174">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="0a691-1175"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiadającego mu parametru metody add prawdopodobnie po *zamykający*.</span><span class="sxs-lookup"><span data-stu-id="0a691-1175">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-1176">Element będzie można podać tylko wtedy, gdy odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1176">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-1177">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1177">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-1178">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1178">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1179">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.</span><span class="sxs-lookup"><span data-stu-id="0a691-1179">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1180">
            <paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1180">
              <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1181">Metodę, która nie jest addMethod reprezentuje o nazwie "Dodaj" (bez uwzględniania wielkości liter).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1181">The method that addMethod represents is not named "Add" (case insensitive).</span>
          </span>
          <span data-ttu-id="0a691-1182">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1182">-or-</span>
          </span>
          <span data-ttu-id="0a691-1183">Metoda czy reprezentuje addMethod nie jest metodą wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1183">The method that addMethod represents is not an instance method.</span>
          </span>
          <span data-ttu-id="0a691-1184">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1184">-or-</span>
          </span>
          <span data-ttu-id="0a691-1185">argumenty nie zawierać taką samą liczbę elementów w postaci z liczbą parametrów metody reprezentuje tego addMethod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1185">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span>
          </span>
          <span data-ttu-id="0a691-1186">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1186">-or-</span>
          </span>
          <span data-ttu-id="0a691-1187">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru metody który <paramref name="addMethod" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1187">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1188">Tworzy puste wyrażenie, które ma <see cref="T:System.Void" /> typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1188">Creates an empty expression that has <see cref="T:System.Void" /> type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1189">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1189">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1190">Puste wyrażenie może służyć, gdy wyrażenie jest oczekiwany, ale jest potrzebne żadne działanie.</span><span class="sxs-lookup"><span data-stu-id="0a691-1190">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="0a691-1191">Na przykład używając puste wyrażenie jako ostatni wyrażenie w wyrażeniu bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-1191">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="0a691-1192">W takim przypadku wartość zwrotna wyrażenie bloku jest nieważne.</span><span class="sxs-lookup"><span data-stu-id="0a691-1192">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1193">Poniższy przykładowy kod przedstawia sposób tworzenia puste wyrażenie i dodać je do wyrażenia bloku.</span><span class="sxs-lookup"><span data-stu-id="0a691-1193">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1194">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1194">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1195">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1195">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1196">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1196">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1197">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1197">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1198">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1198">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1199">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1199">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1200"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1200">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1201">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1201">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="0a691-1202">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1202">Otherwise, it is `false`.</span></span> <span data-ttu-id="0a691-1203"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1203">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="0a691-1204">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1204">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1205">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1205">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1206">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1206">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1207">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator równości <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1207">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1208">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1208">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1209">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1209">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1210">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1210">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1211">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1211">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1212">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1212">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1213">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="0a691-1213">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="0a691-1214">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1214">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1215">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1215">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1216">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1216">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1217">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1217">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1218">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1218">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1219">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1219">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1220">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1221">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które sprawdza, czy wartości dwa argumenty są takie same.</span><span class="sxs-lookup"><span data-stu-id="0a691-1221">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1222">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1222">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1223">Nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1223">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1224">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1224">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1225">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1225">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-1226">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1226">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1227">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1227">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1228">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1228">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
          <span data-ttu-id="0a691-1229">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1229">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1230">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1230">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1231">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1231">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1232"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1232">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1233">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1233">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="0a691-1234">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1234">Otherwise, they are both `false`.</span></span> <span data-ttu-id="0a691-1235">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1235">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1236">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1236">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1237">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1237">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1238">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1238">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1239">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator równości <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1239">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1240">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1240">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1241">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1241">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1242">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1242">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1243">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1243">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1244">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1244">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1245">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1245">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="0a691-1246">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1246">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1247">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1247">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1248">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1248">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1249">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1249">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1250">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1250">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1251">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1251">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1252">Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1252">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1253">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1253">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1254">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1254">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1255">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1255">
              <paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1256">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1256">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1257">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1257">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1258">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1258">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1259">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operację, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1259">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1260">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1260">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1261">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1261">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1262"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1262">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1263">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1263">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-1264">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1264">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-1265"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1265">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1266">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1266">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1267">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1267">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1268">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1268">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1269">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1269">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1270">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1270">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1271">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1271">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1272">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1272">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1273">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1273">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1274">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1274">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1275">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-1275">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-1276">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1276">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1277">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-1277">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-1278">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1278">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1279">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1279">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1280">Typ węzła jest typ wyniku predefiniowanych `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1280">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="0a691-1281">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1281">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1282">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1282">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1283">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje operacji XOR logicznej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1283">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1284">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1284">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1285">
            <see langword="XOR" /> Operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1285">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1286">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1286">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1287">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1287">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1288">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1288">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1289">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operację, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1289">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
          <span data-ttu-id="0a691-1290">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1290">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1291">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1291">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1292">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1292">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1293"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1293">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1294">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1294">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-1295">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1295">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-1296"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1296">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1297">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1297">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1298">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1298">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1299">Następujące reguły określają wybrana implementacja metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1299">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1300">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1300">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1301">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1301">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1302">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1302">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1303">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1303">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1304">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1304">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1305">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1305">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1306">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1306">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1307">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-1307">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-1308">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1308">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1309">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-1309">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-1310">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1310">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1311">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1311">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1312">Typ węzła jest typ wyniku predefiniowanych `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1312">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="0a691-1313">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1313">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1314">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-1314">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1315">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1315">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1316">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1316">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1317">
            <paramref name="method" /> jest <see langword="null" /> i <see langword="XOR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1317">
              <paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1318">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR operacji przypisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1318">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1319">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1319">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1320">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1320">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1321">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR przypisania operacji, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1321">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1322">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1322">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1323">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1323">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1324">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1324">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1325">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1325">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1326">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR przypisania operacji, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1326">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1327">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1327">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1328">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1328">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1329">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1329">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1330">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1330">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-1331">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1331">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1332">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący XOR przypisania operacji, używając <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1332">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1333">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1333">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1334">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1334">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1335">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1335">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="0a691-1336">Aby uzyskać <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), <c>wyrażenie</c> musi być <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1336">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <c>expression</c> must be <see langword="null" />.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="0a691-1337">
            <see cref="T:System.Reflection.FieldInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1337">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1338">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1338">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1339">A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1339">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1340"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość `field`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1340">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1341">
            <paramref name="field" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1341">
              <paramref name="field" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-1342">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1342">-or-</span>
          </span>
          <span data-ttu-id="0a691-1343">Pole reprezentowany przez <paramref name="field" /> nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1343">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1344">
            <paramref name="expression" />. Typ nie jest można przypisać do pola reprezentowane przez typ deklarujący <paramref name="field" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1344">
              <paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1345">
            <see cref="T:System.Linq.Expressions.Expression" /> Których <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera pole o nazwie <c>fieldName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1345">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <c>fieldName</c>.</span>
          </span>
          <span data-ttu-id="0a691-1346">Może to być wartość null dla pola statyczne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1346">This can be null for static fields.</span>
          </span>
        </param>
        <param name="fieldName">
          <span data-ttu-id="0a691-1347">Nazwa pola, aby można było uzyskać dostęp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1347">The name of a field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1348">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola nazwę pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1348">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1349">A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.FieldInfo" /> reprezentująca pole wskazywane przez <paramref name="fieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1349">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1350"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość <xref:System.Reflection.FieldInfo> reprezentująca pole wskazywane przez `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1350">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="0a691-1351">Ta metoda szuka `expression`. Typ i jego typów podstawowych dla pola o nazwie `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1351">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="0a691-1352">Pola publiczne są preferowane względem niepublicznych pól.</span><span class="sxs-lookup"><span data-stu-id="0a691-1352">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="0a691-1353">Jeśli zostanie znaleziony zgodnego pola, ta metoda przekazuje `expression` i <xref:System.Reflection.FieldInfo> reprezentujący to pole, aby <xref:System.Linq.Expressions.Expression.Field%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1353">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1354">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje podczas uzyskiwania dostępu do pola.</span><span class="sxs-lookup"><span data-stu-id="0a691-1354">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1355">
            <paramref name="expression" /> lub <paramref name="fieldName" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1355">
              <paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1356">Brak pola o nazwie <paramref name="fieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1356">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1357">Obiekt zawierający pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1357">The containing object of the field.</span>
          </span>
          <span data-ttu-id="0a691-1358">Może to być wartość null dla pola statyczne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1358">This can be null for static fields.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-1359">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierającego pole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1359">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span>
          </span>
        </param>
        <param name="fieldName">
          <span data-ttu-id="0a691-1360">Pole ma być uzyskiwany dostęp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1360">The field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1361">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1361">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1362">Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1362">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="0a691-1363">Tablica do sixteen <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Action" /> typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1363">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1364">Tworzy <see cref="T:System.Type" /> obiekt, który reprezentuje ogólnego <c>elementu System.Action</c> przekazać typ, który ma argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1364">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1365">Typ <c>elementu System.Action</c> delegata, który ma argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1365">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1366">Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, powstałe w ten sposób <xref:System.Type> obiekt reprezentuje typ delegata skonstruowane `System.Action<T1,…,Tn>` w języku C# lub `System.Action(Of T1,…,Tn)` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="0a691-1366">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1367">
            <paramref name="typeArgs" /> zawiera więcej niż szesnastu elementy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1367">
              <paramref name="typeArgs" /> contains more than sixteen elements.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1368">
            <paramref name="typeArgs" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1368">
              <paramref name="typeArgs" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="0a691-1369">Argumenty typu delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1369">The type arguments of the delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1370">Pobiera <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> lub <c>elementu System.Action</c> przekazać typ, który ma argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1370">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1371">Typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1371">The delegate type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1372">Ostatni argument typu określa typ zwracany delegata.</span><span class="sxs-lookup"><span data-stu-id="0a691-1372">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="0a691-1373">Nie Func akcji jest ani wystarczająco duży, wygeneruje typu delegata niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="0a691-1373">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="0a691-1374">Podobnie jak w przypadku Func, ostatni argument jest typu zwracanego.</span><span class="sxs-lookup"><span data-stu-id="0a691-1374">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="0a691-1375">Można można ustawić na System.Void wygenerowało akcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-1375">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="0a691-1376">Tablica co do seventeen <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Func" /> typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1376">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1377">Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> przekazać typ, który ma argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1377">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="0a691-1378">Ostatni argument typu określa typ zwracany delegata utworzony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1378">The last type argument specifies the return type of the created delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1379">Typ <c>System.Func</c> delegata, który ma argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1379">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1380">`typeArgs` musi zawierać co najmniej jedną i maksymalnie siedemnaście elementów.</span><span class="sxs-lookup"><span data-stu-id="0a691-1380">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="0a691-1381">Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, powstałe w ten sposób <xref:System.Type> obiekt reprezentuje typ delegata skonstruowane `System.Func<T1,…,Tn>` w języku C# lub `System.Func(Of T1,…,Tn)` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="0a691-1381">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1382">
            <paramref name="typeArgs" /> zawiera mniej niż jeden lub więcej niż siedemnaście elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1382">
              <paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1383">
            <paramref name="typeArgs" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1383">
              <paramref name="typeArgs" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1384">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1384">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-1385">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1385">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1386">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1387">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwość do przekazania do etykiety docelowej na przechodzenie do określonej wartości, a wartość null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1387">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-1388">W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.GotoExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0a691-1388">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-1389">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1389">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0a691-1390">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1390">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1391">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1391">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
          <span data-ttu-id="0a691-1392">Można określić wartość przekazana do etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1392">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1393">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1393">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-1394">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1394">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-1395">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1395">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1396">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1396">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1397">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> zestaw do określonej wartości właściwości <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />i wartość null do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1397">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-1398">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1398">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0a691-1399">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1399">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-1400">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1400">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1401">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1401">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span>
          </span>
          <span data-ttu-id="0a691-1402">Można określić wartość przekazana do etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1402">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1403">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1403">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1404">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1404">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1405">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1405">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1406">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1406">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1407">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1407">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1408">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1408">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1409">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1409">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1410"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1410">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1411">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1411">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="0a691-1412">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1412">Otherwise, it is `false`.</span></span> <span data-ttu-id="0a691-1413"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1413">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="0a691-1414"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1414">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1415">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1415">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1416">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1416">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1417">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1417">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1418">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1418">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1419">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1419">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1420">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1420">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1421">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1421">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1422">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1422">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1423">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1423">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1424">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="0a691-1424">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="0a691-1425">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1425">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1426">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1426">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1427">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1427">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1428">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1428">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1429">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1429">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1430">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1430">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1431">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1432">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0a691-1432">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1433">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1433">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1434">Operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1434">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1435">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1435">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1436">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-1437">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1437">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1438">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1438">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1439">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1439">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
          <span data-ttu-id="0a691-1440">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1440">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1442">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1442">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1443"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1443">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1444">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1444">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="0a691-1445">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1445">Otherwise, they are both `false`.</span></span> <span data-ttu-id="0a691-1446"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1446">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1447">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1447">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1448">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1448">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1449">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1449">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="0a691-1450">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1450">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1451">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1451">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1452">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1452">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1453">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1453">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1454">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1454">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1455">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1455">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1456">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1456">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1457">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1457">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="0a691-1458">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1458">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1459">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1459">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1460">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1460">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1461">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1461">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1462">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1462">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1463">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1463">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1464">Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1464">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1465">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1465">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1466">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1466">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1467">
            <paramref name="method" /> jest <see langword="null" /> i operatora "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1467">
              <paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1468">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1468">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1469">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1469">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1470">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1470">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1471">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1471">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1472">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1472">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1473">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1473">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1474"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1474">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1475">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1475">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="0a691-1476">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1476">Otherwise, it is `false`.</span></span> <span data-ttu-id="0a691-1477"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1477">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="0a691-1478"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1478">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1479">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1479">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1480">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1480">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1481">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1481">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1482">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1482">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1483">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1483">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1484">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1484">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1485">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1485">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1486">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1486">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1487">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1487">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1488">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="0a691-1488">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="0a691-1489">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1489">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1490">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1490">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1491">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1491">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1492">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1492">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1493">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1493">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1494">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1494">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1495">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1496">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0a691-1496">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1497">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1497">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1498">Operator "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1498">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1499">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1499">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1500">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-1501">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1501">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1502">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1502">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1503">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1503">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1504">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1504">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1505">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1505">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1506"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1506">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1507">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1507">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="0a691-1508">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1508">Otherwise, they are both `false`.</span></span> <span data-ttu-id="0a691-1509"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1509">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1510">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1510">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1511">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1511">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1512">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1512">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1513">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1513">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1514">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1514">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1515">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1515">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1516">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1516">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1517">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1517">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1518">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1518">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1519">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1519">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1520">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1520">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="0a691-1521">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1521">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1522">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1522">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1523">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1523">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1524">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1524">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1525">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1525">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1526">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1526">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1527">Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1527">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1528">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1528">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1529">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1529">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1530">
            <paramref name="method" /> jest <see langword="null" /> i operatora "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1530">
              <paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="0a691-1531">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="0a691-1532">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1533">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego z <see langword="if" /> instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1533">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1534">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1534">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span>
          </span>
          <span data-ttu-id="0a691-1535">
            <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> Właściwość jest ustawiona na wyrażenie wartości domyślnej i typ powstałe w ten sposób <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracane przez tę metodę jest <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1535">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-1536">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje blok warunkowego.</span><span class="sxs-lookup"><span data-stu-id="0a691-1536">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="0a691-1537">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1537">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="0a691-1538">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1538">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="0a691-1539">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1540">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego z <see langword="if" /> i <see langword="else" /> instrukcje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1540">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1541">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1541">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
          <span data-ttu-id="0a691-1542">Typ wyniku <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracane przez tę metodę jest <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1542">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-1543">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje blok warunkowego.</span><span class="sxs-lookup"><span data-stu-id="0a691-1543">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1544">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększając wartość wyrażenia o 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1544">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1545">
            <see cref="T:System.Linq.Expressions.Expression" /> Przyrost.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1545">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1546">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększając wartość wyrażenia o 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1547">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększany wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1547">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1548">To wyrażenie będzie działać i nie zmienia wartość obiektu, który jest przekazywany do niego.</span><span class="sxs-lookup"><span data-stu-id="0a691-1548">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1549">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje operacji przyrostu.</span><span class="sxs-lookup"><span data-stu-id="0a691-1549">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1550">
            <see cref="T:System.Linq.Expressions.Expression" /> Przyrost.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1550">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1551">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1551">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1552">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przyroście wyrażenie 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1552">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1553">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększany wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1553">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1554">To wyrażenie będzie działać i nie zmienia wartość obiektu, który jest przekazywany do niego.</span><span class="sxs-lookup"><span data-stu-id="0a691-1554">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1555">Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1555">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1556">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda ma zostać zastosowany do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1556">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-1557">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1557">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1558">Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> dotyczący delegat lub wyrażenie lambda listę wyrażenia argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1558">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1559">
            <see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1559">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1560"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> reprezentuje typ zwracany delegata, który jest reprezentowany przez `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-1560">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="0a691-1561"><xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeśli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1561">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="0a691-1562">W przeciwnym razie zawiera te same elementy jako `arguments` z wyjątkiem, że niektóre z nich <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowaną*.</span><span class="sxs-lookup"><span data-stu-id="0a691-1562">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-1563">Element będzie można podać tylko wtedy, gdy odpowiadającego mu parametru delegata reprezentowany przez `expression` jest typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1563">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-1564">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1564">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-1565">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1565">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1566">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="0a691-1566">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1567">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1567">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1568">
            <paramref name="expression" />. Typ nie odpowiada typowi obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1568">
              <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          </span>
          <span data-ttu-id="0a691-1569">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1569">-or-</span>
          </span>
          <span data-ttu-id="0a691-1570">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru delegowanego reprezentowany przez <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1570">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1571">
            <paramref name="arguments" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla delegata reprezentowany przez <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1571">
              <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1572">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda ma zostać zastosowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1572">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-1573">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1573">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1574">Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> dotyczący delegat lub wyrażenie lambda listę wyrażenia argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1574">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1575">
            <see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1575">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1576"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> reprezentuje typ zwracany delegata, który jest reprezentowany przez `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-1576">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="0a691-1577"><xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeśli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1577">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="0a691-1578">W przeciwnym razie zawiera te same elementy jako `arguments` z wyjątkiem, że niektóre z nich <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowaną*.</span><span class="sxs-lookup"><span data-stu-id="0a691-1578">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-1579">Element będzie można podać tylko wtedy, gdy odpowiadającego mu parametru delegata reprezentowany przez `expression` jest typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1579">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-1580">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1580">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-1581">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1581">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1582">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="0a691-1582">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1583">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1583">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1584">
            <paramref name="expression" />. Typ nie odpowiada typowi obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1584">
              <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          </span>
          <span data-ttu-id="0a691-1585">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1585">-or-</span>
          </span>
          <span data-ttu-id="0a691-1586">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru delegowanego reprezentowany przez <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1586">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1587">
            <paramref name="arguments" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla delegata reprezentowany przez <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1587">
              <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1588">Zwraca, czy wyrażenie ma wartość false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1588">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1589">
            <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1589">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1590">Zwraca, czy wyrażenie ma wartość false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1590">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1591">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1591">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1592">
            <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1592">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1593">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1593">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1594">Zwraca, czy wyrażenie ma wartość false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1594">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1595">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1595">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1596">Zwraca, czy wyrażenie daje w wyniku wartość true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1596">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1597">
            <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1597">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1598">Zwraca, czy wyrażenie daje w wyniku wartość true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1598">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1599">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1599">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-1600">
            <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1600">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1601">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1601">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1602">Zwraca, czy wyrażenie daje w wyniku wartość true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1602">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1603">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1603">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1604">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1604">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1605">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z typu void i bez nazwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1605">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1606">Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1606">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-1607">W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.LabelTarget> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0a691-1607">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-1608">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Której ta <see cref="T:System.Linq.Expressions.LabelExpression" /> zostanie skojarzona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1608">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1609">Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący Etykieta bez wartości domyślnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1609">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1610">A <see cref="T:System.Linq.Expressions.LabelExpression" /> bez wartości domyślnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1610">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="0a691-1611">Nazwa etykiety.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1611">The name of the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1612">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety typu void o podanej nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1612">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1613">Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1613">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-1614">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1614">The type of value that is passed when jumping to the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1615">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1615">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1616">Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1616">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-1617">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.LabelTarget> w wyrażeniu pętli.</span><span class="sxs-lookup"><span data-stu-id="0a691-1617">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-1618">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Której ta <see cref="T:System.Linq.Expressions.LabelExpression" /> zostanie skojarzona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1618">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span>
          </span>
        </param>
        <param name="defaultValue">
          <span data-ttu-id="0a691-1619">Wartość tego <see cref="T:System.Linq.Expressions.LabelExpression" /> po osiągnięciu przez przepływu sterowania regularne etykiety.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1619">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1620">Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący etykiety z daną wartość domyślną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1620">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1621">A <see cref="T:System.Linq.Expressions.LabelExpression" /> z daną wartość domyślną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1621">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-1622">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1622">The type of value that is passed when jumping to the label.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-1623">Nazwa etykiety.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1623">The name of the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1624">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem i nazwą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1624">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1625">Nowe <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1625">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1626">Tworzy drzewo wyrażenia, który reprezentuje wyrażenie lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1626">Creates an expression tree that represents a lambda expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-1627">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1627">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1628">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1628">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1629">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1629">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1630">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1630">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-1631">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1631">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1632">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1632">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1633">Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym tworzeniu typem obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1633">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1634">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1634">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1635">`parameters` Parametr nie może mieć więcej niż szesnastu elementów.</span><span class="sxs-lookup"><span data-stu-id="0a691-1635">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="0a691-1636">Elementy `parameters` odwołania musi być równa wyrażeń w `body`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1636">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="0a691-1637">Ta metoda tworzy typ delegata odpowiednie z jednego z `System.Func` delegatów.</span><span class="sxs-lookup"><span data-stu-id="0a691-1637">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="0a691-1638">Następnie przekazuje typ delegata do jednego z <xref:System.Linq.Expressions.ExpressionType.Lambda> metodami factory, aby utworzyć <xref:System.Linq.Expressions.LambdaExpression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1638">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1639">
            <paramref name="body" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1639">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-1640">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1640">-or-</span>
          </span>
          <span data-ttu-id="0a691-1641">Jeden lub więcej elementów <paramref name="parameters" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1641">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1642">
            <paramref name="parameters" /> zawiera więcej niż szesnastu elementy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1642">
              <paramref name="parameters" /> contains more than sixteen elements.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-1643">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1643">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1644">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1644">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1645">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1645">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1646">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1646">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1647">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1647">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-1648">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1648">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1649">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1649">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1650">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1650">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1651">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1651">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1652">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1652">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-1653">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1653">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-1654">Nazwa lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1654">The name for the lambda.</span>
          </span>
          <span data-ttu-id="0a691-1655">Używane w celu emisji informacji o debugowaniu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1655">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1656">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1656">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1657">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1657">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1658">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1658">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-1659">A <see cref="T:System.Type" /> reprezentujący podpis delegata lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1659">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-1660">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1660">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1661">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1661">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1662">Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym tworzeniu typem obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1662">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
          <span data-ttu-id="0a691-1663">Można go po typie delegata nie jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1663">It can be used when the delegate type is not known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1664">Obiekt, który reprezentuje wyrażenie lambda, które ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1664">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1665">Obiekt, który jest zwracany z tej funkcji jest typu <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1665">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="0a691-1666"><xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="0a691-1666">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="0a691-1667">Liczba parametrów dla typu delegata reprezentowany przez`delegateType` musi być równa długości `parameters`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1667">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="0a691-1668">Elementy `parameters` odwołania musi być równa wyrażeń w `body`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1668">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="0a691-1669"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt jest taki sam `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1669">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="0a691-1670">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.</span><span class="sxs-lookup"><span data-stu-id="0a691-1670">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1671">W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje wyrażenie lambda, które dodaje 1 do przekazany argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-1671">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1672">
            <paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1672">
              <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-1673">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1673">-or-</span>
          </span>
          <span data-ttu-id="0a691-1674">Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1674">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1675">
            <paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1675">
              <paramref name="delegateType" /> does not represent a delegate type.</span>
          </span>
          <span data-ttu-id="0a691-1676">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1676">-or-</span>
          </span>
          <span data-ttu-id="0a691-1677">
            <paramref name="body" />. Typ reprezentuje typ, który nie jest można przypisać do typ zwracany typ delegowany reprezentowany przez <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1677">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="0a691-1678">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1678">-or-</span>
          </span>
          <span data-ttu-id="0a691-1679">
            <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata reprezentowany przez <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1679">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="0a691-1680">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1680">-or-</span>
          </span>
          <span data-ttu-id="0a691-1681">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu z odpowiadającym typem parametru na typ delegata reprezentowany przez <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1681">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-1682">A <see cref="T:System.Type" /> reprezentujący podpis delegata lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1682">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-1683">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1683">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1684">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1684">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1685">Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym tworzeniu typem obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1685">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
          <span data-ttu-id="0a691-1686">Można go po typie delegata nie jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1686">It can be used when the delegate type is not known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1687">Obiekt, który reprezentuje wyrażenie lambda, które ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1687">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1688">Obiekt, który jest zwracany z tej funkcji jest typu <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1688">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="0a691-1689"><xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="0a691-1689">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="0a691-1690">Liczba parametrów dla typu delegata reprezentowany przez `delegateType` musi być równa długości `parameters`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1690">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="0a691-1691">Elementy `parameters` odwołania musi być równa wyrażeń w `body`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1691">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="0a691-1692"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt jest taki sam `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1692">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="0a691-1693">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.</span><span class="sxs-lookup"><span data-stu-id="0a691-1693">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1694">
            <paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1694">
              <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-1695">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1695">-or-</span>
          </span>
          <span data-ttu-id="0a691-1696">Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1696">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1697">
            <paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1697">
              <paramref name="delegateType" /> does not represent a delegate type.</span>
          </span>
          <span data-ttu-id="0a691-1698">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1698">-or-</span>
          </span>
          <span data-ttu-id="0a691-1699">
            <paramref name="body" />. Typ reprezentuje typ, który nie jest można przypisać do typ zwracany typ delegowany reprezentowany przez <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1699">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="0a691-1700">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1700">-or-</span>
          </span>
          <span data-ttu-id="0a691-1701">
            <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata reprezentowany przez <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1701">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="0a691-1702">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1702">-or-</span>
          </span>
          <span data-ttu-id="0a691-1703">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu z odpowiadającym typem parametru na typ delegata reprezentowany przez <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1703">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-1704">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1704">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-1705">Nazwa lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1705">The name for the lambda.</span>
          </span>
          <span data-ttu-id="0a691-1706">Używane w celu emisji informacji o debugowaniu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1706">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1707">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1707">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1708">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1708">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1709">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1709">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1710">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1710">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-1711">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1711">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-1712">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1712">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1713">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1713">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1714">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1714">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1715">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1715">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1716">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1716">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-1717">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1717">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-1718">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1718">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1719">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1719">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1720">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1720">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1721">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1721">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1722">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1722">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-1723">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1723">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-1724">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1724">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-1725">Nazwa lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1725">The name for the lambda.</span>
          </span>
          <span data-ttu-id="0a691-1726">Używane w celu emisji informacji o debugowaniu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1726">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1727">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1727">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1728">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1728">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1729">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1729">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-1730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-1731">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1731">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-1732">Nazwa lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1732">The name for the lambda.</span>
          </span>
          <span data-ttu-id="0a691-1733">Używane w celu emisji informacji o debugowaniu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1733">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1734">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1734">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1735">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1735">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1736">Tworzy typu LambdaExpression, tworząc pierwszy typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1736">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1737">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwości równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1737">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="0a691-1738">Typ obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1738">A delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="0a691-1739">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1739">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1740">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1740">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1741">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1741">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1742">
            <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1742">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1743">Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1743">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="0a691-1744">Elementy `parameters` odwołania musi być równa wyrażeń w `body`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1744">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="0a691-1745"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt reprezentuje typ `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1745">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="0a691-1746">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.</span><span class="sxs-lookup"><span data-stu-id="0a691-1746">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1747">
            <paramref name="body" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1747">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-1748">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1748">-or-</span>
          </span>
          <span data-ttu-id="0a691-1749">Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1749">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1750">
            <paramref name="TDelegate" /> nie jest typem delegowanym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1750">
              <paramref name="TDelegate" /> is not a delegate type.</span>
          </span>
          <span data-ttu-id="0a691-1751">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1751">-or-</span>
          </span>
          <span data-ttu-id="0a691-1752">
            <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwa do przypisania do zwracanego typu <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1752">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="0a691-1753">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1753">-or-</span>
          </span>
          <span data-ttu-id="0a691-1754">
            <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1754">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="0a691-1755">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1755">-or-</span>
          </span>
          <span data-ttu-id="0a691-1756">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu danego parametru typu <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1756">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="0a691-1757">Typ obiektu delegowanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1757">A delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="0a691-1758">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1758">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1759">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1759">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1760">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1760">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1761">
            <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1761">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1762">Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1762">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="0a691-1763">Elementy `parameters` odwołania musi być równa wyrażeń w`body`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1763">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="0a691-1764"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikowy obiekt reprezentuje typ `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1764">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="0a691-1765">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt ma pustą kolekcję.</span><span class="sxs-lookup"><span data-stu-id="0a691-1765">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1766">
            <paramref name="body" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1766">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-1767">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1767">-or-</span>
          </span>
          <span data-ttu-id="0a691-1768">Co najmniej jeden element w <paramref name="parameters" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1768">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1769">
            <paramref name="TDelegate" /> nie jest typem delegowanym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1769">
              <paramref name="TDelegate" /> is not a delegate type.</span>
          </span>
          <span data-ttu-id="0a691-1770">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1770">-or-</span>
          </span>
          <span data-ttu-id="0a691-1771">
            <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwa do przypisania do zwracanego typu <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1771">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="0a691-1772">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1772">-or-</span>
          </span>
          <span data-ttu-id="0a691-1773">
            <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1773">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="0a691-1774">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1774">-or-</span>
          </span>
          <span data-ttu-id="0a691-1775">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="parameters" /> nie jest możliwa do przypisania z typu danego parametru typu <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1775">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="0a691-1776">Typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1776">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="0a691-1777">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1777">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1778">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1778">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1779">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1779">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1780">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1780">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1781">
            <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1781">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="0a691-1782">Typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1782">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="0a691-1783">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1783">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1784">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1784">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1785">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1785">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1786">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1786">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1787">
            <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1787">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="0a691-1788">Typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1788">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="0a691-1789">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1789">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-1790">Nazwa lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1790">The name of the lambda.</span>
          </span>
          <span data-ttu-id="0a691-1791">Używany do generowania informacji o debugowaniu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1791">Used for generating debugging information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1792">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1792">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1793">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1793">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1794">
            <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1794">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="0a691-1795">Typ delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1795">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="0a691-1796">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1796">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-1797">Nazwa lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1797">The name of the lambda.</span>
          </span>
          <span data-ttu-id="0a691-1798">Używany do generowania informacji debugowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1798">Used for generating debugging info.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="0a691-1799">A <see cref="T:System.Boolean" /> wskazujące, że jeśli optymalizację wywołania tail będą stosowane w przypadku kompilowania kodu utworzonego wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1799">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="0a691-1800">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1800">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1801">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1801">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1802">
            <see cref="T:System.Linq.Expressions.Expression`1" /> Mający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1802">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1803">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w lewo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1803">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1804">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1804">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1805">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1805">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1806">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w lewo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1806">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1807">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1807">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1808">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1808">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1809"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1809">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1810">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1810">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-1811">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1811">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-1812"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1812">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1813">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1813">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1814">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1814">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1815">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1815">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1816">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w lewo, <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1816">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1817">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1817">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1818">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1818">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1819">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1819">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1820">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1820">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1821">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1821">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1822">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-1822">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-1823">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1823">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1824">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-1824">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-1825">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1825">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1826">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1826">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1827">Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="0a691-1827">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="0a691-1828">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1828">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1829">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="0a691-1829">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1830">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1830">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1831">Operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1831">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1832">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1832">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1833">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1833">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1834">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1834">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1835">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w lewo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1835">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1836">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1836">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1837">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1837">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1838"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1838">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1839">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1839">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-1840">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1840">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-1841"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1841">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1842">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1842">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1843">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1843">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1844">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1844">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1845">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1845">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-1846">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w lewo, <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1846">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1847">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1847">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1848">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1848">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1849">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1849">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1850">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1850">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1851">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1851">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1852">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-1852">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-1853">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1853">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1854">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-1854">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-1855">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1855">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1856">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1856">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1857">Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="0a691-1857">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="0a691-1858">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1858">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1859">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="0a691-1859">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1860">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1860">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1861">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1861">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1862">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator przesunięcia w lewo dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1862">
              <paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1863">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1863">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1864">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1864">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1865">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1865">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1866">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1866">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1867">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1867">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1868">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1868">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1869">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1869">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1870">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1870">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1871">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1871">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1872">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1872">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1873">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1873">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1874">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1874">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1875">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1875">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-1876">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1876">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1877">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w lewo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1877">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1878">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1878">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1879">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1879">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1880">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1880">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1881">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1881">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1882">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1882">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1883">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1883">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1884">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1884">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1885"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1885">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1886">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1886">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="0a691-1887">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1887">Otherwise, it is `false`.</span></span> <span data-ttu-id="0a691-1888"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1888">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="0a691-1889"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1889">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1890">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1890">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1891">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1891">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1892">Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:</span><span class="sxs-lookup"><span data-stu-id="0a691-1892">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="0a691-1893">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1893">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1894">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1894">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1895">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1895">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1896">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1896">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1897">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1897">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1898">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1898">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1899">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="0a691-1899">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="0a691-1900">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1900">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1901">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1901">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1902">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1902">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1903">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1903">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1904">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1904">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1905">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1905">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1906">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1906">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1907">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0a691-1907">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1908">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1908">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1909">Operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1909">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1910">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1910">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1911">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-1912">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1912">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1913">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1914">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1914">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1915">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1915">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1916">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1916">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1917"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1917">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1918">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1918">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="0a691-1919">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1919">Otherwise, they are both `false`.</span></span> <span data-ttu-id="0a691-1920"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1920">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1921">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1921">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1922">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1922">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1923">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1923">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1924">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1924">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1925">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1925">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1926">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1926">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1927">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1927">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1928">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1928">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1929">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1929">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1930">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1930">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1931">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1931">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="0a691-1932">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1932">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1933">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1933">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1934">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1934">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1935">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1935">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1936">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1936">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1937">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1937">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1938">Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1938">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1939">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1939">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-1940">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1940">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1941">
            <paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1941">
              <paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-1942">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1942">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1943">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1943">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1944">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1944">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1945">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1945">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1946">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1946">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1947">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1947">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1948"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1948">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1949">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1949">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="0a691-1950">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1950">Otherwise, it is `false`.</span></span> <span data-ttu-id="0a691-1951"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1951">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="0a691-1952"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1952">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1953">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1953">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1954">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1954">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1955">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1956">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1956">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1957">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1957">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1958">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1958">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1959">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1959">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1960">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1960">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1961">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1961">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1962">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="0a691-1962">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="0a691-1963">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1963">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1964">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1964">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1965">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1965">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1966">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1966">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1967">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1967">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-1968">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1968">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-1969">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1969">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-1970">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia, który porównuje dwie liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0a691-1970">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-1971">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1971">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-1972">Operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1972">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-1973">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1973">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-1974">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1974">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-1975">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1975">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-1976">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1976">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-1977">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie liczbowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1977">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-1978">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-1978">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-1979">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1979">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-1980"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-1980">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-1981">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1981">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="0a691-1982">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1982">Otherwise, they are both `false`.</span></span> <span data-ttu-id="0a691-1983"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1983">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-1984">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-1984">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-1985">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-1985">Implementing Method</span></span>  
 <span data-ttu-id="0a691-1986">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-1986">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-1987">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1987">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1988">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1988">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1989">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-1989">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-1990">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-1990">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-1991">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1991">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1992">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1992">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-1993">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-1993">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-1994">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1994">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="0a691-1995">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-1995">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-1996">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1996">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-1997">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-1997">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-1998">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-1998">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-1999">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-1999">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-2000">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2000">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2001">Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2001">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2002">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2002">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2003">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2003">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2004">
            <paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2004">
              <paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2005">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2005">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="0a691-2006">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2006">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2007">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2007">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2008">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest on polem ani właściwością.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2008">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2009">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2009">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2010">
            <paramref name="member" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2010">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2011">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2011">-or-</span>
          </span>
          <span data-ttu-id="0a691-2012">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2012">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2013">
            <paramref name="member" /> nie reprezentować pole lub właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2013">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="0a691-2014">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2014">-or-</span>
          </span>
          <span data-ttu-id="0a691-2015">
            <see cref="P:System.Reflection.FieldInfo.FieldType" /> Lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2015">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="0a691-2016">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2016">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2017">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2017">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2018">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest on polem ani właściwością.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2018">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2019">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2019">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2020">
            <paramref name="member" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2020">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2021">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2021">-or-</span>
          </span>
          <span data-ttu-id="0a691-2022">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2022">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2023">
            <paramref name="member" /> nie reprezentować pole lub właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2023">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="0a691-2024">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2024">-or-</span>
          </span>
          <span data-ttu-id="0a691-2025">
            <see cref="P:System.Reflection.FieldInfo.FieldType" /> Lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2025">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="0a691-2026">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2026">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2027">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2027">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2028">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> na podstawie metody dostępu określonej właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2028">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2029">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.MemberInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2029">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2030">
            <paramref name="propertyAccessor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2030">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2031">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2031">-or-</span>
          </span>
          <span data-ttu-id="0a691-2032">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2032">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2033">
            <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2033">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="0a691-2034">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2034">-or-</span>
          </span>
          <span data-ttu-id="0a691-2035">
            <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> Właściwości, która metoda reprezentowany przez <paramref name="propertyAccessor" /> dostępy nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2035">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="0a691-2036">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2036">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2037">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2037">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2038">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu oparte na metodę dostępu określonej właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2038">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2039">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.MemberInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2039">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2040">
            <paramref name="propertyAccessor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2040">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2041">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2041">-or-</span>
          </span>
          <span data-ttu-id="0a691-2042">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2042">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2043">
            <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2043">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="0a691-2044">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2044">-or-</span>
          </span>
          <span data-ttu-id="0a691-2045">
            <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> Właściwości, która metoda reprezentowany przez <paramref name="propertyAccessor" /> dostępy nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2045">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2046">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2046">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2047">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2047">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2048">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2048">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2049">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> które używa określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiektów do zainicjowania kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2049">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2050">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2050">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2051"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2051">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="0a691-2052"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2052">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2053">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowe wystąpienie słownika z dwóch par klucz wartość.</span><span class="sxs-lookup"><span data-stu-id="0a691-2053">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2054">
            <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2054">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2055">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2055">-or-</span>
          </span>
          <span data-ttu-id="0a691-2056">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2056">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2057">
            <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2057">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2058">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2058">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2059">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2059">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2060">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą metodę o nazwie "Dodaj" można dodać elementów do kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2060">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2061">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2061">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2062"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2062">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="0a691-2063">Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-2063">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="0a691-2064">Typ argumentu musi być możliwa do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości pierwszego elementu obiektu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2064">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="0a691-2065"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2065">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="0a691-2066"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2066">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="0a691-2067"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metody add, który został wykryty na `newExpression`. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="0a691-2067">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="0a691-2068"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2068">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2069">
            <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2069">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2070">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2070">-or-</span>
          </span>
          <span data-ttu-id="0a691-2071">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2071">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2072">
            <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2072">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2073">Nie istnieje metoda wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter) zadeklarowany w <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2073">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="0a691-2074">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2074">-or-</span>
          </span>
          <span data-ttu-id="0a691-2075">Metoda add na <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2075">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span>
          </span>
          <span data-ttu-id="0a691-2076">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2076">-or-</span>
          </span>
          <span data-ttu-id="0a691-2077">Typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości pierwszego elementu obiektu <paramref name="initializers" /> nie można przypisać do typu argumentu metody add na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2077">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="0a691-2078">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2078">-or-</span>
          </span>
          <span data-ttu-id="0a691-2079">Istnieje więcej niż jedna metoda zgodnego argumentu o nazwie "Dodaj" (bez uwzględniania wielkości liter) na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2079">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2080">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2080">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2081">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2081">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2082">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> które używa określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiektów do zainicjowania kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2082">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2083">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2083">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2084"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2084">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="0a691-2085"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2085">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2086">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowe wystąpienie słownika z dwóch par klucz wartość.</span><span class="sxs-lookup"><span data-stu-id="0a691-2086">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2087">
            <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2087">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2088">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2088">-or-</span>
          </span>
          <span data-ttu-id="0a691-2089">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2089">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2090">
            <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2090">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2091">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2091">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2092">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2092">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2093">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą metodę o nazwie "Dodaj" można dodać elementów do kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2093">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2094">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2094">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2095"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2095">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="0a691-2096">Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-2096">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="0a691-2097">Typ argumentu musi być możliwa do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości pierwszego elementu obiektu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2097">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="0a691-2098"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2098">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="0a691-2099"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2099">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="0a691-2100"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metody add, który został wykryty na `newExpression`. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="0a691-2100">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="0a691-2101"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2101">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2102">
            <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2102">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2103">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2103">-or-</span>
          </span>
          <span data-ttu-id="0a691-2104">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2104">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2105">
            <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2105">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2106">Nie istnieje metoda wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter) zadeklarowany w <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2106">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="0a691-2107">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2107">-or-</span>
          </span>
          <span data-ttu-id="0a691-2108">Metoda add na <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2108">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span>
          </span>
          <span data-ttu-id="0a691-2109">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2109">-or-</span>
          </span>
          <span data-ttu-id="0a691-2110">Typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości pierwszego elementu obiektu <paramref name="initializers" /> nie można przypisać do typu argumentu metody add na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2110">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="0a691-2111">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2111">-or-</span>
          </span>
          <span data-ttu-id="0a691-2112">Istnieje więcej niż jedna metoda zgodnego argumentu o nazwie "Dodaj" (bez uwzględniania wielkości liter) na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2112">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2113">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2113">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="addMethod">
          <span data-ttu-id="0a691-2114">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który dodaje element do kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2114">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2115">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2115">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2116">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą określonej metody do dodawania elementów w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2116">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2117">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2117">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2118"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2118">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="0a691-2119">Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-2119">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="0a691-2120">Jeśli `addMethod` nie jest `null`, musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który ma dokładnie jeden parametr.</span><span class="sxs-lookup"><span data-stu-id="0a691-2120">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="0a691-2121">Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.</span><span class="sxs-lookup"><span data-stu-id="0a691-2121">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="0a691-2122"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2122">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="0a691-2123"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2123">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="0a691-2124"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2124">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="0a691-2125"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2125">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2126">
            <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2126">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2127">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2127">-or-</span>
          </span>
          <span data-ttu-id="0a691-2128">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2128">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2129">
            <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2129">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
          <span data-ttu-id="0a691-2130">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2130">-or-</span>
          </span>
          <span data-ttu-id="0a691-2131">
            <paramref name="addMethod" /> nie jest <see langword="null" /> i nie reprezentuje metodę wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2131">
              <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span>
          </span>
          <span data-ttu-id="0a691-2132">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2132">-or-</span>
          </span>
          <span data-ttu-id="0a691-2133">
            <paramref name="addMethod" /> nie jest <see langword="null" /> i typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody który <paramref name="addMethod" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2133">
              <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2134">
            <paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienia o nazwie "Dodaj", który przyjmuje jeden argument typu zgodnego istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2134">
              <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2135">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2135">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="addMethod">
          <span data-ttu-id="0a691-2136">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę wystąpienia, który przyjmuje jeden argument, który dodaje element do kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2136">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2137">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2137">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2138">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającą określonej metody do dodawania elementów w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2138">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2139">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2139">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2140"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typu, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2140">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="0a691-2141">Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi zadeklarować pojedynczą metodę o nazwie "Dodaj" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument.</span><span class="sxs-lookup"><span data-stu-id="0a691-2141">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="0a691-2142">Jeśli `addMethod` nie jest `null`, musi reprezentować metodą wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który ma dokładnie jeden parametr.</span><span class="sxs-lookup"><span data-stu-id="0a691-2142">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="0a691-2143">Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.</span><span class="sxs-lookup"><span data-stu-id="0a691-2143">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="0a691-2144"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracana <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2144">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="0a691-2145"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest pojedyncza kolekcja, która zawiera odpowiadającego mu elementu z `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2145">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="0a691-2146"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2146">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="0a691-2147"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2147">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2148">
            <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2148">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2149">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2149">-or-</span>
          </span>
          <span data-ttu-id="0a691-2150">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2150">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2151">
            <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2151">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
          <span data-ttu-id="0a691-2152">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2152">-or-</span>
          </span>
          <span data-ttu-id="0a691-2153">
            <paramref name="addMethod" /> nie jest <see langword="null" /> i nie reprezentuje metodę wystąpienia o nazwie "Dodaj" (bez uwzględniania wielkości liter), który przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2153">
              <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span>
          </span>
          <span data-ttu-id="0a691-2154">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2154">-or-</span>
          </span>
          <span data-ttu-id="0a691-2155">
            <paramref name="addMethod" /> nie jest <see langword="null" /> i typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody który <paramref name="addMethod" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2155">
              <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2156">
            <paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienia o nazwie "Dodaj", który przyjmuje jeden argument typu zgodnego istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2156">
              <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2157">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2157">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-2158">Treści pętli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2158">The body of the loop.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2159">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2159">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2160">Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2160">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-2161">Treści pętli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2161">The body of the loop.</span>
          </span>
        </param>
        <param name="break">
          <span data-ttu-id="0a691-2162">Obiekt docelowy podziału używane przez treści pętli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2162">The break target used by the loop body.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2163">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> z danym elementem docelowym treści i podziału.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2163">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2164">Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2164">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-2165">Poniższy przykład przedstawia sposób tworzenia wyrażenia bloku, który zawiera <xref:System.Linq.Expressions.LoopExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0a691-2165">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-2166">Treści pętli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2166">The body of the loop.</span>
          </span>
        </param>
        <param name="break">
          <span data-ttu-id="0a691-2167">Obiekt docelowy podziału używane przez treści pętli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2167">The break target used by the loop body.</span>
          </span>
        </param>
        <param name="continue">
          <span data-ttu-id="0a691-2168">Obiekt docelowy Kontynuuj używane przez treści pętli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2168">The continue target used by the loop body.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2169">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2169">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2170">Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2170">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2171">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> przez wywołanie metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2171">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="0a691-2172">
            <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację binarną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2172">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="0a691-2173">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący Lewy argument operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2173">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2174">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy argument operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2174">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2175">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podanych argumentów operacji lewy i prawy przez wywołanie metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2175">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2176">
            <see cref="T:System.Linq.Expressions.BinaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2176">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2177">`binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> ta metoda wywołuje metodę fabryki.</span><span class="sxs-lookup"><span data-stu-id="0a691-2177">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="0a691-2178">Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2178">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2179">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> metodę w celu utworzenia <xref:System.Linq.Expressions.BinaryExpression> reprezentujący odejmowania jeden numer z innej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2179">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2180">
            <paramref name="binaryType" /> nie odpowiada na węzeł wyrażenie binarne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2180">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2181">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2181">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="0a691-2182">
            <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację binarną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2182">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="0a691-2183">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący Lewy argument operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2183">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2184">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy argument operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2184">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-2185">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2185">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2186">A <see cref="T:System.Reflection.MethodInfo" /> , który określa implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2186">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2187">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand i wdrażanie — metoda, przez wywołanie metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2187">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2188">
            <see cref="T:System.Linq.Expressions.BinaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2188">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2189">`binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki będzie wywoływać tej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2189">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="0a691-2190">Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2190">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="0a691-2191">`liftToNull` i `method` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.</span><span class="sxs-lookup"><span data-stu-id="0a691-2191">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2192">
            <paramref name="binaryType" /> nie odpowiada na węzeł wyrażenie binarne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2192">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2193">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2193">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="0a691-2194">
            <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację binarną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2194">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="0a691-2195">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący Lewy argument operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2195">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2196">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy argument operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2196">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-2197">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2197">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2198">A <see cref="T:System.Reflection.MethodInfo" /> , który określa implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2198">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-2199">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> reprezentujący funkcji konwersji typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2199">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span>
          </span>
          <span data-ttu-id="0a691-2200">Ten parametr jest używany tylko wtedy, gdy <c>binaryType</c> jest <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> lub przydział złożony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2200">This parameter is used only if <c>binaryType</c> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment..</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2201">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand implementacja metody i wpisz przez wywołanie metody fabryki odpowiedniej funkcji konwersji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2202">
            <see cref="T:System.Linq.Expressions.BinaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2202">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2203">`binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki będzie wywoływać tej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2203">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="0a691-2204">Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2204">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="0a691-2205">`liftToNull`, `method` i `conversion` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.</span><span class="sxs-lookup"><span data-stu-id="0a691-2205">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2206">
            <paramref name="binaryType" /> nie odpowiada na węzeł wyrażenie binarne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2206">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2207">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2207">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-2208">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2208">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="variable">
          <span data-ttu-id="0a691-2209">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołanie do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2209">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-2210">Treść instrukcji catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2210">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="0a691-2211">Treść <see cref="T:System.Exception" /> filtru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2211">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2212">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z określonych elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2212">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2213">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2213">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2214">`type` muszą być niezerowe i zgodny z typem `variable` (jeśli go podano).</span><span class="sxs-lookup"><span data-stu-id="0a691-2214">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2215">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2215">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-2216">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2216">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="0a691-2217">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2217">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-2218">Argumenty operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2218">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2219">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2219">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2220">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2220">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-2221">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2221">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="0a691-2222">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2222">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-2223">Argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2223">The argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2224">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2224">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2225">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2225">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-2226">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2226">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="0a691-2227">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2227">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-2228">Argumenty operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2228">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2229">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2229">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2230">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2230">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-2231">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2231">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="0a691-2232">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2232">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-2233">Pierwszy argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2233">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-2234">Drugi argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2234">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2235">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i dwa argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2235">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2236">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2236">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-2237">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2237">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="0a691-2238">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2238">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-2239">Pierwszy argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2239">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-2240">Drugi argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2240">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-2241">Trzeci argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2241">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2242">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i trzech argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2242">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2243">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2243">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="0a691-2244">Typ delegata używane przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2244">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="0a691-2245">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2245">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="0a691-2246">Pierwszy argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2246">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="0a691-2247">Drugi argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2247">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="0a691-2248">Trzeci argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2248">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="0a691-2249">Czwarty argument operacji dynamicznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2249">The fourth argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2250">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operacji dynamicznej związana dostarczonych <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i cztery argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2250">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2251">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2251">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">
          <span data-ttu-id="0a691-2252">
            <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> z <see cref="T:System.Linq.Expressions.GotoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2252">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="0a691-2253">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2253">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0a691-2254">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2254">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-2255">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2255">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2256">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący skoku określonego <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2256">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span>
          </span>
          <span data-ttu-id="0a691-2257">Można także określić wartość przekazana do etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2257">The value passed to the label upon jumping can also be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2258">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa <paramref name="kind" />, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2258">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-2259">Obiekt, do którego należy właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2259">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="0a691-2260">Powinna ona mieć wartość null, jeśli właściwość jest <see langword="static" /> (<see langword="shared" /> w języku Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2260">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="0a691-2261">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujące właściwość do indeksu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2261">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-2262">
            <c>IEnumerable&lt;wyrażenie&gt; </c> (<c>IEnumerable (o wyrażenie)</c> w języku Visual Basic) zawiera argumenty, które będą używane do indeksowania właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2262">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2263">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący uzyskiwania dostępu do właściwości indeksowanych w obiekcie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2263">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2264">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2264">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2265">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący element członkowski należy do obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2265">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span>
          </span>
          <span data-ttu-id="0a691-2266">Może to być wartość null dla statycznych elementów członkowskich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2266">This can be null for static members.</span>
          </span>
        </param>
        <param name="member">
          <span data-ttu-id="0a691-2267">
            <see cref="T:System.Reflection.MemberInfo" /> Opisujący pola lub właściwości, aby można było uzyskać dostęp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2267">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2268">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący uzyskiwania dostępu do pola lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2268">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2269">
            <see cref="T:System.Linq.Expressions.MemberExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2269">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2270">Ta metoda może służyć do tworzenia <xref:System.Linq.Expressions.MemberExpression> reprezentujący uzyskiwania dostępu do pola lub właściwości, w zależności od typu `member`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2270">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="0a691-2271">Jeśli `member` jest typu <xref:System.Reflection.FieldInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Field%2A> do utworzenia <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2271">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="0a691-2272">Jeśli `member` jest typu <xref:System.Reflection.PropertyInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Property%2A> do utworzenia <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2272">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2273">
            <paramref name="member" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2273">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2274">
            <paramref name="member" /> nie reprezentować pole lub właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2274">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-2275">Typ wyniku wyrażenia try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2275">The result type of the try expression.</span>
          </span>
          <span data-ttu-id="0a691-2276">Jeśli wartość null, bodh i wszystkich programów obsługi muszą mieć taki sam typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2276">If null, bodh and all handlers must have identical type.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="0a691-2277">Treść bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2277">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="0a691-2278">Treść bloku finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2278">The body of the finally block.</span>
          </span>
          <span data-ttu-id="0a691-2279">Należy przekazać wartość null, jeśli blok try ma nie koniec bloku skojarzonych z nim.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2279">Pass null if the try block has no finally block associated with it.</span>
          </span>
        </param>
        <param name="fault">
          <span data-ttu-id="0a691-2280">Treść bloku błędów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2280">The body of the fault block.</span>
          </span>
          <span data-ttu-id="0a691-2281">Należy przekazać wartość null, jeśli blok try ma nie bloku błędów skojarzonych z nim.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2281">Pass null if the try block has no fault block associated with it.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="0a691-2282">Kolekcja <see cref="T:System.Linq.Expressions.CatchBlock" />s reprezentujący instrukcji catch ma zostać skojarzony z bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2282">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2283">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z określonych elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2283">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2284">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2284">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2285">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> przez wywołanie metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2285">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <span data-ttu-id="0a691-2286">
            <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2286">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span>
          </span>
        </param>
        <param name="operand">
          <span data-ttu-id="0a691-2287">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2287">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-2288">
            <see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2288">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2289">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument przez wywołanie metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2289">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2290">
            <see cref="T:System.Linq.Expressions.UnaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2290">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2291">`unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> ta metoda wywołuje metodę fabryki.</span><span class="sxs-lookup"><span data-stu-id="0a691-2291">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="0a691-2292">Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2292">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="0a691-2293">`type`Parametru jest ignorowana, jeśli nie ma zastosowania do metody fabryki, która jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="0a691-2293">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2294">
            <paramref name="operand" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2294">
              <paramref name="operand" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2295">
            <paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2295">
              <paramref name="unaryType" /> does not correspond to a unary expression node.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <span data-ttu-id="0a691-2296">
            <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2296">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span>
          </span>
        </param>
        <param name="operand">
          <span data-ttu-id="0a691-2297">
            <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2297">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-2298">
            <see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2298">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2299">
            <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2299">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2300">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument i wdrażanie — metoda, przez wywołanie metody fabryki odpowiednie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2300">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2301">
            <see cref="T:System.Linq.Expressions.UnaryExpression" /> Który wynikiem wywołania metody odpowiednie fabryki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2301">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2302">`unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> ta metoda wywołuje metodę fabryki.</span><span class="sxs-lookup"><span data-stu-id="0a691-2302">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="0a691-2303">Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2303">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="0a691-2304">`type` i `method` parametry są ignorowane, jeśli nie mają zastosowania do metody fabryki, która jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="0a691-2304">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2305">
            <paramref name="operand" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2305">
              <paramref name="operand" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2306">
            <paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2306">
              <paramref name="unaryType" /> does not correspond to a unary expression node.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2307">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich elementu członkowskiego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2307">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="0a691-2308">
            <see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2308">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="0a691-2309">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2309">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2310">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich pola lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2310">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2311">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2311">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2312">`member` Parametru musi reprezentować pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="0a691-2312">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2313">
            <paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2313">
              <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2314">
            <paramref name="member" /> nie reprezentować pole lub właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2314">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="0a691-2315">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2315">-or-</span>
          </span>
          <span data-ttu-id="0a691-2316">
            <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2316">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="0a691-2317">
            <see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2317">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="0a691-2318">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2318">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2319">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich pola lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2319">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2320">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2320">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2321">`member` Parametru musi reprezentować pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="0a691-2321">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2322">
            <paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2322">
              <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2323">
            <paramref name="member" /> nie reprezentować pole lub właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2323">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="0a691-2324">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2324">-or-</span>
          </span>
          <span data-ttu-id="0a691-2325">
            <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2325">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="0a691-2326">
            <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2326">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="0a691-2327">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2327">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2328">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich elementu członkowskiego, który jest dostępny za pomocą metody dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2328">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2329">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2329">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2330">
            <paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2330">
              <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2331">
            <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2331">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="0a691-2332">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2332">-or-</span>
          </span>
          <span data-ttu-id="0a691-2333">
            <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu właściwości używane przez metodę który <paramref name="propertyAccessor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2333">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="0a691-2334">
            <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2334">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="0a691-2335">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2335">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2336">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania Cykliczne elementów członkowskich elementu członkowskiego, który jest dostępny za pomocą metody dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2336">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2337">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> mający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2337">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2338">
            <paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2338">
              <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2339">
            <paramref name="propertyAccessor" /> reprezentuje metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2339">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="0a691-2340">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2340">-or-</span>
          </span>
          <span data-ttu-id="0a691-2341">
            <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu właściwości używane przez metodę który <paramref name="propertyAccessor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2341">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2342">Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwości obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2342">Represents an expression that creates a new object and initializes a property of the object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2343">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2343">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="0a691-2344">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2344">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2345">Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwości obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2345">Represents an expression that creates a new object and initializes a property of the object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2346">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2346">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2347"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2347">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2348">W poniższym przykładzie pokazano wyrażenie, które tworzy nowy obiekt i inicjuje właściwości obiektu.</span><span class="sxs-lookup"><span data-stu-id="0a691-2348">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2349">
            <paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2349">
              <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2350">
            <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu który <paramref name="newExpression" />. Wpisz reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2350">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="0a691-2351">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2351">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="0a691-2352">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2352">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2353">Tworzy <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2353">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2354">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2354">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2355"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2355">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2356">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MemberInitExpression> reprezentujący inicjowania nowego obiektu dwóch członków.</span><span class="sxs-lookup"><span data-stu-id="0a691-2356">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2357">
            <paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2357">
              <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2358">
            <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwości elementu <paramref name="bindings" /> nie reprezentuje element członkowski typu który <paramref name="newExpression" />. Wpisz reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2358">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2359">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2359">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2360">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2360">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2361">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2361">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2362">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2362">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2364">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2364">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2365"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2365">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2366">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2366">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2367">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2367">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-2368"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2368">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2369">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2369">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2370">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2370">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2371">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2371">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2372">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator modulo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2372">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2373">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2373">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2374">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2374">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2375">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2375">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2376">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2376">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2377">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2377">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2378">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2378">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2379">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2379">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2380">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2380">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2381">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2381">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2382">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2382">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2383">Typ węzła jest typu wyników operator modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2383">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="0a691-2384">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2384">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2385">Typ węzła jest typ dopuszczający wartość null, odpowiadający typowi wynik operatora modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2385">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2386">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2386">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2387">Operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2387">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2388">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2388">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2389">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2389">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2390">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2390">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2391">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2391">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2393">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2393">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2394"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2394">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2395">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2395">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2396">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2396">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-2397"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2397">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2398">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2398">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2399">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2399">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2400">Implementującej metody dla operacji jest wybierany zgodnie z następującymi regułami:</span><span class="sxs-lookup"><span data-stu-id="0a691-2400">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="0a691-2401">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2401">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-2402">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator modulo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2402">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2403">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2403">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2404">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2404">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2405">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2405">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2406">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2406">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2407">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2407">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2408">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2408">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2409">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2409">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2410">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2410">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2411">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2411">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2412">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2412">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2413">Typ węzła jest typu wyników operator modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2413">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="0a691-2414">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2414">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2415">Typ węzła jest typ dopuszczający wartość null, odpowiadający typowi wynik operatora modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2415">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2416">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2416">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2417">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2417">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2418">
            <paramref name="method" /> jest <see langword="null" /> i operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2418">
              <paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2419">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2420">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2420">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2421">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2422">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2422">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2424">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2424">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2425">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2425">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2426">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2426">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2427">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2427">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2429">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2429">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2430">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2431">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2431">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-2432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2433">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2435">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2436">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2437">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2438">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2438">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2439">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2439">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2440">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2440">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2441"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2441">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2442">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2442">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2443">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2443">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-2444"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2444">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2445">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2445">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2446">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2446">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2447">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2447">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2448">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2448">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2449">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2449">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2450">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2450">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2451">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2451">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2452">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2452">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2453">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2453">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2454">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2454">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2455">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2455">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2456">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2456">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2457">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2457">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2458">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2458">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2459">Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2459">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="0a691-2460">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2460">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2461">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-2461">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2462">Poniższy przykładowy kod przedstawia sposób tworzenia wyrażenia mnoży dwie wartości.</span><span class="sxs-lookup"><span data-stu-id="0a691-2462">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2463">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2463">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2464">Operator mnożenia nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2464">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2465">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2465">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2466">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2466">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2467">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2467">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2468">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2468">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2469">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2469">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2470">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2470">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2471"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2471">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2472">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2472">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2473">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2473">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-2474"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2474">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2475">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2475">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2476">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2476">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2477">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2477">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2478">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2478">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-2479">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2479">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2480">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2480">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2481">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2481">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2482">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2482">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2483">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2483">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2484">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2484">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2485">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2485">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2486">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2486">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2487">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2487">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2488">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2488">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2489">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2489">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2490">Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2490">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="0a691-2491">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2491">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2492">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-2492">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2493">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2493">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2494">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2494">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2495">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2495">
              <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2496">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2496">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2497">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2497">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2498">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2498">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2499">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2499">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2500">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2500">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2501">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2502">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2503">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2503">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2504">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2504">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2505">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2505">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2506">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2506">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2507">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2508">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2508">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-2509">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2509">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2510">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący przypisania mnożenie nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2510">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2511">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2511">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2512">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2513">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2513">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2514">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2514">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2515">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2515">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2516">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2516">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2517">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2517">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2518">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2518">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2519">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2519">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2520">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2520">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2521">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2521">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2522">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2522">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2523">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2524">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2524">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-2525">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2525">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2526">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2526">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2527">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2527">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2528">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczne mnożenie, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2529">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2529">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2530">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2530">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2531">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczne mnożenie, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2531">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2532">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2532">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2533">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2533">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2534"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2534">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2535">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2535">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2536">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2536">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-2537"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2537">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2538">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2538">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2539">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2539">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2540">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2540">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2541">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2541">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2542">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2542">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2543">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2543">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2544">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2544">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2545">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2545">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2546">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2546">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2547">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2547">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2548">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2548">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2549">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2549">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2550">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2550">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2551">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2551">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2552">Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2552">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="0a691-2553">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2553">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2554">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-2554">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2555">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2555">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2556">Operator mnożenia nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2556">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2557">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2557">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2558">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2558">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2559">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2559">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2560">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczne mnożenie, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2560">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2561">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2561">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2562">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2562">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2563"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2563">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2564">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2564">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2565">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2565">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-2566"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2566">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2567">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2567">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2568">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2568">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2569">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2569">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2570">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2570">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-2571">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2571">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2572">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2572">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2573">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2573">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2574">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2574">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2575">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2575">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2576">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2576">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2577">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2577">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2578">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2578">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2579">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2579">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2580">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2580">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2581">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2581">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2582">Typ węzła jest typu wyników operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-2582">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="0a691-2583">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2583">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2584">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku mnożenia wstępnie zdefiniowanego operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-2584">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2585">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2585">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2586">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2586">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2587">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2587">
              <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2588">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2588">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2589">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2589">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2590">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2590">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2591">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2591">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2592"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2592">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-2593"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2593">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2594">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2594">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2595">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="0a691-2595">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2596">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2596">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2597">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2597">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2598">Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2598">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2599">W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2599">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2600">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2600">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2601">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2601">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2602">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2602">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2603">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2603">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2604">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2604">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2605">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2605">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2606">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2606">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2607">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2607">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-2608">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2608">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2609">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2609">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2610">W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje operacji arytmetycznych negacji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2610">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2611">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2611">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2612">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2612">The unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2613">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2613">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2614">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2614">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2615">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2615">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2616">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2616">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2617"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2617">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-2618"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2618">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2619">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2619">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2620">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="0a691-2620">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2621">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2621">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2622">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2622">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2623">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2623">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-2624">Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2624">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2625">W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2625">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2626">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2626">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2627">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2627">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2628">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2628">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2629">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2629">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2630">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2630">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2631">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2631">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2632">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2632">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2633">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2633">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-2634">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2634">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2635">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2635">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2636">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2636">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2637">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2637">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2638">
            <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2638">
              <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-2639">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2639">-or-</span>
          </span>
          <span data-ttu-id="0a691-2640">
            <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2640">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2641">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2641">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2642">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2642">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2643">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2643">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2644">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2644">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2645"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2645">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-2646"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2646">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2647">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2647">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2648">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="0a691-2648">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2649">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2649">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2650">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2650">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2651">Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2651">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2652">W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2652">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2653">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2653">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2654">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2654">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2655">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2655">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2656">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2656">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2657">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2657">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2658">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2658">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2659">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2659">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2660">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2660">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-2661">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2661">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2662">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2662">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2663">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2663">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2664">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2664">The unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2665">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2665">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2666">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2666">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2667">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację negacji arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2667">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
          <span data-ttu-id="0a691-2668">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2668">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2669">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2669">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2670"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2670">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-2671"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2671">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2672">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2672">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2673">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="0a691-2673">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2674">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2674">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2675">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2675">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2676">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2676">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-2677">Jeśli `expression`. Typ jest typem zdefiniowane przez użytkownika, który definiuje Jednoargumentowy operator, minus <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2677">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2678">W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2678">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2679">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2679">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2680">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2680">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2681">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2681">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2682">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2682">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2683">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2683">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2684">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2684">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2685">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2685">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2686">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2686">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-2687">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2687">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2688">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2688">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2689">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2689">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2690">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2690">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2691">
            <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2691">
              <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-2692">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2692">-or-</span>
          </span>
          <span data-ttu-id="0a691-2693">
            <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2693">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2694">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2694">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="0a691-2695">
            <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2695">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2696">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor, który nie przyjmuje żadnych argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2696">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2697">A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2697">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2698"><xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> są puste kolekcje.</span><span class="sxs-lookup"><span data-stu-id="0a691-2698">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="0a691-2699"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość reprezentuje typ deklarujący reprezentowany przez konstruktora `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2699">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2700">
            <paramref name="constructor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2700">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2701">Konstruktor, który <paramref name="constructor" /> reprezentuje ma co najmniej jeden parametr.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2701">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-2702">A <see cref="T:System.Type" /> mający konstruktora, który nie przyjmuje żadnych argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2702">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2703">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2703">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2704">A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> ustawioną właściwość <see cref="T:System.Reflection.ConstructorInfo" /> reprezentujący konstruktor bez parametrów dla określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2704">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2705">`type` Parametru musi reprezentować typu, który ma konstruktor bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="0a691-2705">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="0a691-2706"><xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> są puste kolekcje.</span><span class="sxs-lookup"><span data-stu-id="0a691-2706">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="0a691-2707"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest równa `type`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2707">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2708">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.New%28System.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.NewExpression> reprezentujący utworzenie nowego wystąpienia obiektu słownika przez wywołanie konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="0a691-2708">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2709">
            <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2709">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2710">Typ który <paramref name="type" /> reprezentuje nie ma konstruktora bez parametrów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2710">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="0a691-2711">
            <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2711">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-2712">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2712">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2713">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2713">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2714">A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2714">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2715">`arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2715">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2716">Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2716">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="0a691-2717"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący reprezentowany przez konstruktora `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2717">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2718"><xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość ma pustą kolekcję.</span><span class="sxs-lookup"><span data-stu-id="0a691-2718">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2719">
            <paramref name="constructor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2719">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2720">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2720">-or-</span>
          </span>
          <span data-ttu-id="0a691-2721">Element <paramref name="arguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2721">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2722">
            <paramref name="arguments" /> Parametru nie zawiera taką samą liczbę elementów jak liczba parametrów konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2722">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="0a691-2723">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2723">-or-</span>
          </span>
          <span data-ttu-id="0a691-2724">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2724">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="0a691-2725">
            <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2725">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-2726">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2726">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2727">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2727">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2728">A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2728">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2729">`arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2729">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2730">Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2730">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="0a691-2731"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący reprezentowany przez konstruktora `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2731">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2732"><xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość ma pustą kolekcję.</span><span class="sxs-lookup"><span data-stu-id="0a691-2732">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2733">
            <paramref name="constructor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2733">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2734">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2734">-or-</span>
          </span>
          <span data-ttu-id="0a691-2735">Element <paramref name="arguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2735">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2736">Długość <paramref name="arguments" /> jest zgodna z liczbą parametrów dla konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2736">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="0a691-2737">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2737">-or-</span>
          </span>
          <span data-ttu-id="0a691-2738">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2738">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="0a691-2739">
            <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2739">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-2740">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2740">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <param name="members">
          <span data-ttu-id="0a691-2741">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2741">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2742">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2742">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
          <span data-ttu-id="0a691-2743">Elementy członkowskie, które uzyskują dostęp do pola zainicjowany konstruktor został określony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2743">The members that access the constructor initialized fields are specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2744">A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2744">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2745">`arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2745">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2746">Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2746">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="0a691-2747">Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2747">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="0a691-2748">Jeśli `members` nie jest `null`, musi mieć taką samą liczbę elementów jako `arguments` i nie może być każdy element `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2748">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="0a691-2749">Każdy element `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia na typ deklarujący reprezentowany przez konstruktora `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2749">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2750">Jeśli termin reprezentuje właściwością, musi mieć właściwość `get` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="0a691-2750">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="0a691-2751">Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego który `members` reprezentuje element.</span><span class="sxs-lookup"><span data-stu-id="0a691-2751">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="0a691-2752"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora który `constructor` reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="0a691-2752">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2753">
            <paramref name="constructor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2753">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2754">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2754">-or-</span>
          </span>
          <span data-ttu-id="0a691-2755">Element <paramref name="arguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2755">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2756">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2756">-or-</span>
          </span>
          <span data-ttu-id="0a691-2757">Element <paramref name="members" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2757">An element of <paramref name="members" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2758">
            <paramref name="arguments" /> Parametru nie zawiera taką samą liczbę elementów jak liczba parametrów konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2758">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="0a691-2759">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2759">-or-</span>
          </span>
          <span data-ttu-id="0a691-2760">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2760">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="0a691-2761">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2761">-or-</span>
          </span>
          <span data-ttu-id="0a691-2762">
            <paramref name="members" /> Parametru nie ma taką samą liczbę elementów jako <paramref name="arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2762">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span>
          </span>
          <span data-ttu-id="0a691-2763">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2763">-or-</span>
          </span>
          <span data-ttu-id="0a691-2764">Element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość, która reprezentuje typ, który nie jest możliwa do przypisania do typu elementu członkowskiego reprezentowanego przez odpowiedni element <paramref name="members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2764">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="0a691-2765">
            <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2765">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-2766">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2766">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <param name="members">
          <span data-ttu-id="0a691-2767">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2767">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2768">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określony Konstruktor z określonymi argumentami.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2768">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
          <span data-ttu-id="0a691-2769">Elementy członkowskie, które uzyskują dostęp do pola zainicjowany konstruktor są określone jako tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2769">The members that access the constructor initialized fields are specified as an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2770">A <see cref="T:System.Linq.Expressions.NewExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2770">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2771">`arguments` Parametr muszą zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora reprezentowany przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2771">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2772">Jeśli `arguments` jest `null`, jest on uznawany za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2772">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="0a691-2773">Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> jest pustej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2773">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="0a691-2774">Jeśli `members` nie jest `null`, musi mieć taką samą liczbę elementów jako `arguments` i nie może być każdy element `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2774">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="0a691-2775">Każdy element `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia na typ deklarujący reprezentowany przez konstruktora `constructor`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2775">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="0a691-2776">Jeśli termin reprezentuje właściwość, właściwość musi być może pobrać wartości pola skojarzone.</span><span class="sxs-lookup"><span data-stu-id="0a691-2776">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="0a691-2777">Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego który `members` reprezentuje element.</span><span class="sxs-lookup"><span data-stu-id="0a691-2777">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="0a691-2778"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora który `constructor` reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="0a691-2778">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2779">
            <paramref name="constructor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2779">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2780">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2780">-or-</span>
          </span>
          <span data-ttu-id="0a691-2781">Element <paramref name="arguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2781">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2782">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2782">-or-</span>
          </span>
          <span data-ttu-id="0a691-2783">Element <paramref name="members" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2783">An element of <paramref name="members" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2784">
            <paramref name="arguments" /> Parametru nie zawiera taką samą liczbę elementów jak liczba parametrów konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2784">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="0a691-2785">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2785">-or-</span>
          </span>
          <span data-ttu-id="0a691-2786">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="arguments" /> nie można przypisać do typu odpowiadającego mu parametru konstruktora który <paramref name="constructor" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2786">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="0a691-2787">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2787">-or-</span>
          </span>
          <span data-ttu-id="0a691-2788">
            <paramref name="members" /> Parametru nie ma taką samą liczbę elementów jako <paramref name="arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2788">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span>
          </span>
          <span data-ttu-id="0a691-2789">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2789">-or-</span>
          </span>
          <span data-ttu-id="0a691-2790">Element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość, która reprezentuje typ, który nie jest możliwa do przypisania do typu elementu członkowskiego reprezentowanego przez odpowiedni element <paramref name="members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2790">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2791">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicę, która ma określony rangę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2791">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-2792">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2792">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="bounds">
          <span data-ttu-id="0a691-2793">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2793">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2794">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicę, która ma określony rangę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2794">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2795">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2795">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2796"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której pozycję jest równa długości `bounds` i o typie elementu `type`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2796">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="0a691-2797"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi przedstawiać typ całkowity.</span><span class="sxs-lookup"><span data-stu-id="0a691-2797">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2798">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy ciągów, które ma pozycję 2.</span><span class="sxs-lookup"><span data-stu-id="0a691-2798">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2799">
            <paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2799">
              <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2800">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2800">-or-</span>
          </span>
          <span data-ttu-id="0a691-2801">Element <paramref name="bounds" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2801">An element of <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2802">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="bounds" /> nie reprezentuje typ całkowity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2802">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-2803">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2803">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="bounds">
          <span data-ttu-id="0a691-2804">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2804">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2805">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicę, która ma określony rangę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2805">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2806">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2806">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2807"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której pozycję jest równa długości `bounds` i o typie elementu `type`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2807">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="0a691-2808"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi przedstawiać typ całkowity.</span><span class="sxs-lookup"><span data-stu-id="0a691-2808">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2809">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy ciągów, które ma pozycję 2.</span><span class="sxs-lookup"><span data-stu-id="0a691-2809">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2810">
            <paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2810">
              <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2811">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2811">-or-</span>
          </span>
          <span data-ttu-id="0a691-2812">Element <paramref name="bounds" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2812">An element of <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2813">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="bounds" /> nie reprezentuje typ całkowity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2813">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2814">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenia tablicą jednowymiarową i inicjowania go z listy elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2814">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-2815">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2815">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2816">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2816">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2817">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenia tablicą jednowymiarową i inicjowania go z listy elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2817">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2818">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2818">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2819"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typu, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jest *cytowaną*.</span><span class="sxs-lookup"><span data-stu-id="0a691-2819">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-2820">Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2820">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-2821">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2821">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-2822">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2822">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="0a691-2823"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablica której pozycję to 1, którego typ elementu `type`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2823">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2824">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy jednowymiarowej tablicy ciągów, które jest inicjowany z listy wyrażeń ciągu.</span><span class="sxs-lookup"><span data-stu-id="0a691-2824">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2825">
            <paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2825">
              <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2826">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2826">-or-</span>
          </span>
          <span data-ttu-id="0a691-2827">Element <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2827">An element of <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2828">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwa do przypisania do typu który <paramref name="type" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2828">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-2829">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2829">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="0a691-2830">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2830">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2831">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenia tablicą jednowymiarową i inicjowania go z listy elementów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2831">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2832">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2832">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2833"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typu, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jest *cytowaną*.</span><span class="sxs-lookup"><span data-stu-id="0a691-2833">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a691-2834">Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2834">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="0a691-2835">Zamykający oznacza, że element jest ujęte w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2835">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="0a691-2836">Wynikowa węzeł jest <xref:System.Linq.Expressions.UnaryExpression> których <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2836">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="0a691-2837"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablica której pozycję to 1, którego typ elementu `type`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2837">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2838">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, które reprezentuje tworzenie tablicy jednowymiarowej tablicy ciągów, które jest inicjowany z listy wyrażeń ciągu.</span><span class="sxs-lookup"><span data-stu-id="0a691-2838">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2839">
            <paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2839">
              <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-2840">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2840">-or-</span>
          </span>
          <span data-ttu-id="0a691-2841">Element <paramref name="initializers" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2841">An element of <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2842">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwa do przypisania do typu <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2842">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2843">Pobiera typ węzła <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2843">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a691-2844">Jeden z <see cref="T:System.Linq.Expressions.ExpressionType" /> wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2844">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2845"><xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość zawiera opis wyspecjalizowanego <xref:System.Linq.Expressions.Expression> niż tylko jego typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="0a691-2845">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="0a691-2846">Na przykład <xref:System.Linq.Expressions.BinaryExpression> może służyć do reprezentowania różne rodzaje wyrażenia binarne, takie jak "większe niż" operacja lub operacji dzielenia.</span><span class="sxs-lookup"><span data-stu-id="0a691-2846">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="0a691-2847"><xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość czy opisano te wyrażenia binarne jako <xref:System.Linq.Expressions.ExpressionType.Divide> i <xref:System.Linq.Expressions.ExpressionType.GreaterThan>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="0a691-2847">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="0a691-2848">Typ CLR statyczny wyrażenia który <xref:System.Linq.Expressions.Expression> reprezentuje obiekt jest reprezentowana przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0a691-2848">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2849">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2849">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2850">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2850">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2851">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2851">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2852">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2852">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2853"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2853">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-2854"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2854">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2855">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2855">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2856">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2856">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2857">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2857">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2858">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2858">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2859">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który określa jednoargumentowy not operator <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2859">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2860">W przeciwnym razie, jeśli `expression`. Typ typu liczbowego lub typu Boolean, metoda wykonawcze jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2860">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2861">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2861">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2862">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2862">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2863">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2863">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2864">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2864">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2865">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2865">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2866">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2866">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2867">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2867">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2868">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2868">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-2869">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2869">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2870">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2870">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-2871">W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje logicznych nie operacji.</span><span class="sxs-lookup"><span data-stu-id="0a691-2871">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2872">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2872">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2873">Jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2873">The unary not operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2874">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2874">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2875">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2875">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2876">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2876">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
          <span data-ttu-id="0a691-2877">Można określić implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2877">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2878">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2878">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2879"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2879">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-2880"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2880">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2881">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2881">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2882">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2882">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2883">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2883">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2884">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2884">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2885">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2885">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-2886">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który określa jednoargumentowy not operator <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2886">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2887">W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2887">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2888">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2888">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2889">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2889">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2890">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2890">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2891">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2891">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2892">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2892">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2893">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2893">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2894">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2894">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2895">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-2895">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-2896">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2896">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2897">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2897">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2898">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2898">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2899">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2899">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2900">
            <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2900">
              <paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-2901">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2901">-or-</span>
          </span>
          <span data-ttu-id="0a691-2902">
            <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2902">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2903">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2903">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2904">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2904">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2905">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2905">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2906">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2906">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2907">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2907">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2908">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2908">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2909"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2909">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2910">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> jest właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2910">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="0a691-2911">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2911">Otherwise, it is `false`.</span></span> <span data-ttu-id="0a691-2912"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2912">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="0a691-2913"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2913">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2914">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2914">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2915">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2915">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2916">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2916">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2917">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2917">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2918">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2918">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2919">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2919">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2920">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2920">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2921">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2921">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2922">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2922">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2923">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="0a691-2923">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="0a691-2924">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2924">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2925">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2925">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-2926">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2926">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2927">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2927">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2928">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2928">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-2929">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2929">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2930">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2930">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2931">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2931">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2932">Operator nierówności nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2932">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2933">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2933">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2934">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2934">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="0a691-2935">
            <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2935">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2936">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2936">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2937">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2937">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2938">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2938">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2939">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2939">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2940"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2940">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2941">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2941">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="0a691-2942">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2942">Otherwise, they are both `false`.</span></span> <span data-ttu-id="0a691-2943"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2943">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2944">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2944">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2945">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2945">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2946">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2946">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2947">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2947">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2948">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2948">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2949">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2949">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2950">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2950">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2951">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2951">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2952">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2952">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2953">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2953">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2954">Jeśli są spełnione następujące dwa warunki, węzeł jest unosiło; Ponadto typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2954">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="0a691-2955">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2955">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2956">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2956">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="0a691-2957">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2957">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2958">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2958">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2959">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-2959">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="0a691-2960">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2960">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2961">Typ węzła jest nullable <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2961">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-2962">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2962">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-2963">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2963">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-2964">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator nierówności dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2964">
              <paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2965">Zwraca wyrażenie odpowiadające te dopełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2965">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2966">
            <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2966">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2967">Zwraca wyrażenie odpowiadające te dopełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2967">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2968">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2968">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-2969">
            <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2969">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-2970">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2970">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2971">Zwraca wyrażenie odpowiadające te dopełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2971">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2972">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2972">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-2973">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2973">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-2974">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2974">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-2975">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2975">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-2976">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2976">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-2977">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-2977">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-2978">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2978">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-2979"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2979">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-2980">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2980">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-2981">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2981">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-2982"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2982">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-2983">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-2983">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-2984">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-2984">Implementing Method</span></span>  
 <span data-ttu-id="0a691-2985">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-2985">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-2986">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2986">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2987">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-2987">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-2988">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-2988">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-2989">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2989">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2990">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2990">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-2991">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-2991">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-2992">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-2992">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-2993">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-2993">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-2994">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-2994">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-2995">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-2995">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-2996">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-2996">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-2997">Typ węzła jest typ wyniku predefiniowanych bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-2997">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="0a691-2998">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-2998">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-2999">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-2999">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3000">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentuje logicznej operacji lub.</span><span class="sxs-lookup"><span data-stu-id="0a691-3000">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3001">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3001">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3002">Bitowe <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3002">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3003">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3003">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3004">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3004">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3005">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3005">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3006">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3006">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3007">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3007">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3008">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3008">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3009"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3009">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3010">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3010">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3011">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3011">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3012"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3012">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3013">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3013">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3014">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3014">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3015">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3015">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3016">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3016">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3017">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3017">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3018">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub Boolean, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3018">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3019">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3019">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3020">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3020">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3021">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3021">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3022">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3022">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3023">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3023">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3024">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3024">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3025">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3025">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3026">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3026">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3027">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3027">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3028">Typ węzła jest typ wyniku predefiniowanych bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3028">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="0a691-3029">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3029">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3030">Typ węzła jest typ dopuszczający wartość null, odpowiednio do typu wyniku predefiniowanych bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3030">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3031">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3031">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3032">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3032">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3033">
            <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3033">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3034">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3034">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3035">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3035">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3036">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3036">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3037">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3037">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3038">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3038">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3039">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3039">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3040">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3040">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3041">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3041">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3042">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3042">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3043">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3043">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3044">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3044">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3045">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3045">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3046">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3046">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-3047">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3047">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3048">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przypisania OR.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3048">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3049">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3049">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3050">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="OR" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy operatora daje w wyniku <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3050">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3051">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3051">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3052">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3052">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3053">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="OR" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3053">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3054">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3054">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3055">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3055">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3056"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3056">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3057">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3057">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3058">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3058">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3059"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3059">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3060">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3060">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3061">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3061">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3062">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3062">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3063">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3063">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="0a691-3064">Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0a691-3064">The conditional `OR` operator cannot be overloaded in C# or [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span></span> <span data-ttu-id="0a691-3065">Jednak warunkowe `OR` operator jest oceniane przy użyciu operatora testu koniunkcji `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3065">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="0a691-3066">W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3066">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="0a691-3067">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3067">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3068">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3068">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3069">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3069">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3070">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3070">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3071">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3071">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3072">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3072">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3073">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3073">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3074">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3074">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3075">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3075">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3076">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="0a691-3076">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="0a691-3077">Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3077">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3078">Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3078">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="0a691-3079">Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3079">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3080">Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3080">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3081">Poniższy przykładowy kod przedstawia sposób utworzyć wyrażenie reprezentuje logicznych `OR` operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3081">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3082">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3082">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3083">Bitowe <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3083">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-3084">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3084">-or-</span>
          </span>
          <span data-ttu-id="0a691-3085">
            <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3085">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3086">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3086">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3087">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3087">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3088">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3088">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3089">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowego <see langword="OR" /> operacja, która ocenia drugi argument tylko wtedy, gdy pierwszy argument operacji daje w wyniku <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3089">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3090">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3090">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3091">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3091">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3092"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3092">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3093">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3093">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3094">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3094">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3095"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3095">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3096">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3096">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3097">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3097">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3098">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3098">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3099">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3099">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-3100">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads-bitowe `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3100">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="0a691-3101">Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0a691-3101">The conditional `OR` operator cannot be overloaded in C# or [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span></span> <span data-ttu-id="0a691-3102">Jednak warunkowe `OR` operator jest oceniane przy użyciu operatora testu koniunkcji `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3102">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="0a691-3103">W związku z tym zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3103">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="0a691-3104">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy Boolean, implementującej metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3104">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3105">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3105">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3106">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3106">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3107">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3107">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3108">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3108">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3109">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3109">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3110">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null, a odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3110">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3111">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3111">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3112">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3112">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3113">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="0a691-3113">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="0a691-3114">Jeśli `left`. Typ i `right`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3114">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3115">Typ węzła jest typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3115">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="0a691-3116">Jeśli `left`. Typ i `right`. Typ dopuszczają wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3116">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3117">Typ węzła jest typ dopuszczający wartość null, umożliwiająca typu wyników wstępnie zdefiniowanych warunkowego `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="0a691-3117">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3118">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3118">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3119">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3119">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3120">
            <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3120">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-3121">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3121">-or-</span>
          </span>
          <span data-ttu-id="0a691-3122">
            <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3122">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3123">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3123">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-3124">Typ parametr lub zmienna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3124">The type of the parameter or variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3125">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3125">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3126">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła o określonej nazwie i typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3126">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-3127">Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.MethodCallExpression> obiekt, który wyświetla wartość <xref:System.Linq.Expressions.ParameterExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0a691-3127">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-3128">Typ parametr lub zmienna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3128">The type of the parameter or variable.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-3129">Nazwa parametr lub zmienna, używana do debugowania lub drukowania tylko do celów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3129">The name of the parameter or variable, used for debugging or printing purpose only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3130">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3130">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3131">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> i <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3131">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3132">
            <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3132">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3133">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne dekrementacja 1 oryginalne wyrażenie wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3133">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3134">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3134">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3135">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne dekrementacja 1 oryginalne wyrażenie wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3135">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3136">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3136">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3137">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3137">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3138">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3138">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3139">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne dekrementacja 1 oryginalne wyrażenie wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3139">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3140">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3140">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3141">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne przyrostu 1 oryginalne wyrażenie wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3142">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3142">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3143">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne przyrostu 1 oryginalne wyrażenie wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3143">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3144">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3144">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3145">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3145">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3146">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3146">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3147">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie następuje przez kolejne przyrostu 1 oryginalne wyrażenie wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3147">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3148">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3148">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3149">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podniesienia liczby do potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3149">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3150">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3150">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3151">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3151">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3152">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podniesienia liczby do potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3153">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3153">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3154">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3154">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3155"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3155">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3156">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3156">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3157">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3157">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3158"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3158">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3159">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3159">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3160">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3160">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3161">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3161">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3162">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator wykładniczy <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3162">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3163">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-3163">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3164">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3164">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="0a691-3165">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3165">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3166">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3166">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3167">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3167">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3168">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3168">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3169">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3169">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3170">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3170">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3171">Operator wykładniczy nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3171">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-3172">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3172">-or-</span>
          </span>
          <span data-ttu-id="0a691-3173">
            <paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3173">
              <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3174">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3174">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3175">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3175">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3176">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3176">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3177">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podniesienia liczby do potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3178">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3178">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3179">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3179">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3180"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3180">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3181">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3181">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3182">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3182">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3183"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3183">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3184">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3184">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3185">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3185">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3186">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3186">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3187">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3187">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3188">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator wykładniczy <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3188">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3189">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-3189">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3190">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3190">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="0a691-3191">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3191">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3192">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3192">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3193">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3193">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3194">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3194">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3195">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3195">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3196">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3196">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3197">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3197">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3198">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator wykładniczy dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3198">
              <paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-3199">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3199">-or-</span>
          </span>
          <span data-ttu-id="0a691-3200">
            <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3200">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3201">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3202">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3202">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3203">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3204">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3204">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3205">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3205">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3206">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3206">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3207">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3207">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3208">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3208">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3209">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3209">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3210">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3210">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3211">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3211">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3212">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3212">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3213">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3213">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-3214">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3214">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3215">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wyniku wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3215">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3216">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3216">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3217">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia 1 i przypisuje wynik z powrotem do wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3217">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3218">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3218">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3219">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia 1 i przypisuje wynik z powrotem do wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3219">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3220">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3220">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3221">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3221">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3222">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3222">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3223">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia 1 i przypisuje wynik z powrotem do wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3223">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3224">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3224">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3225">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zwiększa wyrażenie 1 i przypisuje wynik wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3226">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3226">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3227">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zwiększa wyrażenie 1 i przypisuje wynik wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3227">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3228">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3228">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3229">
            <see cref="T:System.Linq.Expressions.Expression" /> Mogła zastosować operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3229">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3230">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3230">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3231">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zwiększa wyrażenie 1 i przypisuje wynik wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3231">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3232">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenia wynikowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3232">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3233">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3233">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3234">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3234">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="0a691-3235">Może to być wartość null dla właściwości statycznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3235">This can be null for static properties.</span>
          </span>
        </param>
        <param name="propertyAccessor">
          <span data-ttu-id="0a691-3236">
            <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3236">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3237">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości, za pomocą metody dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3237">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3238">A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący dostęp do właściwości <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3238">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3239"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-3239">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="0a691-3240">Jeśli metoda reprezentowany przez `propertyAccessor` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3240">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3241">
            <paramref name="propertyAccessor" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3241">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-3242">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3242">-or-</span>
          </span>
          <span data-ttu-id="0a691-3243">Metoda który <paramref name="propertyAccessor" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3243">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3244">
            <paramref name="expression" />. Typ nie jest możliwa do przypisania do typ deklarujący metodzie reprezentowany przez <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3244">
              <paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span>
          </span>
          <span data-ttu-id="0a691-3245">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3245">-or-</span>
          </span>
          <span data-ttu-id="0a691-3246">Metoda który <paramref name="propertyAccessor" /> reprezentuje nie jest metodą dostępu właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3246">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3247">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3247">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="0a691-3248">Może to być wartość null dla właściwości statycznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3248">This can be null for static properties.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="0a691-3249">
            <see cref="T:System.Reflection.PropertyInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3249">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3250">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3250">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3251">A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3251">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3252"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-3252">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="0a691-3253">Jeśli właściwość reprezentowany przez `property` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3253">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3254">
            <paramref name="property" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3254">
              <paramref name="property" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="0a691-3255">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3255">-or-</span>
          </span>
          <span data-ttu-id="0a691-3256">Właściwość który <paramref name="property" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3256">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3257">
            <paramref name="expression" />. Typ nie jest możliwa do przypisania do właściwości typ deklarujący który <paramref name="property" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3257">
              <paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3258">
            <see cref="T:System.Linq.Expressions.Expression" /> Których <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość o nazwie <c>propertyName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3258">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <c>propertyName</c>.</span>
          </span>
          <span data-ttu-id="0a691-3259">Może to być <see langword="null" /> właściwości statycznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3259">This can be <see langword="null" /> for static properties.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="0a691-3260">Nazwa właściwości, aby można było uzyskać dostęp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3260">The name of a property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3261">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3261">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3262">A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący właściwość oznaczona <paramref name="propertyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3262">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3263"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Reflection.PropertyInfo> reprezentujący właściwość oznaczona `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3263">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="0a691-3264">Ta metoda szuka `expression`. Typ i jego typów podstawowych dla właściwości o nazwie `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3264">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="0a691-3265">Właściwości publiczne są preferowane względem niepublicznych właściwości.</span><span class="sxs-lookup"><span data-stu-id="0a691-3265">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="0a691-3266">Jeśli zostanie znaleziony zgodnej właściwości, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> reprezentujący tej właściwości, aby <xref:System.Linq.Expressions.Expression.Property%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a691-3266">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3267">Poniższy przykład pokazuje, jak utworzyć wyrażenie reprezentuje podczas uzyskiwania dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="0a691-3267">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3268">
            <paramref name="expression" /> lub <paramref name="propertyName" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3268">
              <paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3269">Nie ma właściwości o nazwie <paramref name="propertyName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3269">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-3270">Obiekt, do którego należy właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3270">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="0a691-3271">Jeśli właściwość jest statyczna/udostępnionego, może mieć wartości null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3271">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="0a691-3272">
            <see cref="T:System.Reflection.PropertyInfo" /> Reprezentujący właściwość do indeksu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3272">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-3273">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które są używane do indeksowania właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3273">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3274">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostępu do właściwości indeksowanej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3274">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3275">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3275">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-3276">Obiekt, do którego należy właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3276">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="0a691-3277">Jeśli właściwość jest statyczna/udostępnionego, może mieć wartości null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3277">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="0a691-3278">
            <see cref="T:System.Reflection.PropertyInfo" /> Reprezentujący właściwość do indeksu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3278">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-3279">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które są używane do indeksowania właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3279">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3280">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostępu do właściwości indeksowanej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3280">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3281">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3281">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="0a691-3282">Obiekt, do którego należy właściwość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3282">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="0a691-3283">Jeśli właściwość jest statyczna/udostępnionego, może mieć wartości null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3283">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="0a691-3284">Nazwa indeksatora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3284">The name of the indexer.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="0a691-3285">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które są używane do indeksowania właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3285">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3286">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostępu do właściwości indeksowanej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3286">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3287">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3287">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3288">Obiekt zawierający właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3288">The containing object of the property.</span>
          </span>
          <span data-ttu-id="0a691-3289">Może to być wartość null dla właściwości statycznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3289">This can be null for static properties.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3290">
            <see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierający właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3290">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="0a691-3291">Właściwość, aby można było uzyskać dostęp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3291">The property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3292">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> podczas uzyskiwania dostępu do właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3292">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3293">Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3293">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3294">
            <see cref="T:System.Linq.Expressions.Expression" /> Których <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość lub pole o nazwie <c>propertyOrFieldName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3294">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <c>propertyOrFieldName</c>.</span>
          </span>
          <span data-ttu-id="0a691-3295">Może to być wartość null dla statycznych elementów członkowskich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3295">This can be null for static members.</span>
          </span>
        </param>
        <param name="propertyOrFieldName">
          <span data-ttu-id="0a691-3296">Nazwa właściwości lub pola, aby można było uzyskać dostęp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3296">The name of a property or field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3297">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący podczas uzyskiwania dostępu do właściwości lub pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3297">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3298">A <see cref="T:System.Linq.Expressions.MemberExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawioną właściwość <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawioną właściwość <see cref="T:System.Reflection.PropertyInfo" /> lub <see cref="T:System.Reflection.FieldInfo" /> reprezentujący właściwości lub pola wskazywane przez <paramref name="propertyOrFieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3298">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3299"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> lub <xref:System.Reflection.FieldInfo.FieldType%2A> właściwości <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo>odpowiednio reprezentujący właściwość lub pole wskazywane przez `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3299">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="0a691-3300">Ta metoda szuka `expression`. Typ i jego typów podstawowych właściwości lub pola o nazwie `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3300">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="0a691-3301">Właściwości publiczne i pola są preferowane względem niepublicznych właściwości i pola.</span><span class="sxs-lookup"><span data-stu-id="0a691-3301">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="0a691-3302">Ponadto właściwości są preferowane względem pola.</span><span class="sxs-lookup"><span data-stu-id="0a691-3302">Also, properties are given preference over fields.</span></span> <span data-ttu-id="0a691-3303">Jeśli zostanie znaleziony zgodnej właściwości ani pola, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo> reprezentujący tej właściwości lub pola do <xref:System.Linq.Expressions.Expression.Property%2A> lub <xref:System.Linq.Expressions.Expression.Field%2A>odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="0a691-3303">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3304">Poniższy przykład przedstawia sposób tworzenia wyrażenie reprezentuje podczas uzyskiwania dostępu do właściwości lub pola.</span><span class="sxs-lookup"><span data-stu-id="0a691-3304">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3305">
            <paramref name="expression" /> lub <paramref name="propertyOrFieldName" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3305">
              <paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3306">Nie właściwości lub pola o nazwie <paramref name="propertyOrFieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3306">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3307">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3307">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3308">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie, które ma stałej wartości typu <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3308">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3309">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3309">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3310"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> reprezentuje utworzony typ <xref:System.Linq.Expressions.Expression%601>, gdzie argument typu jest reprezentowana przez typ `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-3310">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="0a691-3311"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3311">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="0a691-3312">Zarówno <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3312">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3313">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3313">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3314">Ogranicza ten węzeł do wyrażenia prostsze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3314">Reduces this node to a simpler expression.</span>
          </span>
          <span data-ttu-id="0a691-3315">Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3315">If CanReduce returns true, this should return a valid expression.</span>
          </span>
          <span data-ttu-id="0a691-3316">Ta metoda może zwracać innego węzła, które muszą zostać zmniejszona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3316">This method can return another node which itself must be reduced.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3317">Zmniejszenie wyrażenie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3317">The reduced expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3318">Ogranicza ten węzeł do wyrażenia prostsze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3318">Reduces this node to a simpler expression.</span>
          </span>
          <span data-ttu-id="0a691-3319">Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3319">If CanReduce returns true, this should return a valid expression.</span>
          </span>
          <span data-ttu-id="0a691-3320">Ta metoda może zwracać innego węzła, które muszą zostać zmniejszona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3320">This method can return another node which itself must be reduced.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3321">Zmniejszenie wyrażenie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3321">The reduced expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3322">W odróżnieniu od Zmniejsz ta metoda sprawdza, czy węzeł zmniejszenie spełnia niektórych invariants.</span><span class="sxs-lookup"><span data-stu-id="0a691-3322">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3323">Zmniejsza wyrażenie z typem węzła znane (który nie jest węzłem rozszerzenia) lub po prostu zwraca wyrażenie, jeśli jest on już znanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3323">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3324">Zmniejszenie wyrażenie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3324">The reduced expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3325">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3326">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3327">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości odwołań.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3327">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3328">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3328">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3329">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3329">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3330">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3331">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie nierówności odwołań.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3331">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3332">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3332">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3333">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3333">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3334">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3334">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3335">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3335">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-3336">Nowe <see cref="T:System.Type" /> wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3336">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3337">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątek z danym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3337">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3338">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie Wystąpił wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3338">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3339">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3339">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-3340">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3340">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3341">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3341">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3342">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />i wartość null do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3342">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-3343">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3343">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0a691-3344">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3344">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3345">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3345">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
          <span data-ttu-id="0a691-3346">Można określić wartość przekazana do etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3346">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3347">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3347">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-3348">W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.Expression.Return%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3348">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-3349">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3349">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3350">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3350">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3351">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return z określonym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3351">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3352">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />i wartość null do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3352">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="0a691-3353">
            <see cref="T:System.Linq.Expressions.LabelTarget" /> Który <see cref="T:System.Linq.Expressions.GotoExpression" /> spowoduje przejście do.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3353">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0a691-3354">Wartość, która zostanie przekazany do skojarzone etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3354">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3355">
            <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3355">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3356">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return z określonym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3356">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span>
          </span>
          <span data-ttu-id="0a691-3357">Można określić wartość przekazana do etykiety na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3357">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3358">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> ustawioną właściwość <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawioną właściwość <paramref name="type" />, i <paramref name="value" /> do przekazania do etykiety docelowej na przejście.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3358">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3359">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w prawo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3359">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3360">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3360">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3361">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3361">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3362">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w prawo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3362">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3364">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3364">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3365"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3365">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3366">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3366">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3367">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3367">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3368"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3368">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3369">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3369">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3370">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3370">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3371">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3371">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3372">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w prawo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3372">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3373">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3373">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3374">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3374">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3375">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3375">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3376">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3376">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3377">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3377">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3378">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3378">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3379">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3379">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3380">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3380">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3381">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3381">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3382">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3382">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3383">Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="0a691-3383">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="0a691-3384">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3384">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3385">Typ węzła jest typ dopuszczający wartość null, która odnosi się do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="0a691-3385">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3386">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3386">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3387">Operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3387">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3388">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3388">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3389">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3389">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3390">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3390">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3391">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji przesunięcia w prawo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3391">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3393">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3393">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3394"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3394">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3395">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3395">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3396">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3396">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3397"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3397">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3398">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3398">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3399">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3399">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3400">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3400">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3401">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3401">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-3402">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator przesunięcia w prawo <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3402">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3403">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości zerowe) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3403">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3404">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3404">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3405">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3405">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3406">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3406">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3407">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3407">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3408">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3408">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3409">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3409">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3410">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3410">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3411">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3411">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3412">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3412">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3413">Typ węzła jest typu wyników wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="0a691-3413">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="0a691-3414">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3414">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3415">Typ węzła jest typ dopuszczający wartość null, która odnosi się do typu wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="0a691-3415">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3416">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3416">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3417">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3417">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3418">
            <paramref name="method" /> jest <see langword="null" /> i operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3418">
              <paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3419">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3420">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3420">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3421">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3422">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3422">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3424">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3424">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3425">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3425">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3426">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3426">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3427">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3427">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3429">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3429">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3430">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3431">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3431">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-3432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3433">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowe przypisania przesunięcia w prawo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3435">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3435">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="0a691-3436">Kolekcja <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3436">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3437">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3437">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3438">Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3438">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="0a691-3439">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3439">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3440">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3440">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3441">Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3441">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3442">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3442">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3443">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3443">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3444">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3444">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3445">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3445">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3446">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3446">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3447">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3447">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3448"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3448">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3449">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3449">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3450">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3450">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3451"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3451">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3452">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3452">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3453">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3453">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3454">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3454">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3455">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3455">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3456">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3456">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3457">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3457">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3458">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3458">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3459">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3459">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3460">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3460">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3461">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3461">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3462">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3462">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3463">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3463">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3464">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3464">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3465">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3465">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3466">Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-3466">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="0a691-3467">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3467">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3468">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-3468">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3469">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie odejmuje argumentu z pierwszym argumentem.</span><span class="sxs-lookup"><span data-stu-id="0a691-3469">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3470">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3470">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3471">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3471">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3472">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3472">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3473">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3473">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3474">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3474">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3475">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3475">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3476">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3476">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3477">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3477">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3478"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3478">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3479">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3479">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3480">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3480">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3481"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3481">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3482">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3482">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3483">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3483">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3484">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3484">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3485">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3485">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-3486">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3486">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3487">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3487">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3488">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3488">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3489">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3489">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3490">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3490">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3491">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3491">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3492">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3492">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3493">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3493">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3494">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3494">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3495">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3495">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3496">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3496">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3497">Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-3497">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="0a691-3498">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3498">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3499">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-3499">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3500">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3500">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3501">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3501">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3502">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator odejmowania dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3502">
              <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3503">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3503">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3504">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3505">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3505">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3506">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3506">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3508">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3509">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3509">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3510">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3510">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3511">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3511">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3512">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3512">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3513">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3513">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3514">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3514">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3515">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3515">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-3516">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3516">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3517">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3519">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3519">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3520">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3521">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3521">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3522">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3522">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3524">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3525">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3525">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3526">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3526">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3527">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3527">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3528">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3528">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3529">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3529">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3530">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3530">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3531">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3531">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="0a691-3532">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3532">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3533">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3535">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3535">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3536">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3536">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3537">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3537">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3538">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3538">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3539">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3539">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3540">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3540">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3541"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3541">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3542">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3542">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3543">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3543">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3544"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3544">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3545">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3545">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3546">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3546">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3547">Następujące reguły określają wybranej implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3547">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3548">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3548">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3549">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3549">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3550">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3550">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3551">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3551">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3552">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3552">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3553">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3553">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3554">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3554">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3555">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3555">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3556">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3556">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3557">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3557">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3558">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3558">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3559">Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-3559">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="0a691-3560">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3560">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3561">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-3561">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3562">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3562">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3563">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3563">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="0a691-3564">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3564">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="0a691-3565">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3565">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3566">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3566">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3567">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, która ma sprawdzanie przepełnienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3567">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3568">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3568">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3569">Powstałe w ten sposób <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3569">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="0a691-3570"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3570">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3571">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3571">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3572">W przeciwnym razie są one `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3572">Otherwise, they are `false`.</span></span> <span data-ttu-id="0a691-3573"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Jest właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3573">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="0a691-3574">Poniżej opisano implementującej metody typu węzła i czy węzeł jest unosiło.</span><span class="sxs-lookup"><span data-stu-id="0a691-3574">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3575">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3575">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3576">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3576">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="0a691-3577">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje dwa argumenty jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3577">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-3578">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który overloads operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3578">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3579">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typy liczbowe, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3579">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3580">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3580">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3581">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3581">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3582">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentu implementującej metody, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3582">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3583">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3583">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3584">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3584">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3585">`left`. Typ i `right`. Typ są oba typy wartości, których co najmniej jedna nie dopuszcza wartości null i odpowiednie typy wartości null są takie same odpowiednie typy argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3585">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3586">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3586">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3587">Jeśli metoda wykonawcze jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3587">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3588">Jeśli `left`. Typ i `right`. Typ są dopuszcza wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3588">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3589">Typ węzła jest typu wyników operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="0a691-3589">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="0a691-3590">Jeśli `left`. Typ i `right`. Typ są wartości null, jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3590">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="0a691-3591">Typ węzła jest typ dopuszczający wartość null, umożliwiająca operator odejmowania wstępnie zdefiniowanego typu wyników.</span><span class="sxs-lookup"><span data-stu-id="0a691-3591">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3592">
            <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3592">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3593">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3593">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3594">
            <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator odejmowania dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3594">
              <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3595">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3595">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="0a691-3596">Wartość do sprawdzenia przed każdym przypadku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3596">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="0a691-3597">Zestaw przypadków dla tego wyrażenia switch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3597">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3598">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję bez przypadek domyślny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3598">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3599">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3599">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3600">Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć ten sam typ, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3600">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="0a691-3601">Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawne `break` instrukcja, która oznacza, że nie Brak niejawnego poniżej od jednej etykiety case do innej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3601">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="0a691-3602">Jeśli `switchValue` nie pasuje do żadnego przypadków, nie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="0a691-3602">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3603">W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje przełącznik instrukcję bez przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="0a691-3603">The following example demonstrates how to create an expression that represents a swtich statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="0a691-3604">Wartość do sprawdzenia przed każdym przypadku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3604">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="0a691-3605">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3605">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="0a691-3606">Zestaw przypadków dla tego wyrażenia switch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3606">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3607">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3607">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3608">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3608">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3609">Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć ten sam typ, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3609">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="0a691-3610">Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawne `break` instrukcja, która oznacza, że nie Brak niejawnego poniżej od jednej etykiety case do innej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3610">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="0a691-3611">Jeśli `switchValue` nie pasuje do żadnego przypadkach przypadek domyślny reprezentowany przez `defaultBody` jest uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="0a691-3611">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3612">W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje przełącznik instrukcję, która ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="0a691-3612">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="0a691-3613">Wartość do sprawdzenia przed każdym przypadku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3613">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="0a691-3614">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3614">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="0a691-3615">Metoda porównania równości do użycia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3615">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="0a691-3616">Zestaw przypadków dla tego wyrażenia switch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3616">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3617">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3617">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3618">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3618">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="0a691-3619">Wartość do sprawdzenia przed każdym przypadku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3619">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="0a691-3620">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3620">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="0a691-3621">Metoda porównania równości do użycia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3621">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="0a691-3622">Zestaw przypadków dla tego wyrażenia switch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3622">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3623">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3623">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3624">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3624">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-3625">Typ wyniku przełącznika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3625">The result type of the switch.</span>
          </span>
        </param>
        <param name="switchValue">
          <span data-ttu-id="0a691-3626">Wartość do sprawdzenia przed każdym przypadku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3626">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="0a691-3627">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3627">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="0a691-3628">Metoda porównania równości do użycia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3628">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="0a691-3629">Zestaw przypadków dla tego wyrażenia switch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3629">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3630">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3630">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3631">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3631">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-3632">Typ wyniku przełącznika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3632">The result type of the switch.</span>
          </span>
        </param>
        <param name="switchValue">
          <span data-ttu-id="0a691-3633">Wartość do sprawdzenia przed każdym przypadku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3633">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="0a691-3634">Wynik przełącznika Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3634">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="0a691-3635">Metoda porównania równości do użycia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3635">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="0a691-3636">Zestaw przypadków dla tego wyrażenia switch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3636">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3637">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji, która ma przypadek domyślny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3637">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case..</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3638">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3638">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3639">Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektu do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3639">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-3640">Treść wielkość liter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3640">The body of the case.</span>
          </span>
        </param>
        <param name="testValues">
          <span data-ttu-id="0a691-3641">Wartości testowe sprawy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3641">The test values of the case.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3642">Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektu do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3642">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3643">Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3643">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3644">Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć ten sam typ, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3644">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="0a691-3645">Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawne `break` instrukcja, która oznacza, że nie Brak niejawnego poniżej od jednej etykiety case do innej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3645">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3646">W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentuje przełącznik instrukcję, która ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="0a691-3646">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-3647">Treść wielkość liter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3647">The body of the case.</span>
          </span>
        </param>
        <param name="testValues">
          <span data-ttu-id="0a691-3648">Wartości testowe sprawy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3648">The test values of the case.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3649">Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3649">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3650">Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3650">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3651">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3651">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0a691-3652">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3652">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3653">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3653">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3654">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3654">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0a691-3655">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3655">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="0a691-3656">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3656">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3657">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3657">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3658">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ustawiono wartość określonej właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3658">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0a691-3659">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3659">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="0a691-3660">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3660">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <param name="languageVendor">
          <span data-ttu-id="0a691-3661">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3661">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3662">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3662">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3663">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ustawiono wartość określonej właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3663">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="0a691-3664">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3664">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="0a691-3665">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3665">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <param name="languageVendor">
          <span data-ttu-id="0a691-3666">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3666">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span>
          </span>
        </param>
        <param name="documentType">
          <span data-ttu-id="0a691-3667">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> równa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3668">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3668">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3669">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> mający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ustawiono wartość określonej właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3669">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3670">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Zgłaszanie wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3670">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0a691-3671">
            <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3671">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3672">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Zgłaszanie wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3672">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3673">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3673">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-3674">Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiekt, który używa <xref:System.Linq.Expressions.Expression.Throw%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3674">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0a691-3675">
            <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3675">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3676">Nowe <see cref="T:System.Type" /> wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3676">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3677">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zgłaszanie wyjątków z danym typem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3677">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3678">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3678">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3679">Zwraca tekstową reprezentację wartości <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3679">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3680">Tekstową reprezentację wartości <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3680">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-3681">Treść bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3681">The body of the try block.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="0a691-3682">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch ma zostać skojarzony z bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3682">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3683">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolnej liczby catch instrukcji i ani błędów ani bloku finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3683">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3684">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3684">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-3685">W poniższym przykładzie pokazano, jak utworzyć <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch.</span><span class="sxs-lookup"><span data-stu-id="0a691-3685">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-3686">Treść bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3686">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="0a691-3687">Treść bloku finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3687">The body of the finally block.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="0a691-3688">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch ma zostać skojarzony z bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3688">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3689">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolną liczbę instrukcji catch i bloku finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3689">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3690">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3690">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a691-3691">W poniższym przykładzie pokazano, jak utworzyć <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch i finally instrukcji.</span><span class="sxs-lookup"><span data-stu-id="0a691-3691">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-3692">Treść bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3692">The body of the try block.</span>
          </span>
        </param>
        <param name="fault">
          <span data-ttu-id="0a691-3693">Treść bloku błędów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3693">The body of the fault block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3694">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z blokiem błąd i nie catch instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3694">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3695">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3695">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="0a691-3696">Treść bloku try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3696">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="0a691-3697">Treść bloku finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3697">The body of the finally block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3698">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> bloku try przy reprezentujący koniec instrukcji catch bloku i nie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3698">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3699">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3699">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="0a691-3700">Tablica obiektów typu, które określają argumentów typu dla typu delegata elementu System.Action.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3700">An array of Type objects that specify the type arguments for the System.Action delegate type.</span>
          </span>
        </param>
        <param name="actionType">
          <span data-ttu-id="0a691-3701">Po powrocie z tej metody zawiera typu ogólnego delegat elementu System.Action, która przyjmuje argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3701">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="0a691-3702">Zawiera wartość null, jeśli nie delegat elementu System.Action ogólny zgodny <c>typeArgs</c>. Ten parametr jest przekazywany jako niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3702">Contains null if there is no generic System.Action delegate that matches the <c>typeArgs</c>.This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3703">Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje typu ogólnego delegat elementu System.Action, która przyjmuje argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3703">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3704">wartość true, jeśli ogólny typ delegata elementu System.Action został utworzony dla konkretnego <paramref name="typeArgs" />false w przeciwnym razie wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3704">true if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="0a691-3705">Tablica obiektów typu, które określają argumentów typu dla typu delegata System.Func.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3705">An array of Type objects that specify the type arguments for the System.Func delegate type.</span>
          </span>
        </param>
        <param name="funcType">
          <span data-ttu-id="0a691-3706">Gdy metoda zwróci wartość, zawiera ogólny typ delegata System.Func, który ma argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3706">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="0a691-3707">Zawiera wartość null, jeśli nie Delegat ogólny System.Func, który odpowiada <c>typeArgs</c>. Ten parametr jest przekazywany jako niezainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3707">Contains null if there is no generic System.Func delegate that matches the <c>typeArgs</c>.This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3708">Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólny typ delegata System.Func, który zawiera argumenty określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3708">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="0a691-3709">Ostatni argument typu określa typ zwracany delegata utworzony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3709">The last type argument specifies the return type of the created delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3710">wartość true, jeśli utworzono ogólny typ delegata System.Func określonych <paramref name="typeArgs" />false w przeciwnym razie wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3710">true if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3711">Pobiera typ statyczny wyrażenia, który to <see cref="T:System.Linq.Expressions.Expression" /> reprezentuje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3711">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a691-3712">
            <see cref="T:System.Type" /> Reprezentujący typ statyczny wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3712">The <see cref="T:System.Type" /> that represents the static type of the expression.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3713"><xref:System.Linq.Expressions.Expression.NodeType%2A> Jest typ węzła drzewa wyrażenia, podczas gdy <xref:System.Linq.Expressions.Expression.Type%2A> reprezentuje wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR) typ statyczny wyrażenia, który reprezentuje węzeł.</span><span class="sxs-lookup"><span data-stu-id="0a691-3713">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="0a691-3714">Na przykład dwa węzły o różnych typach węzłów może mieć takie same <xref:System.Linq.Expressions.Expression.Type%2A>, jak pokazano w poniższym przykładzie kodu.</span><span class="sxs-lookup"><span data-stu-id="0a691-3714">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3715">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3715">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3716">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3716">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3717">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawnego odwołania lub konwersji pakującej gdzie <see langword="null" /> jest dostarczany w razie niepowodzenia konwersji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3717">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3718">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3718">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3719"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3719">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="0a691-3720"><xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> właściwości są `false`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3720">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3721">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.UnaryExpression> reprezentujący konwersji odwołania wyrażenia liczby całkowitej wartości null na typ integer wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3721">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3722">
            <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3722">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3723">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="T:System.Linq.Expressions.Expression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3723">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3724">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3724">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3725">Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> który porównuje tożsamości typu run-time.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3725">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3726">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> i dla których <see cref="T:System.Linq.Expressions.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione na określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3726">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3727">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3727">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3728">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3728">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3729">Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3729">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3730">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> i dla których <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione na określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3730">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3731"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> reprezentuje <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="0a691-3731">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a691-3732">W poniższym przykładzie pokazano sposób użycia <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.TypeBinaryExpression> reprezentujący typ testu wartość ciągu przed <xref:System.Int32> typu.</span><span class="sxs-lookup"><span data-stu-id="0a691-3732">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3733">
            <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3733">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3734">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jednoargumentowe plus operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3734">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3735">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3735">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3736">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jednoargumentowe plus operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3736">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3737">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3737">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3738"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3738">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-3739"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3739">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3740">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3740">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3741">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="0a691-3741">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3742">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3742">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3743">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3743">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3744">Jeśli `expression`. Typ jest zdefiniowany przez użytkownika typu, który definiuje jednoargumentowe plus operatora, <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3744">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3745">W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3745">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3746">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3746">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3747">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3747">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3748">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3748">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3749">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3749">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3750">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3750">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3751">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3751">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3752">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3752">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3753">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-3753">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-3754">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3754">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3755">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3755">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3756">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3756">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3757">Jednoargumentowe plus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3757">The unary plus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3758">
            <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3758">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="0a691-3759">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3759">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3760">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jednoargumentowe plus operacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3760">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3761">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> mający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> właściwości mają określone wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3761">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3762"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość powstałe w ten sposób <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3762">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="0a691-3763"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3763">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="0a691-3764">Jeśli węzeł została wyjęta, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3764">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="0a691-3765">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="0a691-3765">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="0a691-3766">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="0a691-3766">Implementing Method</span></span>  
 <span data-ttu-id="0a691-3767">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="0a691-3767">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="0a691-3768">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metodę, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3768">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="0a691-3769">Jeśli `expression`. Typ jest zdefiniowany przez użytkownika typu, który definiuje jednoargumentowe plus operatora, <xref:System.Reflection.MethodInfo> reprezentujący, który jest operator implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3769">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3770">W przeciwnym razie, jeśli `expression`. Typ jest typ liczbowy, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="0a691-3770">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="0a691-3771">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="0a691-3771">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="0a691-3772">Jeśli metoda implementujący nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="0a691-3772">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="0a691-3773">Jeśli `expression`. Typ można przypisać do typu argumentu implementującej metody, nie została wyjęta węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3773">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="0a691-3774">Typ węzła jest zwracany typ metody implementującej.</span><span class="sxs-lookup"><span data-stu-id="0a691-3774">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="0a691-3775">Jeśli spełnione są następujące dwa warunki, zniesienia węzeł i typ węzła jest typ dopuszczający wartość null, umożliwiająca zwracany typ implementujący metody:</span><span class="sxs-lookup"><span data-stu-id="0a691-3775">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="0a691-3776">`expression`. Typ jest typem wartości null, a odpowiedni typ niedopuszczający wartości null jest taki sam, jak typ argumentu implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="0a691-3776">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="0a691-3777">Zwracany typ metody implementującej to typ niedopuszczający wartości null.</span><span class="sxs-lookup"><span data-stu-id="0a691-3777">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="0a691-3778">Jeśli metoda wykonawcze jest `null`, jest typ węzła `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="0a691-3778">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="0a691-3779">Jeśli `expression`. Typ wartości null, węzeł nie została wyjęta.</span><span class="sxs-lookup"><span data-stu-id="0a691-3779">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="0a691-3780">W przeciwnym razie jest unosiło węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3780">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a691-3781">
            <paramref name="expression" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3781">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a691-3782">
            <paramref name="method" /> nie jest <see langword="null" /> , a także metoda reprezentuje zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie jeden argument.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3782">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a691-3783">
            <paramref name="method" /> jest <see langword="null" /> i jednoargumentowe plus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3783">
              <paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="0a691-3784">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3784">-or-</span>
          </span>
          <span data-ttu-id="0a691-3785">
            <paramref name="expression" />. Typ (lub odpowiedniego typu wartości null, jeśli jest to typ wartości null) nie jest można przypisać do typu argumentu metody reprezentowany przez <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3785">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="0a691-3786">
            <see cref="T:System.Linq.Expressions.Expression" /> Do unbox —.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3786">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0a691-3787">Nowe <see cref="T:System.Type" /> wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3787">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3788">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Rozpakowywanie jawnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3788">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3789">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3789">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a691-3790">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3790">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-3791">Typ parametr lub zmienna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3791">The type of the parameter or variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3792">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3792">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3793">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła o określonej nazwie i typ</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3793">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="0a691-3794">Typ parametr lub zmienna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3794">The type of the parameter or variable.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="0a691-3795">Nazwa parametru lub zmiennej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3795">The name of the parameter or variable.</span>
          </span>
          <span data-ttu-id="0a691-3796">Ta nazwa jest używana do debugowania lub drukowania tylko do celów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3796">This name is used for debugging or printing purpose only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3797">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3797">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3798">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzła o określonej nazwie i typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3798">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">
          <span data-ttu-id="0a691-3799">Wystąpienie <see cref="T:System.Func`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3799">An instance of <see cref="T:System.Func`2" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a691-3800">Zmniejsza węzeł, a następnie wywołuje delegata dla gości na zmniejszenie wyrażenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3800">Reduces the node and then calls the visitor delegate on the reduced expression.</span>
          </span>
          <span data-ttu-id="0a691-3801">Metoda zgłasza wyjątek, jeśli węzeł nie jest możliwe do zredukowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3801">The method throws an exception if the node is not reducible.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a691-3802">Wyrażenie odwiedzana lub wyrażenie, które powinny zostać użyte w drzewie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a691-3802">The expression being visited, or an expression which should replace it in the tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a691-3803">Przesłonić tę metodę w celu zapewnienia logiki przeprowadzenie elementów podrzędnych węzła.</span><span class="sxs-lookup"><span data-stu-id="0a691-3803">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="0a691-3804">Typowa implementacja wywołuje obiekt odwiedzający. Odwiedź na wszystkich jego elementów podrzędnych i czy je zmienić, powinien zwrócić nową kopię samego zmodyfikowanego podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="0a691-3804">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
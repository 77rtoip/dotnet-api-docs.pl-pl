<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e0971025e96a96fe9dd01fb4474fa27260c00135" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69118369" /></Metadata><TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Dostarcza klasę bazową, z której są wyprowadzane klasy, które reprezentują węzły drzewa wyrażeń. Zawiera <see langword="static" /> również metody fabryki<see langword="Shared" /> (w Visual Basic) do tworzenia różnych typów węzłów. Jest <see langword="abstract" /> to Klasa.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie bloku. Wyrażenie bloku składa się z <xref:System.Linq.Expressions.MethodCallExpression> dwóch obiektów i <xref:System.Linq.Expressions.ConstantExpression> jednego obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="nodeType"><see cref="T:System.Linq.Expressions.ExpressionType" /> Do ustawienia jako typ węzła.</param>
        <param name="type">W <see cref="P:System.Linq.Expressions.Expression.Type" /> tym<see cref="T:System.Linq.Expressions.Expression" />celu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany z konstruktorów w klasach pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="visitor">Odwiedzający, aby odwiedzić ten węzeł przy użyciu.</param>
        <summary>Wysyła do określonej metody odwiedzin dla tego typu węzła. Na przykład program <see cref="T:System.Linq.Expressions.MethodCallExpression" /> <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />wywołuje.</summary>
        <returns>Wynik odwiedzania tego węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta domyślna implementacja dla <xref:System.Linq.Expressions.ExpressionType.Extension> węzłów wywołuje <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>. Zastąp tę metodę, aby wywołać bardziej konkretną metodę na pochodnej klasie <xref:System.Linq.Expressions.ExpressionVisitor> odwiedzającej klasy. Jednak nadal powinien obsługiwać nieznanych odwiedzających przez wywoływanie <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetycznego, która nie ma sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetycznego, która nie ma sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub reprezentuje`right` Typzdefiniowanyprzezużytkownika,któryprzeciążaoperatordodawania,reprezentujeon<xref:System.Reflection.MethodInfo> metodę implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora dodawania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora dodawania.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które dodaje dwie liczby całkowite.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetycznego, która nie ma sprawdzania przepełnienia. Można określić metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> , który ma <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i, oraz właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator dodawania, to <xref:System.Reflection.MethodInfo> oznacza metodę implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora dodawania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora dodawania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która nie ma sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która nie ma sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które dodaje wartość do zmiennej liczb całkowitych, a następnie przypisuje wynik operacji do zmiennej.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która nie ma sprawdzania przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która nie ma sprawdzania przepełnienia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która jest w trakcie sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która jest w trakcie sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która jest w trakcie sprawdzania przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania, która jest w trakcie sprawdzania przepełnienia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetycznego, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetycznego, która ma sprawdzanie przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub reprezentuje`right` Typzdefiniowanyprzezużytkownika,któryprzeciążaoperatordodawania,reprezentujeon<xref:System.Reflection.MethodInfo> metodę implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora dodawania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora dodawania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetycznego, która ma sprawdzanie przepełnienia. Można określić metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> , który ma <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i, oraz właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Metoda implementująca dla operacji jest wybierana na podstawie następujących reguł:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator dodawania, to <xref:System.Reflection.MethodInfo> oznacza metodę implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora dodawania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora dodawania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="AND" /> .</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="AND" /> .</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.And" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `AND` reprezentuje<xref:System.Reflection.MethodInfo>Typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy całkowite lub logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora bitowego `AND` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `AND` operatora bitowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące logiczną i operację na dwóch wartościach logicznych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora bitowego <see langword="AND" /> dla elementu. <paramref name="left" /> Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="AND" /> . Można określić metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.And" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Metoda implementująca dla operacji jest wybierana na podstawie następujących reguł:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` `AND` reprezentuje<xref:System.Reflection.MethodInfo> typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza metodę implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy całkowite lub logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora bitowego `AND` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `AND` operatora bitowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operatorem <see langword="AND" /> bitowym nie jest zdefiniowany <paramref name="left" />dla. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację warunkową <see langword="AND" /> , która oblicza drugi operand tylko wtedy, gdy <see langword="true" />pierwszy operand zwraca wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację warunkową <see langword="AND" /> , która oblicza drugi operand tylko wtedy, gdy <see langword="true" />pierwszy operand zwraca wartość.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `AND` reprezentuje<xref:System.Reflection.MethodInfo>Typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza, że metoda jest metodą implementującą. `right`  
  
    > [!NOTE]
    >  Operator warunkowy `AND` nie może być przeciążony w C# ani Visual Basic. Operator warunkowy `AND` jest jednak oceniany przy użyciu operatora bitowego `AND` . W ten sposób zdefiniowane przez użytkownika Przeciążenie operatora bitowego `AND` może być metodą implementującą dla tego typu węzła.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   `left`. Wpisz i `right`. Typ jest tym samym typem Boolean.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora warunkowego `AND` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ dopuszcza wartość null, węzeł zostanie zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `AND` operatora warunkowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wykonuje operacje logiczne i dla dwóch operandów tylko wtedy, gdy pierwszy operand jest wynikiem `true`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora bitowego <see langword="AND" /> dla elementu. <paramref name="left" /> Wpisz i <paramref name="right" />. Wprowadź.  
  
—lub— 
 <paramref name="left" />. Wpisz i <paramref name="right" />. Typ nie jest tym samym typem Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację warunkową <see langword="AND" /> , która oblicza drugi operand tylko wtedy, gdy pierwszy operand jest rozpoznawany jako true. Można określić metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Metoda implementująca dla operacji jest wybierana na podstawie następujących reguł:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` `AND` reprezentuje<xref:System.Reflection.MethodInfo> typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza metodę implementującą.  
  
    > [!NOTE]
    >  Operator warunkowy `AND` nie może być przeciążony w C# ani Visual Basic. Operator warunkowy `AND` jest jednak oceniany przy użyciu operatora bitowego `AND` . W ten sposób zdefiniowane przez użytkownika Przeciążenie operatora bitowego `AND` może być metodą implementującą dla tego typu węzła.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   `left`. Wpisz i `right`. Typ jest tym samym typem Boolean.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora warunkowego `AND` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ dopuszcza wartość null, węzeł zostanie zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `AND` operatora warunkowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operatorem <see langword="AND" /> bitowym nie jest zdefiniowany <paramref name="left" />dla. Wpisz i <paramref name="right" />. Wprowadź.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" /> i <paramref name="left" />. Wpisz i <paramref name="right" />. Typ nie jest tym samym typem Boolean.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową i przypisanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową i przypisanie.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową i przypisanie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową i przypisanie.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy dostęp <see cref="T:System.Linq.Expressions.IndexExpression" /> do tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Wyrażenie reprezentujące tablicę wielowymiarową.</param>
        <param name="indexes"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierające wyrażenia służące do indeksowania tablicy.</param>
        <summary>Tworzy dostęp <see cref="T:System.Linq.Expressions.IndexExpression" /> do tablicy wielowymiarowej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie reprezentujące tablicę można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metody lub przez <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zmienić wartość elementu w tablicy wielowymiarowej przy użyciu `ArrayAccess` metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Wyrażenie reprezentujące tablicę do indeksowania.</param>
        <param name="indexes">Tablica zawierająca wyrażenia używane do indeksowania tablicy.</param>
        <summary>Tworzy dostęp <see cref="T:System.Linq.Expressions.IndexExpression" /> do tablicy.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie reprezentujące tablicę można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metody lub przez <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
 W przypadku tablic wielowymiarowych Użyj <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zmienić wartość elementu tablicy przy użyciu `ArrayAccess` metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący zastosowanie operatora indeksu tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> ustawić właściwość równą.</param>
        <param name="indexes">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy do tablicy rangi więcej niż jeden.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element elementu `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równą <xref:System.Int32>wartość. Właściwość musi reprezentować typ tablicy, której ranga pasuje do liczby elementów w `indexes`. <xref:System.Linq.Expressions.Expression.Type%2A> `array`  
  
 Jeśli ranga `array`. Typ to 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>. Właściwość jest ustawiona na `array` , <xref:System.Linq.Expressions.BinaryExpression.Right%2A> a`indexes`właściwość jest ustawiana na pojedynczy element. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość<xref:System.Linq.Expressions.BinaryExpression>reprezentujetyp elementu .`array` Wprowadź.  
  
 Jeśli ranga `array`. Typ jest więcej niż jeden, ta metoda zwraca <xref:System.Linq.Expressions.MethodCallExpression>. <xref:System.Reflection.MethodInfo> `Get` <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na, która opisuje metodę wystąpienia publicznego `array`dla typu reprezentowanego przez właściwość. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metody w celu <xref:System.Linq.Expressions.MethodCallExpression> utworzenia, która reprezentuje indeksowanie do dwuwymiarowej tablicy.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />lub <paramref name="indexes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />. Typ nie reprezentuje typu tablicy.  
  
—lub— 
Ranga <paramref name="array" />. Typ nie jest zgodny z liczbą elementów w <paramref name="indexes" />.  
  
—lub— 
Właściwość co najmniej jednego <paramref name="indexes" /> elementu nie reprezentuje <see cref="T:System.Int32" /> typu. <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="index">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zastosowanie operatora indeksu tablicy do tablicy rangi 1.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`musi reprezentować indeks typu <xref:System.Int32>.  
  
 <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> Właściwośćbędąca`false`wynikiem `null`jest równa i jestustawianana.<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość jest równa `array`typowi elementu. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />lub <paramref name="index" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />. Typ nie reprezentuje typu tablicy.  
  
—lub— 
 <paramref name="array" />. Typ reprezentuje typ tablicy, której ranga nie jest 1.  
  
—lub— 
 <paramref name="index" />. Typ nie reprezentuje <see cref="T:System.Int32" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Tablica <see cref="T:System.Linq.Expressions.Expression" /> wystąpień — indeksy dla operacji indeksu tablicy.</param>
        <param name="indexes">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy do tablicy wielowymiarowej.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element elementu `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równą <xref:System.Int32>wartość. Właściwość musi reprezentować typ tablicy, której ranga pasuje do liczby elementów w `indexes`. <xref:System.Linq.Expressions.Expression.Type%2A> `array`  
  
 Jeśli ranga `array`. Typ to 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>. Właściwość jest ustawiona na `array` , <xref:System.Linq.Expressions.BinaryExpression.Right%2A> a`indexes`właściwość jest ustawiana na pojedynczy element. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość<xref:System.Linq.Expressions.BinaryExpression>reprezentujetyp elementu .`array` Wprowadź.  
  
 Jeśli ranga `array`. Typ jest więcej niż jeden, ta metoda zwraca <xref:System.Linq.Expressions.MethodCallExpression>. <xref:System.Reflection.MethodInfo> `Get` <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na, która opisuje metodę wystąpienia publicznego `array`dla typu reprezentowanego przez właściwość. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metody w celu <xref:System.Linq.Expressions.MethodCallExpression> utworzenia, która reprezentuje indeksowanie do dwuwymiarowej tablicy.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />lub <paramref name="indexes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />. Typ nie reprezentuje typu tablicy.  
  
—lub— 
Ranga <paramref name="array" />. Typ nie jest zgodny z liczbą elementów w <paramref name="indexes" />.  
  
—lub— 
Właściwość co najmniej jednego <paramref name="indexes" /> elementu nie reprezentuje <see cref="T:System.Int32" /> typu. <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie służące do uzyskania długości tablicy jednowymiarowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> <paramref name="array" />Właściwość równą i Właściwość równa. <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwośćmusireprezentować`array` typ tablicy.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest równa <xref:System.Int32>. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwośćjest`null` ima`false`ustawioną wartość. <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />. Typ nie reprezentuje typu tablicy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Assign` Wyrażenie kopiuje wartość dla typów wartości i kopiuje odwołanie do typów referencyjnych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące operację przypisywania.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.MemberAssignment" /> Tworzy element reprezentujący inicjalizację elementu członkowskiego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> , aby <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawić właściwość równą.</param>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjalizację pola lub właściwości.</summary>
        <returns><see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> A, który ma równe, i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> właściwości i, ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberAssignment" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.PropertyInfo.PropertyType%2A> `member` <xref:System.Reflection.FieldInfo.FieldType%2A> Właściwość musi być możliwa do przypisania do typu reprezentowanego przez właściwość lub. `expression` <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />lub <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />nie reprezentuje pola lub właściwości.  
  
—lub— 
Właściwość reprezentowana przez <paramref name="member" /> nie <see langword="set" /> ma metody dostępu.  
  
—lub— 
 <paramref name="expression" />. Nie można przypisać typu do typu pola lub właściwości <paramref name="member" /> reprezentowanej przez.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę metody dostępu do właściwości.</param>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.MemberAssignment" /> Tworzy element reprezentujący inicjalizację elementu członkowskiego przy użyciu metody dostępu do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" /> , który <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> ma <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> <see cref="T:System.Reflection.PropertyInfo" /> <paramref name="propertyAccessor" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> , <paramref name="expression" />Właściwość ustawiona na, która reprezentuje właściwość, do której uzyskano dostęp w, i Właściwość ustawioną na. <see cref="P:System.Linq.Expressions.MemberBinding.Member" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi być możliwa do przypisania do typu reprezentowanego przez <xref:System.Reflection.PropertyInfo.PropertyType%2A> Właściwość właściwości, do której uzyskuje się `propertyAccessor`dostęp w. `expression` <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />lub <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />nie reprezentuje metody akcesora właściwości.  
  
—lub— 
Właściwość, do której <paramref name="propertyAccessor" /> uzyskuje dostęp, <see langword="set" /> nie ma metody dostępu.  
  
—lub— 
 <paramref name="expression" />. Nie można przypisać typu do typu pola lub właściwości <paramref name="member" /> reprezentowanej przez.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.BlockExpression" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.BlockExpression" /> , który zawiera podane wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.BlockExpression" /> , który zawiera podane wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie bloku. Wyrażenie bloku składa się z <xref:System.Linq.Expressions.MethodCallExpression> dwóch obiektów i <xref:System.Linq.Expressions.ConstantExpression> jednego obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający podane zmienne i wyrażenia.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak przekazać parametr do wyrażenia bloku i przetworzyć ten parametr w bloku.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający podane zmienne i wyrażenia.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dwa wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.BlockExpression" /> , który zawiera dane wyrażenia, nie ma zmiennych i ma określony typ wyniku.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.BlockExpression" /> , który zawiera dane wyrażenia, nie ma zmiennych i ma określony typ wyniku.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzecie wyrażenie w bloku.</param>
        <summary><see cref="T:System.Linq.Expressions.BlockExpression" /> Tworzy, który zawiera trzy wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający podane zmienne i wyrażenia.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający podane zmienne i wyrażenia.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzecie wyrażenie w bloku.</param>
        <param name="arg3">Czwarte wyrażenie w bloku.</param>
        <summary><see cref="T:System.Linq.Expressions.BlockExpression" /> Tworzy, który zawiera cztery wyrażenia i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzecie wyrażenie w bloku.</param>
        <param name="arg3">Czwarte wyrażenie w bloku.</param>
        <param name="arg4">Piąte wyrażenie w bloku.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający pięć wyrażeń i nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wyrażenie bloku jest wykonywane, zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy instrukcję <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentującą wartość Break.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <summary>Tworzy instrukcję <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentującą wartość Break.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> o <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> wartości równejBreak<paramref name="target" />, Właściwośćustawionanaiwartośćnulldoprzesłaniadoetykietydocelowejpoprzejściu.<see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie, które zawiera <xref:System.Linq.Expressions.LoopExpression> obiekt, który <xref:System.Linq.Expressions.Expression.Break%2A> używa metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="value">Wartość, która zostanie przeniesiona do skojarzonej etykiety po przejściu.</param>
        <summary>Tworzy instrukcję <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentującą wartość Break. Wartość przeskoczy do etykiety po przejściu można określić.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> o <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> wartościrównej<paramref name="value" /> Break, <paramref name="target" />Właściwość ustawiona na i do przesłania do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję Break o określonym typie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> o <paramref name="target" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> <paramref name="type" />wartości równej Break, WłaściwośćustawionanaiWłaściwośćustawionena.<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="value">Wartość, która zostanie przeniesiona do skojarzonej etykiety po przejściu.</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję Break o określonym typie. Wartość przeskoczy do etykiety po przejściu można określić.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> o <paramref name="target" /> <paramref name="type" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> <paramref name="value" /> wartości równej Break, Właściwośćustawionana,właściwośćustawionanaidoprzesłaniadoetykietydocelowejpoprzejściu.<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.MethodCallExpression" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">Element <see cref="T:System.Linq.Expressions.Expression" /> określający wystąpienie wywołania metody wystąpienia <see langword="null" /> ( <see langword="static" /> <see langword="Shared" /> Metoda w Visual Basic).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody, która nie przyjmuje argumentów.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby reprezentować wywołanie `static` metody (`Shared` w Visual Basic) `instance` , należy przekazać parametr `null` w przypadku wywołania tej metody.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> , właściwość `instance` musi być możliwa do przypisania do typu deklarującego metody reprezentowanej przez `method`.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.MethodCallExpression> jest pusta. <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość jest równa zwracanym typem metody reprezentowanej przez `method`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wywołuje metodę bez argumentów.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="instance" />is <see langword="null" /> i<paramref name="method" /> reprezentuje metodę wystąpienia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />. Nie można przypisać typu do typu deklarującego metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę docelową.</param>
        <param name="arguments">Kolekcja <see cref="T:System.Linq.Expressions.Expression" /> , która reprezentuje argumenty wywołań.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej (Shared w Visual Basic).</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <param name="arg0"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje pierwszy argument.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> metody (<see langword="Shared" /> w Visual Basic), która przyjmuje jeden argument.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie, które wywołuje `static` metodę (`Shared` w Visual Basic), która przyjmuje jeden argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Reprezentuje metodę <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> (w<see langword="Shared" /> Visual Basic) ,abyustawić<see cref="T:System.Reflection.MethodInfo" />Właściwość <see langword="static" /> równą.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> metody (<see langword="Shared" /> w Visual Basic), która ma argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `arguments` `method`nie `null`jest, musi mieć taką samą liczbę elementów jak liczba parametrów dla metody reprezentowanej przez. Każdy element w `arguments` nie może być `null` i musi być możliwy ** `method`do przypisania do odpowiadającego mu parametru, prawdopodobnie po utworzeniu.  
  
> [!NOTE]
>  Element zostanie umieszczony w cudzysłowie, jeśli odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`arguments`właściwość jest elementem elementu.  
  
 Właściwość <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> będąca <xref:System.Linq.Expressions.MethodCallExpression> wynikiem jest pusta, jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy `arguments`, które mogą być ujęte w cudzysłów.  
  
 Właściwość wynikowa <xref:System.Linq.Expressions.MethodCallExpression> jest równa zwracanym typem metody reprezentowanej przez `method`. <xref:System.Linq.Expressions.Expression.Type%2A> <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Właściwość jest`null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="arguments" /> nie jest równa liczbie parametrów dla metody reprezentowanej przez <paramref name="method" />.  
  
—lub— 
Co najmniej jednego elementu elementu nie można przypisać do odpowiadającego mu parametru metody reprezentowanej przez <paramref name="method" />. <paramref name="arguments" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Linq.Expressions.Expression" /> Aby ustawić<see langword="null" /> Właściwość równą (<see langword="static" /> w Visual Basic) metodę.<see langword="Shared" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <param name="arguments">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby reprezentować wywołanie `static` metody (`Shared` w Visual Basic) `instance` , należy przekazać parametr `null` w przypadku wywołania tej metody lub wywołać <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> , właściwość `instance` musi być możliwa do przypisania do typu deklarującego metody reprezentowanej przez `method`.  
  
 Jeśli `arguments` `method`nie `null`jest, musi mieć taką samą liczbę elementów jak liczba parametrów dla metody reprezentowanej przez. Każdy element w `arguments` nie może być `null` i musi być możliwy ** `method`do przypisania do odpowiadającego mu parametru, prawdopodobnie po utworzeniu.  
  
> [!NOTE]
>  Element zostanie umieszczony w cudzysłowie, jeśli odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`arguments`właściwość jest elementem elementu.  
  
 Właściwość <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> będąca <xref:System.Linq.Expressions.MethodCallExpression> wynikiem jest pusta, jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy `arguments`, które mogą być ujęte w cudzysłów.  
  
 Właściwość wynikowa <xref:System.Linq.Expressions.MethodCallExpression> jest równa zwracanym typem metody reprezentowanej przez `method`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="instance" />is <see langword="null" /> i<paramref name="method" /> reprezentuje metodę wystąpienia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />. Nie można przypisać typu do typu deklarującego metody reprezentowanej przez <paramref name="method" />.  
  
—lub— 
Liczba elementów w <paramref name="arguments" /> nie jest równa liczbie parametrów dla metody reprezentowanej przez <paramref name="method" />.  
  
—lub— 
Co najmniej jednego elementu elementu nie można przypisać do odpowiadającego mu parametru metody reprezentowanej przez <paramref name="method" />. <paramref name="arguments" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Element <see cref="T:System.Linq.Expressions.Expression" /> określający wystąpienie wywołania metody wystąpienia <see langword="null" /> ( <see langword="static" /> <see langword="Shared" /> Metoda w Visual Basic).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby reprezentować wywołanie `static` metody (`Shared` w Visual Basic) `instance` , należy przekazać parametr `null` w przypadku wywołania tej metody lub wywołać <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> , właściwość `instance` musi być możliwa do przypisania do typu deklarującego metody reprezentowanej przez `method`.  
  
 Jeśli `arguments` `method`nie `null`jest, musi mieć taką samą liczbę elementów jak liczba parametrów dla metody reprezentowanej przez. Każdy element w `arguments` nie może być `null` i musi być możliwy ** `method`do przypisania do odpowiadającego mu parametru, prawdopodobnie po utworzeniu.  
  
> [!NOTE]
>  Element zostanie umieszczony w cudzysłowie, jeśli odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`arguments`właściwość jest elementem elementu.  
  
 Właściwość <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> będąca <xref:System.Linq.Expressions.MethodCallExpression> wynikiem jest pusta, jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy `arguments`, które mogą być ujęte w cudzysłów.  
  
 Właściwość wynikowa <xref:System.Linq.Expressions.MethodCallExpression> jest równa zwracanym typem metody reprezentowanej przez `method`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="instance" />is <see langword="null" /> i<paramref name="method" /> reprezentuje metodę wystąpienia.  
  
—lub— 
 <paramref name="arguments" />nie <see langword="null" /> jest i co najmniej jeden z jego elementów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />. Nie można przypisać typu do typu deklarującego metody reprezentowanej przez <paramref name="method" />.  
  
—lub— 
Liczba elementów w <paramref name="arguments" /> nie jest równa liczbie parametrów dla metody reprezentowanej przez <paramref name="method" />.  
  
—lub— 
Co najmniej jednego elementu elementu nie można przypisać do odpowiadającego mu parametru metody reprezentowanej przez <paramref name="method" />. <paramref name="arguments" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <param name="arg0"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje pierwszy argument.</param>
        <param name="arg1"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje drugi argument.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje dwa argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Linq.Expressions.Expression" /> Określa wystąpienie dla wywołania wystąpienia. (Przekaż wartość null dla statycznej metody udostępnionej w Visual Basic).</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę docelową.</param>
        <param name="arg0"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje pierwszy argument.</param>
        <param name="arg1"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje drugi argument.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody, która przyjmuje dwa argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wywołuje metodę wystąpienia, która ma dwa argumenty.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">, <see cref="T:System.Linq.Expressions.Expression" /> Której<see cref="P:System.Linq.Expressions.Expression.Type" /> wartość właściwości będzie przeszukiwana dla określonej metody.</param>
        <param name="methodName">Nazwa metody.</param>
        <param name="typeArguments">Tablica <see cref="T:System.Type" /> obiektów, które określają parametry typu metody ogólnej. Ten argument powinien mieć wartość null, gdy methodName określa metodę nierodzajową.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, która reprezentuje argumenty metody.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody przez wywołanie odpowiedniej metody fabryki.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> , która <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> <see cref="T:System.Reflection.MethodInfo" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> Właściwość równą <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <paramref name="instance" />Właściwość równa, ustawiana na, która reprezentuje określoną metodę wystąpienia i ustawiona na <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> określone argumenty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość wynikowa <xref:System.Linq.Expressions.MethodCallExpression> jest równa zwracanym typowi metody oznaczonej przez `methodName`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" />lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma metody, której <paramref name="methodName" />nazwa jest zgodna <paramref name="typeArguments" />z parametrami typu i którego <paramref name="instance" />typy parametrów <paramref name="arguments" /> są zgodne. Typ lub jego typy podstawowe.  
  
—lub— 
Więcej niż jedna metoda, której nazwa <paramref name="methodName" />to, których parametry typu <paramref name="typeArguments" />są zgodne, <paramref name="arguments" /> a których typy parametrów są zgodne <paramref name="instance" />, znajdują się w. Typ lub jego typy podstawowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <param name="arg0"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje pierwszy argument.</param>
        <param name="arg1"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje drugi argument.</param>
        <param name="arg2"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje trzeci argument.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje trzy argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ, który zawiera określoną <see langword="static" /> metodę (<see langword="Shared" /> w Visual Basic).</param>
        <param name="methodName">Nazwa metody.</param>
        <param name="typeArguments">Tablica <see cref="T:System.Type" /> obiektów, które określają parametry typu metody ogólnej. Ten argument powinien mieć wartość null, gdy methodName określa metodę nierodzajową.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, która reprezentuje argumenty metody.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> metody (<see langword="Shared" /> w Visual Basic) przez wywołanie odpowiedniej metody fabryki.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="T:System.Reflection.MethodInfo" /> <see langword="Shared" /> <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> <see langword="static" /> Właściwość równą <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, Właściwośćustawionana,którareprezentujeokreślonąmetodę(wVisualBasic),i<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> Właściwość ustawiona do określonych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość wynikowa <xref:System.Linq.Expressions.MethodCallExpression> jest równa zwracanym typowi metody oznaczonej przez `methodName`. <xref:System.Linq.Expressions.Expression.Type%2A> <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Właściwość jest`null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma metody, której <paramref name="methodName" />nazwa jest zgodna <paramref name="typeArguments" />z parametrami typu i którego typy parametrów <paramref name="arguments" /> są zgodne, <paramref name="type" /> w lub jego typach podstawowych.  
  
—lub— 
Więcej niż jedna metoda, której nazwa <paramref name="methodName" />to, których parametry typu <paramref name="typeArguments" />są zgodne, <paramref name="arguments" /> a których typy parametrów są zgodne <paramref name="type" /> , znajdują się w lub w jego typach podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Linq.Expressions.Expression" /> Określa wystąpienie dla wywołania wystąpienia. (Przekaż wartość null dla statycznej metody udostępnionej w Visual Basic).</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę docelową.</param>
        <param name="arg0"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje pierwszy argument.</param>
        <param name="arg1"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje drugi argument.</param>
        <param name="arg2"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje trzeci argument.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody, która przyjmuje trzy argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <param name="arg0"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje pierwszy argument.</param>
        <param name="arg1"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje drugi argument.</param>
        <param name="arg2"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje trzeci argument.</param>
        <param name="arg3"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje czwarty argument.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje cztery argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ustawić właściwość równą.</param>
        <param name="arg0"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje pierwszy argument.</param>
        <param name="arg1"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje drugi argument.</param>
        <param name="arg2"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje trzeci argument.</param>
        <param name="arg3"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje czwarty argument.</param>
        <param name="arg4"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje piąty argument.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej przyjmującej pięć argumentów.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> A, który <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ma<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MethodCallExpression" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że węzeł można zmniejszyć do prostszego węzła. Jeśli zwraca wartość true, funkcja Zmniejsz () może zostać wywołana w celu utworzenia zredukowanego formularza.</summary>
        <value><see langword="true" />Jeśli węzeł można zmniejszyć; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable"><see cref="T:System.Linq.Expressions.ParameterExpression" /> Reprezentuje odwołanie<see cref="T:System.Exception" /> do obiektu przechwytywanego przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z odwołaniem do przechwyconego <see cref="T:System.Exception" /> obiektu do użycia w treści procedury obsługi.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Ta wartość zostanie<see cref="P:System.Linq.Expressions.Expression.Type" />obsłużyć. <see cref="T:System.Exception" /> <see cref="T:System.Linq.Expressions.CatchBlock" /></param>
        <param name="body">Treść instrukcji catch.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić, <xref:System.Linq.Expressions.Expression.Type%2A> <xref:System.Exception> <xref:System.Linq.Expressions.CatchBlock>aby można było przechwycić, ale nie będzie można użyć odwołania do tego obiektu w obiekcie. <xref:System.Exception>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable"><see cref="T:System.Linq.Expressions.ParameterExpression" /> Reprezentuje odwołanie<see cref="T:System.Exception" /> do obiektu przechwytywanego przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję Catch <see cref="T:System.Exception" /> z filtrem i odwołaniem do przechwyconego <see cref="T:System.Exception" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Ta wartość zostanie<see cref="P:System.Linq.Expressions.Expression.Type" />obsłużyć. <see cref="T:System.Exception" /> <see cref="T:System.Linq.Expressions.CatchBlock" /></param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję Catch <see cref="T:System.Exception" /> z filtrem, ale bez odwołania do przechwyconego <see cref="T:System.Exception" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="document"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentuje plik źródłowy.</param>
        <summary><see cref="T:System.Linq.Expressions.DebugInfoExpression" /> Tworzy do czyszczenia punkt sekwencji.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> do czyszczenia punktu sekwencji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączenia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression> Właściwośćbędąca`null` wynikiem jest i<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> maustawioną`false`wartość. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa typowi wyniku operacji łączenia. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
#### <a name="result-type"></a>Typ wyniku  
 Następujące reguły określają typ wyniku:  
  
-   Jeśli `left`. Typ reprezentuje typ dopuszczający wartość `right`null i. Typ jest niejawnie konwertowany na odpowiedni typ niedopuszczający wartości null, typ wyniku to niedopuszczający wartości null `left`. Wprowadź.  
  
-   W przeciwnym razie `right`, jeśli. Typ jest niejawnie konwertowany `left`na. Typ wynik to `left`. Wprowadź.  
  
-   W przeciwnym razie, Jeśli odpowiednik `left`nie dopuszcza wartości null. Typ jest niejawnie konwertowany `right`na. Typ wynik to `right`. Wprowadź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwośćniereprezentujetypureferencyjnego<paramref name="left" /> lub typu wartości null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" />. Wpisz i <paramref name="right" />. Typ nie jest konwertowany na siebie.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132">?? Operator (C# odwołanie)</related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączenia przy użyciu funkcji konwersji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> , który ma <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> Właściwość równą i, oraz właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression> Właściwośćbędąca`null` wynikiem jest i<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> maustawioną`false`wartość. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Method%2A>  
  
 Właściwość wynikowa <xref:System.Linq.Expressions.BinaryExpression> jest równa typowi wyniku operacji łączenia. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 Następujące reguły określają typ wyniku:  
  
-   Jeśli `left`. Typ reprezentuje typ dopuszczający wartość `right`null i. Typ jest niejawnie konwertowany na odpowiedni typ niedopuszczający wartości null, typ wyniku to niedopuszczający wartości null `left`. Wprowadź.  
  
-   W przeciwnym razie `right`, jeśli. Typ jest niejawnie konwertowany `left`na. Typ wynik to `left`. Wprowadź.  
  
-   W przeciwnym razie, Jeśli odpowiednik `left`nie dopuszcza wartości null. Typ jest niejawnie konwertowany `right`na. Typ wynik to `right`. Wprowadź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" />. Wpisz i <paramref name="right" />. Typ nie jest konwertowany na siebie.  
  
—lub— 
 <paramref name="conversion" />nie <see langword="null" /> jest i <paramref name="conversion" />. Typ jest typem delegata, który nie przyjmuje dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwośćniereprezentujetypureferencyjnego<paramref name="left" /> lub typu wartości null.  
  
—lub— 
Właściwość reprezentuje typ, którego nie można przypisać do typu parametru typu <paramref name="conversion" />delegata. <paramref name="left" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> Wprowadź.  
  
—lub— 
Właściwość nie jest równa zwracanego typu typu <paramref name="conversion" />delegata. <paramref name="right" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcję warunkową.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> ustawić właściwość równą.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ustawić właściwość równą.</param>
        <param name="ifFalse"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcję warunkową.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ConditionalExpression> <xref:System.Linq.Expressions.Expression.Type%2A> jest`ifTrue`równawłaściwości. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje instrukcję warunkową. Jeśli pierwszy argument jest obliczany `true`przez, drugi argument jest wykonywany; w przeciwnym razie trzeci argument jest wykonywany.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="test" />or <paramref name="ifTrue" /> lub <paramref name="ifFalse" /> is .<see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="test" />. Typ nie <see cref="T:System.Boolean" />jest.  
  
—lub— 
 <paramref name="ifTrue" />. Typ nie jest równy <paramref name="ifFalse" />. Wprowadź.</exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> ustawić właściwość równą.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ustawić właściwość równą.</param>
        <param name="ifFalse"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcję warunkową.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia jawne ujednolicenie typu wyniku wyrażenia warunkowego w przypadkach, w których typy `ifTrue` i `ifFalse` wyrażenia są różne. Typy obu `ifTrue` i `ifFalse` muszą mieć niejawnie przywoływane odwołanie do typu wyników. `type` Może być<xref:System.Void>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ConstantExpression" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Aby<see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> ustawić właściwość równą.</param>
        <summary><see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> Tworzy właściwość ,którama<see cref="T:System.Linq.Expressions.ConstantExpression" /> ustawioną określoną wartość.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> ma<see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ConstantExpression> jest `value`równa typowi. <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli `value` jest `null`, jest<xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Object>.  
  
 Aby przedstawić `null`, można również <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> użyć metody, za pomocą której można jawnie określić typ.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje wartość stałą.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Aby<see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="T:System.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.ConstantExpression" /> , który <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> ma właściwości <see cref="P:System.Linq.Expressions.Expression.Type" /> i ustawione na określone wartości.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> A, który <see cref="P:System.Linq.Expressions.Expression.Type" /> ma<see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.ConstantExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być przydatna do reprezentowania wartości typów dopuszczających wartość null.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje stałą typu dopuszczającego wartość null i ustawić jej wartość na `null`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />nie <see langword="null" /> jest i <paramref name="type" /> nie można jej przypisać <paramref name="value" />z typu dynamicznego.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy instrukcję <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentującą kontynuację.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <summary>Tworzy instrukcję <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentującą kontynuację.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> o <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> wartości równejContinue<paramref name="target" />, Właściwośćustawionana,awartośćnull,któramazostaćprzeniesionadoetykietydocelowejpoprzejściu.<see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie pętli, które używa <xref:System.Linq.Expressions.Expression.Continue%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję Continue o określonym typie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> o <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> wartości <see cref="P:System.Linq.Expressions.Expression.Type" /> równej <paramref name="type" />Kontynuuj <paramref name="target" />, Właściwośćustawionana,właściwośćustawionana,iwartośćnulldoprzesłaniadoetykietydocelowej<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> po przejściu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="T:System.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> A, który <see cref="P:System.Linq.Expressions.Expression.Type" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.UnaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość jest`false`. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> to. `true` W przeciwnym razie jest `false`to.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   `expression`Jeśli. Typ lub `type` jest typem zdefiniowanym przez użytkownika, który definiuje niejawny lub jawny operator <xref:System.Reflection.MethodInfo> konwersji, który reprezentuje operator jest metodą implementującą.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`te elementy. Typ i `type` reprezentuje typy liczbowe lub logiczne, lub dopuszczające wartości null lub niedopuszczające null typy wyliczeniowe, Metoda implementująca to `null`.  
  
    -   `expression`Jeśli. Typ lub `type` jest typem referencyjnym, z `expression`którego istnieje jawne opakowanie, rozpakowywanie lub konwersja odwołania. Wpisz do `type`, Metoda implementująca to `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody implementującej, a zwracany typ metody implementującej jest możliwy do przypisania do `type`, węzeł nie zostanie zniesiony.  
  
-   Jeśli jedno lub oba z `expression`. Wpisz lub `type` jest typem wartości null, a odpowiednie typy wartości, które nie są dopuszczane do wartości null, są równe typem argumentu i typem zwracanym metody implementującej odpowiednio, węzeł zostanie zniesiony.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli oba `expression`te elementy. Typ i `type` nie dopuszcza wartości null, węzeł nie zostanie zniesiony.  
  
-   W przeciwnym razie węzeł zostanie zniesiony.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące operację konwersji typu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora konwersji między <paramref name="expression" />. Wpisz i <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="T:System.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, dla której określono metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość jest`false`. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> to. `true` W przeciwnym razie jest `false`to.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli metoda nie `null`jest, jest to metoda implementująca. Musi reprezentować metodę inną niż void `static` (`Shared` w Visual Basic), która przyjmuje jeden argument.  
  
-   W przeciwnym razie, `expression`Jeśli. Typ lub `type` jest typem zdefiniowanym przez użytkownika, który definiuje niejawny lub jawny operator <xref:System.Reflection.MethodInfo> konwersji, który reprezentuje operator jest metodą implementującą.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`te elementy. Typ i `type` reprezentuje typy liczbowe lub logiczne, lub dopuszczające wartości null lub niedopuszczające null typy wyliczeniowe, Metoda implementująca to `null`.  
  
    -   `expression`Jeśli. Typ lub `type` jest typem referencyjnym, z `expression`którego istnieje jawne opakowanie, rozpakowywanie lub konwersja odwołania. Wpisz do `type`, Metoda implementująca to `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody implementującej, a zwracany typ metody implementującej jest możliwy do przypisania do `type`, węzeł nie zostanie zniesiony.  
  
-   W przypadku obu lub obu `expression`tych elementów. Wpisz lub `type` jest typem wartości null, a odpowiednie typy wartości, które nie są dopuszczane do wartości null, są równe typem argumentu i typem zwracanym metody implementującej odpowiednio, węzeł zostanie zniesiony.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli oba `expression`te elementy. Typ i `type` nie dopuszcza wartości null, węzeł nie zostanie zniesiony.  
  
-   W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora konwersji między <paramref name="expression" />. Wpisz i <paramref name="type" />.  
  
—lub— 
 <paramref name="expression" />. Nie można przypisać typu do typu argumentu metody reprezentowanej przez <paramref name="method" />.  
  
—lub— 
Typ zwracany metody reprezentowanej przez <paramref name="method" /> nie można przypisać do <paramref name="type" />elementu.  
  
—lub— 
 <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartości null, a odpowiadający mu typ wartości niedopuszczający wartości null nie jest równy typowi argumentu lub zwracanym typem, metody reprezentowanej przez <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę zgodną <paramref name="method" /> z opisem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="T:System.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> A, który <see cref="P:System.Linq.Expressions.Expression.Type" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.UnaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość jest`false`. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> to. `true` W przeciwnym razie jest `false`to.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   `expression`Jeśli. Typ lub `type` jest typem zdefiniowanym przez użytkownika, który definiuje niejawny lub jawny operator <xref:System.Reflection.MethodInfo> konwersji, który reprezentuje operator jest metodą implementującą.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`te elementy. Typ i `type` reprezentuje typy liczbowe lub logiczne, lub dopuszczające wartości null lub niedopuszczające null typy wyliczeniowe, Metoda implementująca to `null`.  
  
    -   `expression`Jeśli. Typ lub `type` jest typem referencyjnym, z `expression`którego istnieje jawne opakowanie, rozpakowywanie lub konwersja odwołania. Wpisz do `type`, Metoda implementująca to `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody implementującej, a zwracany typ metody implementującej jest możliwy do przypisania do `type`, węzeł nie zostanie zniesiony.  
  
-   W przypadku obu lub obu `expression`tych elementów. Wpisz lub `type` jest typem wartości null, a odpowiednie typy wartości, które nie są dopuszczane do wartości null, są równe typem argumentu i typem zwracanym metody implementującej odpowiednio, węzeł zostanie zniesiony.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli oba `expression`te elementy. Typ i `type` nie dopuszcza wartości null, węzeł nie zostanie zniesiony.  
  
-   W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora konwersji między <paramref name="expression" />. Wpisz i <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="T:System.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłasza wyjątek, jeśli typ docelowy jest przepełniony i dla którego określono metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość jest`false`. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> to. `true` W przeciwnym razie jest `false`to.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli metoda nie `null`jest, jest to metoda implementująca. Musi reprezentować metodę inną niż void `static` (`Shared` w Visual Basic), która przyjmuje jeden argument.  
  
-   W przeciwnym razie, `expression`Jeśli. Typ lub `type` jest typem zdefiniowanym przez użytkownika, który definiuje niejawny lub jawny operator <xref:System.Reflection.MethodInfo> konwersji, który reprezentuje operator jest metodą implementującą.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`te elementy. Typ i `type` reprezentuje typy liczbowe lub logiczne, lub dopuszczające wartości null lub niedopuszczające null typy wyliczeniowe, Metoda implementująca to `null`.  
  
    -   `expression`Jeśli. Typ lub `type` jest typem referencyjnym, z `expression`którego istnieje jawne opakowanie, rozpakowywanie lub konwersja odwołania. Wpisz do `type`, Metoda implementująca to `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody implementującej, a zwracany typ metody implementującej jest możliwy do przypisania do `type`, węzeł nie zostanie zniesiony.  
  
-   W przypadku obu lub obu `expression`tych elementów. Wpisz lub `type` jest typem wartości null, a odpowiednie typy wartości, które nie są dopuszczane do wartości null, są równe typem argumentu i typem zwracanym metody implementującej odpowiednio, węzeł zostanie zniesiony.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli oba `expression`te elementy. Typ i `type` nie dopuszcza wartości null, węzeł nie zostanie zniesiony.  
  
-   W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora konwersji między <paramref name="expression" />. Wpisz i <paramref name="type" />.  
  
—lub— 
 <paramref name="expression" />. Nie można przypisać typu do typu argumentu metody reprezentowanej przez <paramref name="method" />.  
  
—lub— 
Typ zwracany metody reprezentowanej przez <paramref name="method" /> nie można przypisać do <paramref name="type" />elementu.  
  
—lub— 
 <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartości null, a odpowiadający mu typ wartości niedopuszczający wartości null nie jest równy typowi argumentu lub zwracanym typem, metody reprezentowanej przez <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę zgodną <paramref name="method" /> z opisem.</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startLine" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startColumn" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endLine" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endColumn" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="document"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentuje plik źródłowy.</param>
        <param name="startLine">Wiersz startowy <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Musi być większa niż 0.</param>
        <param name="startColumn">Kolumna początkowa tego <see cref="T:System.Linq.Expressions.DebugInfoExpression" />elementu. Musi być większa niż 0.</param>
        <param name="endLine">Linia końcowa tego <see cref="T:System.Linq.Expressions.DebugInfoExpression" />elementu. Musi być większy lub równy wierszowi początkowemu.</param>
        <param name="endColumn">Kolumna końcowa tego <see cref="T:System.Linq.Expressions.DebugInfoExpression" />elementu. Jeśli linia końcowa jest taka sama jak linia początkowa, musi być większa lub równa wartości kolumny Start. W każdym przypadku musi być większa niż 0.</param>
        <summary><see cref="T:System.Linq.Expressions.DebugInfoExpression" /> Tworzy z określonym zakresem.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszenie wartości wyrażenia o 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zmniejszenia.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszenie wartości wyrażenia o 1.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący zmniejszenie wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie jest funkcjonalne i nie zmienia wartości przenoszonego obiektu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które odejmuje 1 od danej wartości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zmniejszenia.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszenie wartości wyrażenia o 1.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący zmniejszenie wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie jest funkcjonalne i nie zmienia wartości przenoszonego obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.DefaultExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.Type" /> ma właściwość ustawioną na określony typ.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> ma<see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość równą i Właściwość ustawioną na określony typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje wartość domyślną dla danego typu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dzielenia arytmetycznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość na.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość na.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dzielenia arytmetycznego.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub reprezentuje`right` Typzdefiniowanyprzezużytkownika,któryprzeciążaoperatordzielenia,oznaczato,żemetodajest<xref:System.Reflection.MethodInfo> metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora dzielenia.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odpowiada typowi wyniku wstępnie zdefiniowanego operatora dzielenia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie dzielące jego pierwszy argument przez drugi argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora dzielenia dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dzielenia arytmetycznego. Można określić metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje <xref:System.Reflection.MethodInfo> typ zdefiniowany przez użytkownika, który przeciąża operator dzielenia, oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora dzielenia.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odpowiada typowi wyniku wstępnie zdefiniowanego operatora dzielenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator dzielenia nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania dzielenia, która nie ma sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania dzielenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania dzielenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania dzielenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A, który <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> równe i ma ustawioną wartość i. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wyniku zostanie wywnioskowana z typów argumentów i określonego typu zwracanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A, który <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> równe i ma ustawioną wartość i. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wyniku zostanie wywnioskowana z typów argumentów i określonego typu zwracanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A, który <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> równe i ma ustawioną wartość i. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wyniku zostanie wywnioskowana z typów argumentów i określonego typu zwracanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A, który <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> równe i ma ustawioną wartość i. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wyniku zostanie wywnioskowana z typów argumentów i określonego typu zwracanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A, który <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> równe i ma ustawioną wartość i. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wyniku zostanie wywnioskowana z typów argumentów i określonego typu zwracanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <param name="arg3">Czwarty argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A, który <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> równe i ma ustawioną wartość i. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwość wyniku zostanie wywnioskowana z typów argumentów i określonego typu zwracanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ElementInit" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> ustawić właściwość równą.</param>
        <param name="arguments"><see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> Obiekt <see cref="T:System.Collections.Generic.IEnumerable`1" /> zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty, aby ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.ElementInit" />Tworzy, <see cref="T:System.Collections.Generic.IEnumerable`1" /> podaną jako drugi argument.</summary>
        <returns>Ma właściwości i<see cref="P:System.Linq.Expressions.ElementInit.Arguments" />ustawione na określone wartości. <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> <see cref="T:System.Linq.Expressions.ElementInit" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` Parametr musi reprezentować metodę wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter). Metoda Add musi mieć taką samą liczbę parametrów jak liczba elementów w `arguments`. Właściwość każdego elementu w `arguments` elemencie musi być możliwa do przypisania do typu odpowiedniego parametru metody Add, prawdopodobnie po utworzeniu. ** <xref:System.Linq.Expressions.Expression.Type%2A>  
  
> [!NOTE]
>  Element zostanie umieszczony w cudzysłowie, jeśli odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`arguments`właściwość jest elementem elementu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metody do <xref:System.Linq.Expressions.ElementInit> utworzenia, która reprezentuje wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metody w celu zainicjowania elementu kolekcji słownika.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addMethod" />lub <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Metoda <paramref name="addMethod" /> reprezentowana nie jest nazwą "Add" (bez uwzględniania wielkości liter).  
  
—lub— 
Metoda, która <paramref name="addMethod" /> reprezentuje, nie jest metodą wystąpienia.  
  
—lub— 
 <paramref name="arguments" />nie zawiera takiej samej liczby elementów jak liczba parametrów dla metody, która <paramref name="addMethod" /> reprezentuje.  
  
—lub— 
Nie można przypisać <paramref name="arguments" /> <paramref name="addMethod" /> właściwości co najmniej jednego elementu elementu do typu odpowiadającego mu parametru metody, która reprezentuje. <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> ustawić właściwość równą.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ustawiania właściwości równej.</param>
        <summary><see cref="T:System.Linq.Expressions.ElementInit" />Tworzy, używając tablicy wartości jako drugi argument.</summary>
        <returns>Ma właściwości i<see cref="P:System.Linq.Expressions.ElementInit.Arguments" />ustawione na określone wartości. <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> <see cref="T:System.Linq.Expressions.ElementInit" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` Parametr musi reprezentować metodę wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter). Metoda Add musi mieć taką samą liczbę parametrów jak liczba elementów w `arguments`. Właściwość każdego elementu w `arguments` elemencie musi być możliwa do przypisania do typu odpowiedniego parametru metody Add, prawdopodobnie po utworzeniu. ** <xref:System.Linq.Expressions.Expression.Type%2A>  
  
> [!NOTE]
>  Element zostanie umieszczony w cudzysłowie, jeśli odpowiedni parametr metody jest typu <xref:System.Linq.Expressions.Expression>. QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`arguments`właściwość jest elementem elementu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metody do <xref:System.Linq.Expressions.ElementInit> utworzenia, która reprezentuje wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metody w celu zainicjowania elementu kolekcji słownika.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addMethod" />lub <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Metoda, którą reprezentuje metoda addMethod, nie ma nazwy "Add" (bez uwzględniania wielkości liter).  
  
—lub— 
Metoda, którą reprezentuje metoda addMethod, nie jest metodą wystąpienia.  
  
—lub— 
argumenty nie zawierają takiej samej liczby elementów jak liczba parametrów dla metody reprezentowanej przez metodę addMethod.  
  
—lub— 
Nie można przypisać <paramref name="arguments" /> <paramref name="addMethod" /> właściwości co najmniej jednego elementu elementu do typu odpowiadającego mu parametru metody, która reprezentuje. <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy puste wyrażenie, które ma <see cref="T:System.Void" /> typ.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> <see cref="T:System.Void" />Właściwość równą i Właściwość ustawioną na. <see cref="P:System.Linq.Expressions.Expression.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pustego wyrażenia można użyć w przypadku, gdy jest oczekiwane wyrażenie, ale nie jest wymagana żadna akcja. Na przykład, można użyć pustego wyrażenia jako ostatniego wyrażenia w wyrażeniu bloku. W tym przypadku zwracaną wartością wyrażenia bloku jest void.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć puste wyrażenie i dodać je do wyrażenia bloku.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest. `true` W przeciwnym razie jest `false`to. Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub reprezentuje`right` Typzdefiniowanyprzezużytkownika,któryprzeciążaoperatorrówności,tooznacza,żemetodajest<xref:System.Reflection.MethodInfo> metodą implementującą.  
  
-   W przeciwnym razie metoda implementująca `null`ma wartość.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła <xref:System.Boolean>:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła to <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które sprawdza, czy wartości dwóch argumentów są równe.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora równości dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości. Można określić metodę implementującą.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> zostanie zniesiony, właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwość jest równa `liftToNull`. W przeciwnym razie są oba `false`te elementy. Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje <xref:System.Reflection.MethodInfo> typ zdefiniowany przez użytkownika, który przeciąża operator równości, to oznacza metodę implementującą metodę.  
  
-   W przeciwnym razie metoda implementująca `null`ma wartość.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony; Ponadto typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator równości nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="XOR" /> .</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="XOR" /> przy użyciu <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `XOR` reprezentujetyp<xref:System.Reflection.MethodInfo> zdefiniowany przez użytkownika, który przeciąża operator, oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy całkowite lub logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego `XOR` operatora.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odpowiada typowi wyniku wstępnie zdefiniowanego `XOR` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące logiczną operację XOR.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano <paramref name="left" />operatoradlaelementu <see langword="XOR" /> . Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="XOR" /> przy użyciu <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika. Można określić metodę implementującą.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ <xref:System.Reflection.MethodInfo> zdefiniowany przez użytkownika, który przeciąża `XOR` operator, oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy całkowite lub logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego `XOR` operatora.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odpowiada typowi wyniku wstępnie zdefiniowanego `XOR` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> <paramref name="left" />i operatorniejestzdefiniowanydla.<see langword="XOR" /> Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania XOR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania XOR przy użyciu <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania XOR przy użyciu <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania XOR przy użyciu <c>op_ExclusiveOr</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do pola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawić właściwość równą. Dla <see langword="static" /> <paramref name="expression" /> <see langword="null" />(<see langword="Shared" /> w Visual Basic) musi być.</param>
        <param name="field"><see cref="T:System.Reflection.FieldInfo" /> Aby<see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do pola.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> A, który <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ma<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.MemberExpression> <xref:System.Reflection.FieldInfo.FieldType%2A> jest`field`równawłaściwości. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="field" />jest <see langword="null" />.  
  
—lub— 
Pole <paramref name="field" /> reprezentowane przez <see langword="null" />nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) i <paramref name="expression" /> ma wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />. Nie można przypisać typu do typu deklarującego pola reprezentowanego przez <paramref name="field" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Zawierający pole o nazwie<paramref name="fieldName" />. <see cref="T:System.Linq.Expressions.Expression" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> Może to mieć wartość null w przypadku pól statycznych.</param>
        <param name="fieldName">Nazwa pola do uzyskania dostępu.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do pola, w którym znajduje się nazwa pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> <paramref name="expression" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.MemberExpression.Member" /> , <see cref="T:System.Reflection.FieldInfo" /> <paramref name="fieldName" />Właściwość ustawiona na, i Właściwość ustawiona na, która reprezentuje pole, które jest oznaczone przez. <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.MemberExpression> <xref:System.Reflection.FieldInfo.FieldType%2A> <xref:System.Reflection.FieldInfo> Właściwość będąca wynikiem jest równa właściwości, która reprezentuje pole, które jest oznaczone przez `fieldName`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 Ta metoda wyszukuje `expression`. Typ i jego typy podstawowe dla pola, które ma nazwę `fieldName`. Pola publiczne mają pierwszeństwo przed polami niepublicznymi. Jeśli zostanie znalezione pasujące pole, ta metoda przekazuje `expression` <xref:System.Reflection.FieldInfo> i reprezentuje to pole jako <xref:System.Linq.Expressions.Expression.Field%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące dostęp do pola.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="fieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie zdefiniowano <paramref name="fieldName" /> pola o nazwie <paramref name="expression" />w. Typ lub jego typy podstawowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fieldName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">Zawierający obiekt pola. Może to mieć wartość null w przypadku pól statycznych.</param>
        <param name="type"><see cref="P:System.Linq.Expressions.Expression.Type" /> Zawiera pole.</param>
        <param name="fieldName">Pole, do którego ma zostać uzyskany dostęp.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do pola.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica do szesnastu <see cref="T:System.Type" /> obiektów, które określają argumenty typu <see langword="System.Action" /> dla typu delegata.</param>
        <summary>Tworzy obiekt, który reprezentuje ogólny <c>System.</c> typ delegata akcji, który ma określone argumenty typu. <see cref="T:System.Type" /></summary>
        <returns>Typ obiektu <c>System. Action</c> , który ma określone argumenty typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs` Przykładowo, jeśli elementy reprezentują typy `T1…Tn`, obiekt wyniku <xref:System.Type> reprezentuje skonstruowany typ `System.Action<T1,…,Tn>` delegata w C# lub `System.Action(Of T1,…,Tn)` w Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeArgs" />zawiera więcej niż szesnaste elementy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Argumenty typu delegata.</param>
        <summary>Pobiera obiekt, który reprezentuje generyczny typ <c>System. Func</c> lub <c>System. Action</c> , który ma określone argumenty typu. <see cref="P:System.Linq.Expressions.Expression.Type" /></summary>
        <returns>Typ delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Argument Last Type Określa zwracany typ delegata. Jeśli żadna z funkcji Func lub akcja nie jest wystarczająco duża, wygeneruje niestandardowy typ delegata.  
  
 Podobnie jak w przypadku funkcji Func, ostatni argument jest typem zwracanym. Można ustawić wartość System. void, aby utworzyć akcję.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica jednej do obiektów siedemnastu <see cref="T:System.Type" /> , która określa argumenty typu <see langword="System.Func" /> dla typu delegata.</param>
        <summary>Tworzy obiekt, który reprezentuje ogólny typ <c>System. Func</c> delegata, który ma określone argumenty typu. <see cref="P:System.Linq.Expressions.Expression.Type" /> Argument Last Type Określa zwracany typ utworzonego delegata.</summary>
        <returns>Typ delegata <c>System. Func</c> , który ma określone argumenty typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs`musi zawierać co najmniej jeden i najwyżej siedemnastu elementy.  
  
 `typeArgs` Przykładowo, jeśli elementy reprezentują typy `T1…Tn`, obiekt wyniku <xref:System.Type> reprezentuje skonstruowany typ `System.Func<T1,…,Tn>` delegata w C# lub `System.Func(Of T1,…,Tn)` w Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeArgs" />zawiera mniej niż jeden lub więcej elementów niż siedemnastu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "przejdź do".</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "przejdź do".</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równagoto,właściwośćustawionanaokreślonąwartośćorazwartośćnulldoprzesłaniadoetykietydocelowej<see cref="P:System.Linq.Expressions.GotoExpression.Target" /> po przejściu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.GotoExpression> obiekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="value">Wartość, która zostanie przeniesiona do skojarzonej etykiety po przejściu.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "przejdź do". Wartość przeskoczy do etykiety po przejściu można określić.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> <paramref name="value" /> równym goto, <paramref name="target" />Właściwość ustawiona na i do przesłania do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "przejdź do" o określonym typie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa<see cref="P:System.Linq.Expressions.Expression.Type" /> goto, <paramref name="type" />Właściwość ustawiona na określoną wartość, właściwość ustawiona na i wartość null do przesłania do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="value">Wartość, która zostanie przeniesiona do skojarzonej etykiety po przejściu.</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "przejdź do" o określonym typie. Wartość przeskoczy do etykiety po przejściu można określić.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.Expression.Type" /> równa<paramref name="type" />goto, <paramref name="target" />Właściwość ustawiona na, właściwość ustawiona na, i <paramref name="value" /> do do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównywanie numeryczne "większe niż".</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównywanie numeryczne "większe niż".</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest. `true` W przeciwnym razie jest `false`to. Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator "większe niż", oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła <xref:System.Boolean>:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła to <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które porównuje dwie liczby całkowite.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównywanie numeryczne "większe niż". Można określić metodę implementującą.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> zostanie zniesiony, właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwość jest równa `liftToNull`. W przeciwnym razie są oba `false`te elementy. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator "większe niż", <xref:System.Reflection.MethodInfo> oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony; Ponadto typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż lub równe" porównanie liczbowe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż lub równe" porównanie liczbowe.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest. `true` W przeciwnym razie jest `false`to. Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator "większe niż lub równe", oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła <xref:System.Boolean>:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła to <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które porównuje dwie liczby całkowite.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "większe niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż lub równe" porównanie liczbowe.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> zostanie zniesiony, właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwość jest równa `liftToNull`. W przeciwnym razie są oba `false`te elementy. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator " <xref:System.Reflection.MethodInfo> większe niż lub równe", oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony; Ponadto typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator "większe niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> ustawić właściwość równą.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący blok warunkowy <see langword="if" /> z instrukcją.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />Właściwość równą i,, właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> Właściwość jest ustawiona na wyrażenie domyślne i typ wynikowego <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracanego przez tę metodę jest <see cref="T:System.Void" />. <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące blok warunkowy.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> ustawić właściwość równą.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ustawić właściwość równą.</param>
        <param name="ifFalse"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący blok warunkowy za <see langword="if" /> pomocą <see langword="else" /> instrukcji i.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> Typ wynikowego <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracanego przez tę metodę jest <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące blok warunkowy.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy, który reprezentuje zwiększenie wartości wyrażenia o 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do przyrostu.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy, który reprezentuje zwiększenie wartości wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , która reprezentuje wyrażenie zwiększające wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie jest funkcjonalne i nie zmienia wartości obiektu, który jest do niego przesłany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację przyrostu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do przyrostu.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy, który reprezentuje zwiększenie wartości wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , która reprezentuje wyrażenie zwiększające wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie jest funkcjonalne i nie zmienia wartości obiektu, który jest do niego przesłany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.InvocationExpression" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje wyrażenie delegata lub lambda, które ma zostać zastosowane.</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawiera<see cref="T:System.Linq.Expressions.Expression" /> obiekty, które reprezentują argumenty, do których jest stosowana delegat lub wyrażenie lambda.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.InvocationExpression" /> , który ma zastosowanie do listy wyrażeń argumentów delegata lub wyrażenia lambda.</summary>
        <returns><see cref="T:System.Linq.Expressions.InvocationExpression" /> , Który stosuje określony delegat lub wyrażenie lambda do podanych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.InvocationExpression> reprezentuje zwracany typ delegata reprezentowanego przez `expression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
 Właściwość <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> będąca <xref:System.Linq.Expressions.InvocationExpression> wynikiem jest pusta, jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy, `arguments` co z tą różnicą <xref:System.Linq.Expressions.Expression> , że niektóre z tych obiektów mogą być ujęte w *cudzysłów*.  
  
> [!NOTE]
>  Element zostanie cytowany tylko wtedy, gdy odpowiedni parametr delegata reprezentowany przez `expression` jest typu. <xref:System.Linq.Expressions.Expression> QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`arguments`właściwość jest elementem elementu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metody do <xref:System.Linq.Expressions.InvocationExpression> tworzenia, która reprezentuje wywołanie wyrażenia lambda z określonymi argumentami.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />. Typ nie reprezentuje typu delegata lub <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
—lub— 
Właściwości elementu nie można przypisać do typu odpowiadającego mu parametru delegata reprezentowanego przez <paramref name="expression" />. <see cref="P:System.Linq.Expressions.Expression.Type" /> <paramref name="arguments" /></exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="arguments" />nie zawiera takiej samej liczby elementów jak lista parametrów delegata reprezentowanego przez <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">Reprezentuje wyrażenie delegata lub lambda ,któremazostaćzastosowane.<see cref="T:System.Linq.Expressions.Expression" /></param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, która reprezentuje argumenty, do których jest stosowana delegat lub wyrażenie lambda.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.InvocationExpression" /> , który ma zastosowanie do listy wyrażeń argumentów delegata lub wyrażenia lambda.</summary>
        <returns><see cref="T:System.Linq.Expressions.InvocationExpression" /> , Który stosuje określony delegat lub wyrażenie lambda do podanych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.InvocationExpression> reprezentuje zwracany typ delegata reprezentowanego przez `expression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
 Właściwość <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> będąca <xref:System.Linq.Expressions.InvocationExpression> wynikiem jest pusta, jeśli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy, `arguments` co z tą różnicą <xref:System.Linq.Expressions.Expression> , że niektóre z tych obiektów mogą być ujęte w *cudzysłów*.  
  
> [!NOTE]
>  Element zostanie cytowany tylko wtedy, gdy odpowiedni parametr delegata reprezentowany przez `expression` jest typu. <xref:System.Linq.Expressions.Expression> QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`arguments`właściwość jest elementem elementu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metody do <xref:System.Linq.Expressions.InvocationExpression> tworzenia, która reprezentuje wywołanie wyrażenia lambda z określonymi argumentami.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />. Typ nie reprezentuje typu delegata lub <see cref="T:System.Linq.Expressions.Expression`1" />.  
  
—lub— 
Właściwości elementu nie można przypisać do typu odpowiadającego mu parametru delegata reprezentowanego przez <paramref name="expression" />. <see cref="P:System.Linq.Expressions.Expression.Type" /> <paramref name="arguments" /></exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="arguments" />nie zawiera takiej samej liczby elementów jak lista parametrów delegata reprezentowanego przez <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy wyrażenie daje w wyniku wartość false.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do obliczenia.</param>
        <summary>Zwraca czy wyrażenie daje w wyniku wartość false.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do obliczenia.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary>Zwraca czy wyrażenie daje w wyniku wartość false.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca czy wyrażenie ma wartość true.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do obliczenia.</param>
        <summary>Zwraca czy wyrażenie ma wartość true.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do obliczenia.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary>Zwraca czy wyrażenie ma wartość true.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy etykietę <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentującą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę z typem void i bez nazwy.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.LabelTarget> obiekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">, <see cref="T:System.Linq.Expressions.LabelTarget" /> Z<see cref="T:System.Linq.Expressions.LabelExpression" /> którym zostanie skojarzona.</param>
        <summary>Tworzy etykietę <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentującą bez wartości domyślnej.</summary>
        <returns><see cref="T:System.Linq.Expressions.LabelExpression" /> Bez wartości domyślnej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa etykiety.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę z typem void i podaną nazwę.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ wartości, która jest przesyłana podczas przechodzenia do etykiety.</param>
        <summary>Tworzy etykietę <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentującą dany typ.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje sposób używania <xref:System.Linq.Expressions.LabelTarget> obiektu w wyrażeniu pętli.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">, <see cref="T:System.Linq.Expressions.LabelTarget" /> Z<see cref="T:System.Linq.Expressions.LabelExpression" /> którym zostanie skojarzona.</param>
        <param name="defaultValue">Wartość tego <see cref="T:System.Linq.Expressions.LabelExpression" /> elementu, gdy etykieta zostanie osiągnięta przy użyciu standardowego przepływu sterowania.</param>
        <summary>Tworzy etykietę <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentującą daną wartość domyślną.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LabelExpression" /> z daną wartością domyślną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ wartości, która jest przesyłana podczas przechodzenia do etykiety.</param>
        <param name="name">Nazwa etykiety.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę o danym typie i nazwie.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy drzewo wyrażenia, które reprezentuje wyrażenie lambda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy po raz pierwszy konstrukcja typu delegata z treści wyrażenia i wyliczalną kolekcję wyrażeń parametrów. Można go użyć, jeśli typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> wypełnienia kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy po raz pierwszy konstruowanie typu delegata z treści wyrażenia i tablicy wyrażeń parametrów. Można go użyć, jeśli typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> A, który <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ma<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.LambdaExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `parameters` Parametr nie może mieć więcej niż szesnastu elementów.  
  
 Elementy `parameters` musi być odwołaniem równym wyrażeniem parametrów w `body`.  
  
 Ta metoda konstruuje odpowiedni typ delegata z jednego z `System.Func` delegatów ogólnych. Następnie przekazuje typ delegata do jednej z <xref:System.Linq.Expressions.ExpressionType.Lambda> metod fabrycznych w celu <xref:System.Linq.Expressions.LambdaExpression>utworzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="parameters" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" />zawiera więcej niż szesnaste elementy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy po raz pierwszy konstrukcja typu delegata z treści wyrażenia, parametr, który wskazuje, czy Optymalizacja wywołania tail zostanie zastosowana, oraz wyliczalną kolekcję wyrażeń parametrów. Można go użyć, jeśli typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty używane do <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> wypełniania kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy po raz pierwszy konstrukcja typu delegata z treści wyrażenia, parametr, który wskazuje, czy Optymalizacja wywołania tail zostanie zastosowana i tablicę wyrażeń parametrów. Można go użyć, jeśli typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacji debugowania.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy po raz pierwszy konstruowanie typu delegata z treści wyrażenia, nazwy wyrażenia lambda i wyliczalnej kolekcji wyrażeń parametrów. Można go użyć, jeśli typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Type" /> Reprezentuje sygnaturę delegata dla wyrażenia lambda.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy miejsce, gdzie typ delegata jest znany w czasie kompilacji, z wyliczalną kolekcją wyrażeń parametrów.</summary>
        <returns>Obiekt, który reprezentuje wyrażenie lambda, które <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma właściwość <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> równą i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości i i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ustawia określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany przez tę funkcję, jest typu <xref:System.Linq.Expressions.Expression%601>. <xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwracanego obiektu, ponieważ konkretny typ wyrażenia lambda nie jest znany w czasie kompilacji.  
  
 Liczba parametrów dla typu delegata reprezentowanego przez`delegateType` musi być równa `parameters`długości.  
  
 Elementy `parameters` musi być odwołaniem równym wyrażeniem parametrów w `body`.  
  
 Właściwość obiektu będącego wynikiem jest `delegateType`równa. <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli `parameters` jest `null` ,<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość obiektu będącego wynikiem jest pustą kolekcją.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentujące wyrażenie lambda, które dodaje 1 do porzuconego argumentu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="delegateType" />lub <paramref name="body" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element w <paramref name="parameters" /> programie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" />nie reprezentuje typu delegata.  
  
—lub— 
 <paramref name="body" />. Typ reprezentuje typ, którego nie można przypisać do typu zwracanego typu delegata reprezentowanego przez <paramref name="delegateType" />.  
  
—lub— 
 <paramref name="parameters" />nie zawiera takiej samej liczby elementów jak lista parametrów dla typu delegata reprezentowanego przez <paramref name="delegateType" />.  
  
—lub— 
Właściwość elementu nie jestmożliwa<paramref name="delegateType" />do przypisania z typu odpowiedniego parametru typu delegata reprezentowanego przez. <paramref name="parameters" /> <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Type" /> Reprezentuje sygnaturę delegata dla wyrażenia lambda.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> wypełnienia kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy miejsce, gdzie typ delegata jest znany w czasie kompilacji, z tablicą wyrażeń parametrów.</summary>
        <returns>Obiekt, który reprezentuje wyrażenie lambda, które <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma właściwość <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> równą i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości i i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ustawia określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który jest zwracany przez tę funkcję, jest typu <xref:System.Linq.Expressions.Expression%601>. <xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwracanego obiektu, ponieważ konkretny typ wyrażenia lambda nie jest znany w czasie kompilacji.  
  
 Liczba parametrów dla typu delegata reprezentowanego przez `delegateType` musi być równa `parameters`długości.  
  
 Elementy `parameters` musi być odwołaniem równym wyrażeniem parametrów w `body`.  
  
 Właściwość obiektu będącego wynikiem jest `delegateType`równa. <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli `parameters` jest `null` ,<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość obiektu będącego wynikiem jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="delegateType" />lub <paramref name="body" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element w <paramref name="parameters" /> programie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" />nie reprezentuje typu delegata.  
  
—lub— 
 <paramref name="body" />. Typ reprezentuje typ, którego nie można przypisać do typu zwracanego typu delegata reprezentowanego przez <paramref name="delegateType" />.  
  
—lub— 
 <paramref name="parameters" />nie zawiera takiej samej liczby elementów jak lista parametrów dla typu delegata reprezentowanego przez <paramref name="delegateType" />.  
  
—lub— 
Właściwość elementu nie jestmożliwa<paramref name="delegateType" />do przypisania z typu odpowiedniego parametru typu delegata reprezentowanego przez. <paramref name="parameters" /> <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacji debugowania.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy po raz pierwszy konstrukcja typu delegata z treści wyrażenia, nazwę wyrażenia lambda, parametr, który wskazuje, czy Optymalizacja wywołania tail zostanie zastosowana, oraz wyliczalną kolekcję wyrażeń parametrów. Można go użyć, jeśli typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" /> Reprezentujący sygnaturę delegata dla wyrażenia lambda.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.LambdaExpression" /> gdzie typ delegata jest znany w czasie kompilacji, z parametrem, który wskazuje, czy Optymalizacja wywołania tail zostanie zastosowana, oraz wyliczalną kolekcję wyrażeń parametrów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" /> Reprezentujący sygnaturę delegata dla wyrażenia lambda.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty używane do <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> wypełniania kolekcji.</param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.LambdaExpression" /> gdzie typ delegata jest znany w czasie kompilacji, z parametrem wskazującym, czy zostanie zastosowana Optymalizacja wywołania tail i tablicą wyrażeń parametrów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" /> Reprezentujący sygnaturę delegata dla wyrażenia lambda.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacji debugowania.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary><see cref="T:System.Linq.Expressions.LambdaExpression" /> Tworzy miejsce, gdzie typ delegata jest znany w czasie kompilacji, z nazwą wyrażenia lambda i wyliczalną kolekcją wyrażeń parametrów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="P:System.Linq.Expressions.Expression.Type" /> Reprezentujący sygnaturę delegata dla wyrażenia lambda.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacji debugowania.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.LambdaExpression" /> gdzie typ delegata jest znany w czasie kompilacji, z nazwą wyrażenia lambda, parametrem, który wskazuje, czy Optymalizacja wywołania tail zostanie zastosowana, oraz wyliczalną kolekcję wyrażeń parametrów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma właściwość równą lambda, a <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> właściwości <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i i są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji, z wyliczalną kolekcją wyrażeń parametrów.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.Expression`1" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i właściwości iiustawiaokreślonewartości.<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba parametrów dla typu `TDelegate` delegata musi być równa liczbie elementów w. `parameters`  
  
 Elementy `parameters` musi być odwołaniem równym wyrażeniem parametrów w `body`.  
  
 Właściwość obiektu będącego wynikiem reprezentuje typ `TDelegate`. <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli `parameters` jest `null` ,<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość obiektu będącego wynikiem jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element w <paramref name="parameters" /> programie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TDelegate" />nie jest typem delegowanym.  
  
—lub— 
 <paramref name="body" />. Typ reprezentuje typ, którego nie można przypisać do zwracanego typu <paramref name="TDelegate" />.  
  
—lub— 
 <paramref name="parameters" />nie zawiera takiej samej liczby elementów jak lista parametrów dla <paramref name="TDelegate" />.  
  
—lub— 
Właściwość elementu nie jestmożliwa<paramref name="TDelegate" />do przypisania z typu odpowiadającego typu parametru. <paramref name="parameters" /> <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> wypełnienia kolekcji.</param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji, z tablicą wyrażeń parametrów.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.Expression`1" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i właściwości iiustawiaokreślonewartości.<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba parametrów dla typu `TDelegate` delegata musi być równa liczbie elementów w. `parameters`  
  
 Elementy `parameters` musi być odwołaniem równym wyrażeniem parametrów w`body`.  
  
 Właściwość obiektu będącego wynikiem reprezentuje typ `TDelegate`. <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli `parameters` jest `null` ,<xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość obiektu będącego wynikiem jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element w <paramref name="parameters" /> programie <see langword="null" />jest.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TDelegate" />nie jest typem delegowanym.  
  
—lub— 
 <paramref name="body" />. Typ reprezentuje typ, którego nie można przypisać do zwracanego typu <paramref name="TDelegate" />.  
  
—lub— 
 <paramref name="parameters" />nie zawiera takiej samej liczby elementów jak lista parametrów dla <paramref name="TDelegate" />.  
  
—lub— 
Właściwość elementu nie jestmożliwa<paramref name="TDelegate" />do przypisania z typu odpowiadającego typu parametru. <paramref name="parameters" /> <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji, z parametrem wskazującym, czy zostanie zastosowana Optymalizacja wywołania tail i wyliczalną kolekcją wyrażeń parametrów.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.Expression`1" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i właściwości iiustawiaokreślonewartości.<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty używane do <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> wypełniania kolekcji.</param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji, z parametrem wskazującym, czy zostanie zastosowana Optymalizacja wywołania tail i tablicą wyrażeń parametrów.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.Expression`1" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i właściwości iiustawiaokreślonewartości.<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="name">Nazwa wyrażenia lambda. Służy do generowania informacji o debugowaniu.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary><see cref="T:System.Linq.Expressions.Expression`1" /> Tworzy miejsce, gdzie typ delegata jest znany w czasie kompilacji, z nazwą wyrażenia lambda i wyliczalną kolekcją wyrażeń parametrów.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.Expression`1" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i właściwości iiustawiaokreślonewartości.<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> ustawić właściwość równą.</param>
        <param name="name">Nazwa wyrażenia lambda. Służy do generowania informacji o debugowaniu.</param>
        <param name="tailCall">Wskazuje <see cref="T:System.Boolean" /> , czy Optymalizacja wywołania tail zostanie zastosowana podczas kompilowania utworzonego wyrażenia.</param>
        <param name="parameters">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ParameterExpression" /></param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.Expression`1" /> gdzie typ delegata jest znany w czasie kompilacji, z nazwą wyrażenia lambda, parametrem wskazującym, czy zostanie zastosowana Optymalizacja wywołania tail i wyliczalną kolekcją wyrażeń parametrów.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.Expression`1" /> , który <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> i właściwości iiustawiaokreślonewartości.<see cref="P:System.Linq.Expressions.LambdaExpression.Body" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przesunięcia w lewo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przesunięcia w lewo.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator przesunięcia w lewo, to oznacza, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Typ jest typem całkowitym (jednym z <xref:System.Byte> <xref:System.Int16>, <xref:System.SByte> <xref:System.UInt16> <xref:System.Int32> ,,<xref:System.UInt32>,,,,, lub odpowiednimi typami dopuszczającymi wartość null) i `right`. <xref:System.Int64> <xref:System.UInt64> Typ to <xref:System.Int32>, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odpowiada typowi wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który <xref:System.Reflection.MethodInfo> przeciąża operator przesunięcia w lewo, oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Typ jest typem całkowitym (jednym z <xref:System.Byte> <xref:System.Int16>, <xref:System.SByte> <xref:System.UInt16> <xref:System.Int32> ,,<xref:System.UInt32>,,,,, lub odpowiednimi typami dopuszczającymi wartość null) i `right`. <xref:System.Int64> <xref:System.UInt64> Typ to <xref:System.Int32>, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odpowiada typowi wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w lewym przesunięciu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w lewym przesunięciu.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w lewym przesunięciu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w lewym przesunięciu.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównywanie numeryczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównywanie numeryczne.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest. `true` W przeciwnym razie jest `false`to. Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Metoda implementująca dla operacji jest wybierana na podstawie następujących reguł:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator "mniejsze niż", oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła <xref:System.Boolean>:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła to <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które porównuje dwie liczby całkowite.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "Less" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż" porównywanie numeryczne.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> zostanie zniesiony, właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwość jest równa `liftToNull`. W przeciwnym razie są oba `false`te elementy. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator "mniejsze niż", <xref:System.Reflection.MethodInfo> oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony; Ponadto typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator "Less" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest. `true` W przeciwnym razie jest `false`to. Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator "mniejsze lub równe", oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła <xref:System.Boolean>:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła to <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które porównuje dwie liczby całkowite.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "Less" lub "EQUAL" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> zostanie zniesiony, właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwość jest równa `liftToNull`. W przeciwnym razie są oba `false`te elementy. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator " <xref:System.Reflection.MethodInfo> mniejsze lub równe", oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony; Ponadto typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.MemberListBinding" /> Tworzy obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">Reprezentuje pole lub właściwość <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ,abyustawićwłaściwośćrówną.<see cref="T:System.Reflection.MemberInfo" /></param>
        <param name="initializers">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ElementInit" /></param>
        <summary><see cref="T:System.Linq.Expressions.MemberListBinding" /> Tworzy miejsce, gdzie składowa jest polem lub właściwością.</summary>
        <returns><see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> A, który <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ma<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberListBinding" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />nie reprezentuje pola lub właściwości.  
  
—lub— 
Lub pola lub właściwości<paramref name="member" /> reprezentowanej przez nie implementuje <see cref="T:System.Collections.IEnumerable" />. <see cref="P:System.Reflection.FieldInfo.FieldType" /> <see cref="P:System.Reflection.PropertyInfo.PropertyType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">Reprezentuje pole lub właściwość <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ,abyustawićwłaściwośćrówną.<see cref="T:System.Reflection.MemberInfo" /></param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełnienia kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.MemberListBinding" /> Tworzy miejsce, gdzie składowa jest polem lub właściwością.</summary>
        <returns><see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> A, który <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ma<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberListBinding" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />nie reprezentuje pola lub właściwości.  
  
—lub— 
Lub pola lub właściwości<paramref name="member" /> reprezentowanej przez nie implementuje <see cref="T:System.Collections.IEnumerable" />. <see cref="P:System.Reflection.FieldInfo.FieldType" /> <see cref="P:System.Reflection.PropertyInfo.PropertyType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę metody dostępu do właściwości.</param>
        <param name="initializers">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ElementInit" /></param>
        <summary><see cref="T:System.Linq.Expressions.MemberListBinding" /> Tworzy na podstawie określonej metody dostępu do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> , który <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> ma <see cref="T:System.Reflection.MemberInfo" /> <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> <paramref name="propertyAccessor" />Właściwość równą <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, właściwość ustawiona na, która reprezentuje właściwość, która jest używana w i wypełnia elementy <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />nie reprezentuje metody akcesora właściwości.  
  
—lub— 
Właściwość, której Metoda reprezentowana przez <paramref name="propertyAccessor" /> dostęp nie implementuje <see cref="T:System.Collections.IEnumerable" />. <see cref="P:System.Reflection.PropertyInfo.PropertyType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę metody dostępu do właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełnienia kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.MemberListBinding" /> Tworzy obiekt na podstawie określonej metody dostępu do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> , który <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> ma <see cref="T:System.Reflection.MemberInfo" /> <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> <paramref name="propertyAccessor" />Właściwość równą <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, właściwość ustawiona na, która reprezentuje właściwość, która jest używana w i wypełnia elementy <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />nie reprezentuje metody akcesora właściwości.  
  
—lub— 
Właściwość, której Metoda reprezentowana przez <paramref name="propertyAccessor" /> dostęp nie implementuje <see cref="T:System.Collections.IEnumerable" />. <see cref="P:System.Reflection.PropertyInfo.PropertyType" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ListInitExpression" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="initializers">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.ElementInit" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.ListInitExpression" /> , który używa <see cref="T:System.Linq.Expressions.ElementInit" /> określonych obiektów do zainicjowania kolekcji.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> A, który <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ma<see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.ListInitExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>. <xref:System.Linq.Expressions.Expression.Type%2A> `newExpression`  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metody do <xref:System.Linq.Expressions.ListInitExpression> utworzenia, która reprezentuje inicjalizację nowego wystąpienia słownika z dwiema parami klucz-wartość.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="initializers">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <summary><see cref="T:System.Linq.Expressions.ListInitExpression" /> Tworzy, który używa metody o nazwie "Add", aby dodać elementy do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ma<see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>. <xref:System.Linq.Expressions.Expression.Type%2A> `newExpression`  
  
 Aby można było użyć tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>,. `newExpression` Typ lub jego typ podstawowy muszą deklarować pojedynczą metodę o nazwie "Add" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Typ argumentu musi być możliwy do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość pierwszego `initializers`elementu.  
  
 Właściwość zwracanego <xref:System.Linq.Expressions.ListInitExpression> elementu zawiera jeden element `initializers`typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwość każdego elementu jest kolekcją pojedynczą, która `initializers`zawiera odpowiedni element. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwość każdego elementu reprezentuje metodę Add, która została wykryta. `newExpression` <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Typ lub jego typ podstawowy.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie istnieje metoda wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter) <paramref name="newExpression" />zadeklarowanej w elemencie. Typ lub jego typ podstawowy.  
  
—lub— 
Metoda Add dla <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jednego argumentu.  
  
—lub— 
Typu reprezentowanego przez <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość pierwszego <paramref name="initializers" /> elementu nie można przypisać do typu argumentu metody <paramref name="newExpression" />Add. Typ lub jego typ podstawowy.  
  
—lub— 
W systemie <paramref name="newExpression" />istnieje więcej niż jedna metoda zgodna z argumentami o nazwie "Add" (bez uwzględniania wielkości liter). Typ i/lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.ListInitExpression" /> , który używa <see cref="T:System.Linq.Expressions.ElementInit" /> określonych obiektów do zainicjowania kolekcji.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> A, który <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ma<see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.ListInitExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>. <xref:System.Linq.Expressions.Expression.Type%2A> `newExpression`  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metody do <xref:System.Linq.Expressions.ListInitExpression> utworzenia, która reprezentuje inicjalizację nowego wystąpienia słownika z dwiema parami klucz-wartość.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> wypełnienia kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.ListInitExpression" /> Tworzy, który używa metody o nazwie "Add", aby dodać elementy do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ma<see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>. <xref:System.Linq.Expressions.Expression.Type%2A> `newExpression`  
  
 Aby można było użyć tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>,. `newExpression` Typ lub jego typ podstawowy muszą deklarować pojedynczą metodę o nazwie "Add" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Typ argumentu musi być możliwy do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość pierwszego `initializers`elementu.  
  
 Właściwość zwracanego <xref:System.Linq.Expressions.ListInitExpression> elementu zawiera jeden element `initializers`typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwość każdego elementu jest kolekcją pojedynczą, która `initializers`zawiera odpowiedni element. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwość każdego elementu reprezentuje metodę Add, która została wykryta. `newExpression` <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Typ lub jego typ podstawowy.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie istnieje metoda wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter) <paramref name="newExpression" />zadeklarowanej w elemencie. Typ lub jego typ podstawowy.  
  
—lub— 
Metoda Add dla <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jednego argumentu.  
  
—lub— 
Typu reprezentowanego przez <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość pierwszego <paramref name="initializers" /> elementu nie można przypisać do typu argumentu metody <paramref name="newExpression" />Add. Typ lub jego typ podstawowy.  
  
—lub— 
W systemie <paramref name="newExpression" />istnieje więcej niż jedna metoda zgodna z argumentami o nazwie "Add" (bez uwzględniania wielkości liter). Typ i/lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="addMethod"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter), która dodaje element do kolekcji.</param>
        <param name="initializers">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <summary><see cref="T:System.Linq.Expressions.ListInitExpression" /> Tworzy, który używa określonej metody do dodawania elementów do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ma<see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>. <xref:System.Linq.Expressions.Expression.Type%2A> `newExpression`  
  
 Jeśli `addMethod` jest `null`, .`newExpression` Typ lub jego typ podstawowy muszą deklarować pojedynczą metodę o nazwie "Add" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Jeśli `addMethod` nie jest `null`, musi reprezentować metodę wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter), która ma dokładnie jeden parametr. Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość każdego `initializers` elementu musi być możliwy do przypisania do typu argumentu metody Add.  
  
 Właściwość zwracanego <xref:System.Linq.Expressions.ListInitExpression> elementu zawiera jeden element `initializers`typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwość każdego elementu jest kolekcją pojedynczą, która `initializers`zawiera odpowiedni element. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwość każdego elementu jest równa `addMethod`. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.AddMethod%2A>  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.  
  
—lub— 
 <paramref name="addMethod" />nie jest <see langword="null" /> i nie reprezentuje metody wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument.  
  
—lub— 
 <paramref name="addMethod" />nie <see langword="null" /> jest, a typ reprezentowany <see cref="P:System.Linq.Expressions.Expression.Type" /> przez właściwość <paramref name="initializers" /> co najmniej jednego elementu nie może zostać przypisany do typu argumentu metody, która <paramref name="addMethod" /> reprezentuje.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="addMethod" />nie <see langword="null" /> jest ani metoda wystąpienia o nazwie "Add", która ma jeden argument zgodny z typem <paramref name="newExpression" />istnieje w. Typ lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="addMethod"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę wystąpienia, która przyjmuje jeden argument, który dodaje element do kolekcji.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> wypełnienia kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.ListInitExpression" /> Tworzy, który używa określonej metody do dodawania elementów do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ma<see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>. <xref:System.Linq.Expressions.Expression.Type%2A> `newExpression`  
  
 Jeśli `addMethod` jest `null`, .`newExpression` Typ lub jego typ podstawowy muszą deklarować pojedynczą metodę o nazwie "Add" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument. Jeśli `addMethod` nie jest `null`, musi reprezentować metodę wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter), która ma dokładnie jeden parametr. Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość każdego `initializers` elementu musi być możliwy do przypisania do typu argumentu metody Add.  
  
 Właściwość zwracanego <xref:System.Linq.Expressions.ListInitExpression> elementu zawiera jeden element `initializers`typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwość każdego elementu jest kolekcją pojedynczą, która `initializers`zawiera odpowiedni element. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwość każdego elementu jest równa `addMethod`. <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> <xref:System.Linq.Expressions.ElementInit.AddMethod%2A>  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element <paramref name="initializers" />. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.  
  
—lub— 
 <paramref name="addMethod" />nie jest <see langword="null" /> i nie reprezentuje metody wystąpienia o nazwie "Add" (bez uwzględniania wielkości liter), która przyjmuje dokładnie jeden argument.  
  
—lub— 
 <paramref name="addMethod" />nie <see langword="null" /> jest, a typ reprezentowany <see cref="P:System.Linq.Expressions.Expression.Type" /> przez właściwość <paramref name="initializers" /> co najmniej jednego elementu nie może zostać przypisany do typu argumentu metody, która <paramref name="addMethod" /> reprezentuje.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="addMethod" />nie <see langword="null" /> jest ani metoda wystąpienia o nazwie "Add", która ma jeden argument zgodny z typem <paramref name="newExpression" />istnieje w. Typ lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.LoopExpression" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body">Treść pętli.</param>
        <summary><see cref="T:System.Linq.Expressions.LoopExpression" /> Tworzy z podaną treścią.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body">Treść pętli.</param>
        <param name="break">Element docelowy Break używany przez treść pętli.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.LoopExpression" /> z podaną treścią i elementem docelowym Break.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie bloku zawierające <xref:System.Linq.Expressions.LoopExpression> obiekt.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body">Treść pętli.</param>
        <param name="break">Element docelowy Break używany przez treść pętli.</param>
        <param name="continue">Element docelowy kontynuacji używany przez treść pętli.</param>
        <summary><see cref="T:System.Linq.Expressions.LoopExpression" /> Tworzy z podaną treścią.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.BinaryExpression" /> Tworzy przez wywołanie odpowiedniej metody fabryki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><see cref="T:System.Linq.Expressions.ExpressionType" /> Określa typ operacji binarnej.</param>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje lewy operand.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje prawy operand.</param>
        <summary><see cref="T:System.Linq.Expressions.BinaryExpression" />Tworzy, za pomocą lewego i prawego operandu, przez wywołanie odpowiedniej metody fabryki.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> Wynika to z wywołania odpowiedniej metody fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr określa metodę fabryki <xref:System.Linq.Expressions.BinaryExpression> wywoływaną przez tę metodę. `binaryType` Na przykład, jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> metody w celu <xref:System.Linq.Expressions.BinaryExpression> utworzenia, która reprezentuje odejmowanie jednej liczby z innego.  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" />nie odpowiada węzłowi wyrażenia binarnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType"><see cref="T:System.Linq.Expressions.ExpressionType" /> Określa typ operacji binarnej.</param>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje lewy operand.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje prawy operand.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , która określa metodę implementującą.</param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.BinaryExpression" />na podstawie lewego operandu, prawy operand i metodę implementującą, wywołując odpowiednią metodę fabryki.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> Wynika to z wywołania odpowiedniej metody fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr określa metodę fabryki <xref:System.Linq.Expressions.BinaryExpression> , która będzie wywoływana przez tę metodę. `binaryType` Na przykład, jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>. Parametry `liftToNull` i`method` są ignorowane, Jeśli odpowiednia metoda fabryki nie ma odpowiadającego mu parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" />nie odpowiada węzłowi wyrażenia binarnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><see cref="T:System.Linq.Expressions.ExpressionType" /> Określa typ operacji binarnej.</param>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje lewy operand.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje prawy operand.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , która określa metodę implementującą.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> Reprezentujący funkcję konwersji typu. Ten parametr jest używany tylko w <paramref name="binaryType" /> przypadku <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> przypisania złożonego.</param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.BinaryExpression" />na podstawie lewego operandu, prawego operandu, implementując metodę i funkcję konwersji typu, wywołując odpowiednią metodę fabryki.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> Wynika to z wywołania odpowiedniej metody fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr określa metodę fabryki <xref:System.Linq.Expressions.BinaryExpression> , która będzie wywoływana przez tę metodę. `binaryType` Na przykład, jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>. Parametry i `method` `liftToNull` są`conversion` ignorowane, Jeśli odpowiednia metoda fabryki nie ma odpowiadającego mu parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" />nie odpowiada węzłowi wyrażenia binarnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Ta wartość zostanie<see cref="P:System.Linq.Expressions.Expression.Type" />obsłużyć. <see cref="T:System.Exception" /> <see cref="T:System.Linq.Expressions.CatchBlock" /></param>
        <param name="variable"><see cref="T:System.Linq.Expressions.ParameterExpression" /> Reprezentuje odwołanie<see cref="T:System.Exception" /> do obiektu przechwytywanego przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch z określonymi elementami.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type`musi mieć wartość różną od null i być zgodne z `variable` typem elementu (jeśli jest dostarczany).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A,któryma<see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />równe i ma wartość, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma ustawioną określoną wartość. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i jeden argument.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A,któryma<see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />równe i ma wartość, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma ustawioną określoną wartość. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A,któryma<see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />równe i ma wartość, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma ustawioną określoną wartość. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez podane <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i dwa argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A,któryma<see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />równe i ma wartość, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma ustawioną określoną wartość. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez dostarczone <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i trzy argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A,któryma<see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />równe i ma wartość, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma ustawioną określoną wartość. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Spinacz środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <param name="arg3">Czwarty argument operacji dynamicznej.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną powiązaną przez dostarczone <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i cztery argumenty.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> A,któryma<see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />równe i ma wartość, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ma ustawioną określoną wartość. <see cref="T:System.Linq.Expressions.DynamicExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="kind"><see cref="T:System.Linq.Expressions.GotoExpressionKind" /> z <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="value">Wartość, która zostanie przeniesiona do skojarzonej etykiety po przejściu.</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący skok określonego <see cref="T:System.Linq.Expressions.GotoExpressionKind" />elementu. Można również określić wartość przekazaną do etykiety przy przejściu.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" /> A<paramref name="kind" />równa, Właściwośćustawiona<paramref name="target" />na, Właściwośćustawiona<paramref name="type" />na i<paramref name="value" /> do przesłania do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.Expression.Type" /> <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Jeśli właściwość jest <see langword="static" /> (<see langword="shared" /> w Visual Basic) powinna mieć wartość null.</param>
        <param name="indexer"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje właściwość do indeksowania.</param>
        <param name="arguments"><c>&lt;Wyrażenie"&gt; IEnumerable</c> " (<c>wyrażenie)</c> w Visual Basic), które zawiera argumenty, które zostaną użyte do indeksowania właściwości.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostęp do indeksowanej właściwości w obiekcie.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje obiekt, do którego należy element członkowski. Może to mieć wartość null w przypadku statycznych elementów członkowskich.</param>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> Zawiera opis pola lub właściwości, które mają być dostępne.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do pola lub właściwości.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" /> Wynika to z wywołania odpowiedniej metody fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć do utworzenia <xref:System.Linq.Expressions.MemberExpression> , która reprezentuje dostęp do pola lub właściwości, w zależności od `member`typu. Jeśli `member` jest typu <xref:System.Reflection.FieldInfo>, <xref:System.Linq.Expressions.Expression.Field%2A> Ta<xref:System.Linq.Expressions.MemberExpression>metoda wywołuje, aby utworzyć. Jeśli `member` jest typu <xref:System.Reflection.PropertyInfo>, <xref:System.Linq.Expressions.Expression.Property%2A> Ta<xref:System.Linq.Expressions.MemberExpression>metoda wywołuje, aby utworzyć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />nie reprezentuje pola lub właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku wyrażenia try. Jeśli wartość jest równa null, treść i wszystkie programy obsługi muszą mieć identyczny typ.</param>
        <param name="body">Treść bloku try.</param>
        <param name="finally">Treść bloku finally. Przekaż wartość null, jeśli blok try nie ma skojarzonego bloku finally.</param>
        <param name="fault">Treść bloku błędu. Przekaż wartość null, jeśli blok try nie ma skojarzonego z nim bloku błędu.</param>
        <param name="handlers">Kolekcja <see cref="T:System.Linq.Expressions.CatchBlock" />s reprezentująca instrukcje catch, które mają być skojarzone z blokiem try.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący blok try z określonymi elementami.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy przez wywołanie odpowiedniej metody fabryki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType"><see cref="T:System.Linq.Expressions.ExpressionType" /> Określa typ operacji jednoargumentowej.</param>
        <param name="operand"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje operand.</param>
        <param name="type">Określa typ do przekonwertowania na <see langword="null" /> (jeśli nie dotyczy). <see cref="T:System.Type" /></param>
        <summary>Tworzy, <see cref="T:System.Linq.Expressions.UnaryExpression" />na podstawie operandu, wywołanie odpowiedniej metody fabryki.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Wynika to z wywołania odpowiedniej metody fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr określa metodę fabryki <xref:System.Linq.Expressions.UnaryExpression> wywoływaną przez tę metodę. `unaryType` Na przykład, jeśli `unaryType` jest <xref:System.Linq.Expressions.ExpressionType.Convert>równe, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>. `type`Parametr jest ignorowany, jeśli nie ma zastosowania do metody fabryki, która jest wywoływana.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="operand" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unaryType" />nie odpowiada jednoargumentowym węzłem wyrażenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType"><see cref="T:System.Linq.Expressions.ExpressionType" /> Określa typ operacji jednoargumentowej.</param>
        <param name="operand"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentuje operand.</param>
        <param name="type">Określa typ do przekonwertowania na <see langword="null" /> (jeśli nie dotyczy). <see cref="T:System.Type" /></param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary>Tworzy obiekt <see cref="T:System.Linq.Expressions.UnaryExpression" />, na podstawie operandu i metody implementującej, wywołując odpowiednią metodę fabryki.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Wynika to z wywołania odpowiedniej metody fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr określa metodę fabryki <xref:System.Linq.Expressions.UnaryExpression> wywoływaną przez tę metodę. `unaryType` Na przykład, jeśli `unaryType` jest <xref:System.Linq.Expressions.ExpressionType.Convert>równe, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>. Parametry `type` i`method` są ignorowane, jeśli nie mają zastosowania do metody fabryki, która jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="operand" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unaryType" />nie odpowiada jednoargumentowym węzłem wyrażenia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne Inicjowanie elementów członkowskich.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> Aby<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawić właściwość równą.</param>
        <param name="bindings">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.MemberBinding" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne Inicjowanie elementów członkowskich pola lub właściwości.</summary>
        <returns><see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> A, który <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ma<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberMemberBinding" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` Parametr musi reprezentować pole lub właściwość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />nie reprezentuje pola lub właściwości.  
  
—lub— 
Właściwość elementu nie reprezentuje składowej typu pola lub właściwości <paramref name="member" /> reprezentowanej przez. <paramref name="bindings" /> <see cref="P:System.Linq.Expressions.MemberBinding.Member" /></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> Aby<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> ustawić właściwość równą.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne Inicjowanie elementów członkowskich pola lub właściwości.</summary>
        <returns><see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> A, który <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ma<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberMemberBinding" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` Parametr musi reprezentować pole lub właściwość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />nie reprezentuje pola lub właściwości.  
  
—lub— 
Właściwość elementu nie reprezentuje składowej typu pola lub właściwości <paramref name="member" /> reprezentowanej przez. <paramref name="bindings" /> <see cref="P:System.Linq.Expressions.MemberBinding.Member" /></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę metody dostępu do właściwości.</param>
        <param name="bindings">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.MemberBinding" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne Inicjowanie elementów członkowskich, do których uzyskuje się dostęp przy użyciu metody dostępu do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> , który <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> ma <see cref="T:System.Reflection.PropertyInfo" /> <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> <paramref name="propertyAccessor" />Właściwość równą <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, właściwość ustawiona na, która reprezentuje właściwość, do której uzyskano dostęp w, i właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.MemberBinding.Member" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />nie reprezentuje metody akcesora właściwości.  
  
—lub— 
Właściwość elementu nie reprezentuje elementu członkowskiego typu właściwości, do którego uzyskuje dostęp Metoda, która <paramref name="propertyAccessor" /> reprezentuje. <paramref name="bindings" /> <see cref="P:System.Linq.Expressions.MemberBinding.Member" /></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę metody dostępu do właściwości.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne Inicjowanie elementów członkowskich, do których uzyskuje się dostęp przy użyciu metody dostępu do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> , który <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> ma <see cref="T:System.Reflection.PropertyInfo" /> <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> <paramref name="propertyAccessor" />Właściwość równą <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, właściwość ustawiona na, która reprezentuje właściwość, do której uzyskano dostęp w, i właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.MemberBinding.Member" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />nie reprezentuje metody akcesora właściwości.  
  
—lub— 
Właściwość elementu nie reprezentuje elementu członkowskiego typu właściwości, do którego uzyskuje dostęp Metoda, która <paramref name="propertyAccessor" /> reprezentuje. <paramref name="bindings" /> <see cref="P:System.Linq.Expressions.MemberBinding.Member" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="bindings">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.MemberBinding" /></param>
        <summary>Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> A, który <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ma<see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberInitExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.MemberInitExpression> <xref:System.Linq.Expressions.Expression.Type%2A> jest`newExpression`równawłaściwości. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość elementu nie reprezentuje składowej typu, który <paramref name="newExpression" />. <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> <paramref name="bindings" /> Typ reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> , aby <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> ustawić właściwość równą.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> wypełnienia kolekcji.</param>
        <summary><see cref="T:System.Linq.Expressions.MemberInitExpression" />Tworzy.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> A, który <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ma<see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberInitExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.MemberInitExpression> <xref:System.Linq.Expressions.Expression.Type%2A> jest`newExpression`równawłaściwości. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> metody w celu <xref:System.Linq.Expressions.MemberInitExpression> utworzenia, która reprezentuje inicjalizację dwóch elementów członkowskich nowego obiektu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość elementu nie reprezentuje składowej typu, który <paramref name="newExpression" />. <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> <paramref name="bindings" /> Typ reprezentuje.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący liczbę operacji pozostałej arytmetycznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący liczbę operacji pozostałej arytmetycznej.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub reprezentuje`right` Typzdefiniowanyprzezużytkownika,któryprzeciążaoperatormodulo,tooznacza,żemetodajest<xref:System.Reflection.MethodInfo> metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora modułu.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator modulo nie jest zdefiniowany dla <paramref name="left" />elementu. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący liczbę operacji pozostałej arytmetycznej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Metoda implementująca dla operacji jest wybierana na podstawie następujących reguł:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje <xref:System.Reflection.MethodInfo> typ zdefiniowany przez użytkownika, który przeciąża operator modulo, to oznacza, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora modułu.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator modulo nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący resztę operacji przypisania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący resztę operacji przypisania.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący resztę operacji przypisania.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący resztę operacji przypisania.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację mnożenia, która nie ma sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację mnożenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator mnożenia, to oznacza, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora mnożenia.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora mnożenia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które mnoży dwie wartości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora mnożenia dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację mnożenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, <xref:System.Reflection.MethodInfo> który przeciąża operator mnożenia, to oznacza metodę implementującą metodę.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora mnożenia.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora mnożenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator mnożenia nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która nie ma sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która nie ma sprawdzania przepełnienia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetycznego, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetycznego, która ma sprawdzanie przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator mnożenia, to oznacza, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora mnożenia.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora mnożenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora mnożenia dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację mnożenia arytmetycznego, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, <xref:System.Reflection.MethodInfo> który przeciąża operator mnożenia, to oznacza metodę implementującą metodę.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora mnożenia.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora mnożenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator mnożenia nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący arytmetyczną operację negacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący arytmetyczną operację negacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są one fałszywe.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator minus <xref:System.Reflection.MethodInfo> , który reprezentuje operatora to metoda implementująca.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typem liczbowym, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ wartości niedopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentujące arytmetyczną operację negacji.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy operator minus nie jest zdefiniowany <paramref name="expression" />dla. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący arytmetyczną operację negacji.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> A, który <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.UnaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są one fałszywe.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest, i reprezentuje metodę inną niż void (w Visual Basic), która przyjmuje jeden argument, jest to metoda implementująca dla tego węzła.  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator minus <xref:System.Reflection.MethodInfo> , który reprezentuje operatora to metoda implementująca.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typem liczbowym, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ wartości niedopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator jednoargumentowy minus nie jest zdefiniowany <paramref name="expression" />dla. Wprowadź.  
  
—lub— 
 <paramref name="expression" />. Typ (lub odpowiedni typ niedopuszczający wartości null, jeśli jest typem wartości null), nie można przypisać do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący arytmetyczną operację negacji, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący arytmetyczną operację negacji, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są one fałszywe.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator minus <xref:System.Reflection.MethodInfo> , który reprezentuje operatora to metoda implementująca.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typem liczbowym, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ wartości niedopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy operator minus nie jest zdefiniowany <paramref name="expression" />dla. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący arytmetyczną operację negacji, która ma sprawdzanie przepełnienia. Można określić metodę implementującą.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> A, który <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.UnaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są one fałszywe.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest, i reprezentuje metodę inną niż void (w Visual Basic), która przyjmuje jeden argument, jest to metoda implementująca dla tego węzła.  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator minus <xref:System.Reflection.MethodInfo> , który reprezentuje operatora to metoda implementująca.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typem liczbowym, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ wartości niedopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator jednoargumentowy minus nie jest zdefiniowany <paramref name="expression" />dla. Wprowadź.  
  
—lub— 
 <paramref name="expression" />. Typ (lub odpowiedni typ niedopuszczający wartości null, jeśli jest typem wartości null), nie można przypisać do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.NewExpression" />Tworzy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> Aby<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywoływanie określonego konstruktora, który nie przyjmuje argumentów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ma<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Linq.Expressions.NewExpression.Arguments%2A> <xref:System.Linq.Expressions.NewExpression> i <xref:System.Linq.Expressions.NewExpression.Members%2A> wypływające są puste kolekcje. Właściwość reprezentuje typ deklarujący konstruktora reprezentowanego przez `constructor`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Konstruktor, który <paramref name="constructor" /> reprezentuje, zawiera co najmniej jeden parametr.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> , który ma konstruktora, który nie przyjmuje argumentów.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywoływanie konstruktora bez parametrów określonego typu.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.NewExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.New" /> <see cref="T:System.Reflection.ConstructorInfo" /> Właściwość równą i właściwość, która reprezentuje konstruktora bez parametrów dla określonego typu. <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` Parametr musi reprezentować typ, który ma Konstruktor bez parametrów.  
  
 Właściwości <xref:System.Linq.Expressions.NewExpression.Arguments%2A> <xref:System.Linq.Expressions.NewExpression> i <xref:System.Linq.Expressions.NewExpression.Members%2A> wypływające są puste kolekcje. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa `type`.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.New%28System.Type%29> metody w celu <xref:System.Linq.Expressions.NewExpression> utworzenia, która reprezentuje konstruowanie nowego wystąpienia obiektu słownika przez wywołanie konstruktora bez parametrów.  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ <paramref name="type" /> reprezentujący nie ma konstruktora bez parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> Aby<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> ustawić właściwość równą.</param>
        <param name="arguments">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywoływanie określonego konstruktora z określonymi argumentami.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.New" /> A, który <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.NewExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi zawierać taką samą liczbę elementów jak liczba parametrów dla konstruktora reprezentowanego przez `constructor`. `arguments` Jeśli `arguments` jest `null`, <xref:System.Linq.Expressions.NewExpression> jest<xref:System.Linq.Expressions.NewExpression.Arguments%2A> uznawana za pusty, a właściwość będąca wynikiem jest pustą kolekcją.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora reprezentowanego przez `constructor`. <xref:System.Linq.Expressions.Expression.Type%2A> <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />jest <see langword="null" />.  
  
—lub— 
Element <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Parametr nie zawiera takiej samej liczby elementów jak liczba parametrów dla konstruktora, który <paramref name="constructor" /> reprezentuje. <paramref name="arguments" />  
  
—lub— 
Właściwość elementu nie <paramref name="constructor" /> może zostać przypisana do typu odpowiadającego mu parametru konstruktora, który reprezentuje. <paramref name="arguments" /> <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> Aby<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> ustawić właściwość równą.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywoływanie określonego konstruktora z określonymi argumentami.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.New" /> A, który <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ma<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.NewExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi zawierać taką samą liczbę elementów jak liczba parametrów dla konstruktora reprezentowanego przez `constructor`. `arguments` Jeśli `arguments` jest `null`, <xref:System.Linq.Expressions.NewExpression> jest<xref:System.Linq.Expressions.NewExpression.Arguments%2A> uznawana za pusty, a właściwość będąca wynikiem jest pustą kolekcją.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora reprezentowanego przez `constructor`. <xref:System.Linq.Expressions.Expression.Type%2A> <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />jest <see langword="null" />.  
  
—lub— 
Element <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="arguments" /> jest równa liczbie parametrów konstruktora, który <paramref name="constructor" /> reprezentuje.  
  
—lub— 
Właściwość elementu nie <paramref name="constructor" /> może zostać przypisana do typu odpowiadającego mu parametru konstruktora, który reprezentuje. <paramref name="arguments" /> <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> Aby<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> ustawić właściwość równą.</param>
        <param name="arguments">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <param name="members">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.NewExpression.Members" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Reflection.MemberInfo" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywoływanie określonego konstruktora z określonymi argumentami. Określono elementy członkowskie, które uzyskują dostęp do zainicjowanego konstruktora pól.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.New" /> , który ma <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> <see cref="P:System.Linq.Expressions.NewExpression.Members" /> Właściwość równą i, oraz właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi zawierać taką samą liczbę elementów jak liczba parametrów dla konstruktora reprezentowanego przez `constructor`. `arguments` Jeśli `arguments` jest `null`, <xref:System.Linq.Expressions.NewExpression> jest<xref:System.Linq.Expressions.NewExpression.Arguments%2A> uznawana za pusty, a właściwość będąca wynikiem jest pustą kolekcją.  
  
 Jeśli `members` ma `null`wartość <xref:System.Linq.Expressions.NewExpression> , <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość będąca wynikiem jest pustą kolekcją. Jeśli `members` `arguments` `null`nie `null`jest, musi mieć taką samą liczbę elementów jak i każdy element nie może być. Każdy element elementu `members` musi <xref:System.Reflection.PropertyInfo>być <xref:System.Reflection.FieldInfo> `constructor`lub <xref:System.Reflection.MethodInfo> reprezentujący element członkowski wystąpienia w typie deklarującym konstruktora reprezentowanego przez. Jeśli reprezentuje właściwość, właściwość musi mieć `get` akcesor. Odpowiadający element `arguments` dla każdego `members` elementu obiektu musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość reprezentującą typ, który `members` można przypisać do typu elementu członkowskiego reprezentowanego przez element.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, który `constructor` reprezentuje. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />jest <see langword="null" />.  
  
—lub— 
Element <paramref name="arguments" /> jest <see langword="null" />.  
  
—lub— 
Element <paramref name="members" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Parametr nie zawiera takiej samej liczby elementów jak liczba parametrów dla konstruktora, który <paramref name="constructor" /> reprezentuje. <paramref name="arguments" />  
  
—lub— 
Właściwość elementu nie <paramref name="constructor" /> może zostać przypisana do typu odpowiadającego mu parametru konstruktora, który reprezentuje. <paramref name="arguments" /> <see cref="P:System.Linq.Expressions.Expression.Type" />  
  
—lub— 
Parametr nie ma takiej samej liczby elementów jak <paramref name="arguments" />. <paramref name="members" />  
  
—lub— 
Element <paramref name="arguments" /> <paramref name="members" />ma właściwość, która reprezentuje typ, który nie jest możliwy do przypisania do typu elementu członkowskiego reprezentowanego przez odpowiadający mu element elementu. <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> Aby<see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> ustawić właściwość równą.</param>
        <param name="arguments">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <param name="members">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.NewExpression.Members" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywoływanie określonego konstruktora z określonymi argumentami. Elementy członkowskie, które mają dostęp do zainicjowanego konstruktora pól, są określone jako tablica.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.New" /> , który ma <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> <see cref="P:System.Linq.Expressions.NewExpression.Members" /> Właściwość równą i, oraz właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr musi zawierać taką samą liczbę elementów jak liczba parametrów dla konstruktora reprezentowanego przez `constructor`. `arguments` Jeśli `arguments` jest `null`, <xref:System.Linq.Expressions.NewExpression> jest<xref:System.Linq.Expressions.NewExpression.Arguments%2A> uznawana za pusty, a właściwość będąca wynikiem jest pustą kolekcją.  
  
 Jeśli `members` ma `null`wartość <xref:System.Linq.Expressions.NewExpression> , <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość będąca wynikiem jest pustą kolekcją. Jeśli `members` `arguments` `null`nie `null`jest, musi mieć taką samą liczbę elementów jak i każdy element nie może być. Każdy element elementu `members` musi <xref:System.Reflection.PropertyInfo>być <xref:System.Reflection.FieldInfo> `constructor`lub <xref:System.Reflection.MethodInfo> reprezentujący element członkowski wystąpienia w typie deklarującym konstruktora reprezentowanego przez. Jeśli reprezentuje właściwość, właściwość musi mieć możliwość pobrania wartości skojarzonego pola. Odpowiadający element `arguments` dla każdego `members` elementu obiektu musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość reprezentującą typ, który `members` można przypisać do typu elementu członkowskiego reprezentowanego przez element.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, który `constructor` reprezentuje. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />jest <see langword="null" />.  
  
—lub— 
Element <paramref name="arguments" /> jest <see langword="null" />.  
  
—lub— 
Element <paramref name="members" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Parametr nie zawiera takiej samej liczby elementów jak liczba parametrów dla konstruktora, który <paramref name="constructor" /> reprezentuje. <paramref name="arguments" />  
  
—lub— 
Właściwość elementu nie <paramref name="constructor" /> może zostać przypisana do typu odpowiadającego mu parametru konstruktora, który reprezentuje. <paramref name="arguments" /> <see cref="P:System.Linq.Expressions.Expression.Type" />  
  
—lub— 
Parametr nie ma takiej samej liczby elementów jak <paramref name="arguments" />. <paramref name="members" />  
  
—lub— 
Element <paramref name="arguments" /> <paramref name="members" />ma właściwość, która reprezentuje typ, który nie jest możliwy do przypisania do typu elementu członkowskiego reprezentowanego przez odpowiadający mu element elementu. <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, która ma określoną rangę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Reprezentujący typ elementu tablicy.</param>
        <param name="bounds">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, która ma określoną rangę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> ma<see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której ranga jest `bounds` równa długości i której typem elementu jest `type`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość każdego`bounds` elementu musi reprezentować typ całkowity.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metody w celu utworzenia drzewa wyrażenia, które reprezentuje tablicę ciągów, która ma rangę 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />lub <paramref name="bounds" /> jest <see langword="null" />.  
  
—lub— 
Element <paramref name="bounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość<paramref name="bounds" /> elementu nie reprezentuje typu całkowitego.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Reprezentujący typ elementu tablicy.</param>
        <param name="bounds">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, która ma określoną rangę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> ma<see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której ranga jest `bounds` równa długości i której typem elementu jest `type`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość każdego`bounds` elementu musi reprezentować typ całkowity.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metody w celu utworzenia drzewa wyrażenia, które reprezentuje tablicę ciągów, która ma rangę 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />lub <paramref name="bounds" /> jest <see langword="null" />.  
  
—lub— 
Element <paramref name="bounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość<paramref name="bounds" /> elementu nie reprezentuje typu całkowitego.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie jednowymiarowej tablicy i Inicjowanie jej z listy elementów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Reprezentujący typ elementu tablicy.</param>
        <param name="initializers">Zawiera <see cref="T:System.Collections.Generic.IEnumerable`1" /> <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> obiekty, które mają być używane do wypełniania kolekcji. <see cref="T:System.Linq.Expressions.Expression" /></param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie jednowymiarowej tablicy i Inicjowanie jej z listy elementów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> ma<see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość każdego `type`elementu musi reprezentować typ, który można przypisać do typu reprezentowanego przez, prawdopodobnie po cudzysłowie. ** `initializers` <xref:System.Linq.Expressions.Expression.Type%2A>  
  
> [!NOTE]
>  Element zostanie ujęty w cudzysłów tylko `type` wtedy <xref:System.Linq.Expressions.Expression>, gdy jest. QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`initializers`właściwość jest elementem elementu.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której ranga to 1 i którego typem elementu jest `type`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metody w celu utworzenia drzewa wyrażenia, które reprezentuje tworzenie jednowymiarowej tablicy ciągów, która jest inicjowana za pomocą listy wyrażeń ciągów.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Element <paramref name="initializers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Właściwość elementu reprezentuje typ, którego nie można przypisać do typu, który <paramref name="type" /> reprezentuje. <paramref name="initializers" /> <see cref="P:System.Linq.Expressions.Expression.Type" /></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Reprezentujący typ elementu tablicy.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> wypełnienia kolekcji.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie jednowymiarowej tablicy i Inicjowanie jej z listy elementów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> ma<see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość każdego `type`elementu musi reprezentować typ, który można przypisać do typu reprezentowanego przez, prawdopodobnie po cudzysłowie. ** `initializers` <xref:System.Linq.Expressions.Expression.Type%2A>  
  
> [!NOTE]
>  Element zostanie ujęty w cudzysłów tylko `type` wtedy <xref:System.Linq.Expressions.Expression>, gdy jest. QUOTE oznacza, że element jest opakowany <xref:System.Linq.Expressions.ExpressionType.Quote> w węźle. Węzeł <xref:System.Linq.Expressions.UnaryExpression> , <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> którego`initializers`właściwość jest elementem elementu.  
  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, której ranga to 1 i którego typem elementu jest `type`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metody w celu utworzenia drzewa wyrażenia, które reprezentuje tworzenie jednowymiarowej tablicy ciągów, która jest inicjowana za pomocą listy wyrażeń ciągów.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />lub <paramref name="initializers" /> jest <see langword="null" />.  
  
—lub— 
Element <paramref name="initializers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Właściwość elementu reprezentuje typ, którego nie można przypisać do typu <paramref name="type" />. <see cref="P:System.Linq.Expressions.Expression.Type" /> <paramref name="initializers" /></exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ <see cref="T:System.Linq.Expressions.Expression" />węzła.</summary>
        <value>Jedna z <see cref="T:System.Linq.Expressions.ExpressionType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zawiera bardziej wyspecjalizowany opis typu, <xref:System.Linq.Expressions.Expression> a nie tylko jego typ pochodny. <xref:System.Linq.Expressions.Expression.NodeType%2A> Na przykład, <xref:System.Linq.Expressions.BinaryExpression> można użyć do reprezentowania wielu różnych rodzajów wyrażeń binarnych, takich jak operacja dzielenia lub operacji "większe niż". Właściwość będzie zawierać opis tych <xref:System.Linq.Expressions.ExpressionType.Divide> wyrażeń binarnych odpowiednio <xref:System.Linq.Expressions.ExpressionType.GreaterThan>do i. <xref:System.Linq.Expressions.Expression.NodeType%2A>  
  
 Statyczny typ CLR wyrażenia, które <xref:System.Linq.Expressions.Expression> reprezentuje obiekt, jest reprezentowany <xref:System.Linq.Expressions.Expression.Type%2A> przez właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator not <xref:System.Reflection.MethodInfo> , który reprezentuje ten operator jako metodę implementującą.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typu liczbowego lub logicznego, Metoda implementująca `null`to.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ nie dopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentujące logiczne nie operację.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora jednoargumentowego not <paramref name="expression" />dla elementu. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego. Można określić metodę implementującą.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> A, który <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.UnaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest, i reprezentuje metodę inną niż void (w Visual Basic), która przyjmuje jeden argument, jest to metoda implementująca dla tego węzła.  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator not <xref:System.Reflection.MethodInfo> , który reprezentuje ten operator jako metodę implementującą.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typem liczbowym, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ wartości niedopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator jednoargumentowy nie jest zdefiniowany dla <paramref name="expression" />elementu. Wprowadź.  
  
—lub— 
 <paramref name="expression" />. Typ (lub odpowiedni typ niedopuszczający wartości null, jeśli jest typem wartości null), nie można przypisać do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.BinaryExpression" /> Tworzy, który reprezentuje porównanie nierówności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.BinaryExpression" /> Tworzy, który reprezentuje porównanie nierówności.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość jest. `true` W przeciwnym razie jest `false`to. Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator nierówności, oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie metoda implementująca `null`ma wartość.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła <xref:System.Boolean>:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła to <xref:System.Boolean>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora nierówności dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="liftToNull"><see langword="true" />Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> na <see langword="true" />; , aby <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> ustawić wartość .<see langword="false" /> <see langword="false" /></param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.BinaryExpression" /> Tworzy, który reprezentuje porównanie nierówności.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> zostanie zniesiony, właściwość jest `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwość jest równa `liftToNull`. W przeciwnym razie są oba `false`te elementy. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który <xref:System.Reflection.MethodInfo> przeciąża operator nierówności, to oznacza metodę implementującą metodę.  
  
-   W przeciwnym razie metoda implementująca `null`ma wartość.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony; Ponadto typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Zwracany typ metody implementującej to <xref:System.Boolean>.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła to <xref:System.Boolean>.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ <xref:System.Boolean> węzła dopuszcza wartość null, jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator nierówności nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyrażenie reprezentujące te uzupełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">A <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Zwraca wyrażenie reprezentujące te uzupełnienia.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">A <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary>Zwraca wyrażenie reprezentujące te uzupełnienia.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="OR" /> .</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="OR" /> .</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `OR` reprezentuje<xref:System.Reflection.MethodInfo>Typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy całkowite lub logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora bitowego `OR` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `OR` operatora bitowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące logiczne lub operację.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora bitowego <see langword="OR" /> dla elementu. <paramref name="left" /> Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową <see langword="OR" /> .</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` `OR` reprezentuje<xref:System.Reflection.MethodInfo> typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza metodę implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy całkowite lub logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora bitowego `OR` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `OR` operatora bitowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operatorem <see langword="OR" /> bitowym nie jest zdefiniowany <paramref name="left" />dla. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową lub przypisanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową lub przypisanie.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową lub przypisanie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitową lub przypisanie.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację warunkową <see langword="OR" /> , która oblicza drugi operand tylko wtedy, gdy <see langword="false" />pierwszy operator szacuje wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację warunkową <see langword="OR" /> , która oblicza drugi operand tylko wtedy, gdy <see langword="false" />pierwszy operand zwraca wartość.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `OR` reprezentuje<xref:System.Reflection.MethodInfo>Typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza, że metoda jest metodą implementującą. `right`  
  
    > [!NOTE]
    >  Operator warunkowy `OR` nie może być przeciążony w C# ani Visual Basic. Operator warunkowy `OR` jest jednak oceniany przy użyciu operatora bitowego `OR` . W ten sposób zdefiniowane przez użytkownika Przeciążenie operatora bitowego `OR` może być metodą implementującą dla tego typu węzła.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   `left`. Wpisz i `right`. Typ jest tym samym typem Boolean.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora warunkowego `OR` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ dopuszcza wartość null, węzeł zostanie zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `OR` operatora warunkowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie reprezentujące operację logiczną `OR` , która oblicza drugi operand tylko wtedy, gdy pierwszy operand zwraca wartość. `false`  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora bitowego <see langword="OR" /> dla elementu. <paramref name="left" /> Wpisz i <paramref name="right" />. Wprowadź.  
  
—lub— 
 <paramref name="left" />. Wpisz i <paramref name="right" />. Typ nie jest tym samym typem Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację warunkową <see langword="OR" /> , która oblicza drugi operand tylko wtedy, gdy <see langword="false" />pierwszy operand zwraca wartość.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` `OR` reprezentuje<xref:System.Reflection.MethodInfo> typ zdefiniowany przez użytkownika, który przeciąża operator bitowy, to oznacza metodę implementującą.  
  
    > [!NOTE]
    >  Operator warunkowy `OR` nie może być przeciążony w C# ani Visual Basic. Operator warunkowy `OR` jest jednak oceniany przy użyciu operatora bitowego `OR` . W ten sposób zdefiniowane przez użytkownika Przeciążenie operatora bitowego `OR` może być metodą implementującą dla tego typu węzła.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy logiczne, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   `left`. Wpisz i `right`. Typ jest tym samym typem Boolean.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora warunkowego `OR` .  
  
-   Jeśli `left`. Wpisz i `right`. Typ dopuszcza wartość null, węzeł zostanie zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego `OR` operatora warunkowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operatorem <see langword="OR" /> bitowym nie jest zdefiniowany <paramref name="left" />dla. Wpisz i <paramref name="right" />. Wprowadź.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" /> i <paramref name="left" />. Wpisz i <paramref name="right" />. Typ nie jest tym samym typem Boolean.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ParameterExpression" /> Tworzy węzeł, który może służyć do identyfikowania parametru lub zmiennej w drzewie wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametru lub zmiennej.</param>
        <summary><see cref="T:System.Linq.Expressions.ParameterExpression" /> Tworzy węzeł, który może służyć do identyfikowania parametru lub zmiennej w drzewie wyrażenia.</summary>
        <returns><see cref="T:System.Linq.Expressions.ParameterExpression" /> Węzeł o określonej nazwie i typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć <xref:System.Linq.Expressions.MethodCallExpression> obiekt, który drukuje wartość <xref:System.Linq.Expressions.ParameterExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametru lub zmiennej.</param>
        <param name="name">Nazwa parametru lub zmiennej używana tylko do celów debugowania lub drukowania.</param>
        <summary><see cref="T:System.Linq.Expressions.ParameterExpression" /> Tworzy węzeł, który może służyć do identyfikowania parametru lub zmiennej w drzewie wyrażenia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> A, który <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ma<see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.ParameterExpression" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, po którym następuje kolejne zmniejszenie o 1 pierwotne wyrażenie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, po którym następuje kolejne zmniejszenie o 1 pierwotne wyrażenie.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, po którym następuje kolejne zmniejszenie o 1 pierwotne wyrażenie.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, po którym następuje kolejne zwiększenie o 1 pierwotne wyrażenie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, po którym następuje kolejne zwiększenie o 1 pierwotne wyrażenie.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, po którym następuje kolejne zwiększenie o 1 pierwotne wyrażenie.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenie liczby do potęgi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenie liczby do potęgi.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator wykładniczy, oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typ jest obu <xref:System.Double>, Metoda implementująca to <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora potęgowania dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.  
  
—lub— 
 <paramref name="left" />. Wpisz i/lub <paramref name="right" />. Typ nie <see cref="T:System.Double" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenie liczby do potęgi.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje metodę, `static` która nie jest typu void`Shared` (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, <xref:System.Reflection.MethodInfo> który przeciąża operator wykładniczy, oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typ jest obu <xref:System.Double>, Metoda implementująca to <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator wykładniczy nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.  
  
—lub— 
 <paramref name="method" />jest <see langword="null" /> i <paramref name="left" />. Wpisz i/lub <paramref name="right" />. Typ nie <see cref="T:System.Double" />jest.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący generowanie wyrażenia do potęgi i przypisywanie wyniku z powrotem do wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący generowanie wyrażenia do potęgi i przypisywanie wyniku z powrotem do wyrażenia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący generowanie wyrażenia do potęgi i przypisywanie wyniku z powrotem do wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący generowanie wyrażenia do potęgi i przypisywanie wyniku z powrotem do wyrażenia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy, która zmniejsza wyrażenie o 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy, która zmniejsza wyrażenie o 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy, która zmniejsza wyrażenie o 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy program, który zwiększa wyrażenie o 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy program, który zwiększa wyrażenie o 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do zastosowania operacji na.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę implementującą.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy program, który zwiększa wyrażenie o 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wynikowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawić właściwość równą. Może to mieć wartość null w przypadku właściwości statycznych.</param>
        <param name="propertyAccessor"><see cref="T:System.Reflection.MethodInfo" /> Reprezentuje metodę metody dostępu do właściwości.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do właściwości przy użyciu metody akcesora właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> <see cref="T:System.Reflection.PropertyInfo" /> <paramref name="propertyAccessor" />Właściwość równą <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <paramref name="expression" /> Właściwość ustawiona na i Właściwość ustawiona na, która reprezentuje właściwość, która jest używana w. <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.MemberExpression> <xref:System.Reflection.PropertyInfo.PropertyType%2A> jest<xref:System.Linq.Expressions.MemberExpression.Member%2A>równawłaściwości. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 `propertyAccessor` Jeśli metoda reprezentowana przez is jest `static` (`Shared` w Visual Basic), `expression` może być. `null`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />jest <see langword="null" />.  
  
—lub— 
Metoda, która <paramref name="propertyAccessor" /> reprezentuje nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) i <paramref name="expression" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />. Nie można przypisać typu do typu deklarującego metody reprezentowanej przez <paramref name="propertyAccessor" />.  
  
—lub— 
Metoda, która <paramref name="propertyAccessor" /> reprezentuje, nie jest metodą metody dostępu do właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> ustawić właściwość równą. Może to mieć wartość null w przypadku właściwości statycznych.</param>
        <param name="property"><see cref="T:System.Reflection.PropertyInfo" /> Aby<see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do właściwości.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> A, który <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ma<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.MemberExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.MemberExpression> <xref:System.Reflection.PropertyInfo.PropertyType%2A> jest<xref:System.Linq.Expressions.MemberExpression.Member%2A>równawłaściwości. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 `property` Jeśli właściwość reprezentowana przez is jest `static` (`Shared` w Visual Basic), `expression` może być. `null`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="property" />jest <see langword="null" />.  
  
—lub— 
Właściwość, która <paramref name="property" /> reprezentuje nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) i <paramref name="expression" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />. Nie można przypisać typu do typu deklarującego właściwości, która <paramref name="property" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Zawierający właściwość o nazwie<paramref name="propertyName" />. <see cref="T:System.Linq.Expressions.Expression" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> Może to być <see langword="null" /> dla właściwości statycznych.</param>
        <param name="propertyName">Nazwa właściwości do uzyskania dostępu.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> <paramref name="expression" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.MemberExpression.Member" /> , <see cref="T:System.Reflection.PropertyInfo" /> <paramref name="propertyName" />Właściwość ustawiona na, i Właściwość ustawiona na, która reprezentuje właściwość, która jest oznaczona przez. <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.MemberExpression> <xref:System.Reflection.PropertyInfo.PropertyType%2A> <xref:System.Reflection.PropertyInfo> Właściwość będąca wynikiem jest równa właściwości, która reprezentuje właściwość, która jest oznaczona przez `propertyName`. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 Ta metoda wyszukuje `expression`. Typ i jego typy podstawowe dla właściwości, która ma nazwę `propertyName`. Właściwości publiczne mają pierwszeństwo przed niepublicznymi właściwościami. Jeśli zostanie znaleziona zgodna właściwość, ta metoda przekazuje `expression` <xref:System.Reflection.PropertyInfo> i reprezentuje tę właściwość do <xref:System.Linq.Expressions.Expression.Property%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie reprezentujące dostęp do właściwości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="propertyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie zdefiniowano <paramref name="propertyName" /> właściwości o nazwie <paramref name="expression" />w. Typ lub jego typy podstawowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Jeśli właściwość jest statyczna/współdzielona, musi mieć wartość null.</param>
        <param name="indexer"><see cref="T:System.Reflection.PropertyInfo" /> Reprezentuje właściwość do indeksowania.</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Obiekty,któresą<see cref="T:System.Linq.Expressions.Expression" /> używane do indeksowania właściwości.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostęp do właściwości indeksowanej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Jeśli właściwość jest statyczna/współdzielona, musi mieć wartość null.</param>
        <param name="indexer"><see cref="T:System.Reflection.PropertyInfo" /> Reprezentuje właściwość do indeksowania.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, która jest używana do indeksowania właściwości.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostęp do właściwości indeksowanej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="propertyName" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do którego należy właściwość. Jeśli właściwość jest statyczna/współdzielona, musi mieć wartość null.</param>
        <param name="propertyName">Nazwa indeksatora.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, która jest używana do indeksowania właściwości.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentujący dostęp do właściwości indeksowanej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="propertyName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">Obiekt zawierający właściwość. Może to mieć wartość null w przypadku właściwości statycznych.</param>
        <param name="type"><see cref="P:System.Linq.Expressions.Expression.Type" /> Zawiera właściwość.</param>
        <param name="propertyName">Właściwość, do której ma zostać uzyskany dostęp.</param>
        <summary><see cref="T:System.Linq.Expressions.MemberExpression" /> Tworzy dostęp do właściwości.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">, Który <see cref="T:System.Linq.Expressions.Expression" />zawierawłaściwość lub pole o nazwie <paramref name="propertyOrFieldName" />. <see cref="P:System.Linq.Expressions.Expression.Type" /> Może to mieć wartość null w przypadku statycznych elementów członkowskich.</param>
        <param name="propertyOrFieldName">Nazwa właściwości lub pola do uzyskania dostępu.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentujący dostęp do właściwości lub pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> <paramref name="expression" /> Właściwośćrówną<see cref="P:System.Linq.Expressions.MemberExpression.Member" /> , <see cref="T:System.Reflection.PropertyInfo" /> <see cref="T:System.Reflection.FieldInfo" /> Właściwość ustawiona na, i Właściwość ustawiona na lub, która reprezentuje właściwość lub pole <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> wskazywane przez <paramref name="propertyOrFieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldInfo.FieldType%2A> <xref:System.Reflection.PropertyInfo.PropertyType%2A> <xref:System.Reflection.PropertyInfo> `propertyOrFieldName`Właściwość będąca wynikiem <xref:System.Linq.Expressions.MemberExpression> jest równa lub właściwości lub<xref:System.Reflection.FieldInfo>(odpowiednio), która reprezentuje właściwość lub pole oznaczone przez. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
 Ta metoda wyszukuje `expression`. Typ i jego typy podstawowe dla właściwości lub pola, które ma nazwę `propertyOrFieldName`. Właściwości publiczne i pola mają pierwszeństwo przed niepublicznymi właściwościami i polami. Ponadto właściwości mają pierwszeństwo przed polami. Jeśli zostanie znaleziona zgodna właściwość lub pole, ta metoda przekazuje `expression` <xref:System.Reflection.PropertyInfo> i lub <xref:System.Reflection.FieldInfo> reprezentuje tę właściwość lub pole odpowiednio do <xref:System.Linq.Expressions.Expression.Property%2A> lub <xref:System.Linq.Expressions.Expression.Field%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie reprezentujące dostęp do właściwości lub pola.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="propertyOrFieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie zdefiniowano właściwości ani <paramref name="propertyOrFieldName" /> pola o nazwie <paramref name="expression" />w elemencie. Typ lub jego typy podstawowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie, które ma stałą wartość typu <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> reprezentuje typ <xref:System.Linq.Expressions.Expression%601>skonstruowany, gdzie argument typu jest typem reprezentowane przez `expression`. <xref:System.Linq.Expressions.Expression.Type%2A> Wprowadź. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość jest`null`. Oba <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są .`false`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redukuje ten węzeł do prostszego wyrażenia. Jeśli redukcja zwróci wartość true, powinna zwracać prawidłowe wyrażenie. Ta metoda może zwrócić inny węzeł, który musi zostać zmniejszony.</summary>
        <returns>Zredukowane wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redukuje ten węzeł do prostszego wyrażenia. Jeśli redukcja zwróci wartość true, powinna zwracać prawidłowe wyrażenie. Ta metoda może zwrócić inny węzeł, który musi zostać zmniejszony.</summary>
        <returns>Zredukowane wyrażenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do zmniejszenia, ta metoda sprawdza, czy zredukowany węzeł spełnia pewne niewarianty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redukuje wyrażenie do znanego typu węzła (który nie jest węzłem rozszerzenia) lub po prostu zwraca wyrażenie, jeśli jest już znanym typem.</summary>
        <returns>Zredukowane wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości odwołań.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie nierówności.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne zgłoszenie wyjątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne zgłoszenie wyjątku.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący ponowne zgłoszenie wyjątku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Nowe <see cref="T:System.Type" /> wyrażenie.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne zgłoszenie wyjątku dla danego typu.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący ponowne zgłoszenie wyjątku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję return.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję return.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równą<paramref name="target" />Return, właściwość ustawioną na i wartość null do przesłania do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="value">Wartość, która zostanie przeniesiona do skojarzonej etykiety po przejściu.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję return. Wartość przeskoczy do etykiety po przejściu można określić.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> o <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> wartościrównej<paramref name="value" /> Continue, <paramref name="target" />Właściwość ustawiona na i do przesłania do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie zawierające <xref:System.Linq.Expressions.Expression.Return%2A> metodę.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.GotoExpression" /> Tworzy reprezentowanie instrukcji return z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> <see cref="P:System.Linq.Expressions.Expression.Type" /> <paramref name="type" />równej Return<paramref name="target" />, właściwość ustawiona na, właściwość ustawiona na i wartość null do przesłania do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" /> Przeskoczydo<see cref="T:System.Linq.Expressions.GotoExpression" /> .</param>
        <param name="value">Wartość, która zostanie przeniesiona do skojarzonej etykiety po przejściu.</param>
        <param name="type"><see cref="T:System.Type" /> Aby<see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.GotoExpression" /> Tworzy reprezentowanie instrukcji return z określonym typem. Wartość przeskoczy do etykiety po przejściu można określić.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.Expression.Type" /> <paramref name="value" /> <paramref name="type" />równej wartości Kontynuuj<paramref name="target" />, właściwość ustawiona na, właściwość ustawiona na, i do do etykiety docelowej po przejściu. <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przesunięcia w prawo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przesunięcia w prawo.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator przesunięcia w prawo, to oznacza, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Typ jest typem całkowitym (jednym z <xref:System.Byte> <xref:System.Int16>, <xref:System.SByte> <xref:System.UInt16> <xref:System.Int32> ,,<xref:System.UInt32>,,,,, lub odpowiednimi typami dopuszczającymi wartość null) i `right`. <xref:System.Int64> <xref:System.UInt64> Typ to <xref:System.Int32>, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który <xref:System.Reflection.MethodInfo> przeciąża operator przesunięcia w prawo, to oznacza, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Typ jest typem całkowitym (jednym z <xref:System.Byte> <xref:System.Int16>, <xref:System.SByte> <xref:System.UInt16> <xref:System.Int32> ,,<xref:System.UInt32>,,,,, lub odpowiednimi typami dopuszczającymi wartość null) i `right`. <xref:System.Int64> <xref:System.UInt64> Typ to <xref:System.Int32>, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w prawo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w prawo.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitową operację przypisywania w prawo.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variables">Kolekcja <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> wypełnienia kolekcji.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> , które <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ma<see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiektów do użycia w celu <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> wypełnienia kolekcji.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> , które <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ma<see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację odejmowania, która nie ma sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację odejmowania, która nie ma sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator odejmowania, oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora odejmowania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora odejmowania.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie odjęcie argumentu od pierwszego argumentu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora odejmowania dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację odejmowania, która nie ma sprawdzania przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, <xref:System.Reflection.MethodInfo> który przeciąża operator odejmowania, oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora odejmowania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora odejmowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która nie ma sprawdzania przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która nie ma sprawdzania przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która nie ma sprawdzania przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która nie ma sprawdzania przepełnienia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która ma sprawdzanie przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisywania odejmowania, która ma sprawdzanie przepełnienia.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />Właściwość równą i ,<see cref="P:System.Linq.Expressions.BinaryExpression.Method" />,, i<see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> właściwości ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację odejmowania, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację odejmowania, która ma sprawdzanie przepełnienia.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> A, który <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ma<see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.BinaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybraną metodę implementującą dla operacji:  
  
-   <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub <xref:System.Reflection.MethodInfo> reprezentuje typ zdefiniowany przez użytkownika, który przeciąża operator odejmowania, oznacza to, że metoda jest metodą implementującą. `right`  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora odejmowania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora odejmowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operatora odejmowania dla elementu <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> ustawić właściwość równą.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący arytmetyczną operację odejmowania, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> ma <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> Właściwość równą i,, i właściwości, i ustawione na określone wartości. <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W efekcie <xref:System.Linq.Expressions.BinaryExpression> <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwość ma ustawioną metodę implementującą. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość jest`null`.  
  
 Poniższe informacje opisują metodę implementującą, typ węzła i informacje o tym, czy węzeł został zniesiony.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest i reprezentuje metodę, która nie jest typu void (w Visual Basic), która przyjmuje dwa argumenty, jest to metoda implementująca dla tego węzła.  
  
-   W przeciwnym razie, <xref:System.Linq.Expressions.Expression.Type%2A> Jeśli właściwość `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, <xref:System.Reflection.MethodInfo> który przeciąża operator odejmowania, oznacza to, że metoda jest metodą implementującą.  
  
-   W przeciwnym razie `left`, jeśli. Wpisz i `right`. Typem są typy liczbowe, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `left`. Wpisz i `right`. Typ można przypisać do odpowiednich typów argumentów metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `left`. Wpisz i `right`. Typ to oba typy wartości, które co najmniej jeden dopuszcza wartość null, a odpowiednie typy niedopuszczające wartości null są równe odpowiednim typom argumentów metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli metoda implementowania jest `null`:  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł nie zostanie zniesiony. Typ węzła jest typem wyniku wstępnie zdefiniowanego operatora odejmowania.  
  
-   Jeśli `left`. Wpisz i `right`. Typ nie dopuszcza wartości null, węzeł zostaje zniesiony. Typ węzła jest typem dopuszczającym wartość null, który odnosi się do typu wyników wstępnie zdefiniowanego operatora odejmowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />jest <see langword="null" /> i operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Wpisz i <paramref name="right" />. Wprowadź.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.SwitchExpression" /> <see langword="switch" /> reprezentujący instrukcję.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana względem każdego przypadku.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia przełącznika.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.SwitchExpression" /> <see langword="switch" /> reprezentujący instrukcję bez domyślnego przypadku.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty <xref:System.Linq.Expressions.SwitchExpression> `void`w obiekcie muszą mieć ten sam typ, chyba że ma typ. <xref:System.Linq.Expressions.SwitchExpression>  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawną `break` instrukcję, co oznacza, że nie istnieje niejawna pochodząca z jednej etykiety case do innej.  
  
 Jeśli `switchValue` nie pasuje do żadnego z tych przypadków, nie zostanie zgłoszony żaden wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentujące instrukcję Switch bez domyślnego przypadku.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana względem każdego przypadku.</param>
        <param name="defaultBody">Wynik przełączenia, jeśli <paramref name="switchValue" /> nie jest zgodny z żadnym przypadkiem.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia przełącznika.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.SwitchExpression" /> <see langword="switch" /> reprezentujący instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty <xref:System.Linq.Expressions.SwitchExpression> `void`w obiekcie muszą mieć ten sam typ, chyba że ma typ. <xref:System.Linq.Expressions.SwitchExpression>  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawną `break` instrukcję, co oznacza, że nie istnieje niejawna pochodząca z jednej etykiety case do innej.  
  
 Jeśli `switchValue` nie pasuje do żadnego z przypadków, domyślnym przypadkiem reprezentowane przez `defaultBody` jest uruchomienie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentujące instrukcję Switch, która ma przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana względem każdego przypadku.</param>
        <param name="defaultBody">Wynik przełączenia, jeśli <paramref name="switchValue" /> nie jest zgodny z żadnym przypadkiem.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia przełącznika.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.SwitchExpression" /> <see langword="switch" /> reprezentujący instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana względem każdego przypadku.</param>
        <param name="defaultBody">Wynik przełączenia, jeśli <paramref name="switchValue" /> nie jest zgodny z żadnym przypadkiem.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia przełącznika.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.SwitchExpression" /> <see langword="switch" /> reprezentujący instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku przełącznika.</param>
        <param name="switchValue">Wartość, która ma być testowana względem każdego przypadku.</param>
        <param name="defaultBody">Wynik przełączenia, jeśli <paramref name="switchValue" /> nie jest zgodny z żadnym przypadkiem.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia przełącznika.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.SwitchExpression" /> <see langword="switch" /> reprezentujący instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku przełącznika.</param>
        <param name="switchValue">Wartość, która ma być testowana względem każdego przypadku.</param>
        <param name="defaultBody">Wynik przełączenia, jeśli <paramref name="switchValue" /> nie jest zgodny z żadnym przypadkiem.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia przełącznika.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.SwitchExpression" /> <see langword="switch" /> reprezentujący instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt, który ma być używany <see cref="T:System.Linq.Expressions.SwitchExpression" /> w obiekcie. <see cref="T:System.Linq.Expressions.SwitchCase" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body">Treść przypadku.</param>
        <param name="testValues">Wartości testowe przypadku.</param>
        <summary>Tworzy obiekt, który ma być używany <see cref="T:System.Linq.Expressions.SwitchExpression" /> w obiekcie. <see cref="T:System.Linq.Expressions.SwitchCase" /></summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty <xref:System.Linq.Expressions.SwitchExpression> `void`w obiekcie muszą mieć ten sam typ, chyba że ma typ. <xref:System.Linq.Expressions.SwitchExpression>  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiekt ma niejawną `break` instrukcję, co oznacza, że nie istnieje niejawna pochodząca z jednej etykiety case do innej.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wyrażenie reprezentujące instrukcję Switch, która ma przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treść przypadku.</param>
        <param name="testValues">Wartości testowe przypadku.</param>
        <summary>Tworzy do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" />. <see cref="T:System.Linq.Expressions.SwitchCase" /></summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> ustawić wartość równą.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> , który <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> ma ustawioną określoną wartość właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="language" Type="System.Guid" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> ustawić wartość równą.</param>
        <param name="language">A <see cref="T:System.Guid" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ustawić wartość równą.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Ma właściwości i<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />ustawione na określoną wartość. <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="language" Type="System.Guid" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="languageVendor" Type="System.Guid" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> ustawić wartość równą.</param>
        <param name="language">A <see cref="T:System.Guid" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ustawić wartość równą.</param>
        <param name="languageVendor">A <see cref="T:System.Guid" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ustawić wartość równą.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> , który <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> ma właściwość <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> i ma ustawioną określoną wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="language" Type="System.Guid" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="languageVendor" Type="System.Guid" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="documentType" Type="System.Guid" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> ustawić wartość równą.</param>
        <param name="language">A <see cref="T:System.Guid" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ustawić wartość równą.</param>
        <param name="languageVendor">A <see cref="T:System.Guid" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ustawić wartość równą.</param>
        <param name="documentType">A <see cref="T:System.Guid" /> , aby <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ustawić wartość równą.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>Obiekt <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> , który <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> ma właściwości <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> i i<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ma ustawioną określoną wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Przerzucanie wyjątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Przerzucanie wyjątku.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Linq.Expressions.TryExpression> jak utworzyć obiekt, który <xref:System.Linq.Expressions.Expression.Throw%2A> używa metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="type">Nowe <see cref="T:System.Type" /> wyrażenie.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Przerzucanie wyjątku dla danego typu.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> Reprezentujący wyjątek.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tekstową reprezentację <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>Tekstowa reprezentacja <see cref="T:System.Linq.Expressions.Expression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="handlers">Tablica zawierająca zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcje catch do skojarzenia z blokiem try.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący blok try z dowolną liczbą instrukcji catch, a nie błąd ani blok finally.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="finally">Treść bloku finally.</param>
        <param name="handlers">Tablica zawierająca zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcje catch do skojarzenia z blokiem try.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący blok try z dowolną liczbą instrukcji catch i bloku finally.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch i instrukcję finally.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="fault">Treść bloku błędu.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący blok try z blokiem błędu i bez instrukcji catch.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body">Treść bloku try.</param>
        <param name="finally">Treść bloku finally.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący blok try z blokiem finally i bez instrukcji catch.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica typów obiektów, które określają argumenty typu dla typu delegata system. Action.</param>
        <param name="actionType">Gdy ta metoda zwraca, zawiera typ ogólny system. Action akcji, który ma określone argumenty typu. Zawiera wartość null, jeśli nie istnieje ogólny system. Action delegat pasujący <paramref name="typeArgs" />do. Ten parametr jest przekazaniem niezainicjowanym.</param>
        <summary><see cref="P:System.Linq.Expressions.Expression.Type" /> Tworzy obiekt, który reprezentuje ogólny system. typ delegata akcji, który ma określone argumenty typu.</summary>
        <returns><see langword="true" />Jeśli typ elementu delegowanego system. Action został utworzony dla <paramref name="typeArgs" />określonego; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica typów obiektów, które określają argumenty typu dla typu delegata system. Func.</param>
        <param name="funcType">Gdy ta metoda zwraca, zawiera typ delegata system. Func, który ma określone argumenty typu. Zawiera wartość null, jeśli nie istnieje ogólny delegat system. Func pasujący <paramref name="typeArgs" />do. Ten parametr jest przekazaniem niezainicjowanym.</param>
        <summary><see cref="P:System.Linq.Expressions.Expression.Type" /> Tworzy obiekt, który reprezentuje ogólny typ System. Func delegata, który ma określone argumenty typu. Argument Last Type Określa zwracany typ utworzonego delegata.</summary>
        <returns><see langword="true" />Jeśli typ delegata system. Func został utworzony dla określonego <paramref name="typeArgs" />elementu; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ statyczny wyrażenia reprezentowanego przez to <see cref="T:System.Linq.Expressions.Expression" /> wyrażenie.</summary>
        <value><see cref="T:System.Type" /> Reprezentuje typ statyczny wyrażenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to typ węzła drzewa wyrażenia, <xref:System.Linq.Expressions.Expression.Type%2A> natomiast reprezentuje typ statycznego środowiska uruchomieniowego języka wspólnego (CLR) wyrażenia reprezentowanego przez ten węzeł. <xref:System.Linq.Expressions.Expression.NodeType%2A> Na przykład dwa węzły z różnymi typami węzłów mogą mieć taki sam <xref:System.Linq.Expressions.Expression.Type%2A>sposób, jak pokazano w poniższym przykładzie kodu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="T:System.Type" /> , aby <see cref="P:System.Linq.Expressions.Expression.Type" /> ustawić właściwość równą.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawne odwołanie lub konwersję z opakowaniem, gdzie <see langword="null" /> jest dostarczany, jeśli konwersja nie powiedzie się.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> A, który <see cref="P:System.Linq.Expressions.Expression.Type" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.UnaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest `null`. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwości <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> i. `false`  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metody w celu <xref:System.Linq.Expressions.UnaryExpression> utworzenia, która reprezentuje konwersję odwołania do niedopuszczających wartości null wyrażenia Integer do wartości null typu Integer.  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="T:System.Linq.Expressions.Expression" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> , aby <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> Tworzy porównanie tożsamości typu w czasie wykonywania.</summary>
        <returns>Wartość <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> , dla <see cref="P:System.Linq.Expressions.Expression.NodeType" /> której właściwość jest równa <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> i dla której <see cref="T:System.Linq.Expressions.Expression" /> właściwości i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> są ustawione na określone wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> ustawić właściwość równą.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> , aby <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.TypeBinaryExpression" />Tworzy.</summary>
        <returns>Wartość <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> , dla <see cref="P:System.Linq.Expressions.Expression.NodeType" /> której właściwość jest równa <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> i dla której <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> właściwości i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> są ustawione na określone wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> reprezentuje <xref:System.Boolean>. <xref:System.Linq.Expressions.Expression.Type%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metody do <xref:System.Linq.Expressions.TypeBinaryExpression> utworzenia, która reprezentuje test typu wartości ciągu dla <xref:System.Int32> typu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />lub <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy element reprezentujący jednoargumentową operację Plus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy element reprezentujący jednoargumentową operację Plus.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> , który <see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i Właściwość ustawioną na określoną wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są one fałszywe.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator plus <xref:System.Reflection.MethodInfo> , który reprezentuje ten operator jako metodę implementującą.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typem liczbowym, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ wartości niedopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy operator plus nie jest zdefiniowany <paramref name="expression" />dla. Wprowadź.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Aby<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> ustawić właściwość równą.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> , aby <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ustawić właściwość równą.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> Tworzy element reprezentujący jednoargumentową operację Plus.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> A, który <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ma<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> Właściwość równą i właściwości i i ustawia określone wartości. <see cref="T:System.Linq.Expressions.UnaryExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość będąca wynikiem <xref:System.Linq.Expressions.UnaryExpression> jest ustawiona na metodę implementującą. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostanie zniesiony, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwości i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są jednocześnie `true`. W przeciwnym razie są one fałszywe.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają metodę implementującą dla operacji:  
  
-   Jeśli `method` `static` `Shared` nie `null` jest, i reprezentuje metodę inną niż void (w Visual Basic), która przyjmuje jeden argument, jest to metoda implementująca dla tego węzła.  
  
-   Jeśli `expression`. Typ jest typem zdefiniowanym przez użytkownika, który definiuje jednoargumentowy operator plus <xref:System.Reflection.MethodInfo> , który reprezentuje ten operator jako metodę implementującą.  
  
-   W przeciwnym razie `expression`, jeśli. Typ jest typem liczbowym, Metoda implementująca to `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli metoda implementująca nie `null`jest:  
  
-   Jeśli `expression`. Typ jest możliwy do przypisania do typu argumentu metody implementującej, węzeł nie zostanie zniesiony. Typ węzła jest typem zwracanym metody implementującej.  
  
-   Jeśli spełnione są następujące dwa warunki, węzeł zostanie zniesiony i typ węzła jest typem dopuszczającym wartość null, który odpowiada zwracanym typem metody implementującej:  
  
    -   `expression`. Typ jest typem wartości null, a odpowiedni typ wartości niedopuszczający wartości null jest równy typowi argumentu metody implementującej.  
  
    -   Typem zwracanym metody implementującej jest typ wartości niedopuszczający wartości null.  
  
 Jeśli jest `null`to metoda implementująca, typ węzła to `expression`. Wprowadź. Jeśli `expression`. Typ nie dopuszcza wartości null, węzeł nie został zniesiony. W przeciwnym razie węzeł zostanie zniesiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />nie <see langword="null" /> jest i metoda, która reprezentuje zwraca <see langword="void" />, nie <see langword="static" /> jest (<see langword="Shared" /> w Visual Basic) lub nie przyjmuje dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />is <see langword="null" /> i operator jednoargumentowy Plus nie jest zdefiniowany <paramref name="expression" />dla. Wprowadź.  
  
—lub— 
 <paramref name="expression" />. Typ (lub odpowiedni typ niedopuszczający wartości null, jeśli jest typem wartości null), nie można przypisać do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> Do Unbox.</param>
        <param name="type">Nowe <see cref="T:System.Type" /> wyrażenie.</param>
        <summary>Tworzy element <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawne rozpakowywanie.</summary>
        <returns>Wystąpienie elementu <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ParameterExpression" /> Tworzy węzeł, który może służyć do identyfikowania parametru lub zmiennej w drzewie wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametru lub zmiennej.</param>
        <summary><see cref="T:System.Linq.Expressions.ParameterExpression" /> Tworzy węzeł, który może służyć do identyfikowania parametru lub zmiennej w drzewie wyrażenia.</summary>
        <returns><see cref="T:System.Linq.Expressions.ParameterExpression" /> Węzeł o określonej nazwie i typie</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametru lub zmiennej.</param>
        <param name="name">Nazwa parametru lub zmiennej. Ta nazwa jest używana tylko do celów debugowania lub drukowania.</param>
        <summary><see cref="T:System.Linq.Expressions.ParameterExpression" /> Tworzy węzeł, który może służyć do identyfikowania parametru lub zmiennej w drzewie wyrażenia.</summary>
        <returns><see cref="T:System.Linq.Expressions.ParameterExpression" /> Węzeł o określonej nazwie i typie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="visitor">Wystąpienie elementu <see cref="T:System.Func`2" />.</param>
        <summary>Redukuje węzeł, a następnie wywołuje delegata odwiedzających na zmniejszonym wyrażeniu. Metoda zgłasza wyjątek, jeśli węzeł nie jest możliwe do zredukowania.</summary>
        <returns>Odwiedzane wyrażenie lub wyrażenie, które powinno zastąpić je w drzewie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp tę metodę, aby zapewnić logikę do przeszukiwania elementów podrzędnych węzła. Typowa implementacja spowoduje wywołanie gościa. Zapoznaj się z każdym elementem podrzędnym, a jeśli którykolwiek z nich się zmieni, zwróć nową kopię samego siebie ze zmodyfikowanymi elementami podrzędnymi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
